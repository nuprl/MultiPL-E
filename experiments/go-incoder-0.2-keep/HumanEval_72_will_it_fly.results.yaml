language: go_test.go
name: HumanEval_72_will_it_fly
results:
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // \nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjawgerr1_test.go:167:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: write your function here\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp26nlpcqz_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp26nlpcqz_test.go:42:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp26nlpcqz_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // \nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjawgerr1_test.go:167:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    if q == nil || w < 0 {\n        return\
    \ false\n    }\n    max := 0\n    for _, v := range q {\n        max += v\n  \
    \  }\n    if max > w {\n        return false\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum += v\n    }\n    if sum < max {\n        return\
    \ false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n \
    \ candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmppjywydu4_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmppjywydu4_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        if v > max {\n            max = v\n        }\n    }\n    sum := 0\n \
    \   for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n     \
    \   return false\n    }\n    if sum == max {\n        return true\n    }\n   \
    \ if sum > max {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpvz842s3i_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpvz842s3i_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpvz842s3i_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp1jqyfnzg_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp1jqyfnzg_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max := 0\n\
    \    for _, v := range q {\n        max += v\n    }\n    if max > w {\n      \
    \  return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum +=\
    \ v\n    }\n    if sum < max {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpyjgqvrh9_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpyjgqvrh9_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum > w {\n\
    \        return false\n    }\n    if sum == w {\n        return true\n    }\n\
    \    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpm03ei0m8_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpm03ei0m8_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpm03ei0m8_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: Write the code here.\n    return false\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp7e0u49kv_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp7e0u49kv_test.go:42:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmp7e0u49kv_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    if\
    \ max < w {\n        return true\n    }\n    sum := 0\n    for _, v := range q\
    \ {\n        sum += v\n    }\n    if sum < max {\n        return true\n    }\n\
    \    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp9hljprps_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__5 (0.00s)\n        tmp9hljprps_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max == w {\n        return true\n    }\n    if\
    \ max < w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < max {\n        return false\n   \
    \ }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate :=\
    \ will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected:\
    \ true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n    \
    \ { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpuiiykbx8_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpuiiykbx8_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpuiiykbx8_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpuiiykbx8_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if len(q)\
    \ == 1 {\n        return q[0] == q[0]\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    return\
    \ sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp5x146nxw_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp5x146nxw_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max == 0 {\n        return true\n    }\n    if\
    \ max < w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < max {\n        return false\n   \
    \ }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate :=\
    \ will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected:\
    \ true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n    \
    \ { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpgosddifu_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpgosddifu_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpgosddifu_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpgosddifu_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp1jqyfnzg_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp1jqyfnzg_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpndnxjrzo_test.go:275:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max := 0\n\
    \    for _, v := range q {\n        max = max * 10 + v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp6d4pmlzh_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: Write the function here\n    return false\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpu4s6yy3z_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpu4s6yy3z_test.go:42:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpu4s6yy3z_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: Write your function here\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp4kb3xk1w_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp4kb3xk1w_test.go:42:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp4kb3xk1w_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: Write the function here.\n    return false\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp781zsvhq_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp781zsvhq_test.go:42:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmp781zsvhq_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    sum :=\
    \ 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    if sum == max {\n        return true\n    }\n\
    \    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp91bhogr6_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpy5mgsnfg_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpy5mgsnfg_test.go:42:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpy5mgsnfg_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if w == 0\
    \ {\n        return false\n    }\n    max := 0\n    for _, v := range q {\n  \
    \      max += v\n    }\n    if max > w {\n        return false\n    }\n    return\
    \ will_it_fly(q[1:], w) || will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpvqhci7j2_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpvqhci7j2_test.go:54:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpah317_zw_test.go:167:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    if max\
    \ < w {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n\
    \        sum += v\n    }\n    if sum < max {\n        return false\n    }\n  \
    \  return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpwgmxpq_u_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpwgmxpq_u_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpwgmxpq_u_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if w == 0\
    \ {\n        return false\n    }\n    if q[len(q)-1] == 0 {\n        return will_it_fly(q[:len(q)-1],\
    \ w)\n    }\n    if q[len(q)-1] == w {\n        return will_it_fly(q[:len(q)-1],\
    \ w)\n    }\n    if q[len(q)-1] < w {\n        return will_it_fly(q[:len(q)-1],\
    \ w)\n    }\n    if q[len(q)-1] > w {\n        return will_it_fly(q[:len(q)-1],\
    \ w)\n    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpajzg3drn_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpajzg3drn_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpajzg3drn_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp9p9uba08_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp9p9uba08_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: Write the function here\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp6o2nras9_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp6o2nras9_test.go:42:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp6o2nras9_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    \n    \n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpv_m_2m7b_test.go:44: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpv_m_2m7b_test.go:44:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpv_m_2m7b_test.go:44: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    sum :=\
    \ 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    if sum == max {\n        return true\n    }\n\
    \    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp91bhogr6_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n    max := 0\n\
    \    for _, v := range q {\n        max = max * 10 + v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpc0ew5wf3_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp1jqyfnzg_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp1jqyfnzg_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == 0 {\n        return true\n    }\n\
    \    if max > w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp4gzpl3tx_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp4gzpl3tx_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpemuuy848_test.go:275:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075199
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpah317_zw_test.go:167:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if w == 0\
    \ {\n        return false\n    }\n    if w == 1 {\n        return true\n    }\n\
    \    if q[len(q)-1] != 0 {\n        return false\n    }\n    max := 0\n    for\
    \ _, v := range q {\n        max += v\n    }\n    if max > w {\n        return\
    \ false\n    }\n    return will_it_fly(q[:len(q)-1], w-max)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp181s8fzn_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp181s8fzn_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp181s8fzn_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__5 (0.00s)\n        tmp181s8fzn_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // \nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjawgerr1_test.go:167:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp1jqyfnzg_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp1jqyfnzg_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    if q == nil || w == 0 {\n    \
    \    return true\n    }\n    max := 0\n    for _, v := range q {\n        max\
    \ += v\n    }\n    if max > w {\n        return false\n    }\n    sum := 0\n \
    \   for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n     \
    \   return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmplhnqplhi_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmplhnqplhi_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max := 0\n\
    \    for _, v := range q {\n        max += v\n    }\n    if max > w {\n      \
    \  return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum +=\
    \ v\n    }\n    if sum < max {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpyjgqvrh9_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpyjgqvrh9_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if w == 0\
    \ {\n        return false\n    }\n    if q[len(q)-1] == 0 {\n        return false\n\
    \    }\n    max := 0\n    for _, v := range q {\n        max += v\n    }\n   \
    \ if max > w {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w) && will_it_fly(q[len(q)-1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0388\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.will_it_fly({0xc0401dfe28?,\
    \ 0x0?, 0x3?}, 0x9?)\n\t/tmp/tmpjsjye87x_test.go:19 +0x114 fp=0xc0201e0398 sp=0xc0201e0390\
    \ pc=0x4ef774\ncommand-line-arguments_test.will_it_fly({0xc0401dfe28, 0x1, 0x3},\
    \ 0x9)\n\t/tmp/tmpjsjye87x_test.go:36 +0x9a fp=0xc0201e03d0 sp=0xc0201e0398 pc=0x4ef6fa\n\
    command-line-arguments_test.will_it_fly({0xc0401dfe28, 0x1, 0x3}, 0x9)\n\t/tmp/tmpjsjye87x_test.go:36\
    \ +0xe5 fp=0xc0201e0408 sp=0xc0201e03d0 pc=0x4ef745\ncommand-line-arguments_test.will_it_fly({0xc0401dfe28,\
    \ 0x1, 0x3}, 0x9)\n\t/tmp/tmpjsjye87x_test.go:36 +0xe5 fp=0xc0201e0440 sp=0xc0201e0408\
    \ pc=0x4ef745\ncommand-line-arguments_test.will_it_fly({0xc0401dfe28, 0x1, 0x3},\
    \ 0x9)\n\t/tmp/tmpjsjye87x_test.go:36 +0xe5 fp=0xc0201e0478 sp=0xc0201e0440 pc=0x4ef745\n\
    command-line-arguments_test.will_it_fly({0xc0401dfe28, 0x1, 0x3}, 0x9)\n\t/tmp/tmpjsjye87x_test.go:36\
    \ +0xe5 fp=0xc0201e04b0 sp=0xc0201e0478 pc=0x4ef745\ncommand-line-arguments_test.will_it_fly({0xc0401dfe28,\
    \ 0x1, 0x3}, 0x9)\n\t/tmp/tmpjsjye87x_test.go:36 +0xe5 fp=0xc0201e04e8 sp=0xc0201e04b0\
    \ pc=0x4ef745\ncommand-line-arguments_test.will_it_fly({0xc0401dfe28, 0x1, 0x3},\
    \ 0x9)\n\t/tmp/tmpjsjye87x_test.go:36 +0xe5 fp=0xc0201e0520 sp=0xc0201e04e8 pc=0x4ef745\n\
    command-line-arguments_test.will_it_fly({0xc0401dfe28, 0x1, 0x3}, 0x9)\n\t/tmp/tmpjsjye87x_test.go:36\
    \ +0xe5 fp=0xc0201e0558 sp=0xc0201e0520 pc=0x4ef745\ncommand-line-arguments_test.will_it_fly({0xc0401dfe28,\
    \ 0x1, 0x3}, 0x9)\n\t/tmp/tmpjsjye87x_test.go:36 +0xe5 fp=0xc0201e0590 sp=0xc0201e0558\
    \ pc=0x4ef745\ncommand-line-arguments_test.will_it_fly({0xc0401dfe28, 0x1, 0x3},\
    \ 0x9)\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max < w {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpjx5sh0hr_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpjx5sh0hr_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpjx5sh0hr_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmputbt_pk__test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmputbt_pk__test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmputbt_pk__test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmputbt_pk__test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpah317_zw_test.go:167:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: Write the code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp7qz1ljh8_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp7qz1ljh8_test.go:42:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp7qz1ljh8_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    if q == nil || w < 0 {\n        return\
    \ false\n    }\n    max := 0\n    for _, v := range q {\n        if v > max {\n\
    \            max = v\n        }\n    }\n    sum := 0\n    for _, v := range q\
    \ {\n        sum += v\n    }\n    if sum < max {\n        return false\n    }\n\
    \    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpgghj0wrg_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpgghj0wrg_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpgghj0wrg_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpgnxvm2zf_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpgnxvm2zf_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    sum :=\
    \ 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < w {\n  \
    \      return false\n    }\n    if sum > w {\n        return true\n    }\n   \
    \ if sum == w {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpeglcyoa__test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpeglcyoa__test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpeglcyoa__test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpeglcyoa__test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpemuuy848_test.go:275:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075199
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    \n    max := 0\n    for _, v\
    \ := range q {\n        max += v\n    }\n    \n    if max > w {\n        return\
    \ false\n    }\n    \n    sum := 0\n    for _, v := range q {\n        sum +=\
    \ v\n    }\n    \n    if sum < max {\n        return false\n    }\n    \n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqb5tdljr_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpqb5tdljr_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // \nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjawgerr1_test.go:167:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write code here\n    if w == 0 {\n        return true\n\
    \    }\n    max := 0\n    for _, v := range q {\n        max += v\n    }\n   \
    \ if max > w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < max {\n        return false\n   \
    \ }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate :=\
    \ will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected:\
    \ true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n    \
    \ { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp4ssimhs4_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp4ssimhs4_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpah317_zw_test.go:167:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: Write the function here\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp6o2nras9_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp6o2nras9_test.go:42:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp6o2nras9_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpc1r_l8oc_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpc1r_l8oc_test.go:42:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpc1r_l8oc_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp9p9uba08_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp9p9uba08_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    \n    // Write your code here\n    \n\
    \    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpw7o9gnw9_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpw7o9gnw9_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpw7o9gnw9_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max = max+v\n    }\n    if max == w {\n        return true\n  \
    \  }\n    if max < w {\n        return false\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum = sum+v\n    }\n    if sum < max {\n        return\
    \ false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n \
    \ candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpar9d4ylj_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpar9d4ylj_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpar9d4ylj_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpar9d4ylj_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < w {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpwdfihe4p_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpwdfihe4p_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpwdfihe4p_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max := 0\n\
    \    for _, v := range q {\n        max += v\n    }\n    if max > w {\n      \
    \  return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum +=\
    \ v\n    }\n    if sum < max {\n        return false\n    }\n    return will_it_fly(q[1:],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp_4jdb7jz_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp_4jdb7jz_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: Write a function that returns True if the object q\
    \ will fly, and False otherwise.\n    // The object q will fly if it's balanced\
    \ (it is a palindromic list) and the sum of its elements is less than or equal\
    \ the maximum possible weight w.\n    // Example:\n    // will_it_fly([1, 2],\
    \ 5) \u279E False \n    // # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n    // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n    // will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n    // # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less\
    \ than the maximum possible weight, and it's balanced.\n    \n    // TODO: Write\
    \ a function that returns True if the object q will fly, and False otherwise.\n\
    \    // The object q will fly if it's balanced (it is a palindromic list) and\
    \ the sum of its elements is less than or equal the maximum possible weight w.\n\
    \    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n    // # 1+2 is\
    \ less than the maximum possible weight, but it's unbalanced.\n    // will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // will_it_fly([3, 2, 3], 9) \u279E True\n    // # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n    // will_it_fly([3],\
    \ 5) \u279E True\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    \n    // TODO: Write a function that returns True if the object\
    \ q will fly, and False otherwise.\n    // The object q will fly if it's balanced\
    \ (it is a palindromic list) and the sum of its elements is less than or equal\
    \ the maximum possible weight w.\n    // Example:\n    // will_it_fly([1, 2],\
    \ 5) \u279E False \n    // # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n    // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n    // will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n    // # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n    // will_it_fly([3], 5) \u279E True\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe6la6lzw_test.go:55:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if q[len(q)-1]\
    \ != len(q)/2 {\n        return false\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    return max <= w\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp1bo9gql7_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp1bo9gql7_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmp1bo9gql7_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // \nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjawgerr1_test.go:167:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    sum :=\
    \ 0\n    for _, v := range q {\n        sum += v\n    }\n    return sum <= max\
    \ && sum == w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpq9_ms7jk_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpq9_ms7jk_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: Write the function here\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp6o2nras9_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp6o2nras9_test.go:42:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp6o2nras9_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp9p9uba08_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp9p9uba08_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: Write your solution here\n    \n    // Write your\
    \ solution here\n    \n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp2vwbjniz_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp2vwbjniz_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp2vwbjniz_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075202
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    return false\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpdj228ozv_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpdj228ozv_test.go:43:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpdj228ozv_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075203
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    sum :=\
    \ 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < w {\n  \
    \      return false\n    }\n    if sum == w {\n        return true\n    }\n  \
    \  if sum > w {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpexa3rs76_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpexa3rs76_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpexa3rs76_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp9p9uba08_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp9p9uba08_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpah317_zw_test.go:167:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    if max\
    \ == 0 {\n        return true\n    }\n    sum := 0\n    for _, v := range q {\n\
    \        sum += v\n    }\n    if sum < w {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpa777czst_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpa777czst_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpa777czst_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpa777czst_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    \n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpa_sxukzj_test.go:43: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpa_sxukzj_test.go:43:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpa_sxukzj_test.go:43: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    \n    max := 0\n    for _, v\
    \ := range q {\n        max += v\n    }\n    \n    if max == w {\n        return\
    \ true\n    }\n    \n    if max < w {\n        return false\n    }\n    \n   \
    \ sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    \n    return\
    \ sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpebdvasvh_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpebdvasvh_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpebdvasvh_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    if max < w {\n        return true\n    }\n    if max <= w {\n        for\
    \ _, v := range q {\n            if v != 0 {\n                if v != q[len(q)-1]\
    \ {\n                    return false\n                }\n            }\n    \
    \    }\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp9yxk8_09_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp1jqyfnzg_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp1jqyfnzg_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if w == 0\
    \ {\n        return false\n    }\n    if q[len(q)-1] == 0 {\n        return will_it_fly(q[:len(q)-1],\
    \ w)\n    }\n    if w == 1 {\n        return true\n    }\n    if q[len(q)-1] ==\
    \ 1 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 2 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 3 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 4 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 5 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 6 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 7 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 8 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 9 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 10 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 11 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 12 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 13 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 14 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 15 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 16 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 17 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 18 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 19 {\n        return will_it_fly(q[:len(q)-1]\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpryv1_rsh_test.go:87:40: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075203
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max := 0\n\
    \    for _, v := range q {\n        max += v\n    }\n    if max > w {\n      \
    \  return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum +=\
    \ v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n \
    \ candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqagi33pm_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpqagi33pm_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    \n    max := 0\n    for _, v\
    \ := range q {\n        max += v\n    }\n    \n    if max > w {\n        return\
    \ false\n    }\n    \n    sum := 0\n    for _, v := range q {\n        sum +=\
    \ v\n    }\n    \n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp78f7_n20_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp78f7_n20_test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum > max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpu094ypyn_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpu094ypyn_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: Write your code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpshsz8m1e_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpshsz8m1e_test.go:42:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpshsz8m1e_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if w == 0\
    \ {\n        return false\n    }\n    if q[len(q)-1] < w {\n        return false\n\
    \    }\n    return will_it_fly(q[:len(q)-1], w) || will_it_fly(q[len(q)-1:], w)\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpwyi3mdew_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpwyi3mdew_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpwyi3mdew_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max := 0\n\
    \    for _, v := range q {\n        max += v\n    }\n    if max > w {\n      \
    \  return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum +=\
    \ v\n    }\n    if sum < max {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpyjgqvrh9_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpyjgqvrh9_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max := 0\n\
    \    for _, v := range q {\n        max += v\n    }\n    if max > w {\n      \
    \  return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum +=\
    \ v\n        if sum > w {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp6ru1_gai_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp6ru1_gai_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        if v > max {\n            max = v\n        }\n    }\n    sum := 0\n \
    \   for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n     \
    \   return false\n    }\n    sum %= max\n    if sum == 0 {\n        return true\n\
    \    }\n    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp_umunyo6_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp_umunyo6_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max < w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpskfbr36f_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpskfbr36f_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpskfbr36f_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpskfbr36f_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    \n    max := 0\n    for _, v\
    \ := range q {\n        max += v\n    }\n    \n    if max > w {\n        return\
    \ false\n    }\n    \n    sum := 0\n    for _, v := range q {\n        sum +=\
    \ v\n    }\n    \n    if sum < max {\n        return false\n    }\n    \n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqb5tdljr_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpqb5tdljr_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max := 0\n\
    \    for _, v := range q {\n        max = max * 10 + v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp6d4pmlzh_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    max := 0\n    for _, v :=\
    \ range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    \n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n\
    \    if sum > max {\n        return false\n    }\n    \n    return true\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpwkhqt50b_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpwkhqt50b_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max = max + v\n    }\n    if max > w {\n        return false\n\
    \    }\n    if max < w {\n        return true\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum += v\n    }\n    if sum < max {\n        return\
    \ false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n \
    \ candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp3l449ylo_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp3l449ylo_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp1jqyfnzg_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp1jqyfnzg_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpc1r_l8oc_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpc1r_l8oc_test.go:42:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpc1r_l8oc_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max < w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpskfbr36f_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpskfbr36f_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpskfbr36f_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpskfbr36f_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max == 0 {\n        return true\n    }\n    if\
    \ max > w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < max {\n        return false\n   \
    \ }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate :=\
    \ will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected:\
    \ true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n    \
    \ { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp511yxsxw_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp511yxsxw_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpemuuy848_test.go:275:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075199
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    for _, v := range q {\n        if v > max {\n            return false\n \
    \       }\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpeqjwwc41_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpeqjwwc41_test.go:54:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // \nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjawgerr1_test.go:167:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    \n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    \n   \
    \ sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    \n    if sum\
    \ < max {\n        return false\n    }\n    \n    if sum == max {\n        return\
    \ true\n    }\n    \n    if sum > max {\n        return true\n    }\n    \n  \
    \  return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp8lmnmqpm_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp8lmnmqpm_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp8lmnmqpm_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        if v > max {\n            max = v\n        }\n    }\n    sum := 0\n \
    \   for _, v := range q {\n        sum += v\n    }\n    if sum < w {\n       \
    \ return false\n    }\n    if sum == w {\n        return true\n    }\n    if sum\
    \ > w {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp75xrra1e_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp75xrra1e_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp75xrra1e_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp75xrra1e_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp1jqyfnzg_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp1jqyfnzg_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max = max+v\n    }\n    if max <= w {\n        return true\n  \
    \  }\n    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpfzbl_f20_test.go:49: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpfzbl_f20_test.go:49:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp1jqyfnzg_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp1jqyfnzg_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        if v > max {\n            max = v\n        }\n    }\n    sum := 0\n \
    \   for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n     \
    \   return false\n    }\n    if sum == max {\n        return true\n    }\n   \
    \ return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp_sr2xskf_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max < w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpf4vgatrs_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpf4vgatrs_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpf4vgatrs_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpf4vgatrs_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.007s\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpemuuy848_test.go:275:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075199
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp3cp3p8kz_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp3cp3p8kz_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp3cp3p8kz_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp3cp3p8kz_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    \n    // Write your test cases here\n\
    \    \n    // Your code here\n    \n    // Write your test cases here\n    \n\
    \    // Your code here\n    \n    // Write your test cases here\n    \n    //\
    \ Your code here\n    \n    // Write your test cases here\n    \n    // Your code\
    \ here\n    \n    // Write your test cases here\n    \n    // Your code here\n\
    \    \n    // Write your test cases here\n    \n    // Your code here\n    \n\
    \    // Write your test cases here\n    \n    // Your code here\n    \n    //\
    \ Write your test cases here\n    \n    // Your code here\n    \n    // Write\
    \ your test cases here\n    \n    // Your code here\n    \n    // Write your test\
    \ cases here\n    \n    // Your code here\n    \n    // Write your test cases\
    \ here\n    \n    // Your code here\n    \n    // Write your test cases here\n\
    \    \n    // Your code here\n    \n    // Write your test cases here\n    \n\
    \    // Your code here\n    \n    // Write your test cases here\n    \n    //\
    \ Your code here\n    \n    // Write your test cases here\n    \n    // Your code\
    \ here\n    \n    // Write your test cases here\n    \n    // Your code here\n\
    \    \n    // Write your test cases here\n    \n    // Your code here\n    \n\
    \    // Write your test cases here\n    \n    // Your code here\n    \n    //\
    \ Write your test cases here\n    \n    // Your code here\n    \n    // Write\
    \ your test cases here\n    \n    // Your code here\n    \n    // Write your test\
    \ cases here\n    \n    // Your code here\n    \n    // Write your test cases\
    \ here\n    \n    // Your code here\n    \n    // Write your test cases here\n\
    \    \n    // Your code here\n    \n    // Write your test cases here\n    \n\
    \    // Your code here\n    \n    // Write your test cases here\n    \n    //\
    \ Your code here\n    \n    // Write your test cases here\n    \n    // Your code\
    \ here\n    \n    // Write your test cases here\n    \n    // Your code here\n\
    \    \n    // Write your test cases here\n    \n    // Your code here\n    \n\
    \    // Write your test cases here\n    \n    // Your code here\n    \n    //\
    \ Write your test cases here\n    \n    // Your code here\n    \n    // Write\
    \ your test cases here\n    \n    // Your code here\n    \n    // Write your test\
    \ cases here\n    \n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpum0xg_o7_test.go:149:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075206
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max := 0\n\
    \    for _, v := range q {\n        max += v\n    }\n    if max > w {\n      \
    \  return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum +=\
    \ v\n    }\n    if sum < max {\n        return false\n    }\n    return will_it_fly(q[1:],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp_4jdb7jz_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp_4jdb7jz_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        if v > max {\n            max = v\n        }\n    }\n    sum := 0\n \
    \   for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n     \
    \   return false\n    }\n    if sum == max {\n        return true\n    }\n   \
    \ if sum > max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp_740tw35_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    if\
    \ max < w {\n        return true\n    }\n    sum := 0\n    for _, v := range q\
    \ {\n        sum += v\n    }\n    if sum < max {\n        return true\n    }\n\
    \    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp9hljprps_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__5 (0.00s)\n        tmp9hljprps_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max = max+v\n    }\n    if max == w {\n        return true\n    }\n \
    \   if max < w {\n        return false\n    }\n    for _, v := range q {\n   \
    \     if v != 0 {\n            if v > max {\n                return false\n  \
    \          }\n        }\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpct8nifbm_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpct8nifbm_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpct8nifbm_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpct8nifbm_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if w == 0\
    \ {\n        return false\n    }\n    if q[len(q)-1] == 0 {\n        return false\n\
    \    }\n    if q[len(q)-1] == 1 {\n        return will_it_fly(q[:len(q)-1], w-1)\n\
    \    }\n    if q[len(q)-1] == 2 {\n        return will_it_fly(q[:len(q)-1], w-2)\n\
    \    }\n    if q[len(q)-1] == 3 {\n        return will_it_fly(q[:len(q)-1], w-3)\n\
    \    }\n    if q[len(q)-1] == 4 {\n        return will_it_fly(q[:len(q)-1], w-4)\n\
    \    }\n    if q[len(q)-1] == 5 {\n        return will_it_fly(q[:len(q)-1], w-5)\n\
    \    }\n    if q[len(q)-1] == 6 {\n        return will_it_fly(q[:len(q)-1], w-6)\n\
    \    }\n    if q[len(q)-1] == 7 {\n        return will_it_fly(q[:len(q)-1], w-7)\n\
    \    }\n    if q[len(q)-1] == 8 {\n        return will_it_fly(q[:len(q)-1], w-8)\n\
    \    }\n    if q[len(q)-1] == 9 {\n        return will_it_fly(q[:len(q)-1], w-9)\n\
    \    }\n    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpvvyr60qh_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpvvyr60qh_test.go:77:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpvvyr60qh_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpc1r_l8oc_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpc1r_l8oc_test.go:42:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpc1r_l8oc_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max := 0\n\
    \    for _, v := range q {\n        max += v\n    }\n    if max > w {\n      \
    \  return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum +=\
    \ v\n    }\n    if sum < max {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpyjgqvrh9_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpyjgqvrh9_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        if v > max {\n            max = v\n        }\n    }\n    sum := 0\n \
    \   for _, v := range q {\n        sum += v\n    }\n    return sum <= w && sum\
    \ == max\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmppxfra3ln_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max < w {\n        return false\n    }\n    for\
    \ _, v := range q {\n        if v != 0 {\n            if v > max {\n         \
    \       return false\n            }\n        }\n    }\n    return true\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp92u9p_96_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp92u9p_96_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp92u9p_96_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp92u9p_96_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075207
- exit_code: 0
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    for i := range q {\n        if q[i] != q[len(q)-1-i] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpgnxvm2zf_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpgnxvm2zf_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: write your function here\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp26nlpcqz_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp26nlpcqz_test.go:42:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp26nlpcqz_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    max := 0\n    for _, v :=\
    \ range q {\n        max += v\n    }\n    \n    if max == w {\n        return\
    \ true\n    }\n    \n    if max > w {\n        return false\n    }\n    \n   \
    \ if max < w {\n        return true\n    }\n    \n    return false\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp_2ci2_qh_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp_2ci2_qh_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp1jqyfnzg_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp1jqyfnzg_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    max := 0\n    for _, v :=\
    \ range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    \n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n\
    \    if sum < max {\n        return false\n    }\n    \n    return true\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpv8s1v9l__test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpv8s1v9l__test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu7ik5x6w_test.go:167:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075206
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp1jqyfnzg_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp1jqyfnzg_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // \nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjawgerr1_test.go:167:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp3cp3p8kz_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp3cp3p8kz_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp3cp3p8kz_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp3cp3p8kz_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    \n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    \n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if\
    \ sum < max {\n        return false\n    }\n    \n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpyv62cdde_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpyv62cdde_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpemuuy848_test.go:275:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075199
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    \n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpa_sxukzj_test.go:43: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpa_sxukzj_test.go:43:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpa_sxukzj_test.go:43: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    \n    max := 0\n    for _, v\
    \ := range q {\n        max += v\n    }\n    \n    if max > w {\n        return\
    \ false\n    }\n    \n    sum := 0\n    for _, v := range q {\n        sum +=\
    \ v\n    }\n    \n    if sum < max {\n        return false\n    }\n    \n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqb5tdljr_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpqb5tdljr_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    \n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    \n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if\
    \ sum < max {\n        return false\n    }\n    \n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpyv62cdde_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpyv62cdde_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    if q == nil || w == 0 {\n        return\
    \ false\n    }\n    if q == nil || w == 0 {\n        return false\n    }\n   \
    \ if q == nil || w == 0 {\n        return false\n    }\n    if q == nil || w ==\
    \ 0 {\n        return false\n    }\n    if q == nil || w == 0 {\n        return\
    \ false\n    }\n    if q == nil || w == 0 {\n        return false\n    }\n   \
    \ if q == nil || w == 0 {\n        return false\n    }\n    if q == nil || w ==\
    \ 0 {\n        return false\n    }\n    if q == nil || w == 0 {\n        return\
    \ false\n    }\n    if q == nil || w == 0 {\n        return false\n    }\n   \
    \ if q == nil || w == 0 {\n        return false\n    }\n    if q == nil || w ==\
    \ 0 {\n        return false\n    }\n    if q == nil || w == 0 {\n        return\
    \ false\n    }\n    if q == nil || w == 0 {\n        return false\n    }\n   \
    \ if q == nil || w == 0 {\n        return false\n    }\n    if q == nil || w ==\
    \ 0 {\n        return false\n    }\n    if q == nil || w == 0 {\n        return\
    \ false\n    }\n    if q == nil || w == 0 {\n        return false\n    }\n   \
    \ if q == nil || w == 0 {\n        return false\n    }\n    if q == nil || w ==\
    \ 0 {\n        return false\n    }\n    if q == nil || w == 0 {\n        return\
    \ false\n    }\n    if q == nil || w == 0 {\n        return false\n    }\n   \
    \ if q == nil || w == 0 {\n        return false\n    }\n    if q == nil || w ==\
    \ 0 {\n        return false\n    }\n    if q == nil || w == 0 {\n        return\
    \ false\n    }\n    if q == nil || w == 0 {\n        return false\n    }\n   \
    \ if q == nil || w == 0 {\n        return false\n    }\n    if q == nil || w ==\
    \ 0 {\n        return false\n    }\n    if q == nil || w == 0 {\n        return\
    \ false\n    }\n    if q == nil || w == 0 {\n        return false\n    }\n   \
    \ if q == nil || w == 0 {\n        return false\n    }\n    if q == nil || w ==\
    \ 0 {\n        return false\n    }\n    if q == nil || w == 0 {\n        return\
    \ false\n    }\n    if q == nil || w == 0 {\n        return false\n    }\n   \
    \ if q == nil || w == 0 {\n        return false\n    }\n    if q == nil || w ==\
    \ 0 {\n        return false\n    }\n    if q == \nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg4eip6td_test.go:130:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075206
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpah317_zw_test.go:167:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    for\
    \ _, v := range q {\n        if v != 0 {\n            if v != q[len(q)-1] {\n\
    \                return false\n            }\n        }\n    }\n    return true\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpl6jggkm8_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpndnxjrzo_test.go:275:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max := 0\n\
    \    for _, v := range q {\n        if v > max {\n            max = v\n      \
    \  }\n    }\n    if max < w {\n        return false\n    }\n    sum := 0\n   \
    \ for _, v := range q {\n        sum += v\n    }\n    if sum < w {\n        return\
    \ false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n \
    \ candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpyz8ub322_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpyz8ub322_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpyz8ub322_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpemuuy848_test.go:275:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075199
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    return\
    \ sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp1xyly9g1_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp1xyly9g1_test.go:53:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpemuuy848_test.go:275:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075199
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: Write the code here.\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < w {\n        return false\n\
    \    }\n    if sum > w {\n        return true\n    }\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpo42qlm5c_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpo42qlm5c_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpo42qlm5c_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpo42qlm5c_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: Write the function here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpj25bbai3_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpj25bbai3_test.go:42:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpj25bbai3_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: Write the function here\n    return false\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpu4s6yy3z_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpu4s6yy3z_test.go:42:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpu4s6yy3z_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    \n    // Write your code here\n    \n\
    \    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpw7o9gnw9_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpw7o9gnw9_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpw7o9gnw9_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: Write the function here.\n    \n    return false\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpujhsg_1l_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpujhsg_1l_test.go:43:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpujhsg_1l_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if q[len(q)-1]\
    \ < w {\n        return false\n    }\n    if q[len(q)-1] == w {\n        return\
    \ will_it_fly(q[:len(q)-1], w)\n    }\n    return will_it_fly(q[:len(q)-1], w)\
    \ || will_it_fly(q, w-(q[len(q)-1]))\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpq5kl_7of_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpq5kl_7of_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpq5kl_7of_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpgnxvm2zf_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpgnxvm2zf_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max := 0\n\
    \    for _, v := range q {\n        max += v\n    }\n    if max > w {\n      \
    \  return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum +=\
    \ v\n        if sum > w {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp6ru1_gai_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp6ru1_gai_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    \n    \n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpv_m_2m7b_test.go:44: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpv_m_2m7b_test.go:44:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpv_m_2m7b_test.go:44: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpemuuy848_test.go:275:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075199
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    sum :=\
    \ 0\n    for _, v := range q {\n        sum += v\n    }\n    return sum <= w &&\
    \ sum == max\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpfzdg72pm_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max := 0\n\
    \    for _, v := range q {\n        max = max * 10 + v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum > max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpuu5sy9m7_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max := 0\n\
    \    for _, v := range q {\n        max += v\n    }\n    if max > w {\n      \
    \  return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum +=\
    \ v\n    }\n    if sum < max {\n        return false\n    }\n    return will_it_fly(q[1:],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp_4jdb7jz_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp_4jdb7jz_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if q[len(q)-1]\
    \ < w {\n        return false\n    }\n    max := 0\n    for _, v := range q {\n\
    \        if v > max {\n            max = v\n        }\n    }\n    sum := 0\n \
    \   for _, v := range q {\n        sum += v\n    }\n    return sum <= w && sum\
    \ == max\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpa1khudp1_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpa1khudp1_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if len(q)\
    \ == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1] {\n \
    \       return false\n    }\n    return will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmptkawsu9__test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    for _, v := range q {\n        if v != 0 {\n            if v != q[len(q)-1]\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmprypjplwc_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max < w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpf4vgatrs_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpf4vgatrs_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpf4vgatrs_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpf4vgatrs_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.007s\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu7ik5x6w_test.go:167:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075206
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprj5ak4o2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprj5ak4o2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpemuuy848_test.go:275:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075199
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if q[len(q)-1]\
    \ < w {\n        return false\n    }\n    max := 0\n    for _, v := range q {\n\
    \        if v > max {\n            max = v\n        }\n    }\n    if max <= w\
    \ {\n        return true\n    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp2ufy1sxs_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp2ufy1sxs_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp2ufy1sxs_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075209
- exit_code: 0
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if len(q)\
    \ == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1] {\n \
    \       return false\n    }\n    max := 0\n    for _, v := range q {\n       \
    \ max += v\n    }\n    return max <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.006s\n"
  timestamp: 1660075209
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write code here\n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4s3sviwk_test.go:275:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        if v > max {\n            max = v\n        }\n    }\n    sum := 0\n \
    \   for _, v := range q {\n        sum += v\n    }\n    if sum < w {\n       \
    \ return false\n    }\n    if sum == w {\n        return true\n    }\n    if sum\
    \ > w {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp75xrra1e_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp75xrra1e_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp75xrra1e_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp75xrra1e_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 2
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    if q == nil || w < 0 {\n     \
    \   return false\n    }\n    if q == nil {\n        return true\n    }\n    if\
    \ q == []int{} {\n        return true\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max = max + v\n    }\n    if max > w {\n        return false\n\
    \    }\n    if max == w {\n        return true\n    }\n    if max < w {\n    \
    \    return false\n    }\n    return will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp51y4iyy_test.go:27:8: invalid operation: q == []int{} (slice can only
    be compared to nil)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075209
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if len(q)\
    \ == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1] {\n \
    \       return false\n    }\n    max := 0\n    for i := 0; i < len(q); i++ {\n\
    \        max += q[i]\n    }\n    if max > w {\n        return false\n    }\n \
    \   return will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpio5j0i7x_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075209
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: Write your solution here\n    \n    return false\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp4vomrt5o_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp4vomrt5o_test.go:43:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmp4vomrt5o_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075209
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: Write your code here\n    \n    return true\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqhrar099_test.go:43: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpqhrar099_test.go:43:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpqhrar099_test.go:43: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075209
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    if max < w {\n        return true\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < max {\n        return true\n    }\n\
    \    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe9opj089_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__5 (0.00s)\n        tmpe9opj089_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.007s\nFAIL\n"
  timestamp: 1660075209
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // TODO: write your function here\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp26nlpcqz_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp26nlpcqz_test.go:42:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp26nlpcqz_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max := 0\n\
    \    for _, v := range q {\n        max = max+v\n    }\n    if max > w {\n   \
    \     return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum\
    \ = sum+v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpoj8q6uf8_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpoj8q6uf8_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075209
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if len(q)\
    \ == 1 {\n        return q[0] == q[0]\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max = max > v ? max : v\n    }\n    if max < w {\n        return\
    \ false\n    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n  \
    \  }\n    if sum < max {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp37hftay5_test.go:28:23: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075209
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    if q == nil || w == 0 {\n    \
    \    return true\n    }\n    max := 0\n    for _, v := range q {\n        if v\
    \ > max {\n            max = v\n        }\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpo1k1usmz_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpo1k1usmz_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpo1k1usmz_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075210
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        if v > max {\n            max = v\n        }\n    }\n    sum := 0\n \
    \   for _, v := range q {\n        sum += v\n    }\n    if sum < w {\n       \
    \ return false\n    }\n    if sum > w {\n        return true\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp7y1k0s82_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp7y1k0s82_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp7y1k0s82_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp7y1k0s82_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075210
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    if q == nil || w == 0 {\n        return\
    \ true\n    }\n    max := 0\n    for _, v := range q {\n        max += v\n   \
    \ }\n    if max == 0 {\n        return true\n    }\n    if max < w {\n       \
    \ return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum +=\
    \ v\n    }\n    if sum < max {\n        return false\n    }\n    return true\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp9s85ii9t_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp9s85ii9t_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp9s85ii9t_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp9s85ii9t_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075210
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpemuuy848_test.go:275:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075199
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    \n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    \n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if\
    \ sum > w {\n        return false\n    }\n    \n    if sum == max {\n        return\
    \ true\n    }\n    \n    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpn3emyv7e_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpn3emyv7e_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075209
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    if q == nil || w == 0 {\n        return\
    \ true\n    }\n    max := 0\n    for _, v := range q {\n        max += v\n   \
    \ }\n    if max > w {\n        return false\n    }\n    sum := 0\n    for _, v\
    \ := range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpq27_c3_i_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpq27_c3_i_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075210
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp1jqyfnzg_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp1jqyfnzg_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpemuuy848_test.go:275:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075199
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max == 0 {\n        return true\n    }\n    if\
    \ max < w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < max {\n        return false\n   \
    \ }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate :=\
    \ will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected:\
    \ true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n    \
    \ { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpgosddifu_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpgosddifu_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpgosddifu_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpgosddifu_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // will_it_fly([1, 2], 5) \u279E False \n// # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n//\
    \ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3,\
    \ 2, 3], 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w\
    \ int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    if max < w {\n        return true\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpi4m5op7b_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpi4m5op7b_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075209
