language: go_test.go
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcjsiyes8_test.go:54:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_string := \"\"\n \
    \   paren_group_open := false\n    for _, character := range paren_string {\n\
    \        if character == '(' {\n            if paren_group_open {\n          \
    \      fmt.Printf(\"Error: unbalanced paren group\\n\")\n                fmt.Printf(\"\
    Input: %s\\n\", paren_string)\n                fmt.Printf(\"Output: %s\\n\", paren_group_strings)\n\
    \                panic(\"unbalanced paren group\")\n            }\n          \
    \  paren_group_open = true\n            paren_group_string += character\n    \
    \    } else if character == ')' {\n            if paren_group_open {\n       \
    \         paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group_string = \"\"\n                paren_group_open =\
    \ false\n            } else {\n                fmt.Printf(\"Error: unbalanced\
    \ paren group\\n\")\n                fmt.Printf(\"Input: %s\\n\", paren_string)\n\
    \                fmt.Printf(\"Output: %s\\n\", paren_group_strings)\n        \
    \        panic(\"unbalanced paren group\")\n            }\n        } else {\n\
    \            paren_group_string += character\n        }\n    }\n    if paren_group_open\
    \ {\n        paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \    }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr312arta_test.go:27:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmpr312arta_test.go:40:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074062
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := make([]string, 0)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkqhog0p2_test.go:48:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_count := 0\n    paren_group_string\
    \ := \"\"\n    paren_group_open_brace := false\n    paren_group_close_brace :=\
    \ false\n    for _, character := range paren_string {\n        if character ==\
    \ '(' {\n            if paren_group_open_brace {\n                fmt.Println(\"\
    Found a nested group\")\n                paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n                paren_group_count = 0\n               \
    \ paren_group_string = \"\"\n                paren_group_open_brace = false\n\
    \                paren_group_close_brace = false\n            }\n            paren_group_open_brace\
    \ = true\n        } else if character == ')' {\n            if paren_group_close_brace\
    \ {\n                fmt.Println(\"Found a nested group\")\n                paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n                paren_group_count\
    \ = 0\n                paren_group_string = \"\"\n                paren_group_open_brace\
    \ = false\n                paren_group_close_brace = false\n            }\n  \
    \          paren_group_close_brace = true\n        } else if character == ' '\
    \ {\n            continue\n        } else {\n            paren_group_string +=\
    \ string(character)\n        }\n        if paren_group_open_brace {\n        \
    \    paren_group_count += 1\n        }\n        if paren_group_close_brace {\n\
    \            paren_group_count -= 1\n        }\n        if paren_group_count ==\
    \ 0 {\n            paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \            paren_group_string = \"\"\n            paren_group_open_brace = false\n\
    \            paren_group_close_brace = false\n        }\n    }\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Found a nested group\nFound a nested group\nFound a nested group\nFound\
    \ a nested group\nFound a nested group\nFound a nested group\nFound a nested group\n\
    Found a nested group\nFound a nested group\nFound a nested group\nFound a nested\
    \ group\nFound a nested group\nFound a nested group\nFound a nested group\nFound\
    \ a nested group\nFound a nested group\nFound a nested group\nFound a nested group\n\
    Found a nested group\nFound a nested group\nFound a nested group\nFound a nested\
    \ group\nFound a nested group\nFound a nested group\nFound a nested group\nFound\
    \ a nested group\nFound a nested group\nFound a nested group\nFound a nested group\n\
    Found a nested group\nFound a nested group\nFound a nested group\nFound a nested\
    \ group\nFound a nested group\nFound a nested group\nFound a nested group\nFound\
    \ a nested group\nFound a nested group\nFound a nested group\nFound a nested group\n\
    Found a nested group\nFound a nested group\n--- FAIL: TestSeparate_Paren_Groups\
    \ (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n     \
    \   tmpmze4aq8s_test.go:78: expected '[(()()) ((())) () ((())()())]', got '[ \
    \            ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n\
    \        tmpmze4aq8s_test.go:78: expected '[() (()) ((())) (((())))]', got '[\
    \            ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n\
    \        tmpmze4aq8s_test.go:78: expected '[(()(())((())))]', got '[        ]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpmze4aq8s_test.go:78:\
    \ expected '[() (()) (()())]', got '[     ]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074063
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make(map[string][]string)\n    paren_groups [\"(\"] =\
    \ make([]string, 0)\n    paren_groups [\")\"] = make([]string, 0)\n    paren_groups\
    \ [\"(\"] = make([]string, 0)\n    paren_groups [\")\"] = make([]string, 0)\n\
    \    paren_groups [\"(\"] = make([]string, 0)\n    paren_groups [\")\"] = make([]string,\
    \ 0)\n    paren_groups [\"(\"] = make([]string, 0)\n    paren_groups [\")\"] =\
    \ make([]string, 0)\n    paren_groups [\"(\"] = make([]string, 0)\n    paren_groups\
    \ [\")\"] = make([]string, 0)\n    paren_groups [\"(\"] = make([]string, 0)\n\
    \    paren_groups [\")\"] = make([]string, 0)\n    paren_groups [\"(\"] = make([]string,\
    \ 0)\n    paren_groups [\")\"] = make([]string, 0)\n    paren_groups [\"(\"] =\
    \ make([]string, 0)\n    paren_groups [\")\"] = make([]string, 0)\n    paren_groups\
    \ [\"(\"] = make([]string, 0)\n    paren_groups [\")\"] = make([]string, 0)\n\
    \    paren_groups [\"(\"] = make([]string, 0)\n    paren_groups [\")\"] = make([]string,\
    \ 0)\n    paren_groups [\"(\"] = make([]string, 0)\n    paren_groups [\")\"] =\
    \ make([]string, 0)\n    paren_groups [\"(\"] = make([]string, 0)\n    paren_groups\
    \ [\")\"] = make([]string, 0)\n    paren_groups [\"(\"] = make([]string, 0)\n\
    \    paren_groups [\")\"] = make([]string, 0)\n    paren_groups [\"(\"] = make([]string,\
    \ 0)\n    paren_groups [\")\"] = make([]string, 0)\n    paren_groups [\"(\"] =\
    \ make([]string, 0)\n    paren_groups [\")\"] = make([]string, 0)\n    paren_groups\
    \ [\"(\"] = make([]string, 0)\n    paren_groups [\")\"] = make([]string, 0)\n\
    \    paren_groups [\"(\"] = make([]string, 0)\n    paren_groups [\")\"] = make([]string,\
    \ 0)\n    paren_groups [\"(\"] = make([]string, 0)\n    paren_groups [\")\"] =\
    \ make([]string, 0)\n    paren_groups [\"(\"] = make([]string, 0)\n    paren_groups\
    \ [\")\"] = make([]string, 0)\n    paren_groups [\"\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptvmvsgiq_test.go:54:19: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpau96mwwn_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stack := make([]string, 0)\n    stack := append(stack,\
    \ paren_string)\n    index := 0\n    for len(stack) > 0 {\n        index += 1\n\
    \        current := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n\
    \        if current == ')' {\n            result := append(result, current)\n\
    \        }\n        if current == '(' {\n            stack = append(stack, current)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4rgfvseq_test.go:17:11: no new variables on left side of :=

    /tmp/tmp4rgfvseq_test.go:23:23: invalid operation: current == '')'' (mismatched
    types string and untyped rune)

    /tmp/tmp4rgfvseq_test.go:24:13: result declared but not used

    /tmp/tmp4rgfvseq_test.go:26:23: invalid operation: current == ''('' (mismatched
    types string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074062
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := make([]string, 0)\n    paren_group := \"\"\n \
    \   paren_group_open := false\n    paren_group_closed := false\n    paren_group_string\
    \ := \"\"\n    for _, char := range paren_string {\n        if char == '(' {\n\
    \            if paren_group_open {\n                fmt.Println(\"Found open paren\
    \ group\")\n                paren_group_string = paren_group + char\n        \
    \        paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group = \"\"\n                paren_group_open = false\n\
    \                paren_group_closed = false\n            } else {\n          \
    \      paren_group_open = true\n                paren_group = char\n         \
    \   }\n        } else if char == ')' {\n            if paren_group_closed {\n\
    \                fmt.Println(\"Found closed paren group\")\n                paren_group_string\
    \ = paren_group + char\n                paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n                paren_group = \"\"\n                paren_group_open\
    \ = false\n                paren_group_closed = false\n            } else {\n\
    \                paren_group_closed = true\n                paren_group = char\n\
    \            }\n        } else {\n            paren_group += char\n        }\n\
    \    }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd8q24wqc_test.go:24:38: invalid operation: paren_group + char (mismatched
    types string and rune)

    /tmp/tmpd8q24wqc_test.go:31:31: cannot use char (variable of type rune) as type
    string in assignment

    /tmp/tmpd8q24wqc_test.go:36:38: invalid operation: paren_group + char (mismatched
    types string and rune)

    /tmp/tmpd8q24wqc_test.go:43:31: cannot use char (variable of type rune) as type
    string in assignment

    /tmp/tmpd8q24wqc_test.go:46:13: invalid operation: paren_group += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074062
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize result to an empty list\n    var result []string\n\n  \
    \  // Iterate over each character in the input string\n    for _, char := range\
    \ paren_string {\n        // If the character is a left paren, append it to the\
    \ result list\n        if char == '(' {\n            result = append(result, char)\n\
    \        }\n        // If the character is a right paren, append it to the result\
    \ list\n        if char == ')' {\n            result = append(result, char)\n\
    \        }\n        // If the character is a space, append it to the result list\n\
    \        if char == ' ' {\n            result = append(result, char)\n       \
    \ }\n    }\n\n    // Return the result list\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj4f2fsvx_test.go:22:37: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpj4f2fsvx_test.go:26:37: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpj4f2fsvx_test.go:30:37: cannot use char (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074062
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make(map[string][]string)\n    paren_groups[\"\"] = make([]string,\
    \ 0)\n\n    paren_groups := make(map[string][]string)\n    paren_groups[\"\"]\
    \ = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n    paren_groups[\"\
    \"] = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n   \
    \ paren_groups[\"\"] = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups[\"\"] = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups[\"\"] = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups[\"\"] = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups[\"\"] = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups[\"\"] = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups[\"\"] = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups[\"\"] = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups[\"\"] = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups[\"\"] = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups[\"\"] = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups[\"\"] = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups[\"\"] = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups[\"\"] = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups[\"\"] = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups[\"\"] = make([]string, 0)\n\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups[\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5uj9h2f1_test.go:74:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]string, 0)\n\
    \    paren_stack = append(paren_stack, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    for len(paren_stack) > 0 {\n        paren_string = paren_stack[len(paren_stack)-1]\n\
    \        paren_stack = paren_stack[:len(paren_stack)-1]\n        paren_groups\
    \ = append(paren_groups, paren_string)\n        paren_stack = append(paren_stack,\
    \ paren_string)\n    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjd_065ns_test.go:15:5: undefined: paren_groups

    /tmp/tmpjd_065ns_test.go:16:5: undefined: paren_stack

    /tmp/tmpjd_065ns_test.go:17:26: undefined: paren_stack

    /tmp/tmpjd_065ns_test.go:18:27: undefined: paren_groups

    /tmp/tmpjd_065ns_test.go:19:13: undefined: paren_stack

    /tmp/tmpjd_065ns_test.go:20:24: undefined: paren_stack

    /tmp/tmpjd_065ns_test.go:21:23: undefined: paren_stack

    /tmp/tmpjd_065ns_test.go:22:31: undefined: paren_groups

    /tmp/tmpjd_065ns_test.go:23:30: undefined: paren_stack

    /tmp/tmpjd_065ns_test.go:25:12: undefined: paren_groups

    /tmp/tmpjd_065ns_test.go:25:12: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074062
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp142w5_m4_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]string, 0)\n\
    \    paren_stack = append(paren_stack, paren_string)\n    for len(paren_stack)\
    \ > 0 {\n        paren_group = paren_stack[len(paren_stack)-1]\n        paren_stack\
    \ = paren_stack[:len(paren_stack)-1]\n        paren_groups = append(paren_groups,\
    \ paren_group)\n    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp732lg2n5_test.go:15:5: undefined: paren_groups

    /tmp/tmp732lg2n5_test.go:16:5: undefined: paren_stack

    /tmp/tmp732lg2n5_test.go:17:26: undefined: paren_stack

    /tmp/tmp732lg2n5_test.go:18:13: undefined: paren_stack

    /tmp/tmp732lg2n5_test.go:19:9: undefined: paren_group

    /tmp/tmp732lg2n5_test.go:19:23: undefined: paren_stack

    /tmp/tmp732lg2n5_test.go:20:23: undefined: paren_stack

    /tmp/tmp732lg2n5_test.go:21:9: undefined: paren_groups

    /tmp/tmp732lg2n5_test.go:21:31: undefined: paren_groups

    /tmp/tmp732lg2n5_test.go:21:45: undefined: paren_group

    /tmp/tmp732lg2n5_test.go:21:9: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074062
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_string := \"\"\n \
    \   paren_group_open := false\n    paren_group_closed := false\n    for _, char\
    \ := range paren_string {\n        if char == '(' {\n            if paren_group_open\
    \ {\n                fmt.Println(\"Found nested paren group\")\n             \
    \   fmt.Println(paren_group_string)\n                fmt.Println(paren_group_strings)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Print\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n \
    \ candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8coy738c_test.go:68:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    for _, char := range paren_string {\n        if char\
    \ == '(' {\n            open_braces++\n            stack = append(stack, char)\n\
    \        } else if char == ')' {\n            close_braces++\n            if open_braces\
    \ != close_braces {\n                fmt.Println(\"Mismatched braces\")\n    \
    \        }\n            open_braces--\n            stack = stack[:len(stack)-1]\n\
    \        } else if char == ' ' {\n            continue\n        } else {\n   \
    \         fmt.Println(\"Mismatched parens\")\n        }\n    }\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi0kkr03z_test.go:22:35: cannot use char (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074062
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_string := \"\"\n \
    \   paren_group_open := false\n    paren_group_closed := false\n    for _, char\
    \ := range paren_string {\n        if char == '(' {\n            if paren_group_open\
    \ {\n                fmt.Println(\"Found nested paren group\")\n             \
    \   paren_group_strings = append(paren_group_strings, paren_group_string)\n  \
    \              paren_group_string = \"\"\n                paren_group_open = false\n\
    \                paren_group_closed = false\n            }\n            paren_group_open\
    \ = true\n        } else if char == ')' {\n            if paren_group_closed {\n\
    \                fmt.Println(\"Found nested paren group\")\n                paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n                paren_group_string\
    \ = \"\"\n                paren_group_open = false\n                paren_group_closed\
    \ = false\n            }\n            paren_group_closed = true\n        } else\
    \ if char == ' ' {\n            if paren_group_open {\n                paren_group_string\
    \ = paren_group_string + char\n            } else {\n                paren_group_string\
    \ = paren_group_string + char\n            }\n        } else {\n            if\
    \ paren_group_open {\n                paren_group_string = paren_group_string\
    \ + char\n            } else {\n                paren_group_string = paren_group_string\
    \ + char\n            }\n        }\n    }\n    if paren_group_open {\n       \
    \ fmt.Println(\"Found nested paren group\")\n        paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n    }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpua3k_i0o_test.go:40:38: invalid operation: paren_group_string + char (mismatched
    types string and rune)

    /tmp/tmpua3k_i0o_test.go:42:38: invalid operation: paren_group_string + char (mismatched
    types string and rune)

    /tmp/tmpua3k_i0o_test.go:46:38: invalid operation: paren_group_string + char (mismatched
    types string and rune)

    /tmp/tmpua3k_i0o_test.go:48:38: invalid operation: paren_group_string + char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074062
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_regex := regexp.MustCompile(`\\((?P<group>[^\\(\\)]+)\\)`)\n\
    \    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string, -1)\n\
    \    result := make([]string, len(paren_groups))\n    for index, group := range\
    \ paren_groups {\n        result[index] = group[1]\n    }\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0nxpk088_test.go:15:26: undefined: regexp

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074062
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpau96mwwn_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp142w5_m4_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_count := 0\n    paren_group_string\
    \ := \"\"\n    paren_group_open_brace := false\n    paren_group_close_brace :=\
    \ false\n    for _, character := range paren_string {\n        if character ==\
    \ '(' {\n            if paren_group_open_brace {\n                fmt.Println(\"\
    Found an open brace without closing it\")\n            }\n            paren_group_open_brace\
    \ = true\n            paren_group_string += character\n        } else if character\
    \ == ')' {\n            if paren_group_close_brace {\n                fmt.Println(\"\
    Found an open brace without closing it\")\n            }\n            paren_group_close_brace\
    \ = true\n            paren_group_string += character\n        } else if character\
    \ == ' ' {\n            fmt.Println(\"Found a space without an open brace or closing\
    \ it\")\n        } else {\n            if paren_group_open_brace {\n         \
    \       paren_group_string += character\n            } else if paren_group_close_brace\
    \ {\n                paren_group_string += character\n            } else {\n \
    \               paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group_string = \"\"\n                paren_group_open_brace\
    \ = false\n                paren_group_close_brace = false\n                paren_group_count\
    \ += 1\n            }\n        }\n    }\n    paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt_5o3mya_test.go:26:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmpt_5o3mya_test.go:32:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmpt_5o3mya_test.go:37:17: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmpt_5o3mya_test.go:39:17: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074062
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcjsiyes8_test.go:54:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stacks := make(map[string]bool)\n    stack :=\
    \ \"\"\n    for _, char := range paren_string {\n        if char == '(' {\n  \
    \          stacks[stack] = true\n            stack = stack + char\n        } else\
    \ if char == ')' {\n            stacks[stack] = false\n            stack = stack\
    \ + char\n        } else if stacks[stack] {\n            stack = stack + char\n\
    \        } else {\n            result = append(result, stack)\n            stack\
    \ = char\n        }\n    }\n    result = append(result, stack)\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5nd_ejxe_test.go:21:21: invalid operation: stack + char (mismatched types
    string and rune)

    /tmp/tmp5nd_ejxe_test.go:24:21: invalid operation: stack + char (mismatched types
    string and rune)

    /tmp/tmp5nd_ejxe_test.go:26:21: invalid operation: stack + char (mismatched types
    string and rune)

    /tmp/tmp5nd_ejxe_test.go:29:21: cannot use char (variable of type rune) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074062
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc_d1b01q_test.go:54:50: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3d2xvuar_test.go:88:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := make([]string, 0)\n    paren_group_string := \"\
    \"\n    paren_group_open := false\n    paren_group_closed := false\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            if paren_group_open\
    \ {\n                fmt.Println(\"Error: unexpected open paren group\")\n   \
    \         }\n            paren_group_open = true\n            paren_group_string\
    \ += char\n        } else if char == ')' {\n            if paren_group_closed\
    \ {\n                fmt.Println(\"Error: unexpected close paren group\")\n  \
    \          }\n            paren_group_closed = true\n            paren_group_string\
    \ += char\n        } else if char == ' ' {\n            if paren_group_open &&\
    \ paren_group_closed {\n                fmt.Println(\"Error: unexpected space\
    \ between paren groups\")\n            }\n            paren_group_string += char\n\
    \        } else {\n            paren_group_string += char\n        }\n    }\n\
    \    if paren_group_string != \"\" {\n        paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n    }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_kfd3m6j_test.go:25:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmp_kfd3m6j_test.go:31:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmp_kfd3m6j_test.go:36:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmp_kfd3m6j_test.go:38:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074062
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a stack to keep track of open and closed brackets\n   \
    \ stack := make([]string, 0)\n\n    // Iterate through each character in the input\
    \ string\n    for _, c := range paren_string {\n        // If the character is\
    \ a left paren, push it onto the stack\n        if c == '(' {\n            stack\
    \ = append(stack, c) // Add it to the stack\n        }\n        // If the character\
    \ is a right paren, pop it from the stack\n        if c == ')' {\n           \
    \ stack := stack[:len(stack)-1] // Remove the last element from the stack\n  \
    \      }\n        // If the stack is empty, that means we've encountered a closed\
    \ bracket without an open one\n        if len(stack) == 0 {\n            return\
    \ nil\n        }\n    }\n    // If we reach this point, the stack is empty and\
    \ we encountered a closed bracket without an open one\n    return stack\n}\n\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaj5plt_o_test.go:22:35: cannot use c (variable of type rune) as type string
    in argument to append

    /tmp/tmpaj5plt_o_test.go:26:13: stack declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_string := \"\"\n \
    \   paren_group_open := false\n    paren_group_closed := false\n    paren_group_count\
    \ := 0\n    for _, char := range paren_string {\n        if char == '(' {\n  \
    \          if paren_group_open {\n                fmt.Println(\"Found nested group\"\
    )\n                paren_group_string += char\n                paren_group_open\
    \ = false\n                paren_group_closed = false\n                paren_group_count\
    \ = 0\n            } else {\n                paren_group_string += char\n    \
    \            paren_group_open = true\n                paren_group_closed = false\n\
    \                paren_group_count = 0\n            }\n        } else if char\
    \ == ')' {\n            if paren_group_closed {\n                fmt.Println(\"\
    Found nested group\")\n                paren_group_string += char\n          \
    \      paren_group_open = false\n                paren_group_closed = false\n\
    \                paren_group_count = 0\n            } else {\n               \
    \ paren_group_string += char\n                paren_group_open = false\n     \
    \           paren_group_closed = true\n                paren_group_count = 0\n\
    \            }\n        } else if char == ' ' {\n            if paren_group_open\
    \ {\n                paren_group_string += char\n                paren_group_count\
    \ += 1\n            } else {\n                paren_group_string += char\n   \
    \         }\n        } else {\n            if paren_group_open {\n           \
    \     paren_group_string += char\n                paren_group_count += 1\n   \
    \         } else {\n                paren_group_string += char\n            }\n\
    \        }\n    }\n    paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx34eve57_test.go:24:17: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpx34eve57_test.go:29:17: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpx34eve57_test.go:37:17: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpx34eve57_test.go:42:17: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpx34eve57_test.go:49:17: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpx34eve57_test.go:52:17: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpx34eve57_test.go:56:17: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpx34eve57_test.go:59:17: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpau96mwwn_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpau96mwwn_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stacks := make(map[string]bool)\n    stack :=\
    \ \"\"\n    for _, char := range paren_string {\n        if char == '(' {\n  \
    \          if stacks[stack] {\n                fmt.Println(\"Stack already contains\
    \ this group\")\n                return nil\n            }\n            stacks[stack]\
    \ = true\n            stack = stack + char\n        } else if char == ')' {\n\
    \            if !stacks[stack] {\n                fmt.Println(\"Stack does not\
    \ contain this group\")\n                return nil\n            }\n         \
    \   stack = stack + char\n            stacks[stack] = false\n        } else {\n\
    \            stack = stack + char\n        }\n    }\n    for _, stack := range\
    \ stacks {\n        result = append(result, stack)\n    }\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz97da8zt_test.go:25:21: invalid operation: stack + char (mismatched types
    string and rune)

    /tmp/tmpz97da8zt_test.go:31:21: invalid operation: stack + char (mismatched types
    string and rune)

    /tmp/tmpz97da8zt_test.go:34:21: invalid operation: stack + char (mismatched types
    string and rune)

    /tmp/tmpz97da8zt_test.go:38:33: cannot use stack (variable of type bool) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpau96mwwn_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcjsiyes8_test.go:54:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_regex := regexp.MustCompile(`\\((?P<paren_group>[^\\(\\)]+)\\\
    )`)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    result := make([]string, len(paren_groups))\n    for i := range paren_groups\
    \ {\n        result[i] = paren_groups[i].Groups[\"paren_group\"].Value\n    }\n\
    \    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6p9rcxhj_test.go:15:26: undefined: regexp

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stacks := make(map[string]bool)\n    stack :=\
    \ \"\"\n    open_braces := 0\n    close_braces := 0\n    for _, char := range\
    \ paren_string {\n        if char == '(' {\n            open_braces++\n      \
    \      stack = stack + char\n        } else if char == ')' {\n            close_braces++\n\
    \            if stacks[stack] {\n                stacks[stack] = false\n     \
    \           stack = stack[:len(stack)-1]\n            }\n        } else if char\
    \ == ' ' {\n            if open_braces == close_braces {\n                stacks[stack]\
    \ = true\n            }\n        } else {\n            stack = stack + char\n\
    \        }\n    }\n    for stack, open := range stacks {\n        if !open {\n\
    \            result = append(result, stack)\n        }\n    }\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeo_34_t9_test.go:23:21: invalid operation: stack + char (mismatched types
    string and rune)

    /tmp/tmpeo_34_t9_test.go:35:21: invalid operation: stack + char (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_string := \"\"\n \
    \   paren_group_open_braces := 0\n    paren_group_close_braces := 0\n    paren_group_open_parentheses\
    \ := 0\n    paren_group_close_parentheses := 0\n    paren_group_open_brace :=\
    \ false\n    paren_group_close_brace := false\n    paren_group_open_paren := false\n\
    \    paren_group_close_paren := false\n    paren_group_open_brace_or_paren :=\
    \ false\n    paren_group_close_brace_or_paren := false\n    paren_group_open_paren_or_paren\
    \ := false\n    paren_group_close_paren_or_paren := false\n    paren_group_open_brace_or_paren_or_paren\
    \ := false\n    paren_group_close_brace_or_paren_or_paren := false\n    paren_group_open_paren_or_paren_or_paren\
    \ := false\n    paren_group_close_paren_or_paren_or_paren := false\n    paren_group_open_brace_or_paren_or_paren_or_paren\
    \ := false\n    paren_group_close_brace_or_paren_or_paren_or_paren := false\n\
    \    paren_group_open_paren_or_paren_or_paren_or_paren := false\n    paren_group_close_paren_or_paren_or_paren_or_paren\
    \ := false\n    paren_group_open_brace_or_paren_or_paren_or_paren_or_paren :=\
    \ false\n    paren_group_close_brace_or_paren_or_paren_or_paren_or_paren := false\n\
    \    paren_group_open_paren_or_paren_or_paren_or_paren_or_paren := false\n   \
    \ paren_group_close_paren_or_paren_or_paren_or_paren_or_paren := false\n    paren_group_open_brace_or_paren_or_paren_or_paren_or_paren_or_paren\
    \ := false\n    paren_group_close_brace_or_paren_or_paren_or_paren_or_paren_or_paren\
    \ := false\n    paren_group_open_paren_or_paren_or_paren_or_paren_or_paren_or_paren\
    \ := false\n    paren_group_close_paren_or_paren_or_paren_or_paren_or_paren_or_paren\
    \ := false\n    paren_group_open_brace_or_paren_or_paren_or_paren_or_paren\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpszxe6kjv_test.go:46:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074063
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group := \"\"\n    paren_group_open\
    \ := false\n    paren_group_closed := false\n    paren_group_string := \"\"\n\
    \    for _, character := range paren_string {\n        if character == ')' {\n\
    \            if paren_group_open {\n                paren_group_string = paren_group\
    \ + paren_group_string\n                paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n                paren_group_string = \"\"\n           \
    \     paren_group_open = false\n                paren_group_closed = false\n \
    \           } else {\n                paren_group_open = false\n             \
    \   paren_group_closed = true\n            }\n        } else if character == '('\
    \ {\n            if paren_group_closed {\n                paren_group_string =\
    \ paren_group + paren_group_string\n                paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n                paren_group_string = \"\"\n           \
    \     paren_group_open = false\n                paren_group_closed = false\n \
    \           } else {\n                paren_group_open = true\n              \
    \  paren_group_closed = false\n            }\n        } else {\n            paren_group_string\
    \ = paren_group + character\n            paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n            paren_group = \"\"\n            paren_group_open\
    \ = false\n            paren_group_closed = false\n        }\n    }\n    return\
    \ paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n \
    \ candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpucsi73zw_test.go:44:34: invalid operation: paren_group + character (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stack := make([]string, 0)\n    stack := append(stack,\
    \ paren_string)\n    for len(stack) > 0 {\n        result := []string{}\n    \
    \    for _, s := range stack {\n            switch {\n            case s == ')':\n\
    \                if len(stack) == 0 {\n                    fmt.Println(\"Stack\
    \ is empty\")\n                }\n                stack = stack[:len(stack)-1]\n\
    \                break\n            case s == '(':\n                stack = append(stack,\
    \ s)\n                break\n            case s == ' ':\n                break\n\
    \            default:\n                fmt.Println(\"Stack contains invalid character\"\
    )\n            }\n        }\n        result = append(result, stack...)\n    }\n\
    \    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp77ypzjea_test.go:17:11: no new variables on left side of :=

    /tmp/tmp77ypzjea_test.go:22:23: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    /tmp/tmp77ypzjea_test.go:28:23: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmp77ypzjea_test.go:31:23: invalid operation: s == '' '' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcjsiyes8_test.go:54:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcjsiyes8_test.go:54:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[1 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[1 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[1 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[1 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[1 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1c6bsfr9_test.go:53:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074063
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3d2xvuar_test.go:88:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_string := \"\"\n \
    \   brace_count := 0\n    open_paren_count := 0\n    close_paren_count := 0\n\
    \    brace_count += count_open_braces(paren_string)\n    open_paren_count += count_open_parens(paren_string)\n\
    \    close_paren_count += count_close_parens(paren_string)\n    paren_group_string\
    \ = paren_string\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i]\
    \ == '(' {\n            paren_group_string += paren_string[i]\n            paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n            paren_group_string\
    \ = \"\"\n            brace_count++\n            open_paren_count++\n        }\
    \ else if paren_string[i] == ')' {\n            paren_group_string += paren_string[i]\n\
    \            paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \            paren_group_string = \"\"\n            brace_count--\n          \
    \  close_paren_count--\n        } else if paren_string[i] == ' ' {\n         \
    \   paren_group_string += paren_string[i]\n            paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n            paren_group_string = \"\"\n        } else {\n\
    \            paren_group_string += paren_string[i]\n        }\n    }\n    paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzoqbs4at_test.go:20:20: undefined: count_open_braces

    /tmp/tmpzoqbs4at_test.go:21:25: undefined: count_open_parens

    /tmp/tmpzoqbs4at_test.go:22:26: undefined: count_close_parens

    /tmp/tmpzoqbs4at_test.go:26:13: invalid operation: paren_group_string += paren_string[i]
    (mismatched types string and byte)

    /tmp/tmpzoqbs4at_test.go:32:13: invalid operation: paren_group_string += paren_string[i]
    (mismatched types string and byte)

    /tmp/tmpzoqbs4at_test.go:38:13: invalid operation: paren_group_string += paren_string[i]
    (mismatched types string and byte)

    /tmp/tmpzoqbs4at_test.go:42:13: invalid operation: paren_group_string += paren_string[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make(map[string][]string)\n    paren_groups [\"(\"] =\
    \ make([]string, 0)\n    paren_groups [\")\"] = make([]string, 0)\n    paren_groups\
    \ [\"((\"] = make([]string, 0)\n    paren_groups [\")(\"] = make([]string, 0)\n\
    \    paren_groups [\"(()\"] = make([]string, 0)\n    paren_groups [\")()\"] =\
    \ make([]string, 0)\n\n    paren_groups [\"((\"] = append(paren_groups [\"((\"\
    ], paren_string)\n    paren_groups [\")(\"] = append(paren_groups [\")(\"], paren_string)\n\
    \    paren_groups [\"(()\"] = append(paren_groups [\"(()\"], paren_string)\n \
    \   paren_groups [\")()\"] = append(paren_groups [\")()\"], paren_string)\n\n\
    \    paren_groups [\"(\"] = append(paren_groups [\"(\"], paren_string)\n    paren_groups\
    \ [\")\"] = append(paren_groups [\")\"], paren_string)\n\n    paren_groups [\"\
    (\"] = append(paren_groups [\"(\"], paren_string)\n    paren_groups [\")\"] =\
    \ append(paren_groups [\")\"], paren_string)\n\n    paren_groups [\"(\"] = append(paren_groups\
    \ [\"(\"], paren_string)\n    paren_groups [\")\"] = append(paren_groups [\")\"\
    ], paren_string)\n\n    paren_groups [\"(\"] = append(paren_groups [\"(\"], paren_string)\n\
    \    paren_groups [\")\"] = append(paren_groups [\")\"], paren_string)\n\n   \
    \ paren_groups [\"(\"] = append(paren_groups [\"(\"], paren_string)\n    paren_groups\
    \ [\")\"] = append(paren_groups [\")\"], paren_string)\n\n    paren_groups [\"\
    (\"] = append(paren_groups [\"(\"], paren_string)\n    paren_groups [\")\"] =\
    \ append(paren_groups [\")\"], paren_string)\n\n    paren_groups [\"(\"] = append(paren_groups\
    \ [\"(\"], paren_string)\n    paren_groups [\")\"] = append(paren_groups [\")\"\
    ], paren_string)\n\n    paren_groups [\"(\"] = append(paren_groups [\"(\"], paren_string)\n\
    \    paren_groups [\")\"] = append(paren_groups [\")\"], paren_string)\n\n   \
    \ paren_groups [\"(\"] = append(paren_groups [\"(\"], paren_string)\n    paren_groups\
    \ [\")\"] = append(paren_groups [\")\"], paren_string)\n\n    paren_groups [\"\
    (\"] = append(paren_groups [\"(\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5aej189h_test.go:55:47: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make(map[string][]string)\n    paren_stack = make([]string,\
    \ 0)\n    paren_stack_strings := make([]string, 0)\n    paren_group_string :=\
    \ \"\"\n    paren_group_string += \"(\"\n    paren_group_string += \")\"\n   \
    \ paren_groups[paren_group_string] = []string{}\n    paren_stack_strings = append(paren_stack_strings,\
    \ paren_group_string)\n    paren_stack = append(paren_stack, paren_group_string)\n\
    \    paren_group_string += \"(\"\n    paren_group_string += \")\"\n    paren_groups[paren_group_string]\
    \ = []string{}\n    paren_stack_strings = append(paren_stack_strings, paren_group_string)\n\
    \    paren_stack = append(paren_stack, paren_group_string)\n    paren_group_string\
    \ += \"(\"\n    paren_group_string += \")\"\n    paren_groups[paren_group_string]\
    \ = []string{}\n    paren_stack_strings = append(paren_stack_strings, paren_group_string)\n\
    \    paren_stack = append(paren_stack, paren_group_string)\n    paren_group_string\
    \ += \"(\"\n    paren_group_string += \")\"\n    paren_groups[paren_group_string]\
    \ = []string{}\n    paren_stack_strings = append(paren_stack_strings, paren_group_string)\n\
    \    paren_stack = append(paren_stack, paren_group_string)\n    paren_group_string\
    \ += \"(\"\n    paren_group_string += \")\"\n    paren_groups[paren_group_string]\
    \ = []string{}\n    paren_stack_strings = append(paren_stack_strings, paren_group_string)\n\
    \    paren_stack = append(paren_stack, paren_group_string)\n    paren_group_string\
    \ += \"(\"\n    paren_group_string += \")\"\n    paren_groups[paren_group_string]\
    \ = []string{}\n    paren_stack_strings = append(paren_stack_strings, paren_group_string)\n\
    \    paren_stack = append(paren_stack, paren_group_string)\n    paren_group_string\
    \ += \"(\"\n    paren_group_string += \")\"\n    paren_groups[paren_group_string]\
    \ = []string{}\n    paren_stack_strings = append(paren_stack_strings, paren_group_string)\n\
    \    paren_stack = append(paren_stack, paren_group_string)\n    paren_group_string\
    \ += \"(\"\n    paren_group_string += \")\"\n    paren_groups[paren_group_string\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdlly7iwx_test.go:56:36: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxha8bc21_test.go:54:33: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var groups []string\n    stack := make([]string, 0)\n    stack := append(stack,\
    \ paren_string)\n    for len(stack) > 0 {\n        group := stack[len(stack)-1]\n\
    \        stack = stack[:len(stack)-1]\n        if group == \")\" {\n         \
    \   groups = append(groups, group)\n        } else {\n            stack = append(stack,\
    \ group)\n        }\n    }\n    return groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpobqovh3h_test.go:17:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074065
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcjsiyes8_test.go:54:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp142w5_m4_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcjsiyes8_test.go:54:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp142w5_m4_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a slice to store the result\n    result := make([]string,\
    \ 0)\n\n    // Iterate over each character in the string\n    for _, c := range\
    \ paren_string {\n        // If the character is a left paren, add it to the result\
    \ slice\n        if c == '(' {\n            result = append(result, c)\n     \
    \   }\n\n        // If the character is a right paren, remove it from the result\
    \ slice\n        if c == ')' {\n            result = removeElement(result, c)\n\
    \        }\n    }\n\n    // Return the result\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuzm3dzy1_test.go:22:37: cannot use c (variable of type rune) as type string
    in argument to append

    /tmp/tmpuzm3dzy1_test.go:27:22: undefined: removeElement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074065
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := make([]string, 0)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpi57dsk3v_test.go:39: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()()) ((())) () ((())()()) (()()) ((())) () ((())()()) (()()) ((()))\
    \ () ((())()()) (()()) ((())) () ((())()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpi57dsk3v_test.go:39: expected '[() (()) ((())) (((())))]',\
    \ got '[() (()) ((())) (((()))) () (()) ((())) (((()))) () (()) ((())) (((())))\
    \ () (()) ((())) (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpi57dsk3v_test.go:39: expected '[(()(())((())))]', got '[(()(())((())))\
    \ (()(())((()))) (()(())((()))) (()(())((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpi57dsk3v_test.go:39: expected '[() (()) (()())]', got '[(\
    \ ) (( )) (( )( )) ( ) (( )) (( )( )) ( ) (( )) (( )( )) ( ) (( )) (( )( ))]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074065
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make(map[string][]string)\n    paren_groups [\"()\"] =\
    \ make([]string, 0)\n    paren_groups [\"(())\"] = make([]string, 0)\n    paren_groups\
    \ [\"(()())\"] = make([]string, 0)\n    paren_groups [\"()\"] = make([]string,\
    \ 0)\n    paren_groups [\"(())\"] = make([]string, 0)\n    paren_groups [\"(()())\"\
    ] = make([]string, 0)\n\n    paren_groups [\"()\"] = append(paren_groups [\"()\"\
    ], paren_string)\n    paren_groups [\"(())\"] = append(paren_groups [\"(())\"\
    ], paren_string)\n    paren_groups [\"(()())\"] = append(paren_groups [\"(()())\"\
    ], paren_string)\n    paren_groups [\"()\"] = append(paren_groups [\"()\"], paren_string)\n\
    \    paren_groups [\"(())\"] = append(paren_groups [\"(())\"], paren_string)\n\
    \    paren_groups [\"(()())\"] = append(paren_groups [\"(()())\"], paren_string)\n\
    \n    paren_groups [\"()\"] = append(paren_groups [\"()\"], paren_string)\n  \
    \  paren_groups [\"(())\"] = append(paren_groups [\"(())\"], paren_string)\n \
    \   paren_groups [\"(()())\"] = append(paren_groups [\"(()())\"], paren_string)\n\
    \    paren_groups [\"()\"] = append(paren_groups [\"()\"], paren_string)\n   \
    \ paren_groups [\"(())\"] = append(paren_groups [\"(())\"], paren_string)\n  \
    \  paren_groups [\"(()())\"] = append(paren_groups [\"(()())\"], paren_string)\n\
    \n    paren_groups [\"()\"] = append(paren_groups [\"()\"], paren_string)\n  \
    \  paren_groups [\"(())\"] = append(paren_groups [\"(())\"], paren_string)\n \
    \   paren_groups [\"(()())\"] = append(paren_groups [\"(()())\"], paren_string)\n\
    \    paren_groups [\"()\"] = append(paren_groups [\"()\"], paren_string)\n   \
    \ paren_groups [\"(())\"] = append(paren_groups [\"(())\"], paren_string)\n  \
    \  paren_groups [\"(()())\"] = append(paren_groups [\"(()())\"], paren_string)\n\
    \n    paren_groups [\"()\"] = append(paren_groups [\"()\"], paren_string)\n  \
    \  paren_groups [\"(())\"] = append(paren_groups [\"(())\"], paren_string)\n \
    \   paren_groups [\"(()())\"] = append(paren_groups [\"(()())\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4t_bs0kf_test.go:46:52: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3d2xvuar_test.go:88:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqw9uyh_a_test.go:54:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]string, 0)\n\
    \    paren_stack = append(paren_stack, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    for len(paren_stack) > 0 {\n        paren_string := paren_stack[len(paren_stack)-1]\n\
    \        paren_stack = paren_stack[:len(paren_stack)-1]\n        switch paren_string\
    \ {\n        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(paren_stack, paren_string)\n\
    \        case \"(\":\n            paren_stack = append(\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbomljdw4_test.go:73:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a slice to store the output\n    output := make([]string,\
    \ 0)\n\n    // Iterate over the input string\n    for _, char := range paren_string\
    \ {\n        // If the current character is a left paren, add it to the output\n\
    \        if char == '(' {\n            output = append(output, char)\n       \
    \ }\n\n        // If the current character is a right paren, remove it from the\
    \ output\n        if char == ')' {\n            output = append(output, string(rand.Intn(len(output))+1))\n\
    \        }\n    }\n\n    // Return the output\n    return output\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuwg6aad4_test.go:22:37: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpuwg6aad4_test.go:27:44: undefined: rand

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074065
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcjsiyes8_test.go:54:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3d2xvuar_test.go:88:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    paren_string += \"\
    )\"\n    for _, char := range paren_string {\n        if char == '(' {\n     \
    \       stack = append(stack, char)\n        } else if char == ')' {\n       \
    \     if len(stack) == 0 {\n                fmt.Println(\"Unbalanced parenthesis\
    \ detected\")\n                return nil\n            }\n            stack =\
    \ stack[:len(stack)-1]\n            result := append(result, string(stack))\n\
    \            stack = []string{}\n        } else {\n            stack = append(stack,\
    \ char)\n        }\n    }\n    if len(stack) > 0 {\n        fmt.Println(\"Unbalanced\
    \ parenthesis detected\")\n        return nil\n    }\n    return result\n}\n\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_mzdqjha_test.go:20:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmp_mzdqjha_test.go:27:13: result declared but not used

    /tmp/tmp_mzdqjha_test.go:27:45: cannot convert stack (variable of type []string)
    to type string

    /tmp/tmp_mzdqjha_test.go:30:35: cannot use char (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074065
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stack := make([]string, 0)\n    stack := append(stack,\
    \ paren_string)\n    for len(stack) > 0 {\n        current := stack[len(stack)-1]\n\
    \        stack = stack[:len(stack)-1]\n        if current == \")\" {\n       \
    \     stack = append(stack, \"(\")\n        } else {\n            stack = append(stack,\
    \ current)\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl07ly5dk_test.go:17:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074065
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := make([]string, 0)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpi57dsk3v_test.go:39: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()()) ((())) () ((())()()) (()()) ((())) () ((())()()) (()()) ((()))\
    \ () ((())()()) (()()) ((())) () ((())()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpi57dsk3v_test.go:39: expected '[() (()) ((())) (((())))]',\
    \ got '[() (()) ((())) (((()))) () (()) ((())) (((()))) () (()) ((())) (((())))\
    \ () (()) ((())) (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpi57dsk3v_test.go:39: expected '[(()(())((())))]', got '[(()(())((())))\
    \ (()(())((()))) (()(())((()))) (()(())((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpi57dsk3v_test.go:39: expected '[() (()) (()())]', got '[(\
    \ ) (( )) (( )( )) ( ) (( )) (( )( )) ( ) (( )) (( )( )) ( ) (( )) (( )( ))]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074065
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphd7kwtg0_test.go:53:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a list to store our results\n    result := make([]string,\
    \ 0)\n\n    // Iterate through each character in the string\n    for _, char :=\
    \ range paren_string {\n        // If the character is a left paren, add it to\
    \ the list\n        if char == '(' {\n            result = append(result, char)\n\
    \        }\n\n        // If the character is a right paren, remove it from the\
    \ list\n        if char == ')' {\n            result = removeLast(result)\n  \
    \      }\n    }\n\n    // Return the list of results\n    return result\n}\n\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97yqvcul_test.go:22:37: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmp97yqvcul_test.go:27:22: undefined: removeLast

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074065
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_h57s1vl_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group := \"\"\n    paren_group_open\
    \ := false\n    paren_group_closed := false\n    paren_group_string := \"\"\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   if paren_group_open {\n                fmt.Println(\"Found open paren group\
    \ with no matching close paren group\")\n            }\n            paren_group_open\
    \ = true\n            paren_group = char\n        } else if char == ')' {\n  \
    \          if paren_group_open {\n                paren_group_open = false\n \
    \               paren_group_closed = true\n            } else {\n            \
    \    fmt.Println(\"Found close paren group with no matching open paren group\"\
    )\n            }\n        } else if char == ' ' {\n            if paren_group_open\
    \ {\n                paren_group_open = false\n                paren_group_closed\
    \ = false\n            } else {\n                fmt.Println(\"Found space with\
    \ no matching open or close paren group\")\n            }\n        } else if paren_group_open\
    \ {\n            paren_group_string += char\n        } else if paren_group_closed\
    \ {\n            paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \            paren_group_string = \"\"\n            paren_group_open = false\n\
    \            paren_group_closed = false\n        }\n    }\n    if paren_group_open\
    \ {\n        fmt.Println(\"Found open paren group with no matching close paren\
    \ group\")\n    }\n    if paren_group_closed {\n        fmt.Println(\"Found close\
    \ paren group with no matching open paren group\")\n    }\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxz69tify_test.go:26:27: cannot use char (variable of type rune) as type
    string in assignment

    /tmp/tmpxz69tify_test.go:42:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074066
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stack := make([]string, 0)\n    stack := append(stack,\
    \ paren_string)\n    for len(stack) > 0 {\n        current := stack[len(stack)-1]\n\
    \        stack = stack[:len(stack)-1]\n        if current == ')' {\n         \
    \   result := append(result, current)\n        } else {\n            stack = append(stack,\
    \ current)\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj3bc20h2_test.go:17:11: no new variables on left side of :=

    /tmp/tmpj3bc20h2_test.go:21:23: invalid operation: current == '')'' (mismatched
    types string and untyped rune)

    /tmp/tmpj3bc20h2_test.go:22:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074066
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := make([]string, 0)\n    paren_group_string := \"\
    \"\n    paren_group_open := false\n    paren_group_closed := false\n    paren_group_count\
    \ := 0\n    for _, char := range paren_string {\n        if char == '(' {\n  \
    \          if paren_group_open {\n                fmt.Println(\"Found nested paren\
    \ group\")\n                paren_group_closed++\n            } else {\n     \
    \           paren_group_open = true\n                paren_group_count++\n   \
    \         }\n        } else if char == ')' {\n            if paren_group_closed\
    \ {\n                fmt.Println(\"Found nested paren group\")\n             \
    \   paren_group_open = false\n                paren_group_closed--\n         \
    \   } else {\n                paren_group_closed = true\n            }\n     \
    \   } else if char == ' ' {\n            if paren_group_open && paren_group_closed\
    \ {\n                fmt.Println(\"Found nested paren group\")\n             \
    \   paren_group_open = false\n                paren_group_closed--\n         \
    \   }\n        } else {\n            if paren_group_open {\n                paren_group_string\
    \ += char\n            } else {\n                paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n                paren_group_string = \"\"\n           \
    \     paren_group_open = false\n                paren_group_closed = false\n \
    \               paren_group_count = 1\n            }\n        }\n    }\n    paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7lyhw09e_test.go:24:17: invalid operation: paren_group_closed++ (non-numeric
    type bool)

    /tmp/tmp7lyhw09e_test.go:33:17: invalid operation: paren_group_closed-- (non-numeric
    type bool)

    /tmp/tmp7lyhw09e_test.go:41:17: invalid operation: paren_group_closed-- (non-numeric
    type bool)

    /tmp/tmp7lyhw09e_test.go:45:17: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074066
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_string := \"\"\n \
    \   paren_group_count := 0\n    for _, char := range paren_string {\n        if\
    \ char == '(' {\n            paren_group_count++\n        } else if char == ')'\
    \ {\n            paren_group_count--\n        } else if paren_group_count == 0\
    \ {\n            paren_group_string = paren_group_string + char\n        } else\
    \ {\n            paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \            paren_group_string = \"\"\n            paren_group_count = 0\n  \
    \      }\n    }\n    paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8c09srmk_test.go:24:34: invalid operation: paren_group_string + char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074066
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpabwuh8hn_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074065
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxha8bc21_test.go:54:33: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    paren_string += \"\
    )\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa7g7alka_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074065
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a stack to store all open parens\n    stack := make([]string,\
    \ 0)\n    // Initialize a result list to store all groups of parens\n    result\
    \ := make([]string, 0)\n    // Iterate over all characters in the input string\n\
    \    for _, c := range paren_string {\n        // If the character is open paren,\
    \ push it into the stack\n        if c == '(' {\n            stack = append(stack,\
    \ c) // Add it to the stack\n        } else if c == ')' {\n            // If the\
    \ stack is not empty, pop the top element and add it to the result list\n    \
    \        if len(stack) > 0 {\n                result := append(result, string(stack[len(stack)-1]))\n\
    \                // Pop the top element from the stack\n                stack\
    \ = stack[:len(stack)-1]\n            }\n        }\n    }\n    // If the stack\
    \ is not empty, add the last element to the result list\n    if len(stack) > 0\
    \ {\n        result := append(result, string(stack[len(stack)-1]))\n    }\n  \
    \  return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx952j_6r_test.go:23:35: cannot use c (variable of type rune) as type string
    in argument to append

    /tmp/tmpx952j_6r_test.go:27:17: result declared but not used

    /tmp/tmpx952j_6r_test.go:35:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074066
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_string := \"\"\n \
    \   paren_group_open := false\n    paren_group_closed := false\n    paren_group_string\
    \ += paren_string\n    for _, character := range paren_string {\n        if character\
    \ == '(' {\n            if paren_group_open {\n                fmt.Println(\"\
    Found an open paren group without closing it\")\n                fmt.Println(paren_group_string)\n\
    \                fmt.Println(paren_group_strings)\n                panic(\"Found\
    \ an open paren group without closing it\")\n            }\n            paren_group_open\
    \ = true\n            paren_group_string += character\n        } else if character\
    \ == ')' {\n            if paren_group_closed {\n                fmt.Println(\"\
    Found an open paren group without closing it\")\n                fmt.Println(paren_group_string)\n\
    \                fmt.Println(paren_group_strings)\n                panic(\"Found\
    \ an open paren group without closing it\")\n            }\n            paren_group_closed\
    \ = true\n            paren_group_string += character\n        } else if paren_group_open\
    \ && paren_group_closed {\n            paren_group_string += character\n     \
    \   } else if paren_group_open {\n            paren_group_string += character\n\
    \        } else if paren_group_closed {\n            paren_group_string += character\n\
    \        } else {\n            fmt.Println(\"Found an open paren group without\
    \ closing it\")\n            fmt.Println(paren_group_string)\n            fmt.Println(paren_group_strings)\n\
    \            fmt.Println(character)\n            panic(\"Found an open paren group\
    \ without closing it\")\n        }\n    }\n    return paren_group_strings\n}\n\
    \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp85rtyead_test.go:29:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmp85rtyead_test.go:38:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmp85rtyead_test.go:40:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmp85rtyead_test.go:42:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmp85rtyead_test.go:44:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074066
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stack, _ := make([]string, 0)\n    stack :=\
    \ append(stack, paren_string)\n    for len(stack) > 0 {\n        s := stack[len(stack)-1]\n\
    \        if s == ')' {\n            stack = stack[:len(stack)-1]\n           \
    \ result := append(result, s)\n        } else if s == '(' {\n            stack\
    \ = stack[:len(stack)-1]\n        } else {\n            stack = append(stack,\
    \ s)\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpde6cl23z_test.go:16:17: assignment mismatch: 2 variables but make returns
    1 value

    /tmp/tmpde6cl23z_test.go:17:11: no new variables on left side of :=

    /tmp/tmpde6cl23z_test.go:22:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074066
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stack := make([]string, 0)\n    stack := append(stack,\
    \ paren_string)\n    for len(stack) > 0 {\n        current := stack[len(stack)-1]\n\
    \        stack = stack[:len(stack)-1]\n        if current == ')' {\n         \
    \   stack = append(stack, current)\n        } else {\n            stack = append(stack,\
    \ current)\n            result = append(result, current)\n        }\n    }\n \
    \   return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu1u4v2lv_test.go:17:11: no new variables on left side of :=

    /tmp/tmpu1u4v2lv_test.go:21:23: invalid operation: current == '')'' (mismatched
    types string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074066
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]int, 0)\n\
    \    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ -1)\n    paren_stack = append(\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxpm3pyio_test.go:62:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074065
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[1 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[1 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[1 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[1 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[1 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[1 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_27x0e34_test.go:53:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074065
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := make([]string, 0)\n    stack := make([]string, 0)\n    stack\
    \ := append(stack, paren_string)\n    for len(stack) > 0 {\n        paren_string\
    \ := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        result\
    \ := append(result, paren_string)\n        i := 0\n        for ; i < len(paren_string);\
    \ i++ {\n            if paren_string[i] == '(' {\n                stack = append(stack,\
    \ paren_string[:i])\n            }\n            if paren_string[i] == ')' {\n\
    \                stack = append(stack, paren_string[i+1:])\n            }\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxw590j6e_test.go:17:11: no new variables on left side of :=

    /tmp/tmpxw590j6e_test.go:21:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074066
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize result list to store all groups\n    var result []string\n\
    \n    // Iterate over all characters in the input string\n    for _, character\
    \ := range paren_string {\n        // If the character is a left paren, append\
    \ it to the result list\n        if character == '(' {\n            result = append(result,\
    \ character)\n        }\n\n        // If the character is a right paren, remove\
    \ it from the result list\n        if character == ')' {\n            result =\
    \ remove(result, character)\n        }\n    }\n\n    // Return the result list\n\
    \    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppwgbn4o5_test.go:22:37: cannot use character (variable of type rune) as
    type string in argument to append

    /tmp/tmppwgbn4o5_test.go:27:22: undefined: remove

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074066
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stack := make([]string, 0)\n    stack := append(stack,\
    \ paren_string)\n    for len(stack) > 0 {\n        s := stack[len(stack)-1]\n\
    \        stack = stack[:len(stack)-1]\n        if s == \"\" {\n            continue\n\
    \        }\n        if s[0] == '(' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == ')' {\n            stack\
    \ = append(stack[:len(stack)-1], s[1:])\n            continue\n        }\n   \
    \     if s[0] == ' ' {\n            continue\n        }\n        if s[0] == '['\
    \ {\n            stack = append(stack[:len(stack)-1], s[1:])\n            continue\n\
    \        }\n        if s[0] == ']' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == '{' {\n        \
    \    stack = append(stack[:len(stack)-1], s[1:])\n            continue\n     \
    \   }\n        if s[0] == '}' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == '<' {\n        \
    \    stack = append(stack[:len(stack)-1], s[1:])\n            continue\n     \
    \   }\n        if s[0] == '>' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == '/' {\n        \
    \    stack = append(stack[:len(stack)-1], s[1:])\n            continue\n     \
    \   }\n        if s[0] == '\\\\' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == '%' {\n        \
    \    stack = append(stack[:len(stack)-1], s[1:])\n            continue\n     \
    \   }\n        if s[0] == '!' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == '|' {\n        \
    \    stack = append(stack[:len(stack)-1], s[1:])\n            continue\n     \
    \   }\n        if s[0] == '&' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == '+' {\n        \
    \    stack = append(stack[:len(stack)-1], s[1:])\n            continue\n     \
    \   }\n        if s[0] == '-' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == '.' {\n        \
    \    stack = append(stack[:len(stack)-1], s[1:])\n            continue\n     \
    \   }\n        if s[0] == ',' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == ';\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0luejatl_test.go:99:20: rune literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074066
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    stack := append(stack,\
    \ paren_string)\n    index := 0\n    for len(stack) > 0 {\n        index += 1\n\
    \        current := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n\
    \        if current == ')' {\n            result := append(result, current)\n\
    \        } else {\n            stack = append(stack, current)\n        }\n   \
    \ }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n\
    \  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyhlbz76z_test.go:17:11: no new variables on left side of :=

    /tmp/tmpyhlbz76z_test.go:23:23: invalid operation: current == '')'' (mismatched
    types string and untyped rune)

    /tmp/tmpyhlbz76z_test.go:24:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074066
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var groups []string\n    var open_braces int\n    var close_braces int\n\
    \    var open_parens int\n    var close_parens int\n    var current_group string\n\
    \    var current_group_is_closed bool\n    for _, char := range paren_string {\n\
    \        if char == '(' {\n            open_braces++\n            current_group\
    \ = \"\"\n            current_group_is_closed = false\n        } else if char\
    \ == ')' {\n            close_braces++\n            current_group_is_closed =\
    \ true\n        } else if char == ' ' {\n            // Ignore space\n       \
    \ } else if open_braces > 0 && close_braces > 0 && open_braces == close_braces\
    \ {\n            if current_group_is_closed {\n                groups = append(groups,\
    \ current_group)\n                current_group = \"\"\n                current_group_is_closed\
    \ = false\n            } else {\n                current_group += char\n     \
    \       }\n        } else {\n            current_group += char\n        }\n  \
    \  }\n    if current_group != \"\" {\n        groups = append(groups, current_group)\n\
    \    }\n    return groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n\
    \  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpos_w8y2z_test.go:18:9: open_parens declared but not used

    /tmp/tmpos_w8y2z_test.go:19:9: close_parens declared but not used

    /tmp/tmpos_w8y2z_test.go:38:17: invalid operation: current_group += char (mismatched
    types string and rune)

    /tmp/tmpos_w8y2z_test.go:41:13: invalid operation: current_group += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074067
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3d2xvuar_test.go:88:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_string := \"\"\n \
    \   paren_group_open := false\n    paren_group_closed := false\n    paren_group_count\
    \ := 0\n    for _, char := range paren_string {\n        if char == '(' {\n  \
    \          if paren_group_open {\n                fmt.Println(\"Found nested paren\
    \ group\")\n                fmt.Println(paren_group_string)\n                fmt.Println(paren_group_strings)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_count)\n                fmt.Println(paren_group_strings)\n\
    \                fmt.Println(paren_group_string)\n                fmt.Println(paren_group_open)\n\
    \                fmt.Println(paren_group_closed)\n                fmt.Println(paren_group_count)\n\
    \                fmt.Println(paren_group_strings)\n                fmt.Println(paren_group_string)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_count)\n                fmt.Println(paren_group_strings)\n\
    \                fmt.Println(paren_group_string)\n                fmt.Println(paren_group_open)\n\
    \                fmt.Println(paren_group_closed)\n                fmt.Println(paren_group_count)\n\
    \                fmt.Println(paren_group_strings)\n                fmt.Println(paren_group_string)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_count)\n                fmt.Println(paren_group_strings)\n\
    \                fmt.Println(paren_group_string)\n                fmt.Println(paren_group_open)\n\
    \                fmt.Println(paren_group_closed)\n                fmt.Println(paren_group_count)\n\
    \                fmt.Println(paren_group_strings)\n                fmt.Println(paren_group_string)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_count)\n                fmt.Println(paren_group_strings)\n\
    \                fmt.Println(paren_group_string)\n                fmt.Println(paren_group_open)\n\
    \                fmt.Println(paren_group_closed)\n                fmt.Println(paren_group_count)\n\
    \                fmt.Println(paren_group_strings)\n                fmt.Println(paren_group_string)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Print\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n \
    \ candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe0g_vjta_test.go:69:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074066
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \"{}\"\n    paren_string = paren_string[strings.Index(paren_string,\
    \ \"(\"):]\n    paren_string = paren_string[strings.Index(paren_string, \")\"\
    ):]\n    paren_string = paren_string[strings.Index(paren_string, \"(\"):]\n  \
    \  paren_string = paren_string[strings.Index(paren_string, \")\"):]\n    paren_string\
    \ = paren_string[strings.Index(paren_string, \"(\"):]\n    paren_string = paren_string[strings.Index(paren_string,\
    \ \")\"):]\n    paren_string = paren_string[strings.Index(paren_string, \"(\"\
    ):]\n    paren_string = paren_string[strings.Index(paren_string, \")\"):]\n  \
    \  paren_string = paren_string[strings.Index(paren_string, \"(\"):]\n    paren_string\
    \ = paren_string[strings.Index(paren_string, \")\"):]\n    paren_string = paren_string[strings.Index(paren_string,\
    \ \"(\"):]\n    paren_string = paren_string[strings.Index(paren_string, \")\"\
    ):]\n    paren_string = paren_string[strings.Index(paren_string, \"(\"):]\n  \
    \  paren_string = paren_string[strings.Index(paren_string, \")\"):]\n    paren_string\
    \ = paren_string[strings.Index(paren_string, \"(\"):]\n    paren_string = paren_string[strings.Index(paren_string,\
    \ \")\"):]\n    paren_string = paren_string[strings.Index(paren_string, \"(\"\
    ):]\n    paren_string = paren_string[strings.Index(paren_string, \")\"):]\n  \
    \  paren_string = paren_string[strings.Index(paren_string, \"(\"):]\n    paren_string\
    \ = paren_string[strings.Index(paren_string, \")\"):]\n    paren_string = paren_string[strings.Index(paren_string,\
    \ \"(\"):]\n    paren_string = paren_string[strings.Index(paren_string, \")\"\
    ):]\n    paren_string = paren_string[strings.Index(paren_string, \"(\"):]\n  \
    \  paren_string = paren_string[strings.Index(paren_string, \")\"):]\n    paren_string\
    \ = paren_string[strings.Index(paren_string, \"(\"):]\n    paren_string = paren_string[strings.Index(paren_string,\
    \ \")\"):]\n    paren_string = paren_string[strings.Index(paren_string, \"(\"\
    ):]\n    paren_string = paren_string[strings.Index(paren_string, \")\"):]\n  \
    \  paren_string = paren_string[strings.Index(paren_string, \"(\"):]\n    paren_string\
    \ = paren_string[strings.Index(paren_string, \")\"):]\n    paren_string = paren_string[strings.Index(paren_string,\
    \ \"(\"):]\n    paren_string = paren_string[strings.Index(\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9tjqcbsu_test.go:48:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074066
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n   \
    \ brace_close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_brace\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfndjpt8q_test.go:73:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074066
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp142w5_m4_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := make([]string, 0)\n    paren_group_string := \"\
    \"\n    paren_group_open := false\n    paren_group_closed := false\n    paren_group_count\
    \ := 0\n    for _, character := range paren_string {\n        if character ==\
    \ '(' {\n            if paren_group_open {\n                fmt.Printf(\"Found\
    \ a nested paren group at index %d\\n\", paren_group_count)\n                paren_group_closed++\n\
    \            } else {\n                paren_group_open = true\n             \
    \   paren_group_count++\n            }\n        } else if character == ')' {\n\
    \            if paren_group_closed {\n                fmt.Printf(\"Found a nested\
    \ paren group at index %d\\n\", paren_group_count)\n                paren_group_open\
    \ = false\n            } else {\n                paren_group_closed = true\n \
    \               paren_group_count++\n            }\n        } else if character\
    \ == ' ' {\n            if paren_group_open {\n                fmt.Printf(\"Found\
    \ a space at index %d\\n\", paren_group_count)\n                paren_group_closed++\n\
    \            } else {\n                paren_group_open = true\n             \
    \   paren_group_count++\n            }\n        } else {\n            paren_group_string\
    \ += character\n        }\n    }\n    if paren_group_open {\n        fmt.Printf(\"\
    Found a nested paren group at index %d\\n\", paren_group_count)\n        paren_group_closed++\n\
    \    }\n    if paren_group_closed {\n        fmt.Printf(\"Found a nested paren\
    \ group at index %d\\n\", paren_group_count)\n        paren_group_open = false\n\
    \    }\n    paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpalpetzfj_test.go:24:17: invalid operation: paren_group_closed++ (non-numeric
    type bool)

    /tmp/tmpalpetzfj_test.go:40:17: invalid operation: paren_group_closed++ (non-numeric
    type bool)

    /tmp/tmpalpetzfj_test.go:46:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmpalpetzfj_test.go:51:9: invalid operation: paren_group_closed++ (non-numeric
    type bool)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074067
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_h57s1vl_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074064
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]string, 0)\n\
    \    paren_stack = append(paren_stack, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    for len(paren_stack) > 0 {\n        paren_str = paren_stack[len(paren_stack)-1]\n\
    \        paren_stack = paren_stack[:len(paren_stack)-1]\n        if paren_str\
    \ == \")\" {\n            paren_groups = append(paren_groups, paren_str)\n   \
    \     } else {\n            paren_stack = append(paren_stack, paren_str)\n   \
    \     }\n    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5rp7zpj4_test.go:15:5: undefined: paren_groups

    /tmp/tmp5rp7zpj4_test.go:16:5: undefined: paren_stack

    /tmp/tmp5rp7zpj4_test.go:17:26: undefined: paren_stack

    /tmp/tmp5rp7zpj4_test.go:18:27: undefined: paren_groups

    /tmp/tmp5rp7zpj4_test.go:19:13: undefined: paren_stack

    /tmp/tmp5rp7zpj4_test.go:20:9: undefined: paren_str

    /tmp/tmp5rp7zpj4_test.go:20:21: undefined: paren_stack

    /tmp/tmp5rp7zpj4_test.go:21:23: undefined: paren_stack

    /tmp/tmp5rp7zpj4_test.go:22:12: undefined: paren_str

    /tmp/tmp5rp7zpj4_test.go:23:35: undefined: paren_groups

    /tmp/tmp5rp7zpj4_test.go:23:35: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074067
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    for _, character :=\
    \ range paren_string {\n        if character == '(' {\n            stack = append(stack,\
    \ character)\n        } else if character == ')' {\n            if len(stack)\
    \ == 0 {\n                fmt.Println(\"Stack empty\")\n            }\n      \
    \      stack = stack[:len(stack)-1]\n            if stack[len(stack)-1] == '('\
    \ {\n                stack = stack[:len(stack)-1]\n            }\n           \
    \ stack = append(stack, character)\n        } else {\n            if stack[len(stack)-1]\
    \ == '(' {\n                stack = stack[:len(stack)-1]\n            }\n    \
    \        stack = append(stack, character)\n        }\n    }\n    for _, character\
    \ := range stack {\n        result = append(result, character)\n    }\n    return\
    \ result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate :=\
    \ separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected:\
    \ []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"\
    ( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpucaktlx9_test.go:19:35: cannot use character (variable of type rune) as
    type string in argument to append

    /tmp/tmpucaktlx9_test.go:25:39: invalid operation: stack[len(stack) - 1] == ''(''
    (mismatched types string and untyped rune)

    /tmp/tmpucaktlx9_test.go:28:35: cannot use character (variable of type rune) as
    type string in argument to append

    /tmp/tmpucaktlx9_test.go:30:39: invalid operation: stack[len(stack) - 1] == ''(''
    (mismatched types string and untyped rune)

    /tmp/tmpucaktlx9_test.go:33:35: cannot use character (variable of type rune) as
    type string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074067
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a list to store the result\n    result := make([]string,\
    \ 0)\n\n    // Iterate over each character in the string\n    for _, c := range\
    \ paren_string {\n        // If the character is a left paren, push it to the\
    \ result list\n        if c == '(' {\n            result = append(result, c)\n\
    \        }\n\n        // If the character is a right paren, pop the last element\
    \ from the result list\n        if c == ')' {\n            result = result[:len(result)-1]\n\
    \        }\n    }\n\n    // Return the result list\n    return result\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvxvqbpj9_test.go:22:37: cannot use c (variable of type rune) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074067
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_string := \"\"\n \
    \   paren_group_open := false\n    paren_group_closed := false\n    for _, character\
    \ := range paren_string {\n        if paren_group_open {\n            paren_group_string\
    \ += character\n        } else if paren_group_closed {\n            paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n            paren_group_string\
    \ = \"\"\n            paren_group_open = false\n            paren_group_closed\
    \ = false\n        } else if character == '(' {\n            paren_group_open\
    \ = true\n        } else if character == ')' {\n            paren_group_closed\
    \ = true\n        }\n    }\n    paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp89eeknoh_test.go:21:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074067
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpau96mwwn_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := make([]string, 0)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkqhog0p2_test.go:48:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make(map[string][]string)\n    paren_groups [\"(\"] =\
    \ make([]string, 0)\n    paren_groups [\")\"] = make([]string, 0)\n    paren_groups\
    \ [\"((\"] = make([]string, 0)\n    paren_groups [\")(\"] = make([]string, 0)\n\
    \    paren_groups [\"(()\"] = make([]string, 0)\n    paren_groups [\")()\"] =\
    \ make([]string, 0)\n    paren_groups [\"(()()\"] = make([]string, 0)\n    paren_groups\
    \ [\")()()\"] = make([]string, 0)\n    paren_groups [\"(()()()\"] = make([]string,\
    \ 0)\n    paren_groups [\")()()()\"] = make([]string, 0)\n    paren_groups [\"\
    (()()()()\"] = make([]string, 0)\n    paren_groups [\")()()()()\"] = make([]string,\
    \ 0)\n    paren_groups [\"(()()()()()\"] = make([]string, 0)\n    paren_groups\
    \ [\")()()()()()\"] = make([]string, 0)\n    paren_groups [\"(()()()()()()\"]\
    \ = make([]string, 0)\n    paren_groups [\")()()()()()()\"] = make([]string, 0)\n\
    \    paren_groups [\"(()()()()()()()\"] = make([]string, 0)\n    paren_groups\
    \ [\")()()()()()()()\"] = make([]string, 0)\n    paren_groups [\"(()()()()()()()()\"\
    ] = make([]string, 0)\n    paren_groups [\")()()()()()()()()\"] = make([]string,\
    \ 0)\n    paren_groups [\"(()()()()()()()()()\"] = make([]string, 0)\n    paren_groups\
    \ [\")()()()()()()()()()\"] = make([]string, 0)\n    paren_groups [\"(()()()()()()()()()()\"\
    ] = make([]string, 0)\n    paren_groups [\")()()()()()()()()()()\"] = make([]string,\
    \ 0)\n    paren_groups [\"(()()()()()()()()()()()\"] = make([]string, 0)\n   \
    \ paren_groups [\")()()()()()()()()()()()\"] = make([]string, 0)\n    paren_groups\
    \ [\"(()()()()()()()()()()()()\"] = make([]string, 0)\n    paren\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcypxbhd_test.go:44:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074067
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make(map[string][]string)\n    paren_groups[\"\"] = make([]string,\
    \ 0)\n    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := make(map[string][]string)\n\
    \    paren_groups := make(map[string][]string)\n    paren_groups := \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt8ifouzy_test.go:55:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074067
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_string := \"\"\n \
    \   paren_group_open := false\n    paren_group_closed := false\n    paren_group_count\
    \ := 0\n    for _, character := range paren_string {\n        if paren_group_open\
    \ {\n            paren_group_string += character\n        } else {\n         \
    \   if character == ')' {\n                paren_group_open = false\n        \
    \        paren_group_closed = true\n                paren_group_count--\n    \
    \        } else {\n                paren_group_open = true\n                paren_group_count++\n\
    \            }\n        }\n        if paren_group_closed {\n            if paren_group_count\
    \ == 0 {\n                paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group_string = \"\"\n                paren_group_open =\
    \ false\n                paren_group_closed = false\n                paren_group_count\
    \ = 0\n            } else {\n                paren_group_open = false\n      \
    \          paren_group_closed = false\n                paren_group_count = 0\n\
    \            }\n        }\n    }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzzoygv2u_test.go:22:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074067
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := make([]string, 0)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkqhog0p2_test.go:48:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp142w5_m4_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[1 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n    paren_string = paren_string[0 : len(paren_string)-1]\n\
    \    paren_string = paren_string[0 : len(paren_string)-1]\n    paren_string =\
    \ paren_string[0 : len(paren_string)-1]\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2g05f0w3_test.go:53:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074067
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_string := \"\"\n \
    \   paren_group_open := false\n    paren_group_closed := false\n    paren_group_count\
    \ := 0\n    for _, character := range paren_string {\n        if character ==\
    \ '(' {\n            if paren_group_open {\n                fmt.Println(\"Error:\
    \ unexpected open paren group\")\n                fmt.Println(\"  Expected: \\\
    (\" + paren_group_string + \")\")\n                fmt.Println(\"  Actual: \\\
    (\" + paren_string + \")\")\n                fmt.Println(\"  Paren group string:\
    \ \" + paren_group_string)\n                fmt.Println(\"  Paren group count:\
    \ \" + strconv.Itoa(paren_group_count))\n                fmt.Println(\"  Paren\
    \ group open: \" + strconv.Itoa(paren_group_open))\n                fmt.Println(\"\
    \  Paren group closed: \" + strconv.Itoa(paren_group_closed))\n              \
    \  fmt.Println(\"  Paren group strings: \" + strconv.Itoa(len(paren_group_strings)))\n\
    \                fmt.Println(\"  Paren group strings: \" + strconv.Itoa(len(paren_group_strings)))\n\
    \                fmt.Println(\"  Paren group strings: \" + strconv.Itoa(len(paren_group_strings)))\n\
    \                fmt.Println(\"  Paren group strings: \" + strconv.Itoa(len(paren_group_strings)))\n\
    \                fmt.Println(\"  Paren group strings: \" + strconv.Itoa(len(paren_group_strings)))\n\
    \                fmt.Println(\"  Paren group strings: \" + strconv.Itoa(len(paren_group_strings)))\n\
    \                fmt.Println(\"  Paren group strings: \" + strconv.Itoa(len(paren_group_strings)))\n\
    \                fmt.Println(\"  Paren group strings: \" + strconv.Itoa(len(paren_group_strings)))\n\
    \                fmt.Println(\"  Paren group strings: \" + strconv.Itoa(len(paren_group_strings)))\n\
    \                fmt.Println(\"  Paren group strings: \" + strconv.Itoa(len(paren_group_strings)))\n\
    \                fmt.Println(\"  Paren group strings: \" + strconv.Itoa(len(paren_group_strings)))\n\
    \                fmt.Println(\"  Paren group strings: \" + strconv.Itoa(len(paren_group_strings)))\n\
    \                fmt.Println(\"  Paren group strings: \" + strconv.Itoa(len(paren_group_strings)))\n\
    \                fmt.Println(\"  Paren group strings: \" + strconv.Itoa(len(paren_group_string\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr5uacut4_test.go:24:43: unknown escape sequence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074067
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_regex := regexp.MustCompile(`\\((?P<paren_group>[^\\(\\)]+)\\\
    )`)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    result := make([]string, len(paren_groups))\n    for index, paren_group\
    \ := range paren_groups {\n        result[index] = paren_group[0]\n    }\n   \
    \ return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzaxqsroo_test.go:15:26: undefined: regexp

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074067
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_regex := regexp.MustCompile(`\\((?P<paren_group>[^\\(\\)]+)\\\
    )`)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    result := make([]string, len(paren_groups))\n    for index, paren_group\
    \ := range paren_groups {\n        result[index] = paren_group[0]\n    }\n   \
    \ return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzaxqsroo_test.go:15:26: undefined: regexp

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074067
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp142w5_m4_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpau96mwwn_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_regex := regexp.MustCompile(`\\((?P<paren_group>.*?)\\)`)\n\
    \    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string, -1)\n\
    \    result := make([]string, len(paren_groups))\n    for i, paren_group := range\
    \ paren_groups {\n        result[i] = paren_group[0]\n    }\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpke965u9r_test.go:15:26: undefined: regexp

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074067
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcjsiyes8_test.go:54:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpau96mwwn_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpau96mwwn_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3d2xvuar_test.go:88:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpau96mwwn_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcjsiyes8_test.go:54:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc_d1b01q_test.go:54:50: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_string := \"\"\n \
    \   paren_group_open := false\n    paren_group_closed := false\n    paren_group_count\
    \ := 0\n    for _, character := range paren_string {\n        if character ==\
    \ '(' {\n            paren_group_open = true\n            paren_group_string +=\
    \ character\n            paren_group_count += 1\n        } else if character ==\
    \ ')' {\n            paren_group_open = false\n            paren_group_string\
    \ += character\n            paren_group_count += 1\n        } else if paren_group_open\
    \ {\n            paren_group_string += character\n            paren_group_count\
    \ += 1\n        } else if paren_group_closed {\n            paren_group_string\
    \ += character\n            paren_group_count += 1\n        } else if paren_group_count\
    \ == 0 {\n            paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \            paren_group_string = \"\"\n            paren_group_open = false\n\
    \            paren_group_closed = false\n            paren_group_count = 0\n \
    \       }\n    }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpunecnde8_test.go:23:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmpunecnde8_test.go:27:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmpunecnde8_test.go:30:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmpunecnde8_test.go:33:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074067
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcjsiyes8_test.go:54:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a list to hold our results\n    result := make([]string,\
    \ 0)\n\n    // Iterate over each character in the string\n    for _, char := range\
    \ paren_string {\n        // If the character is a left paren, add it to the list\n\
    \        if char == '(' {\n            result = append(result, char)\n       \
    \ }\n\n        // If the character is a right paren, remove it from the list\n\
    \        if char == ')' {\n            result = removeElement(result, char)\n\
    \        }\n    }\n\n    // Return the result\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_0w7ie63_test.go:22:37: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmp_0w7ie63_test.go:27:22: undefined: removeElement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074067
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \")\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zvpovh__test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074060
