language: go_test.go
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool, len(lst))\n\
    \    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool, len(lst))\n\
    \    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool, len(lst))\n\
    \    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool, len(lst))\n\
    \    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool, len(lst))\n\
    \    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool, len(lst))\n\
    \    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool, len(lst))\n\
    \    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool, len(lst))\n\
    \    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool, len(lst))\n\
    \    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool, len(lst))\n\
    \    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool, len(lst))\n\
    \    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool, len(lst))\n\
    \    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool, len(lst))\n\
    \    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool, len(lst))\n\
    \    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool, len(lst))\n\
    \    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool, len(lst))\n\
    \    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool, len(lst))\n\
    \    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool, len(lst))\n\
    \    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool, len(lst))\n\
    \    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool, len(lst))\n\
    \    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47b29tef_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool, len(lst))\n\
    \    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool, len(lst))\n\
    \    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool, len(lst))\n\
    \    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool, len(lst))\n\
    \    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool, len(lst))\n\
    \    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool, len(lst))\n\
    \    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool, len(lst))\n\
    \    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool, len(lst))\n\
    \    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool, len(lst))\n\
    \    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool, len(lst))\n\
    \    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool, len(lst))\n\
    \    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool, len(lst))\n\
    \    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool, len(lst))\n\
    \    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool, len(lst))\n\
    \    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool, len(lst))\n\
    \    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool, len(lst))\n\
    \    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool, len(lst))\n\
    \    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool, len(lst))\n\
    \    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool, len(lst))\n\
    \    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool, len(lst))\n\
    \    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47b29tef_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\
    \ else if lst[i] == \")\" {\n            if stack[i] {\n                stack[i]\
    \ = false\n            } else {\n                return \"No\"\n            }\n\
    \        }\n    }\n    if !stack[len(stack)-1] {\n        return \"Yes\"\n   \
    \ }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqxka3e3h_test.go:62: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpqxka3e3h_test.go:62: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpqxka3e3h_test.go:62: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpqxka3e3h_test.go:62: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpqxka3e3h_test.go:62: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpqxka3e3h_test.go:62: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpqxka3e3h_test.go:62: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpqxka3e3h_test.go:62: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073956
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    result += \"(\"\n    result += \"(\"\n\
    \    for _, s := range lst {\n        if s == \"(\" {\n            result += \"\
    (\"\n        } else {\n            result += \")\"\n        }\n    }\n    result\
    \ += \")\"\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpx62_cb9e_test.go:58: expected 'Yes', got '(()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpx62_cb9e_test.go:58:\
    \ expected 'No', got '(()))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpx62_cb9e_test.go:58: expected 'No', got '(()))'\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpx62_cb9e_test.go:58: expected 'Yes', got '(()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__4 (0.00s)\n        tmpx62_cb9e_test.go:58:\
    \ expected 'Yes', got '(()))'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n\
    \        tmpx62_cb9e_test.go:58: expected 'No', got '(()))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpx62_cb9e_test.go:58: expected 'Yes', got '(()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmpx62_cb9e_test.go:58:\
    \ expected 'No', got '(()))'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpx62_cb9e_test.go:58: expected 'No', got '(()))'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpx62_cb9e_test.go:58: expected 'No', got '(()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpx62_cb9e_test.go:58:\
    \ expected 'Yes', got '((())'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpx62_cb9e_test.go:58: expected 'Yes', got '(()()'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073956
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool, len(lst))\n\
    \    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool, len(lst))\n\
    \    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool, len(lst))\n\
    \    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool, len(lst))\n\
    \    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool, len(lst))\n\
    \    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool, len(lst))\n\
    \    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool, len(lst))\n\
    \    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool, len(lst))\n\
    \    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool, len(lst))\n\
    \    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool, len(lst))\n\
    \    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool, len(lst))\n\
    \    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool, len(lst))\n\
    \    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool, len(lst))\n\
    \    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool, len(lst))\n\
    \    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool, len(lst))\n\
    \    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool, len(lst))\n\
    \    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool, len(lst))\n\
    \    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool, len(lst))\n\
    \    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool, len(lst))\n\
    \    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool, len(lst))\n\
    \    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47b29tef_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := range lst {\n  \
    \      stack[i] = false\n    }\n    result := \"\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    \nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc6ptusk7_test.go:122:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    for i := range lst {\n\
    \        stack[i] = lst[i]\n    }\n    result := \"\"\n    i := 0\n    for i <\
    \ len(stack) {\n        switch stack[i] {\n        case \"(\":\n            stack[i]\
    \ = \")\"\n            i++\n        case \"[\":\n            stack[i] = \"]\"\n\
    \            i++\n        case \"{\":\n            stack[i] = \"}\"\n        \
    \    i++\n        default:\n            result += stack[i]\n            i++\n\
    \        }\n    }\n    if result != \"\" {\n        return \"No\"\n    }\n   \
    \ return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpfb673v4a_test.go:72: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpfb673v4a_test.go:72: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpfb673v4a_test.go:72: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpfb673v4a_test.go:72: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpfb673v4a_test.go:72: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpfb673v4a_test.go:72: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073956
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    result += \"(\"\n    for _, s := range\
    \ lst {\n        result += \"(\"\n        if s == \"(\" {\n            result\
    \ += \"(\"\n        } else {\n            result += \")\"\n        }\n    }\n\
    \    result += \")\"\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpsm27km51_test.go:58: expected 'Yes', got '(()())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpsm27km51_test.go:58:\
    \ expected 'No', got '(()())'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpsm27km51_test.go:58: expected 'No', got '(()())'\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpsm27km51_test.go:58: expected 'Yes', got '(()())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__4 (0.00s)\n        tmpsm27km51_test.go:58:\
    \ expected 'Yes', got '(()())'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n\
    \        tmpsm27km51_test.go:58: expected 'No', got '(()())'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpsm27km51_test.go:58: expected 'Yes', got '(()())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmpsm27km51_test.go:58:\
    \ expected 'No', got '(()())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpsm27km51_test.go:58: expected 'No', got '(()())'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpsm27km51_test.go:58: expected 'No', got '(()())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpsm27km51_test.go:58:\
    \ expected 'Yes', got '(((())'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpsm27km51_test.go:58: expected 'Yes', got '(()(()'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073956
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = 1\n        } else\
    \ if lst[i] == \")\" {\n            stack[i] = -1\n        } else if stack[i]\
    \ == 1 {\n            stack[i] = -1\n        }\n    }\n    for i := 0; i < len(lst);\
    \ i++ {\n        if stack[i] != 1 {\n            return \"No\"\n        }\n  \
    \  }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpr7whm3d0_test.go:62: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpr7whm3d0_test.go:62: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpr7whm3d0_test.go:62: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpr7whm3d0_test.go:62: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpr7whm3d0_test.go:62: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpr7whm3d0_test.go:62: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073956
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n    stack1 :=\
    \ make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n    stack1[0],\
    \ stack2[0] = lst[0], lst[0]\n    stack1[1], stack2[1] = lst[1], lst[1]\n    stack1[2],\
    \ stack2[2] = lst[2], lst[2]\n    stack1[3], stack2[3] = lst[3], lst[3]\n    stack1[4],\
    \ stack2[4] = lst[4], lst[4]\n    stack1[5], stack2[5] = lst[5], lst[5]\n    stack1[6],\
    \ stack2[6] = lst[6], lst[6]\n    stack1[7], stack2[7] = lst[7], lst[7]\n    stack1[8],\
    \ stack2[8] = lst[8], lst[8]\n    stack1[9], stack2[9] = lst[9], lst[9]\n    stack1[10],\
    \ stack2[10] = lst[10], lst[10]\n    stack1[11], stack2[11] = lst[11], lst[11]\n\
    \    stack1[12], stack2[12] = lst[12], lst[12]\n    stack1[13], stack2[13] = lst[13],\
    \ lst[13]\n    stack1[14], stack2[14] = lst[14], lst[14]\n    stack1[15], stack2[15]\
    \ = lst[15], lst[15]\n    stack1[16], stack2[16] = lst[16], lst[16]\n    stack1[17],\
    \ stack2[17] = lst[17], lst[17]\n    stack1[18], stack2[18] = lst[18], lst[18]\n\
    \    stack1[19], stack2[19] = lst[19], lst[19]\n    stack1[20], stack2[20] = lst[20],\
    \ lst[20]\n    stack1[21], stack2[21] = lst[21], lst[21]\n    stack1[22], stack2[22]\
    \ = lst[22], lst[22]\n    stack1[23], stack2[23] = lst[23], lst[23]\n    stack1[24],\
    \ stack2[24] = lst[24], lst[24]\n    stack1[25], stack2[25] = lst[25], lst[25]\n\
    \    stack1[26], stack2[26] = lst[26], lst[26]\n    stack1[27], stack2[27] = lst[27],\
    \ lst[27]\n    stack1[28], stack2[28] = lst[28], lst[28]\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm74e2o49_test.go:54:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool, len(lst))\n\
    \    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool, len(lst))\n\
    \    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool, len(lst))\n\
    \    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool, len(lst))\n\
    \    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool, len(lst))\n\
    \    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool, len(lst))\n\
    \    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool, len(lst))\n\
    \    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool, len(lst))\n\
    \    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool, len(lst))\n\
    \    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool, len(lst))\n\
    \    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool, len(lst))\n\
    \    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool, len(lst))\n\
    \    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool, len(lst))\n\
    \    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool, len(lst))\n\
    \    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool, len(lst))\n\
    \    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool, len(lst))\n\
    \    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool, len(lst))\n\
    \    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool, len(lst))\n\
    \    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool, len(lst))\n\
    \    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool, len(lst))\n\
    \    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47b29tef_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n    stack :=\
    \ make([]string, len(lst))\n    stack[0] = lst[0]\n    stack[1] = lst[1]\n   \
    \ result := \"No\"\n    for i := 2; i < len(lst); i++ {\n        if stack[len(stack)-1]\
    \ != lst[i] {\n            result = \"No\"\n            break\n        }\n   \
    \     stack[len(stack)-1] = lst[i]\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpghc8vsw7_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpghc8vsw7_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpghc8vsw7_test.go:61: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpghc8vsw7_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpghc8vsw7_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpghc8vsw7_test.go:61: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073956
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = \"(\"\n        }\
    \ else if lst[i] == \")\" {\n            if len(stack) == 0 {\n              \
    \  return \"No\"\n            }\n            stack = stack[:len(stack)-1]\n  \
    \          stack[i] = \")\"\n        } else {\n            stack = append(stack,\
    \ lst[i])\n        }\n    }\n    if len(stack) != 0 {\n        return \"No\"\n\
    \    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [1] with length 0 [recovered]\n\tpanic: runtime error: index out of range\
    \ [1] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x514620,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x514620, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens(...)\n\t/tmp/tmp_5ad269h_test.go:29\n\
    command-line-arguments_test.TestMatch_Parens(0xc0001031e0?)\n\t/tmp/tmp_5ad269h_test.go:48\
    \ +0x1ecd\ntesting.tRunner(0xc0001031e0, 0x529f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073956
- exit_code: null
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        stack[i] = lst[i]\n    }\n    result := \"\"\n    i := 0\n  \
    \  for i < len(stack) {\n        if stack[i] == \"(\" {\n            i++\n   \
    \         if i == len(stack) {\n                return \"No\"\n            }\n\
    \            if stack[i] == \"(\" {\n                i++\n                if i\
    \ == len(stack) {\n                    return \"No\"\n                }\n    \
    \        }\n        }\n        if stack[i] == \")\" {\n            i++\n     \
    \       if i == len(stack) {\n                return \"No\"\n            }\n \
    \           if stack[i] == \")\" {\n                i++\n                if i\
    \ == len(stack) {\n                    return \"No\"\n                }\n    \
    \        }\n        }\n        result += stack[i]\n    }\n    return \"Yes\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660073966
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n    if len(lst)\
    \ == 1 {\n        return lst[0]\n    }\n    stack1 := make([]string, len(lst))\n\
    \    stack2 := make([]string, len(lst))\n    stack1[0], stack2[0] = lst[0], lst[0]\n\
    \    stack1[1], stack2[1] = lst[0], lst[0]\n    i := 1\n    for ; i < len(lst);\
    \ i++ {\n        if stack1[i] == ')' {\n            stack1[i] = stack1[i-1]\n\
    \            stack2[i] = stack2[i-1]\n        } else {\n            stack1[i]\
    \ = stack1[i-1]\n            stack2[i] = stack2[i-1]\n        }\n        if stack1[i]\
    \ == '(' {\n            stack1[i] = stack1[i-1]\n            stack2[i] = stack2[i-1]\n\
    \        } else {\n            stack1[i] = stack1[i-1]\n            stack2[i]\
    \ = stack2[i-1]\n        }\n    }\n    if stack1[len(stack1)-1] != ')' {\n   \
    \     return \"No\"\n    }\n    if stack2[len(stack2)-1] != ')' {\n        return\
    \ \"No\"\n    }\n    if stack1[0] != '(' {\n        return \"No\"\n    }\n   \
    \ if stack2[0] != '(' {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvq5bplvd_test.go:32:25: invalid operation: stack1[i] == '')'' (mismatched
    types string and untyped rune)

    /tmp/tmpvq5bplvd_test.go:39:25: invalid operation: stack1[i] == ''('' (mismatched
    types string and untyped rune)

    /tmp/tmpvq5bplvd_test.go:47:33: invalid operation: stack1[len(stack1) - 1] !=
    '')'' (mismatched types string and untyped rune)

    /tmp/tmpvq5bplvd_test.go:50:33: invalid operation: stack2[len(stack2) - 1] !=
    '')'' (mismatched types string and untyped rune)

    /tmp/tmpvq5bplvd_test.go:53:21: invalid operation: stack1[0] != ''('' (mismatched
    types string and untyped rune)

    /tmp/tmpvq5bplvd_test.go:56:21: invalid operation: stack2[0] != ''('' (mismatched
    types string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073956
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else if lst[i] == \")\" {\n            if stack[i] == 0 {\n \
    \               result = \"Yes\"\n                break\n            } else {\n\
    \                stack[i]--\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpppsdamgx_test.go:61: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpppsdamgx_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpppsdamgx_test.go:61: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpppsdamgx_test.go:61: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073956
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"\"\n    i := 0\n\
    \    for _, s := range lst {\n        if s == '(' {\n            stack[i] = 1\n\
    \            i++\n        } else if s == ')' {\n            stack[i] = -1\n  \
    \          i++\n        } else if stack[i] == 1 {\n            result += \"(\"\
    \n            i++\n        } else if stack[i] == -1 {\n            result += \"\
    )\"\n            i++\n        }\n    }\n    if i == len(lst) {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd8hbp9k__test.go:24:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpd8hbp9k__test.go:27:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073956
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"\"\n    i :=\
    \ 0\n    for _, s := range lst {\n        if s[i] == '(' {\n            stack[i]\
    \ = s\n            i++\n        } else if s[i] == ')' {\n            if len(stack)\
    \ == 0 {\n                return \"No\"\n            }\n            result +=\
    \ \"(\" + stack[len(stack)-1] + \")\"\n            stack = stack[:len(stack)-1]\n\
    \            i++\n        } else {\n            result += \"(\" + s + \")\"\n\
    \        }\n    }\n    if len(stack) > 0 {\n        return \"No\"\n    }\n   \
    \ return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range\
    \ [1] with length 1\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens({0xc00011bca0, 0x2, 0x2?})\n\
    \t/tmp/tmp35r2bmqx_test.go:24 +0x21b\ncommand-line-arguments_test.TestMatch_Parens(0x0?)\n\
    \t/tmp/tmp35r2bmqx_test.go:51 +0x99\ntesting.tRunner(0xc0001031e0, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073956
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    for _, s := range lst {\n        if result\
    \ != \"\" {\n            result += \"|\"\n        }\n        result += \"(\" +\
    \ s + \")\"\n    }\n    if result != \"\" {\n        result = \"(\" + result +\
    \ \")\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp0v_6ll2__test.go:57: expected 'Yes', got '((()()|()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp0v_6ll2__test.go:57:\
    \ expected 'No', got '(())|()))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmp0v_6ll2__test.go:57: expected 'No', got '(((()(()))|(())())))'\n \
    \   --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmp0v_6ll2__test.go:57:\
    \ expected 'Yes', got '(()()))|((()()())'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp0v_6ll2__test.go:57: expected 'Yes', got '(((()))))|((()())(())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp0v_6ll2__test.go:57:\
    \ expected 'No', got '((())|(())))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp0v_6ll2__test.go:57: expected 'Yes', got '(((()()|(()))()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmp0v_6ll2__test.go:57:\
    \ expected 'No', got '(((((()|(((())))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp0v_6ll2__test.go:57: expected 'No', got '(()(())|((()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmp0v_6ll2__test.go:57:\
    \ expected 'No', got '(()()|()())'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmp0v_6ll2__test.go:57: expected 'Yes', got '((()|()))'\n \
    \   --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmp0v_6ll2__test.go:57:\
    \ expected 'Yes', got '(())|(())'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073956
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else if lst[i] == \")\" {\n            stack[i] = -1\n      \
    \  } else if stack[i] == 1 {\n            stack[i] = 0\n        } else {\n   \
    \         result = \"Yes\"\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__2\
    \ (0.00s)\n        tmpms0a6hbr_test.go:60: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpms0a6hbr_test.go:60: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n      \
    \  tmpms0a6hbr_test.go:60: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpms0a6hbr_test.go:60: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpms0a6hbr_test.go:60: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmpms0a6hbr_test.go:60: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpms0a6hbr_test.go:60: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073956
- exit_code: null
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    for i := range lst {\n   \
    \     stack[i] = i\n    }\n    result := \"No\"\n    i := 0\n    for i < len(lst)\
    \ {\n        if lst[i] == \"(\" {\n            i++\n            if i == len(lst)\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            if stack[i] == -1 {\n                result = \"No\"\n          \
    \      break\n            }\n            stack[stack[i]] = -1\n            i++\n\
    \        }\n        if lst[i] == \")\" {\n            i++\n            if i ==\
    \ len(lst) {\n                result = \"Yes\"\n                break\n      \
    \      }\n            if stack[i] == -1 {\n                result = \"No\"\n \
    \               break\n            }\n            stack[stack[i]] = -1\n     \
    \       i++\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660073966
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = 1\n        } else\
    \ if lst[i] == \")\" {\n            stack[i] = -1\n        } else {\n        \
    \    return fmt.Sprintf(\"No\")\n        }\n    }\n    return fmt.Sprintf(\"Yes\"\
    )\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqldi2px2_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqldi2px2_test.go:57: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqldi2px2_test.go:57: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqldi2px2_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqldi2px2_test.go:57: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073956
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\
    \ else if lst[i] == \")\" {\n            if !stack[i] {\n                return\
    \ \"No\"\n            }\n            stack[i] = false\n        }\n    }\n    if\
    \ !stack[len(lst)-1] {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp6eqv1ieb_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmp6eqv1ieb_test.go:61: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmp6eqv1ieb_test.go:61: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmp6eqv1ieb_test.go:61: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmp6eqv1ieb_test.go:61: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmp6eqv1ieb_test.go:61: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmp6eqv1ieb_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmp6eqv1ieb_test.go:61: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073956
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n    stack1 :=\
    \ make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n    stack1[0],\
    \ stack2[0] = lst[0], lst[0]\n    stack1[1], stack2[1] = lst[1], lst[1]\n    for\
    \ i := 2; i < len(lst); i++ {\n        if stack1[i] == '(' && stack2[i] == ')'\
    \ {\n            stack1[i] = stack1[i-1]\n            stack2[i] = stack2[i-1]\n\
    \            stack1[i-1], stack2[i-1] = stack1[i-2], stack2[i-2]\n        }\n\
    \    }\n    if stack1[0] == '(' && stack2[0] == ')' {\n        return \"Yes\"\n\
    \    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppy22dir1_test.go:28:25: invalid operation: stack1[i] == ''('' (mismatched
    types string and untyped rune)

    /tmp/tmppy22dir1_test.go:28:45: invalid operation: stack2[i] == '')'' (mismatched
    types string and untyped rune)

    /tmp/tmppy22dir1_test.go:34:21: invalid operation: stack1[0] == ''('' (mismatched
    types string and untyped rune)

    /tmp/tmppy22dir1_test.go:34:41: invalid operation: stack2[0] == '')'' (mismatched
    types string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073956
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if stack[i] {\n            stack[i] = false\n\
    \            result += \"Yes\"\n        } else {\n            stack[i] = true\n\
    \            result += \"No\"\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpz13rez6n_test.go:58: expected 'Yes', got 'NoNoNo'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpz13rez6n_test.go:58:\
    \ expected 'No', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpz13rez6n_test.go:58: expected 'No', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpz13rez6n_test.go:58: expected 'Yes', got 'NoNoNo'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__4 (0.00s)\n        tmpz13rez6n_test.go:58:\
    \ expected 'Yes', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n\
    \        tmpz13rez6n_test.go:58: expected 'No', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpz13rez6n_test.go:58: expected 'Yes', got 'NoNoNo'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmpz13rez6n_test.go:58:\
    \ expected 'No', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpz13rez6n_test.go:58: expected 'No', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpz13rez6n_test.go:58: expected 'No', got 'NoNoNo'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpz13rez6n_test.go:58:\
    \ expected 'Yes', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpz13rez6n_test.go:58: expected 'Yes', got 'NoNoNo'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073956
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else if lst[i] == \")\" {\n            if stack[i] == 1 {\n \
    \               stack[i] = 0\n            } else {\n                result = \"\
    Yes\"\n                break\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpps0qn1o8_test.go:61: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpps0qn1o8_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpps0qn1o8_test.go:61: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpps0qn1o8_test.go:61: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073956
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"\"\n    i :=\
    \ 0\n    for _, s := range lst {\n        if s == '(' {\n            stack[i]\
    \ = s\n            i++\n        } else if s == ')' {\n            i -= 1\n   \
    \         if i == -1 {\n                return \"No\"\n            }\n       \
    \     stack[i] = s\n        } else if s == \"\" {\n            if i == 0 {\n \
    \               return \"No\"\n            }\n            stack[i] = s\n     \
    \   }\n    }\n    for _, s := range stack {\n        if result != \"\" {\n   \
    \         result += s\n        } else {\n            result = s\n        }\n \
    \   }\n    if result == \"()\" {\n        return \"Yes\"\n    }\n    return \"\
    No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu9b1de6e_test.go:24:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpu9b1de6e_test.go:27:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073957
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else {\n            stack[i] = -1\n        }\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        if stack[i] < 0 {\n            result =\
    \ \"No\"\n            break\n        }\n        if stack[i] == 1 {\n         \
    \   stack[i]++\n        } else {\n            stack[i]--\n        }\n    }\n \
    \   if result == \"No\" {\n        result = \"Yes\"\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpjx1n865b_test.go:70: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpjx1n865b_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpjx1n865b_test.go:70: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpjx1n865b_test.go:70: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpjx1n865b_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpjx1n865b_test.go:70: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073957
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool, len(lst))\n\
    \    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool, len(lst))\n\
    \    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool, len(lst))\n\
    \    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool, len(lst))\n\
    \    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool, len(lst))\n\
    \    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool, len(lst))\n\
    \    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool, len(lst))\n\
    \    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool, len(lst))\n\
    \    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool, len(lst))\n\
    \    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool, len(lst))\n\
    \    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool, len(lst))\n\
    \    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool, len(lst))\n\
    \    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool, len(lst))\n\
    \    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool, len(lst))\n\
    \    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool, len(lst))\n\
    \    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool, len(lst))\n\
    \    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool, len(lst))\n\
    \    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool, len(lst))\n\
    \    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool, len(lst))\n\
    \    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool, len(lst))\n\
    \    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47b29tef_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n    stack1 :=\
    \ make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n    for i := 0;\
    \ i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack1[i] = true\n\
    \        }\n        if lst[i] == \")\" {\n            stack1[i] = false\n    \
    \    }\n        if stack1[i] != stack2[i] {\n            return \"No\"\n     \
    \   }\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpko8v_2b9_test.go:63: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpko8v_2b9_test.go:63: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpko8v_2b9_test.go:63: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpko8v_2b9_test.go:63: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpko8v_2b9_test.go:63: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpko8v_2b9_test.go:63: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpko8v_2b9_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpko8v_2b9_test.go:63: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073957
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    result := \"No\"\n    for _, s := range lst {\n        if s ==\
    \ \"(\" || s == \")\" {\n            result += \"Yes\"\n            break\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp9nu6rpwa_test.go:54: expected 'Yes', got 'NoYes'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp9nu6rpwa_test.go:54:\
    \ expected 'No', got 'NoYes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp9nu6rpwa_test.go:54: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp9nu6rpwa_test.go:54: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmp9nu6rpwa_test.go:54: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmp9nu6rpwa_test.go:54: expected 'Yes', got 'NoYes'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmp9nu6rpwa_test.go:54: expected 'Yes', got 'NoYes'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073958
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else {\n            if stack[i] != 0 {\n                stack[i]--\n\
    \            } else {\n                result := \"Yes\"\n            }\n    \
    \    }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpetk6n6ub_test.go:29:17: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073958
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    result := \"No\"\n    for\
    \ _, s := range lst {\n        if s == '(' {\n            stack[len(stack)-1]\
    \ = true\n        } else {\n            stack[len(stack)] = false\n        }\n\
    \    }\n    for i := len(stack) - 1; i >= 0; i-- {\n        if stack[i] {\n  \
    \          result = \"Yes\"\n            break\n        }\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptpxcoasd_test.go:23:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073958
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\n\
    \        if lst[i] == \")\" {\n            stack[i] = false\n        }\n    }\n\
    \    result := \"No\"\n    for i := 0; i < len(lst); i++ {\n        if stack[i]\
    \ {\n            result = \"Yes\"\n            break\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpa6tjm59g_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpa6tjm59g_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpa6tjm59g_test.go:63: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpa6tjm59g_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n    stack1 :=\
    \ make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n    stack1[0],\
    \ stack2[0] = lst[0], lst[0]\n    stack1[1], stack2[1] = lst[1], lst[1]\n    stack1[2],\
    \ stack2[2] = lst[2], lst[2]\n    stack1[3], stack2[3] = lst[3], lst[3]\n    stack1[4],\
    \ stack2[4] = lst[4], lst[4]\n    stack1[5], stack2[5] = lst[5], lst[5]\n    stack1[6],\
    \ stack2[6] = lst[6], lst[6]\n    stack1[7], stack2[7] = lst[7], lst[7]\n    stack1[8],\
    \ stack2[8] = lst[8], lst[8]\n    stack1[9], stack2[9] = lst[9], lst[9]\n    stack1[10],\
    \ stack2[10] = lst[10], lst[10]\n    stack1[11], stack2[11] = lst[11], lst[11]\n\
    \    stack1[12], stack2[12] = lst[12], lst[12]\n    stack1[13], stack2[13] = lst[13],\
    \ lst[13]\n    stack1[14], stack2[14] = lst[14], lst[14]\n    stack1[15], stack2[15]\
    \ = lst[15], lst[15]\n    stack1[16], stack2[16] = lst[16], lst[16]\n    stack1[17],\
    \ stack2[17] = lst[17], lst[17]\n    stack1[18], stack2[18] = lst[18], lst[18]\n\
    \    stack1[19], stack2[19] = lst[19], lst[19]\n    stack1[20], stack2[20] = lst[20],\
    \ lst[20]\n    stack1[21], stack2[21] = lst[21], lst[21]\n    stack1[22], stack2[22]\
    \ = lst[22], lst[22]\n    stack1[23], stack2[23] = lst[23], lst[23]\n    stack1[24],\
    \ stack2[24] = lst[24], lst[24]\n    stack1[25], stack2[25] = lst[25], lst[25]\n\
    \    stack1[26], stack2[26] = lst[26], lst[26]\n    stack1[27], stack2[27] = lst[27],\
    \ lst[27]\n    stack1[28], stack2[28] = lst[28], lst[28]\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzx0di34r_test.go:54:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073958
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    result := \"No\"\n    for _, s := range lst {\n        if s ==\
    \ \"(\" || s == \")\" {\n            result += \"Yes\"\n        }\n    }\n   \
    \ return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqiajido9_test.go:53: expected 'Yes', got 'NoYes'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpqiajido9_test.go:53:\
    \ expected 'No', got 'NoYesYes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpqiajido9_test.go:53: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqiajido9_test.go:53: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqiajido9_test.go:53: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmpqiajido9_test.go:53: expected 'Yes', got 'NoYesYes'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpqiajido9_test.go:53: expected 'Yes', got 'NoYesYes'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = lst[i]\n        } else if lst[i] == \")\" {\n            result := \"Yes\"\
    \n            stack = stack[:len(stack)-1]\n        }\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6aef1wjd_test.go:26:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073958
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\n\
    \        if lst[i] == \")\" {\n            if !stack[i] {\n                return\
    \ \"No\"\n            }\n            stack[i] = false\n        }\n    }\n    return\
    \ \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps7cgvacg_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmps7cgvacg_test.go:59: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmps7cgvacg_test.go:59: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmps7cgvacg_test.go:59: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmps7cgvacg_test.go:59: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmps7cgvacg_test.go:59: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmps7cgvacg_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps7cgvacg_test.go:59: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = true\n        }\n        if lst[i] == \")\" {\n            if stack[i] {\n\
    \                stack[i] = false\n            } else {\n                result\
    \ = \"Yes\"\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpzvzduypw_test.go:62: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpzvzduypw_test.go:62: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpzvzduypw_test.go:62: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpzvzduypw_test.go:62: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    var stack = []int{0}\n    for _, s := range\
    \ lst {\n        if s == '(' {\n            stack = append(stack, -1)\n      \
    \  } else {\n            stack = append(stack, len(stack))\n        }\n    }\n\
    \    for len(stack) > 0 {\n        i := stack[len(stack)-1]\n        if i == -1\
    \ {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack\
    \ = stack[:len(stack)-1]\n            result += \"(\"\n        }\n        for\
    \ _, s := range lst {\n            if s == '(' {\n                stack = append(stack,\
    \ -1)\n            } else {\n                stack = append(stack, len(stack))\n\
    \            }\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8ame6g9y_test.go:23:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmp8ame6g9y_test.go:38:21: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073958
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack1[0], stack2[0] = true, true\n    stack1[1], stack2[1] = true, true\n\
    \    stack1[2], stack2[2] = true, true\n    stack1[3], stack2[3] = true, true\n\
    \    stack1[4], stack2[4] = true, true\n    stack1[5], stack2[5] = true, true\n\
    \    stack1[6], stack2[6] = true, true\n    stack1[7], stack2[7] = true, true\n\
    \    stack1[8], stack2[8] = true, true\n    stack1[9], stack2[9] = true, true\n\
    \    stack1[10], stack2[10] = true, true\n    stack1[11], stack2[11] = true, true\n\
    \    stack1[12], stack2[12] = true, true\n    stack1[13], stack2[13] = true, true\n\
    \    stack1[14], stack2[14] = true, true\n    stack1[15], stack2[15] = true, true\n\
    \    stack1[16], stack2[16] = true, true\n    stack1[17], stack2[17] = true, true\n\
    \    stack1[18], stack2[18] = true, true\n    stack1[19], stack2[19] = true, true\n\
    \    stack1[20], stack2[20] = true, true\n    stack1[21], stack2[21] = true, true\n\
    \    stack1[22], stack2[22] = true, true\n    stack1[23], stack2[23] = true, true\n\
    \    stack1[24], stack2[24] = true, true\n    stack1[25], stack2[25] = true, true\n\
    \    stack1[26], stack2[26] = true, true\n    stack1[27], stack2[27] = true, true\n\
    \    stack1[28], stack2[28] = true, true\n    stack1[29], stack2[29] = true, true\n\
    \    stack1[30], stack2[30] = true, true\n    stack1[31], stack2[31] = true, true\n\
    \    stack1[32], stack2[32] = true, true\n    stack1[33], stack2[33] = true, true\n\
    \    stack1[34], stack2[34] = true, true\n    stack1[35], stack2[35] = true, true\n\
    \    stack1[36], stack2[36] = true, true\n    stack1[37], stack2[37] = true, true\n\
    \    stack1[38], stack2[38] = true, true\n    stack1[39], stack2[39] = true, true\n\
    \    stack1[40], stack2[40] = true, true\n    stack1[4\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvbvfp_yp_test.go:63:13: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073958
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = \"(\"\n        } else if lst[i] == \")\" {\n            stack[i] = \")\"\n\
    \        } else {\n            stack[i] = lst[i]\n        }\n    }\n    for i\
    \ := 0; i < len(stack); i++ {\n        if stack[i] == \"(\" {\n            result\
    \ += \"Yes\"\n            break\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnroovf0_test.go:64: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpvnroovf0_test.go:64: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpvnroovf0_test.go:64: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpvnroovf0_test.go:64: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnroovf0_test.go:64: expected\
    \ 'Yes', got 'NoYes'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n  \
    \      tmpvnroovf0_test.go:64: expected 'Yes', got 'NoYes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else if lst[i] == \")\" {\n            stack[i] = 0\n       \
    \     if stack[i] == 1 {\n                result = \"Yes\"\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp9ugua932_test.go:60: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp9ugua932_test.go:60: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp9ugua932_test.go:60: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp9ugua932_test.go:60: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp9ugua932_test.go:60: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp9ugua932_test.go:60: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073959
- exit_code: null
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        stack[i] = i\n    }\n    result := \"No\"\n    i := 0\n    for\
    \ i < len(lst) {\n        if lst[i] == \"(\" {\n            stack[i] = i\n   \
    \         i++\n        } else if lst[i] == \")\" {\n            i := stack[i]\n\
    \            if i == len(lst) {\n                result = \"Yes\"\n          \
    \      break\n            }\n            stack[i] = i\n            i++\n     \
    \   }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660073971
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else {\n            stack[i] = -1\n        }\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        if stack[i] < 0 {\n            result =\
    \ \"No\"\n            break\n        }\n        if lst[i] == \"(\" {\n       \
    \     stack[i]++\n        } else {\n            stack[i]--\n        }\n    }\n\
    \    if result == \"No\" {\n        result = \"Yes\"\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmp85gxgra9_test.go:70: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmp85gxgra9_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmp85gxgra9_test.go:70: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmp85gxgra9_test.go:70: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmp85gxgra9_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmp85gxgra9_test.go:70: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool, len(lst))\n\
    \    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool, len(lst))\n\
    \    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool, len(lst))\n\
    \    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool, len(lst))\n\
    \    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool, len(lst))\n\
    \    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool, len(lst))\n\
    \    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool, len(lst))\n\
    \    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool, len(lst))\n\
    \    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool, len(lst))\n\
    \    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool, len(lst))\n\
    \    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool, len(lst))\n\
    \    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool, len(lst))\n\
    \    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool, len(lst))\n\
    \    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool, len(lst))\n\
    \    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool, len(lst))\n\
    \    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool, len(lst))\n\
    \    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool, len(lst))\n\
    \    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool, len(lst))\n\
    \    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool, len(lst))\n\
    \    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool, len(lst))\n\
    \    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47b29tef_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\
    \ else if lst[i] == \")\" {\n            stack[i] = false\n        } else {\n\
    \            return \"\"\n        }\n    }\n    if !is_balanced(stack) {\n   \
    \     return \"No\"\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqlx5jcuj_test.go:30:9: undefined: is_balanced

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073958
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := range lst {\n  \
    \      stack[i] = false\n    }\n    result := \"\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    \nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc6ptusk7_test.go:122:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := range lst {\n  \
    \      stack[i] = false\n    }\n    result := \"\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    \nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc6ptusk7_test.go:122:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = \"(\"\n        } else if lst[i] == \")\" {\n            stack[i] = \")\"\n\
    \        } else {\n            if stack[len(stack)-1] != \"\" {\n            \
    \    stack[len(stack)-1] += lst[i]\n            } else {\n                stack\
    \ = append(stack, lst[i])\n            }\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        result = \"Yes\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpmlu6wo5k_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpmlu6wo5k_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpmlu6wo5k_test.go:65: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpmlu6wo5k_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpmlu6wo5k_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpmlu6wo5k_test.go:65: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\
    \ else if lst[i] == \")\" {\n            stack[i] = false\n        } else if stack[i]\
    \ != stack[len(stack)-1] {\n            return fmt.Sprintf(\"No\")\n        }\n\
    \    }\n    return fmt.Sprintf(\"Yes\")\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmprfvpz2fo_test.go:57: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmprfvpz2fo_test.go:57: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmprfvpz2fo_test.go:57: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmprfvpz2fo_test.go:57: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmprfvpz2fo_test.go:57: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmprfvpz2fo_test.go:57: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    for i := range lst {\n\
    \        stack[i] = lst[i]\n    }\n    result := \"No\"\n    i := 0\n    for i\
    \ < len(stack) {\n        if stack[i] == \"(\" {\n            i++\n          \
    \  if i == len(stack) {\n                result = \"Yes\"\n                break\n\
    \            }\n            if stack[i] == \"(\" {\n                i++\n    \
    \            if i == len(stack) {\n                    result = \"Yes\"\n    \
    \                break\n                }\n                if stack[i] == \"(\"\
    \ {\n                    i++\n                    if i == len(stack) {\n     \
    \                   result = \"Yes\"\n                        break\n        \
    \            }\n                    if stack[i] == \"(\" {\n                 \
    \       i++\n                        if i == len(stack) {\n                  \
    \          result = \"Yes\"\n                            break\n             \
    \           }\n                        if stack[i] == \"(\" {\n              \
    \              i++\n                            if i == len(stack) {\n       \
    \                         result = \"Yes\"\n                                break\n\
    \                            }\n                            if stack[i] == \"\
    (\" {\n                                i++\n                                if\
    \ i == len(stack) {\n                                    result = \"Yes\"\n  \
    \                                  break\n                                }\n\
    \                                if stack[i] == \"(\" {\n                    \
    \                i++\n                                    if i == len(stack) {\n\
    \                                        result = \"Yes\"\n                  \
    \                      break\n                                    }\n        \
    \                            if stack[i] == \"(\" {\n                        \
    \                i++\n                                        if i == len(stack)\
    \ {\n                                            result = \"Yes\"\n          \
    \                                  break\n                                   \
    \     }\n                                        if stack[i] == \"(\" {\n    \
    \                                        i++\n                               \
    \             if i == len(stack) {\n                                         \
    \       result = \"Yes\"\n                                                break\n\
    \                                            }\n                             \
    \               if stack[i] == \"(\" {\n                                     \
    \           i++\n                                                if i == len(stack)\
    \ {\n                                                    result = \"Yes\"\n  \
    \                                                  break\n                   \
    \                             }\n                                            \
    \    if stack[i] == \"(\" {\n                                                \
    \    i++\n                                                    if i == len(stack)\
    \ {\n                                                        result = \"Yes\"\n\
    \                                                        break\n             \
    \                                       }\n                                  \
    \                  if stack[i] == \"(\" {\n                                  \
    \                      i++\n                                                 \
    \       if i == len(stack) {\n                                               \
    \             result = \"Yes\"\n                                             \
    \               break\n                                                      \
    \  }\n                                                        if stack[i] == \"\
    (\" {\n                                                            i++\n     \
    \                                                       if i == len(stack) {\n\
    \                                                                result = \"Yes\"\
    \n                                                                break\n    \
    \                                                        }\n                 \
    \                                           if stack[i] == \"(\" {\n         \
    \                                                       i++\n                \
    \                                                if i == len(stack) {\n      \
    \                                                              result = \"Yes\"\
    \n                                                                    break\n\
    \                                                                }\n         \
    \                                                       if stack[i] == \"(\" {\n\
    \                                                                    i++\n   \
    \                                                                 if i == len(stack)\
    \ {\n                                                                        result\
    \ = \"Yes\"\n                                                                \
    \        break\n                                                             \
    \       }\n                                                                  \
    \  if stack[i] == \"(\" {\n                                                  \
    \                      i++\n                                                 \
    \                   }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcar3g03a_test.go:121:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073958
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = 1\n        } else\
    \ if lst[i] == \")\" {\n            stack[i] = -1\n        } else if stack[i]\
    \ == -1 {\n            return fmt.Sprintf(\"No\")\n        }\n    }\n    return\
    \ fmt.Sprintf(\"Yes\")\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpl6ix2wd0_test.go:57: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpl6ix2wd0_test.go:57: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpl6ix2wd0_test.go:57: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpl6ix2wd0_test.go:57: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpl6ix2wd0_test.go:57: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpl6ix2wd0_test.go:57: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073960
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    for _, s := range lst {\n        result\
    \ += \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n        result +=\
    \ \"(\" + s + \")\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'Yes', got '(()()())(()()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'No', got '())())())())'\n    --- FAIL: TestMatch_Parens/test_num__2\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'No', got '((()(()))(())()))((()(()))(())()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'Yes', got '()()))((()()()()()))((()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'Yes', got '((()))))((()())(()((()))))((()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'No', got '(())(()))(())(()))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'Yes', got '((()()(()))())((()()(()))())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'No', got '((((()(((()))((((()(((()))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'No', got '()(())((()()()(())((()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'No', got '()()()()()()()()'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'Yes', got '(()())(()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'Yes', got '())(()())(()'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073960
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    for _, s := range lst {\n        if result\
    \ != \"\" {\n            result += \"|\"\n        }\n        result += \"(\" +\
    \ s + \")\"\n    }\n    if result != \"\" {\n        result = \"(\" + result +\
    \ \")\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp0v_6ll2__test.go:57: expected 'Yes', got '((()()|()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp0v_6ll2__test.go:57:\
    \ expected 'No', got '(())|()))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmp0v_6ll2__test.go:57: expected 'No', got '(((()(()))|(())())))'\n \
    \   --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmp0v_6ll2__test.go:57:\
    \ expected 'Yes', got '(()()))|((()()())'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp0v_6ll2__test.go:57: expected 'Yes', got '(((()))))|((()())(())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp0v_6ll2__test.go:57:\
    \ expected 'No', got '((())|(())))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp0v_6ll2__test.go:57: expected 'Yes', got '(((()()|(()))()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmp0v_6ll2__test.go:57:\
    \ expected 'No', got '(((((()|(((())))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp0v_6ll2__test.go:57: expected 'No', got '(()(())|((()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmp0v_6ll2__test.go:57:\
    \ expected 'No', got '(()()|()())'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmp0v_6ll2__test.go:57: expected 'Yes', got '((()|()))'\n \
    \   --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmp0v_6ll2__test.go:57:\
    \ expected 'Yes', got '(())|(())'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073956
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack\
    \ = append(stack, lst[i])\n        } else if lst[i] == \")\" {\n            if\
    \ len(stack) == 0 {\n                result = \"Yes\"\n                break\n\
    \            }\n            stack = stack[:len(stack)-1]\n            if stack[len(stack)-1]\
    \ == \"(\" {\n                stack = append(stack, lst[i])\n            } else\
    \ {\n                result = \"No\"\n                break\n            }\n \
    \       } else {\n            result = \"No\"\n            break\n        }\n\
    \    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp7v5kj_h4_test.go:69: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp7v5kj_h4_test.go:69: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp7v5kj_h4_test.go:69: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp7v5kj_h4_test.go:69: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp7v5kj_h4_test.go:69: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp7v5kj_h4_test.go:69: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073960
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack3 := make([]string, len(lst))\n    stack4 := make([]string,\
    \ len(lst))\n    stack5 := make([]string, len(lst))\n    stack6 := make([]string,\
    \ len(lst))\n    stack7 := make([]string, len(lst))\n    stack8 := make([]string,\
    \ len(lst))\n    stack9 := make([]string, len(lst))\n    stack10 := make([]string,\
    \ len(lst))\n    stack11 := make([]string, len(lst))\n    stack12 := make([]string,\
    \ len(lst))\n    stack13 := make([]string, len(lst))\n    stack14 := make([]string,\
    \ len(lst))\n    stack15 := make([]string, len(lst))\n    stack16 := make([]string,\
    \ len(lst))\n    stack17 := make([]string, len(lst))\n    stack18 := make([]string,\
    \ len(lst))\n    stack19 := make([]string, len(lst))\n    stack20 := make([]string,\
    \ len(lst))\n    stack21 := make([]string, len(lst))\n    stack22 := make([]string,\
    \ len(lst))\n    stack23 := make([]string, len(lst))\n    stack24 := make([]string,\
    \ len(lst))\n    stack25 := make([]string, len(lst))\n    stack26 := make([]string,\
    \ len(lst))\n    stack27 := make([]string, len(lst))\n    stack28 := make([]string,\
    \ len(lst))\n    stack29 := make([]string, len(lst))\n    stack30 := make([]string,\
    \ len(lst))\n    stack31 := make([]string, len(lst))\n    stack32 := make([]string,\
    \ len(lst))\n    stack33 := make([]string, len(lst))\n    stack34 := make([]string,\
    \ len(lst))\n    stack35 := make([]string, len(lst))\n    stack36 := make([]string,\
    \ len(lst))\n    stack37 := make([]string, len(lst))\n    stack38 := make([]string,\
    \ len(lst))\n    stack39 := make([]string, len(lst))\n    stack40 := make([]string,\
    \ len(lst))\n    stack41 := make([]string, len(lst))\n    stack42 := make([]string,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphkwn7ra5_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    for _, s := range lst {\n        if result\
    \ != \"\" {\n            result = result + \")\"\n        }\n        result =\
    \ result + s\n    }\n    if result != \"\" {\n        result = result + \"(\"\n\
    \    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpzqnojl28_test.go:57: expected 'Yes', got '()())('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpzqnojl28_test.go:57:\
    \ expected 'No', got ')))('\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpzqnojl28_test.go:57: expected 'No', got '(()(()))())())('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpzqnojl28_test.go:57:\
    \ expected 'Yes', got ')()))(()()(('\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpzqnojl28_test.go:57: expected 'Yes', got '(()))))(()())((('\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpzqnojl28_test.go:57:\
    \ expected 'No', got '())())('\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmpzqnojl28_test.go:57: expected 'Yes', got '(()()()))()('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpzqnojl28_test.go:57: expected\
    \ 'No', got '(((()((())('\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpzqnojl28_test.go:57: expected 'No', got ')(())(()(('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpzqnojl28_test.go:57: expected\
    \ 'No', got ')())(('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n  \
    \      tmpzqnojl28_test.go:57: expected 'Yes', got '())('\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpzqnojl28_test.go:57: expected 'Yes', got '))(('\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073960
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    result := \"No\"\n    stack := make([]string, len(lst))\n    for\
    \ i := 0; i < len(lst); i++ {\n        stack[i] = lst[i]\n    }\n    for i :=\
    \ len(stack) - 1; i >= 0; i-- {\n        if stack[i] == \"(\" {\n            stack[i]\
    \ = \"(\"\n            result += \"Yes\"\n        } else {\n            stack[i]\
    \ = \")\"\n            result += \"No\"\n        }\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpm55e9kcn_test.go:61: expected 'Yes', got 'NoNoNo'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpm55e9kcn_test.go:61:\
    \ expected 'No', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpm55e9kcn_test.go:61: expected 'No', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpm55e9kcn_test.go:61: expected 'Yes', got 'NoNoNo'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__4 (0.00s)\n        tmpm55e9kcn_test.go:61:\
    \ expected 'Yes', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n\
    \        tmpm55e9kcn_test.go:61: expected 'No', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpm55e9kcn_test.go:61: expected 'Yes', got 'NoNoNo'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmpm55e9kcn_test.go:61:\
    \ expected 'No', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpm55e9kcn_test.go:61: expected 'No', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpm55e9kcn_test.go:61: expected 'No', got 'NoNoNo'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpm55e9kcn_test.go:61:\
    \ expected 'Yes', got 'NoNoYes'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpm55e9kcn_test.go:61: expected 'Yes', got 'NoYesNo'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073960
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack3 := make([]string, len(lst))\n    stack4 := make([]string,\
    \ len(lst))\n    stack5 := make([]string, len(lst))\n    stack6 := make([]string,\
    \ len(lst))\n    stack7 := make([]string, len(lst))\n    stack8 := make([]string,\
    \ len(lst))\n    stack9 := make([]string, len(lst))\n    stack10 := make([]string,\
    \ len(lst))\n    stack11 := make([]string, len(lst))\n    stack12 := make([]string,\
    \ len(lst))\n    stack13 := make([]string, len(lst))\n    stack14 := make([]string,\
    \ len(lst))\n    stack15 := make([]string, len(lst))\n    stack16 := make([]string,\
    \ len(lst))\n    stack17 := make([]string, len(lst))\n    stack18 := make([]string,\
    \ len(lst))\n    stack19 := make([]string, len(lst))\n    stack20 := make([]string,\
    \ len(lst))\n    stack21 := make([]string, len(lst))\n    stack22 := make([]string,\
    \ len(lst))\n    stack23 := make([]string, len(lst))\n    stack24 := make([]string,\
    \ len(lst))\n    stack25 := make([]string, len(lst))\n    stack26 := make([]string,\
    \ len(lst))\n    stack27 := make([]string, len(lst))\n    stack28 := make([]string,\
    \ len(lst))\n    stack29 := make([]string, len(lst))\n    stack30 := make([]string,\
    \ len(lst))\n    stack31 := make([]string, len(lst))\n    stack32 := make([]string,\
    \ len(lst))\n    stack33 := make([]string, len(lst))\n    stack34 := make([]string,\
    \ len(lst))\n    stack35 := make([]string, len(lst))\n    stack36 := make([]string,\
    \ len(lst))\n    stack37 := make([]string, len(lst))\n    stack38 := make([]string,\
    \ len(lst))\n    stack39 := make([]string, len(lst))\n    stack40 := make([]string,\
    \ len(lst))\n    stack41 := make([]string, len(lst))\n    stack42 := make([]string,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphkwn7ra5_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else {\n            stack[i] = -1\n        }\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        if stack[i] == 1 {\n            if lst[i]\
    \ == \"(\" {\n                stack[i]++\n            } else {\n             \
    \   stack[i]--\n            }\n            if stack[i] == 0 {\n              \
    \  result = \"Yes\"\n                break\n            }\n        }\n    }\n\
    \    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpr13fe_lk_test.go:69: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpr13fe_lk_test.go:69: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpr13fe_lk_test.go:69: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpr13fe_lk_test.go:69: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpr13fe_lk_test.go:69: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpr13fe_lk_test.go:69: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073960
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    result += \"(\"\n    for _, s := range\
    \ lst {\n        if s == \"(\" {\n            result += \"(\"\n        } else\
    \ {\n            result += \")\"\n        }\n    }\n    result += \")\"\n    return\
    \ result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp0h1kytmf_test.go:57: expected 'Yes', got '()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp0h1kytmf_test.go:57:\
    \ expected 'No', got '()))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmp0h1kytmf_test.go:57: expected 'No', got '()))'\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp0h1kytmf_test.go:57: expected 'Yes', got '()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__4 (0.00s)\n        tmp0h1kytmf_test.go:57:\
    \ expected 'Yes', got '()))'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n\
    \        tmp0h1kytmf_test.go:57: expected 'No', got '()))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp0h1kytmf_test.go:57: expected 'Yes', got '()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmp0h1kytmf_test.go:57:\
    \ expected 'No', got '()))'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmp0h1kytmf_test.go:57: expected 'No', got '()))'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmp0h1kytmf_test.go:57: expected 'No', got '()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp0h1kytmf_test.go:57:\
    \ expected 'Yes', got '(())'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp0h1kytmf_test.go:57: expected 'Yes', got '()()'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073960
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool, len(lst))\n\
    \    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool, len(lst))\n\
    \    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool, len(lst))\n\
    \    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool, len(lst))\n\
    \    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool, len(lst))\n\
    \    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool, len(lst))\n\
    \    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool, len(lst))\n\
    \    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool, len(lst))\n\
    \    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool, len(lst))\n\
    \    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool, len(lst))\n\
    \    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool, len(lst))\n\
    \    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool, len(lst))\n\
    \    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool, len(lst))\n\
    \    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool, len(lst))\n\
    \    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool, len(lst))\n\
    \    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool, len(lst))\n\
    \    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool, len(lst))\n\
    \    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool, len(lst))\n\
    \    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool, len(lst))\n\
    \    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool, len(lst))\n\
    \    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47b29tef_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n    stack :=\
    \ make([]int, len(lst))\n    stack[0] = 0\n    result := \"No\"\n    for i :=\
    \ 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[stack[i]]\
    \ = i\n        }\n        if lst[i] == \")\" {\n            stack[stack[i]] =\
    \ -1\n            if stack[stack[i]] == -1 {\n                result = \"Yes\"\
    \n                break\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens(...)\n\t/tmp/tmpqfvqqpwr_test.go:32\n\
    command-line-arguments_test.TestMatch_Parens(0x0?)\n\t/tmp/tmpqfvqqpwr_test.go:49\
    \ +0x1445\ntesting.tRunner(0xc0001924e0, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\
    \ else if lst[i] == \")\" {\n            if !stack[i] {\n                return\
    \ \"No\"\n            }\n            stack[i] = false\n        }\n    }\n    if\
    \ !stack[len(lst)-1] {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpdaihd0s9_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpdaihd0s9_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpdaihd0s9_test.go:61: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpdaihd0s9_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpdaihd0s9_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpdaihd0s9_test.go:61: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    result := \"No\"\n    for _, s := range lst {\n        result\
    \ += \"Yes\"\n        if result == \"No\" {\n            break\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwrc60tr6_test.go:21:12: s declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073960
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\n\
    \        if lst[i] == \")\" {\n            if !stack[i] {\n                return\
    \ \"No\"\n            }\n            stack[i] = false\n        }\n    }\n    return\
    \ \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps7cgvacg_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmps7cgvacg_test.go:59: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmps7cgvacg_test.go:59: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmps7cgvacg_test.go:59: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmps7cgvacg_test.go:59: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmps7cgvacg_test.go:59: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmps7cgvacg_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps7cgvacg_test.go:59: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = lst[i]\n        } else if lst[i] == \")\" {\n            result := \"Yes\"\
    \n            stack = stack[:len(stack)-1]\n        } else if stack[len(stack)-1]\
    \ == \"(\" {\n            stack[len(stack)-1] += lst[i]\n        } else {\n  \
    \          stack = append(stack, lst[i])\n        }\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj0cnhfog_test.go:26:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = \"(\"\n        } else {\n            if stack[len(stack)-1] == \"(\" {\n \
    \               stack[len(stack)-1] = \")\"\n            } else {\n          \
    \      result = \"Yes\"\n                break\n            }\n        }\n   \
    \ }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmptnoe58bd_test.go:61: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmptnoe58bd_test.go:61: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmptnoe58bd_test.go:61: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmptnoe58bd_test.go:61: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmptnoe58bd_test.go:61: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmptnoe58bd_test.go:61: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = \"(\"\n        } else {\n            if stack[len(stack)-1] == \"(\" {\n \
    \               stack[len(stack)-1] = \")\"\n            } else {\n          \
    \      stack[len(stack)] = \")\"\n            }\n        }\n    }\n    if stack[len(stack)-1]\
    \ == \"(\" {\n        result = \"Yes\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range\
    \ [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens(...)\n\t/tmp/tmpdfvcfb26_test.go:29\n\
    command-line-arguments_test.TestMatch_Parens(0x0?)\n\t/tmp/tmpdfvcfb26_test.go:46\
    \ +0x151f\ntesting.tRunner(0xc0001a01a0, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool, len(lst))\n\
    \    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool, len(lst))\n\
    \    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool, len(lst))\n\
    \    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool, len(lst))\n\
    \    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool, len(lst))\n\
    \    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool, len(lst))\n\
    \    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool, len(lst))\n\
    \    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool, len(lst))\n\
    \    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool, len(lst))\n\
    \    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool, len(lst))\n\
    \    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool, len(lst))\n\
    \    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool, len(lst))\n\
    \    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool, len(lst))\n\
    \    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool, len(lst))\n\
    \    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool, len(lst))\n\
    \    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool, len(lst))\n\
    \    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool, len(lst))\n\
    \    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool, len(lst))\n\
    \    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool, len(lst))\n\
    \    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool, len(lst))\n\
    \    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47b29tef_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    var stack = []int{0}\n    for _, s := range\
    \ lst {\n        if s == '(' {\n            stack = append(stack, -1)\n      \
    \  } else {\n            stack = append(stack, len(stack))\n        }\n    }\n\
    \    for len(stack) > 0 {\n        i := stack[len(stack)-1]\n        if i == -1\
    \ {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack\
    \ = stack[:len(stack)-1]\n            result += \"(\"\n            for _, s :=\
    \ range lst {\n                if i == len(stack) {\n                    result\
    \ += s\n                } else {\n                    if stack[len(stack)-1] ==\
    \ len(s) {\n                        result += s\n                    } else {\n\
    \                        result += \"(\"\n                        stack = append(stack,\
    \ len(s))\n                    }\n                }\n            }\n         \
    \   result += \")\"\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu7qiaut1_test.go:23:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073961
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n    stack1 :=\
    \ make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n    stack1[0],\
    \ stack2[0] = lst[0], lst[0]\n    stack1[1], stack2[1] = lst[0], lst[0]\n    i\
    \ := 2\n    for i < len(lst) {\n        if stack1[i] == '(' {\n            stack1[i]\
    \ = ')'\n            stack2[i] = '('\n            i++\n        } else if stack1[i]\
    \ == ')' {\n            stack1[i] = '('\n            stack2[i] = ')'\n       \
    \     i++\n        } else {\n            stack1[i] = stack1[i-1]\n           \
    \ stack2[i] = stack2[i-1]\n        }\n    }\n    if stack1[0] != stack2[0] {\n\
    \        return \"No\"\n    }\n    if stack1[1] != stack2[1] {\n        return\
    \ \"No\"\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpms4eoh3s_test.go:29:25: invalid operation: stack1[i] == ''('' (mismatched
    types string and untyped rune)

    /tmp/tmpms4eoh3s_test.go:30:25: cannot use '')'' (untyped rune constant 41) as
    string value in assignment

    /tmp/tmpms4eoh3s_test.go:31:25: cannot use ''('' (untyped rune constant 40) as
    string value in assignment

    /tmp/tmpms4eoh3s_test.go:33:32: invalid operation: stack1[i] == '')'' (mismatched
    types string and untyped rune)

    /tmp/tmpms4eoh3s_test.go:34:25: cannot use ''('' (untyped rune constant 40) as
    string value in assignment

    /tmp/tmpms4eoh3s_test.go:35:25: cannot use '')'' (untyped rune constant 41) as
    string value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\n\
    \        if lst[i] == \")\" {\n            stack[i] = false\n        }\n    }\n\
    \    if stack[0] {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpcb9b67ic_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpcb9b67ic_test.go:59: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpcb9b67ic_test.go:59: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpcb9b67ic_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpcb9b67ic_test.go:59: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = lst[i]\n       \
    \ } else if lst[i] == \")\" {\n            stack[i] = lst[i]\n            if i\
    \ == len(lst)-1 {\n                return \"No\"\n            }\n        } else\
    \ {\n            if stack[len(stack)-1] == \"(\" {\n                stack[len(stack)-1]\
    \ = lst[i]\n            } else {\n                return \"No\"\n            }\n\
    \        }\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpdljyhm53_test.go:64: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpdljyhm53_test.go:64: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpdljyhm53_test.go:64: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpdljyhm53_test.go:64: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpdljyhm53_test.go:64: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n    stack1 :=\
    \ make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n    stack1[0],\
    \ stack2[0] = lst[0], lst[0]\n    stack1[1], stack2[1] = lst[1], lst[1]\n    i\
    \ := 2\n    for i < len(lst) {\n        if stack1[i] == ')' {\n            stack1[i]\
    \ = '('\n            stack2[i] = '('\n            i++\n            continue\n\
    \        }\n        if stack1[i] == '(' {\n            stack1[i] = ')'\n     \
    \       stack2[i] = ')'\n            i++\n            continue\n        }\n  \
    \      if stack1[i] == stack2[i] {\n            i++\n            continue\n  \
    \      }\n        if stack1[i] == '(' {\n            stack1[i] = ')'\n       \
    \     stack2[i] = ')'\n            i++\n            continue\n        }\n    \
    \    if stack1[i] == stack2[i] {\n            stack1[i] = ')'\n            stack2[i]\
    \ = ')'\n            i++\n            continue\n        }\n        if stack1[i]\
    \ == '(' {\n            stack1[i] = ')'\n            stack2[i] = ')'\n       \
    \     i++\n            continue\n        }\n        if stack1[i] == stack2[i]\
    \ {\n            stack1[i] = ')'\n            stack2[i] = ')'\n            i++\n\
    \            continue\n        }\n        if stack1[i] == '(' {\n            stack1[i]\
    \ = ')'\n            stack2[i] = ')'\n            i++\n            continue\n\
    \        }\n        if stack1[i] == stack2[i] {\n            stack1[i] = ')'\n\
    \            stack2[i] = ')'\n            i++\n            continue\n        }\n\
    \        if stack1[i] == '(' {\n            stack1[i] = ')'\n            stack2[i]\
    \ = ')'\n            i++\n            continue\n        }\n        if stack1[i]\
    \ == stack2[i] {\n            stack1[i] = ')'\n            stack2[i] = ')'\n \
    \           i++\n            continue\n        }\n        if stack1[i] == '('\
    \ {\n            stack1[i] = ')'\n            stack2[i] = ')'\n            i++\n\
    \            continue\n        }\n        if stack1[i] == stack2[i] {\n      \
    \      stack1[i] = ')'\n            stack2[i] = ')'\n            i++\n       \
    \     continue\n        }\n        if stack1[i] == '(' {\n            stack1[i]\
    \ = ')'\n            stack2[i] = ')'\n            i++\n            continue\n\
    \        }\n        if stack1[i] == stack2[i] {\n            stack1[i] = ')'\n\
    \            stack2[i] = ')'\n            i++\n            continue\n        }\n\
    \        if stack1[i] == '(' {\n            stack1[i] = ')'\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjle5nfc5_test.go:119:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073960
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    for _, s := range lst {\n        result\
    \ += \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n        result +=\
    \ \"(\" + s + \")\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'Yes', got '(()()())(()()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'No', got '())())())())'\n    --- FAIL: TestMatch_Parens/test_num__2\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'No', got '((()(()))(())()))((()(()))(())()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'Yes', got '()()))((()()()()()))((()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'Yes', got '((()))))((()())(()((()))))((()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'No', got '(())(()))(())(()))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'Yes', got '((()()(()))())((()()(()))())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'No', got '((((()(((()))((((()(((()))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'No', got '()(())((()()()(())((()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'No', got '()()()()()()()()'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'Yes', got '(()())(()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'Yes', got '())(()())(()'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073960
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = \"(\"\n        }\
    \ else {\n            stack[i] = \")\"\n        }\n    }\n    result := \"No\"\
    \n    for i := 0; i < len(lst); i++ {\n        if stack[len(stack)-i-1] != lst[i]\
    \ {\n            result = \"Yes\"\n            break\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__2\
    \ (0.00s)\n        tmpvm2fso9c_test.go:62: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvm2fso9c_test.go:62: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n      \
    \  tmpvm2fso9c_test.go:62: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvm2fso9c_test.go:62: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvm2fso9c_test.go:62: expected\
    \ 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    result := \"No\"\n    for _, v := range\
    \ lst {\n        if v == \"(\" || v == \")\" {\n            result += \"Yes\"\n\
    \        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8atvljeh_test.go:21:12: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\n\
    \        if lst[i] == \")\" {\n            stack[i] = false\n        }\n    }\n\
    \    if stack[0] && stack[1] {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp24bdesky_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp24bdesky_test.go:59: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp24bdesky_test.go:59: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp24bdesky_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp24bdesky_test.go:59: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp24bdesky_test.go:59: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073962
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        stack[i] = false\n    }\n    result := \"\"\n    result += \"\
    (\"\n    result += \"(\"\n    for i := 0; i < len(lst); i++ {\n        if stack[i]\
    \ {\n            result += \"(\"\n        } else {\n            result += \"(\"\
    \n            stack[i] = true\n        }\n    }\n    result += \"(\"\n    for\
    \ i := len(lst) - 1; i >= 0; i-- {\n        if stack[i] {\n            result\
    \ += \")\"\n        } else {\n            result += \")\"\n            stack[i]\
    \ = true\n        }\n    }\n    result += \")\"\n    return result\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpdnk9zpmx_test.go:72: expected 'Yes', got '((((()))'\n  \
    \  --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpdnk9zpmx_test.go:72:\
    \ expected 'No', got '((((()))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpdnk9zpmx_test.go:72: expected 'No', got '((((()))'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpdnk9zpmx_test.go:72: expected\
    \ 'Yes', got '((((()))'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n\
    \        tmpdnk9zpmx_test.go:72: expected 'Yes', got '((((()))'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpdnk9zpmx_test.go:72: expected\
    \ 'No', got '((((()))'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n \
    \       tmpdnk9zpmx_test.go:72: expected 'Yes', got '((((()))'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpdnk9zpmx_test.go:72: expected\
    \ 'No', got '((((()))'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n \
    \       tmpdnk9zpmx_test.go:72: expected 'No', got '((((()))'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpdnk9zpmx_test.go:72: expected 'No', got '((((()))'\n   \
    \ --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpdnk9zpmx_test.go:72:\
    \ expected 'Yes', got '((((()))'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpdnk9zpmx_test.go:72: expected 'Yes', got '((((()))'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073962
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    for _, s := range lst {\n        if result\
    \ != \"\" {\n            result += \"|\"\n        }\n        result += \"(\" +\
    \ s + \")\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmphmg40j12_test.go:54: expected 'Yes', got '(()()|())'\n \
    \   --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmphmg40j12_test.go:54:\
    \ expected 'No', got '())|())'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmphmg40j12_test.go:54: expected 'No', got '((()(()))|(())()))'\n   \
    \ --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmphmg40j12_test.go:54:\
    \ expected 'Yes', got '()()))|((()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmphmg40j12_test.go:54: expected 'Yes', got '((()))))|((()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmphmg40j12_test.go:54:\
    \ expected 'No', got '(())|(()))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmphmg40j12_test.go:54: expected 'Yes', got '((()()|(()))())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmphmg40j12_test.go:54:\
    \ expected 'No', got '((((()|(((()))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmphmg40j12_test.go:54: expected 'No', got '()(())|((()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmphmg40j12_test.go:54:\
    \ expected 'No', got '()()|()()'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmphmg40j12_test.go:54: expected 'Yes', got '(()|())'\n   \
    \ --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmphmg40j12_test.go:54:\
    \ expected 'Yes', got '())|(()'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073962
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    for i := range lst {\n\
    \        stack[i] = lst[i]\n    }\n    result := \"\"\n    i := 0\n    for i <\
    \ len(stack) {\n        if stack[i] == \"(\" {\n            i++\n            if\
    \ i == len(stack) {\n                return \"No\"\n            }\n          \
    \  if stack[i] == \"(\" {\n                i++\n                if i == len(stack)\
    \ {\n                    return \"No\"\n                }\n            }\n   \
    \     }\n        if stack[i] == \")\" {\n            i++\n            if i ==\
    \ len(stack) {\n                return \"No\"\n            }\n            if stack[i]\
    \ == \")\" {\n                i++\n                if i == len(stack) {\n    \
    \                return \"No\"\n                }\n            }\n        }\n\
    \        if stack[i] == \"(\" {\n            i++\n            if i == len(stack)\
    \ {\n                return \"No\"\n            }\n            if stack[i] ==\
    \ \")\" {\n                i++\n                if i == len(stack) {\n       \
    \             return \"No\"\n                }\n            }\n        }\n   \
    \     if stack[i] == \")\" {\n            i++\n            if i == len(stack)\
    \ {\n                return \"No\"\n            }\n            if stack[i] ==\
    \ \")\" {\n                i++\n                if i == len(stack) {\n       \
    \             return \"No\"\n                }\n            }\n        }\n   \
    \     if stack[i] == \")\" {\n            i++\n            if i == len(stack)\
    \ {\n                return \"No\"\n            }\n            if stack[i] ==\
    \ \")\" {\n                i++\n                if i == len(stack) {\n       \
    \             return \"No\"\n                }\n            }\n        }\n   \
    \     if stack[i] == \")\" {\n            i++\n            if i == len(stack)\
    \ {\n                return \"No\"\n            }\n            if stack[i] ==\
    \ \")\" {\n                i++\n                if i == len(stack) {\n       \
    \             return \"No\"\n                }\n            }\n        }\n   \
    \     if stack[i] == \")\" {\n            i++\n            if i == len(stack)\
    \ {\n                return \"No\"\n            }\n            if stack[i] ==\
    \ \")\" {\n                i++\n                if i == len(stack) {\n       \
    \             return \"No\"\n                }\n            }\n        }\n   \
    \     if stack[i] == \")\" {\n            i++\n            if i == len(stack)\
    \ {\n                return \"No\"\n            }\n            if stack[i] ==\
    \ \")\" {\n                i++\n                if i == len(stack) {\n       \
    \             return \"No\"\n                }\n            }\n        }\n   \
    \     if stack[i] == \")\" {\n            i++\n            if i == len(stack)\
    \ {\n                return \"No\"\n            }\n            if stack[i] ==\
    \ \")\" {\n                i++\n                if i == len(stack) {\n       \
    \             return \"No\"\n                }\n            }\n        }\n   \
    \     if stack[i] == \")\" {\n            i++\n            if i == len(stack)\
    \ {\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ebshztd_test.go:139:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073961
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    i :=\
    \ 0\n    for _, s := range lst {\n        if s == '(' {\n            stack[i]\
    \ = 1\n        } else if s == ')' {\n            stack[i] = -1\n        } else\
    \ {\n            stack[i] = 0\n        }\n        i++\n    }\n    for i := 0;\
    \ i < len(stack); i++ {\n        if stack[i] < 0 {\n            result = \"Yes\"\
    \n            break\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpopfi7xt__test.go:24:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpopfi7xt__test.go:26:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073962
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else if lst[i] == \")\" {\n            stack[i] = -1\n      \
    \  } else if stack[i] != 0 {\n            result := \"No\"\n            break\n\
    \        }\n    }\n    if result == \"No\" {\n        result = \"Yes\"\n    }\n\
    \    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe_iafa_q_test.go:28:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073962
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\
    \ else {\n            stack[i] = false\n        }\n    }\n    result := \"No\"\
    \n    for i := 0; i < len(lst); i++ {\n        if stack[i] {\n            result\
    \ = \"Yes\"\n            break\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpwzjeakdz_test.go:62: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpwzjeakdz_test.go:62: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpwzjeakdz_test.go:62: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpwzjeakdz_test.go:62: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n    stack :=\
    \ make([]bool, len(lst))\n    stack[0] = True\n    for _, s := range lst {\n \
    \       if s == '(' {\n            stack[len(stack)-1] = true\n        } else\
    \ if s == ')' {\n            stack[len(stack)-1] = false\n        } else {\n \
    \           return fmt.Sprintf(\"No\")\n        }\n    }\n    if stack[len(stack)-1]\
    \ {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6x6_j8v0_test.go:24:16: undefined: True

    /tmp/tmp6x6_j8v0_test.go:26:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmp6x6_j8v0_test.go:28:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073962
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    for _, s := range lst {\n        if result\
    \ != \"\" {\n            result += \"|\"\n        }\n        result += \"(\" +\
    \ s + \")\"\n    }\n    if result == \"()\" {\n        return \"Yes\"\n    }\n\
    \    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp6gjw3d88_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp6gjw3d88_test.go:57: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp6gjw3d88_test.go:57: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp6gjw3d88_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp6gjw3d88_test.go:57: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp6gjw3d88_test.go:57: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n    if len(lst)\
    \ == 1 {\n        return lst[0]\n    }\n    stack1 := make([]string, len(lst))\n\
    \    stack2 := make([]string, len(lst))\n    stack1[0], stack2[0] = lst[0], lst[0]\n\
    \    stack1[1], stack2[1] = lst[1], lst[1]\n    stack1[2], stack2[2] = lst[2],\
    \ lst[2]\n    stack1[3], stack2[3] = lst[3], lst[3]\n    stack1[4], stack2[4]\
    \ = lst[4], lst[4]\n    stack1[5], stack2[5] = lst[5], lst[5]\n    stack1[6],\
    \ stack2[6] = lst[6], lst[6]\n    stack1[7], stack2[7] = lst[7], lst[7]\n    stack1[8],\
    \ stack2[8] = lst[8], lst[8]\n    stack1[9], stack2[9] = lst[9], lst[9]\n    stack1[10],\
    \ stack2[10] = lst[10], lst[10]\n    stack1[11], stack2[11] = lst[11], lst[11]\n\
    \    stack1[12], stack2[12] = lst[12], lst[12]\n    stack1[13], stack2[13] = lst[13],\
    \ lst[13]\n    stack1[14], stack2[14] = lst[14], lst[14]\n    stack1[15], stack2[15]\
    \ = lst[15], lst[15]\n    stack1[16], stack2[16] = lst[16], lst[16]\n    stack1[17],\
    \ stack2[17] = lst[17], lst[17]\n    stack1[18], stack2[18] = lst[18], lst[18]\n\
    \    stack1[19], stack2[19] = lst[19], lst[19]\n    stack1[20], stack2[20] = lst[20],\
    \ lst[20]\n    stack1[21], stack2[21] = lst[21], lst[21]\n    stack1[22], stack2[22]\
    \ = lst[22], lst[22]\n    stack1[23], stack2[23] = lst[23], lst[23]\n    stack1[24],\
    \ stack2[24] = lst[24], lst[24]\n    stack1[25], stack2[25] = lst[25], lst[25]\n\
    \    stack1[26], stack2[26] = lst[26], lst[26]\n    stack1[27], stack2[27] = lst[27],\
    \ lst[27]\n    stack1[28], stack\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpadma07q__test.go:56:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073962
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n    stack :=\
    \ make([]string, len(lst))\n    for i := 0; i < len(lst); i++ {\n        if lst[i]\
    \ == \"(\" {\n            stack[i] = \"(\"\n        } else {\n            stack[i]\
    \ = \")\"\n        }\n    }\n    result := \"\"\n    for i := 0; i < len(stack);\
    \ i++ {\n        if stack[i] == \"(\" {\n            result += stack[i]\n    \
    \    } else {\n            result += \"(\" + stack[i]\n        }\n    }\n    if\
    \ result == \"()\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpncvcxype_test.go:69: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpncvcxype_test.go:69: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpncvcxype_test.go:69: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpncvcxype_test.go:69: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpncvcxype_test.go:69: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpncvcxype_test.go:69: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack1[0], stack2[0] = true, true\n    stack1[1], stack2[1] = true, true\n\
    \    for i := 2; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n         \
    \   stack1[i] = false\n        }\n        if lst[i] == \")\" {\n            stack2[i]\
    \ = false\n        }\n    }\n    if stack1[0] && stack2[0] {\n        return \"\
    Yes\"\n    }\n    if stack1[1] && stack2[1] {\n        return \"No\"\n    }\n\
    \    if stack1[0] && stack2[1] {\n        return \"Yes\"\n    }\n    if stack1[1]\
    \ && stack2[0] {\n        return \"No\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmppbgvehxp_test.go:71: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmppbgvehxp_test.go:71: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmppbgvehxp_test.go:71: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmppbgvehxp_test.go:71: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmppbgvehxp_test.go:71: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmppbgvehxp_test.go:71: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073963
- exit_code: null
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    for i := range lst {\n\
    \        stack[i] = lst[i]\n    }\n    result := \"\"\n    i := 0\n    for i <\
    \ len(stack) {\n        if stack[i] == \"(\" {\n            i++\n            if\
    \ i == len(stack) {\n                return \"No\"\n            }\n          \
    \  if stack[i] == \"(\" {\n                i++\n                if i == len(stack)\
    \ {\n                    return \"No\"\n                }\n            }\n   \
    \     }\n        if stack[i] == \")\" {\n            i++\n            if i ==\
    \ len(stack) {\n                return \"No\"\n            }\n            if stack[i]\
    \ == \")\" {\n                i++\n                if i == len(stack) {\n    \
    \                return \"No\"\n                }\n            }\n        }\n\
    \        result += stack[i]\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660073976
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack3 := make([]string, len(lst))\n    stack4 := make([]string,\
    \ len(lst))\n    stack5 := make([]string, len(lst))\n    stack6 := make([]string,\
    \ len(lst))\n    stack7 := make([]string, len(lst))\n    stack8 := make([]string,\
    \ len(lst))\n    stack9 := make([]string, len(lst))\n    stack10 := make([]string,\
    \ len(lst))\n    stack11 := make([]string, len(lst))\n    stack12 := make([]string,\
    \ len(lst))\n    stack13 := make([]string, len(lst))\n    stack14 := make([]string,\
    \ len(lst))\n    stack15 := make([]string, len(lst))\n    stack16 := make([]string,\
    \ len(lst))\n    stack17 := make([]string, len(lst))\n    stack18 := make([]string,\
    \ len(lst))\n    stack19 := make([]string, len(lst))\n    stack20 := make([]string,\
    \ len(lst))\n    stack21 := make([]string, len(lst))\n    stack22 := make([]string,\
    \ len(lst))\n    stack23 := make([]string, len(lst))\n    stack24 := make([]string,\
    \ len(lst))\n    stack25 := make([]string, len(lst))\n    stack26 := make([]string,\
    \ len(lst))\n    stack27 := make([]string, len(lst))\n    stack28 := make([]string,\
    \ len(lst))\n    stack29 := make([]string, len(lst))\n    stack30 := make([]string,\
    \ len(lst))\n    stack31 := make([]string, len(lst))\n    stack32 := make([]string,\
    \ len(lst))\n    stack33 := make([]string, len(lst))\n    stack34 := make([]string,\
    \ len(lst))\n    stack35 := make([]string, len(lst))\n    stack36 := make([]string,\
    \ len(lst))\n    stack37 := make([]string, len(lst))\n    stack38 := make([]string,\
    \ len(lst))\n    stack39 := make([]string, len(lst))\n    stack40 := make([]string,\
    \ len(lst))\n    stack41 := make([]string, len(lst))\n    stack42 := make([]string,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphkwn7ra5_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else {\n            if stack[i] > 0 {\n                stack[i]--\n\
    \            } else {\n                result = \"Yes\"\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmp6gq5o1si_test.go:61: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmp6gq5o1si_test.go:61: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmp6gq5o1si_test.go:61: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmp6gq5o1si_test.go:61: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmp6gq5o1si_test.go:61: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmp6gq5o1si_test.go:61: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = lst[i]\n        } else if lst[i] == \")\" {\n            stack[i] = lst[i]\n\
    \            if stack[len(stack)-1] != \")\" {\n                result = \"No\"\
    \n                break\n            }\n            stack = stack[:len(stack)-1]\n\
    \        } else {\n            if stack[len(stack)-1] != lst[i] {\n          \
    \      result = \"No\"\n                break\n            }\n            stack\
    \ = stack[:len(stack)-1]\n        }\n    }\n    if result == \"No\" {\n      \
    \  result = \"Yes\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmp6e_565w2_test.go:70: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmp6e_565w2_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmp6e_565w2_test.go:70: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmp6e_565w2_test.go:70: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmp6e_565w2_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmp6e_565w2_test.go:70: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: null
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        stack[i] = lst[i]\n    }\n    result := \"\"\n    i := 0\n  \
    \  for i < len(stack) {\n        if stack[i] == \"(\" {\n            i++\n   \
    \         if i == len(stack) {\n                result = \"No\"\n            \
    \    break\n            }\n            if stack[i] == \"(\" {\n              \
    \  i++\n                if i == len(stack) {\n                    result = \"\
    Yes\"\n                    break\n                }\n            }\n        }\n\
    \        if stack[i] == \")\" {\n            i++\n            if i == len(stack)\
    \ {\n                result = \"No\"\n                break\n            }\n \
    \           if stack[i] == \")\" {\n                i++\n                if i\
    \ == len(stack) {\n                    result = \"Yes\"\n                    break\n\
    \                }\n            }\n        }\n    }\n    return result\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660073976
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool, len(lst))\n\
    \    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool, len(lst))\n\
    \    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool, len(lst))\n\
    \    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool, len(lst))\n\
    \    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool, len(lst))\n\
    \    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool, len(lst))\n\
    \    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool, len(lst))\n\
    \    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool, len(lst))\n\
    \    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool, len(lst))\n\
    \    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool, len(lst))\n\
    \    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool, len(lst))\n\
    \    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool, len(lst))\n\
    \    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool, len(lst))\n\
    \    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool, len(lst))\n\
    \    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool, len(lst))\n\
    \    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool, len(lst))\n\
    \    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool, len(lst))\n\
    \    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool, len(lst))\n\
    \    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool, len(lst))\n\
    \    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool, len(lst))\n\
    \    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47b29tef_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack3 := make([]string, len(lst))\n    stack4 := make([]string,\
    \ len(lst))\n    stack5 := make([]string, len(lst))\n    stack6 := make([]string,\
    \ len(lst))\n    stack7 := make([]string, len(lst))\n    stack8 := make([]string,\
    \ len(lst))\n    stack9 := make([]string, len(lst))\n    stack10 := make([]string,\
    \ len(lst))\n    stack11 := make([]string, len(lst))\n    stack12 := make([]string,\
    \ len(lst))\n    stack13 := make([]string, len(lst))\n    stack14 := make([]string,\
    \ len(lst))\n    stack15 := make([]string, len(lst))\n    stack16 := make([]string,\
    \ len(lst))\n    stack17 := make([]string, len(lst))\n    stack18 := make([]string,\
    \ len(lst))\n    stack19 := make([]string, len(lst))\n    stack20 := make([]string,\
    \ len(lst))\n    stack21 := make([]string, len(lst))\n    stack22 := make([]string,\
    \ len(lst))\n    stack23 := make([]string, len(lst))\n    stack24 := make([]string,\
    \ len(lst))\n    stack25 := make([]string, len(lst))\n    stack26 := make([]string,\
    \ len(lst))\n    stack27 := make([]string, len(lst))\n    stack28 := make([]string,\
    \ len(lst))\n    stack29 := make([]string, len(lst))\n    stack30 := make([]string,\
    \ len(lst))\n    stack31 := make([]string, len(lst))\n    stack32 := make([]string,\
    \ len(lst))\n    stack33 := make([]string, len(lst))\n    stack34 := make([]string,\
    \ len(lst))\n    stack35 := make([]string, len(lst))\n    stack36 := make([]string,\
    \ len(lst))\n    stack37 := make([]string, len(lst))\n    stack38 := make([]string,\
    \ len(lst))\n    stack39 := make([]string, len(lst))\n    stack40 := make([]string,\
    \ len(lst))\n    stack41 := make([]string, len(lst))\n    stack42 := make([]string,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphkwn7ra5_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = \"(\"\n        }\
    \ else if lst[i] == \")\" {\n            stack[i] = \")\"\n        } else {\n\
    \            return fmt.Sprintf(\"No\")\n        }\n    }\n    return fmt.Sprintf(\"\
    Yes\")\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpfqyfpqkc_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpfqyfpqkc_test.go:57: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpfqyfpqkc_test.go:57: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpfqyfpqkc_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpfqyfpqkc_test.go:57: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = \"(\"\n        }\
    \ else {\n            stack[i] = \")\"\n        }\n    }\n    result := \"\"\n\
    \    for i := 0; i < len(lst); i++ {\n        if lst[i] == stack[i] {\n      \
    \      result += lst[i]\n        } else {\n            if result != \"\" {\n \
    \               return \"No\"\n            }\n            return \"Yes\"\n   \
    \     }\n    }\n    if result != \"\" {\n        return \"No\"\n    }\n    return\
    \ \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__2\
    \ (0.00s)\n        tmpuzn4bpc2_test.go:69: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpuzn4bpc2_test.go:69: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n      \
    \  tmpuzn4bpc2_test.go:69: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpuzn4bpc2_test.go:69: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpuzn4bpc2_test.go:69: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmpuzn4bpc2_test.go:69: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpuzn4bpc2_test.go:69: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool, len(lst))\n\
    \    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool, len(lst))\n\
    \    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool, len(lst))\n\
    \    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool, len(lst))\n\
    \    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool, len(lst))\n\
    \    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool, len(lst))\n\
    \    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool, len(lst))\n\
    \    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool, len(lst))\n\
    \    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool, len(lst))\n\
    \    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool, len(lst))\n\
    \    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool, len(lst))\n\
    \    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool, len(lst))\n\
    \    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool, len(lst))\n\
    \    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool, len(lst))\n\
    \    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool, len(lst))\n\
    \    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool, len(lst))\n\
    \    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool, len(lst))\n\
    \    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool, len(lst))\n\
    \    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool, len(lst))\n\
    \    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool, len(lst))\n\
    \    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47b29tef_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n    stack :=\
    \ make([]string, len(lst))\n    stack[0] = lst[0]\n    result := \"Yes\"\n   \
    \ for i := 1; i < len(lst); i++ {\n        if stack[len(stack)-1] != lst[i] {\n\
    \            result = \"No\"\n            break\n        }\n        stack = append(stack,\
    \ lst[i])\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmplsxfmypv_test.go:60: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmplsxfmypv_test.go:60: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmplsxfmypv_test.go:60: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmplsxfmypv_test.go:60: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmplsxfmypv_test.go:60: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmplsxfmypv_test.go:60: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var stack = []int{0}\n    var result string\n    for _, s := range\
    \ lst {\n        if s == '(' {\n            stack = append(stack, -1)\n      \
    \  } else {\n            stack = append(stack, len(stack))\n        }\n    }\n\
    \    for len(stack) > 0 {\n        i := stack[len(stack)-1]\n        if i == -1\
    \ {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack\
    \ = stack[:len(stack)-1]\n            if lst[i] != '(' {\n                result\
    \ += \"No\"\n                break\n            }\n            stack[len(stack)-1]\
    \ = i\n        }\n    }\n    if result == \"No\" {\n        result = \"Yes\"\n\
    \    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnzou1spl_test.go:23:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpnzou1spl_test.go:35:26: invalid operation: lst[i] != ''('' (mismatched
    types string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack3 := make([]string, len(lst))\n    stack4 := make([]string,\
    \ len(lst))\n    stack5 := make([]string, len(lst))\n    stack6 := make([]string,\
    \ len(lst))\n    stack7 := make([]string, len(lst))\n    stack8 := make([]string,\
    \ len(lst))\n    stack9 := make([]string, len(lst))\n    stack10 := make([]string,\
    \ len(lst))\n    stack11 := make([]string, len(lst))\n    stack12 := make([]string,\
    \ len(lst))\n    stack13 := make([]string, len(lst))\n    stack14 := make([]string,\
    \ len(lst))\n    stack15 := make([]string, len(lst))\n    stack16 := make([]string,\
    \ len(lst))\n    stack17 := make([]string, len(lst))\n    stack18 := make([]string,\
    \ len(lst))\n    stack19 := make([]string, len(lst))\n    stack20 := make([]string,\
    \ len(lst))\n    stack21 := make([]string, len(lst))\n    stack22 := make([]string,\
    \ len(lst))\n    stack23 := make([]string, len(lst))\n    stack24 := make([]string,\
    \ len(lst))\n    stack25 := make([]string, len(lst))\n    stack26 := make([]string,\
    \ len(lst))\n    stack27 := make([]string, len(lst))\n    stack28 := make([]string,\
    \ len(lst))\n    stack29 := make([]string, len(lst))\n    stack30 := make([]string,\
    \ len(lst))\n    stack31 := make([]string, len(lst))\n    stack32 := make([]string,\
    \ len(lst))\n    stack33 := make([]string, len(lst))\n    stack34 := make([]string,\
    \ len(lst))\n    stack35 := make([]string, len(lst))\n    stack36 := make([]string,\
    \ len(lst))\n    stack37 := make([]string, len(lst))\n    stack38 := make([]string,\
    \ len(lst))\n    stack39 := make([]string, len(lst))\n    stack40 := make([]string,\
    \ len(lst))\n    stack41 := make([]string, len(lst))\n    stack42 := make([]string,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphkwn7ra5_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073959
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    result := \"No\"\n    for _, v := range lst {\n        result\
    \ := \"Yes\"\n        if v == \"(\" {\n            result := \"No\"\n        }\n\
    \        if v == \")\" {\n            result := \"Yes\"\n        }\n    }\n  \
    \  return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_iwq07km_test.go:22:9: result declared but not used

    /tmp/tmp_iwq07km_test.go:24:13: result declared but not used

    /tmp/tmp_iwq07km_test.go:27:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073963
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var stack = []int{0}\n    var result string\n    for _, s := range\
    \ lst {\n        if s == '(' {\n            stack = append(stack, -1)\n      \
    \  } else {\n            stack = append(stack, len(stack))\n        }\n    }\n\
    \    for len(stack) > 0 {\n        i := stack[len(stack)-1]\n        if i == len(lst)\
    \ {\n            stack = stack[:len(stack)-1]\n            result = result + lst[i]\n\
    \            break\n        }\n        if lst[i] == '(' {\n            stack =\
    \ append(stack, i)\n        } else {\n            stack = append(stack, len(stack))\n\
    \        }\n    }\n    if result == \"()\" {\n        return \"Yes\"\n    } else\
    \ {\n        return \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvs_m5_qd_test.go:23:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpvs_m5_qd_test.go:36:22: invalid operation: lst[i] == ''('' (mismatched
    types string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073964
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    var stack = []int{0, 1}\n    for _, s :=\
    \ range lst {\n        if s == '(' {\n            stack[stack[0]] = stack[1]\n\
    \            stack[1]++\n        } else if s == ')' {\n            stack[1]--\n\
    \            if stack[1] == 0 {\n                result += \"(\" + string(stack[0])\
    \ + \")\"\n                stack[0] = 0\n                stack[1] = 1\n      \
    \      }\n        }\n    }\n    if stack[0] == 0 {\n        result = \"No\"\n\
    \    } else {\n        result = \"Yes\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpty8nzte9_test.go:23:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpty8nzte9_test.go:26:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073964
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if stack[i] {\n            result := \"\
    No\"\n            break\n        }\n        if lst[i] == \"(\" {\n           \
    \ stack[i] = true\n        } else {\n            stack[i] = false\n        }\n\
    \    }\n    if result == \"No\" {\n        result = \"Yes\"\n    }\n    return\
    \ result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzawcg9o_test.go:24:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073964
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    for _, s := range lst {\n        result\
    \ += \"(\" + s + \")\"\n    }\n    result += \"()\"\n    return result\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpo4n7c3ye_test.go:52: expected 'Yes', got '(()()())()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpo4n7c3ye_test.go:52:\
    \ expected 'No', got '())())()'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpo4n7c3ye_test.go:52: expected 'No', got '((()(()))(())()))()'\n  \
    \  --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpo4n7c3ye_test.go:52:\
    \ expected 'Yes', got '()()))((()()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpo4n7c3ye_test.go:52: expected 'Yes', got '((()))))((()())(()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpo4n7c3ye_test.go:52:\
    \ expected 'No', got '(())(()))()'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpo4n7c3ye_test.go:52: expected 'Yes', got '((()()(()))())()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmpo4n7c3ye_test.go:52:\
    \ expected 'No', got '((((()(((()))()'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpo4n7c3ye_test.go:52: expected 'No', got '()(())((()()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmpo4n7c3ye_test.go:52:\
    \ expected 'No', got '()()()()()'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpo4n7c3ye_test.go:52: expected 'Yes', got '(()())()'\n  \
    \  --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmpo4n7c3ye_test.go:52:\
    \ expected 'Yes', got '())(()()'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073964
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = \"(\"\n        } else {\n            if stack[len(stack)-1] == \"(\" {\n \
    \               stack[len(stack)-1] = \")\"\n            } else {\n          \
    \      result = \"No\"\n                break\n            }\n        }\n    }\n\
    \    if result == \"No\" {\n        result = \"Yes\"\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpsvyzjx4__test.go:64: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpsvyzjx4__test.go:64: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpsvyzjx4__test.go:64: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpsvyzjx4__test.go:64: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpsvyzjx4__test.go:64: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpsvyzjx4__test.go:64: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073964
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\n\
    \        if lst[i] == \")\" {\n            if !stack[i] {\n                return\
    \ \"No\"\n            }\n            stack[i] = false\n        }\n    }\n    return\
    \ \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps7cgvacg_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmps7cgvacg_test.go:59: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmps7cgvacg_test.go:59: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmps7cgvacg_test.go:59: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmps7cgvacg_test.go:59: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmps7cgvacg_test.go:59: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmps7cgvacg_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps7cgvacg_test.go:59: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        stack[i] = lst[i]\n    }\n    for i :=\
    \ len(stack) - 1; i >= 0; i-- {\n        if stack[i] == \"(\" {\n            stack[i]\
    \ = \")\"\n            result += \"Yes\"\n            break\n        }\n     \
    \   if stack[i] == \")\" {\n            stack[i] = \"(\"\n            result +=\
    \ \"Yes\"\n            break\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpdvsd8fp9_test.go:64: expected 'Yes', got 'NoYes'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpdvsd8fp9_test.go:64:\
    \ expected 'No', got 'NoYes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpdvsd8fp9_test.go:64: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpdvsd8fp9_test.go:64: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpdvsd8fp9_test.go:64: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmpdvsd8fp9_test.go:64: expected 'Yes', got 'NoYes'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpdvsd8fp9_test.go:64: expected 'Yes', got 'NoYes'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073964
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = \"(\"\n            result += \"Yes\"\n        } else {\n            stack[i]\
    \ = \")\"\n            if stack[len(stack)-1] == \"\" {\n                result\
    \ = \"No\"\n                break\n            }\n            result += \"Yes\"\
    \n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpbcha51h4_test.go:62: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpbcha51h4_test.go:62: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpbcha51h4_test.go:62: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpbcha51h4_test.go:62: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpbcha51h4_test.go:62: expected\
    \ 'Yes', got 'NoYesYes'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpbcha51h4_test.go:62: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073964
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = \"(\"\n        }\
    \ else if lst[i] == \")\" {\n            stack[i] = \")\"\n        } else {\n\
    \            return fmt.Sprintf(\"No\")\n        }\n    }\n    return fmt.Sprintf(\"\
    Yes\")\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpfqyfpqkc_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpfqyfpqkc_test.go:57: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpfqyfpqkc_test.go:57: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpfqyfpqkc_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpfqyfpqkc_test.go:57: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\n\
    \        if lst[i] == \")\" {\n            if stack[i] {\n                stack[i]\
    \ = false\n            } else {\n                return \"No\"\n            }\n\
    \        }\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpcuop7eoj_test.go:60: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpcuop7eoj_test.go:60: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpcuop7eoj_test.go:60: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpcuop7eoj_test.go:60: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpcuop7eoj_test.go:60: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpcuop7eoj_test.go:60: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpcuop7eoj_test.go:60: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpcuop7eoj_test.go:60: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073965
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        stack[i] = false\n    }\n    result := \"\"\n    result += \"\
    (\"\n    result += \"(\"\n    for i := 0; i < len(lst); i++ {\n        if stack[i]\
    \ {\n            result += \")\"\n            stack[i] = false\n        } else\
    \ {\n            result += lst[i]\n            stack[i] = true\n        }\n  \
    \  }\n    result += \")\"\n    result += \"(\"\n    for i := 0; i < len(lst);\
    \ i++ {\n        if stack[i] {\n            result += \")\"\n            stack[i]\
    \ = false\n        } else {\n            result += lst[i]\n            stack[i]\
    \ = true\n        }\n    }\n    result += \")\"\n    return result\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmphyvf362__test.go:75: expected 'Yes', got '((()())()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmphyvf362__test.go:75:\
    \ expected 'No', got '(()))()))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmphyvf362__test.go:75: expected 'No', got '(((()(())())()))()))'\n \
    \   --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmphyvf362__test.go:75:\
    \ expected 'Yes', got '(()())(()()()()))'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmphyvf362__test.go:75: expected 'Yes', got '(((())))(()())(()()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmphyvf362__test.go:75:\
    \ expected 'No', got '((()()))()))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmphyvf362__test.go:75: expected 'Yes', got '(((()(()))())()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmphyvf362__test.go:75:\
    \ expected 'No', got '((((((((()))()))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmphyvf362__test.go:75: expected 'No', got '(()(()(()()()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmphyvf362__test.go:75:\
    \ expected 'No', got '(()()()()))'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmphyvf362__test.go:75: expected 'Yes', got '((())()))'\n \
    \   --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmphyvf362__test.go:75:\
    \ expected 'Yes', got '(()()()))'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660073965
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack\
    \ = append(stack, lst[i])\n        } else {\n            stack = pop(stack)\n\
    \            if stack == nil {\n                result = \"Yes\"\n           \
    \     break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp624hpxxi_test.go:26:21: undefined: pop

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073965
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = 1\n        } else\
    \ if lst[i] == \")\" {\n            stack[i] = 0\n        } else if stack[i] ==\
    \ 0 {\n            return fmt.Sprintf(\"No\")\n        }\n    }\n    return fmt.Sprintf(\"\
    Yes\")\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpzd0l6q65_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpzd0l6q65_test.go:57: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpzd0l6q65_test.go:57: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpzd0l6q65_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpzd0l6q65_test.go:57: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073965
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := range lst {\n  \
    \      stack[i] = false\n    }\n    result := \"\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    \nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc6ptusk7_test.go:122:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else if lst[i] == \")\" {\n            stack[i] = 0\n       \
    \     if stack[i]+1 == 0 {\n                result = \"Yes\"\n               \
    \ break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpok7i0clf_test.go:60: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpok7i0clf_test.go:60: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpok7i0clf_test.go:60: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpok7i0clf_test.go:60: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpok7i0clf_test.go:60: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpok7i0clf_test.go:60: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073965
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else if lst[i] == \")\" {\n            stack[i] = -1\n      \
    \  } else if stack[i] != 0 {\n            result := \"No\"\n            break\n\
    \        }\n    }\n    if result == \"No\" {\n        result = \"Yes\"\n    }\n\
    \    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe_iafa_q_test.go:28:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073962
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else if lst[i] == \")\" {\n            if stack[i] == 1 {\n \
    \               result = \"Yes\"\n                break\n            }\n     \
    \       stack[i] = -1\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmppe0lo0ct_test.go:60: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmppe0lo0ct_test.go:60: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmppe0lo0ct_test.go:60: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmppe0lo0ct_test.go:60: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmppe0lo0ct_test.go:60: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmppe0lo0ct_test.go:60: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073965
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else if lst[i] == \")\" {\n            stack[i] = 0\n       \
    \ } else if stack[i] == 0 {\n            result = \"No\"\n            break\n\
    \        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps2g5ay7o_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmps2g5ay7o_test.go:59: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmps2g5ay7o_test.go:59: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmps2g5ay7o_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmps2g5ay7o_test.go:59: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmps2g5ay7o_test.go:59: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073965
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    result += \"(\" + lst[0] + \")\"\n    for\
    \ i := 1; i < len(lst); i++ {\n        result += \"(\" + lst[i] + \")\"\n    }\n\
    \    result += \"(\" + lst[len(lst)-1] + \")\"\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmped1yh_h6_test.go:53: expected 'Yes', got '(()()())())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmped1yh_h6_test.go:53:\
    \ expected 'No', got '())())())'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmped1yh_h6_test.go:53: expected 'No', got '((()(()))(())()))(())()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmped1yh_h6_test.go:53:\
    \ expected 'Yes', got '()()))((()()()((()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmped1yh_h6_test.go:53: expected 'Yes', got '((()))))((()())(()((()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmped1yh_h6_test.go:53:\
    \ expected 'No', got '(())(()))(()))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmped1yh_h6_test.go:53: expected 'Yes', got '((()()(()))())(()))())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmped1yh_h6_test.go:53:\
    \ expected 'No', got '((((()(((()))(((()))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmped1yh_h6_test.go:53: expected 'No', got '()(())((()()((()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmped1yh_h6_test.go:53:\
    \ expected 'No', got '()()()()()()'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmped1yh_h6_test.go:53: expected 'Yes', got '(()())())'\n \
    \   --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmped1yh_h6_test.go:53:\
    \ expected 'Yes', got '())(()(()'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073965
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else {\n            stack[i] = -1\n        }\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        if stack[i] < 0 {\n            result =\
    \ \"No\"\n            break\n        }\n        if lst[i] == \"(\" {\n       \
    \     stack[i]++\n        } else {\n            stack[i]--\n        }\n    }\n\
    \    if result == \"No\" {\n        result = \"Yes\"\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmp85gxgra9_test.go:70: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmp85gxgra9_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmp85gxgra9_test.go:70: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmp85gxgra9_test.go:70: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmp85gxgra9_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmp85gxgra9_test.go:70: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n    stack1 :=\
    \ make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n    stack1[0],\
    \ stack2[0] = lst[0], lst[0]\n    stack1[1], stack2[1] = lst[1], lst[1]\n    stack1[2],\
    \ stack2[2] = lst[2], lst[2]\n    stack1[3], stack2[3] = lst[3], lst[3]\n    stack1[4],\
    \ stack2[4] = lst[4], lst[4]\n    stack1[5], stack2[5] = lst[5], lst[5]\n    stack1[6],\
    \ stack2[6] = lst[6], lst[6]\n    stack1[7], stack2[7] = lst[7], lst[7]\n    stack1[8],\
    \ stack2[8] = lst[8], lst[8]\n    stack1[9], stack2[9] = lst[9], lst[9]\n    stack1[10],\
    \ stack2[10] = lst[10], lst[10]\n    stack1[11], stack2[11] = lst[11], lst[11]\n\
    \    stack1[12], stack2[12] = lst[12], lst[12]\n    stack1[13], stack2[13] = lst[13],\
    \ lst[13]\n    stack1[14], stack2[14] = lst[14], lst[14]\n    stack1[15], stack2[15]\
    \ = lst[15], lst[15]\n    stack1[16], stack2[16] = lst[16], lst[16]\n    stack1[17],\
    \ stack2[17] = lst[17], lst[17]\n    stack1[18], stack2[18] = lst[18], lst[18]\n\
    \    stack1[19], stack2[19] = lst[19], lst[19]\n    stack1[20], stack2[20] = lst[20],\
    \ lst[20]\n    stack1[21], stack2[21] = lst[21], lst[21]\n    stack1[22], stack2[22]\
    \ = lst[22], lst[22]\n    stack1[23], stack2[23] = lst[23], lst[23]\n    stack1[24],\
    \ stack2[24] = lst[24], lst[24]\n    stack1[25], stack2[25] = lst[25], lst[25]\n\
    \    stack1[26], stack2[26] = lst[26], lst[26]\n    stack1[27], stack2[27] = lst[27],\
    \ lst[27]\n    stack1[28], stack2[28] = lst[28], lst[28]\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzx0di34r_test.go:54:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073958
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"No\"\n    i\
    \ := 0\n    for _, s := range lst {\n        if s == '(' {\n            stack[i]\
    \ = s\n            i++\n        } else if s == ')' {\n            stack[i] = s\n\
    \            i++\n            if i == len(stack) {\n                result = \"\
    Yes\"\n                break\n            }\n        } else {\n            stack[i]\
    \ = s\n            i++\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt7e91dde_test.go:24:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpt7e91dde_test.go:27:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073965
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else if lst[i] == \")\" {\n            stack[i] = -1\n      \
    \  } else if stack[i] == 1 {\n            stack[i] = -1\n        } else {\n  \
    \          stack[i] = 0\n            result = \"Yes\"\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__2\
    \ (0.00s)\n        tmpla4c94us_test.go:61: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpla4c94us_test.go:61: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n      \
    \  tmpla4c94us_test.go:61: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpla4c94us_test.go:61: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpla4c94us_test.go:61: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmpla4c94us_test.go:61: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpla4c94us_test.go:61: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073965
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n    stack1 :=\
    \ make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n    stack1[0]\
    \ = lst[0]\n    stack2[0] = lst[0]\n    i := 1\n    for i < len(lst) {\n     \
    \   if lst[i] == \"(\" {\n            stack1[i] = lst[i]\n            stack2[i]\
    \ = lst[i]\n            i += 1\n        } else if lst[i] == \")\" {\n        \
    \    stack1[i] = lst[i]\n            stack2[i] = lst[i]\n            i += 1\n\
    \        } else {\n            stack1[i] = lst[i]\n            stack2[i] = lst[i]\n\
    \            i += 1\n        }\n    }\n    if stack1[0] != stack2[0] {\n     \
    \   return \"No\"\n    }\n    stack1Len := len(stack1)\n    stack2Len := len(stack2)\n\
    \    for i := 1; i < stack1Len; i++ {\n        if stack1[i] != stack2[i] {\n \
    \           return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiob865vo_test.go:47:5: stack2Len declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073965
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\
    \ else if lst[i] == \")\" {\n            if stack[i] {\n                stack[i]\
    \ = false\n            } else {\n                return \"No\"\n            }\n\
    \        }\n    }\n    if !stack[len(stack)-1] {\n        return \"Yes\"\n   \
    \ }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqxka3e3h_test.go:62: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpqxka3e3h_test.go:62: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpqxka3e3h_test.go:62: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpqxka3e3h_test.go:62: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpqxka3e3h_test.go:62: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpqxka3e3h_test.go:62: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpqxka3e3h_test.go:62: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpqxka3e3h_test.go:62: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073956
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"\"\n    for i\
    \ := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else if lst[i] == \")\" {\n            stack[i] = -1\n      \
    \  } else if stack[i] == 1 {\n            result += \"(\"\n        } else {\n\
    \            result += \"(\"\n        }\n    }\n    if result != \"\" {\n    \
    \    result = \"No\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp9ijksva2_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp9ijksva2_test.go:63: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmp9ijksva2_test.go:63:\
    \ expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n\
    \        tmp9ijksva2_test.go:63: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp9ijksva2_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp9ijksva2_test.go:63: expected\
    \ 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n       \
    \ tmp9ijksva2_test.go:63: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else if lst[i] == \")\" {\n            stack[i] = -1\n      \
    \  } else if stack[i] == 1 {\n            stack[i] = 0\n            if i == len(lst)-1\
    \ {\n                if stack[0] == 1 {\n                    result = \"Yes\"\n\
    \                }\n            }\n        }\n    }\n    return result\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp3o6qau9e_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp3o6qau9e_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp3o6qau9e_test.go:63: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp3o6qau9e_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp3o6qau9e_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp3o6qau9e_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack3 := make([]string, len(lst))\n    stack4 := make([]string,\
    \ len(lst))\n    stack5 := make([]string, len(lst))\n    stack6 := make([]string,\
    \ len(lst))\n    stack7 := make([]string, len(lst))\n    stack8 := make([]string,\
    \ len(lst))\n    stack9 := make([]string, len(lst))\n    stack10 := make([]string,\
    \ len(lst))\n    stack11 := make([]string, len(lst))\n    stack12 := make([]string,\
    \ len(lst))\n    stack13 := make([]string, len(lst))\n    stack14 := make([]string,\
    \ len(lst))\n    stack15 := make([]string, len(lst))\n    stack16 := make([]string,\
    \ len(lst))\n    stack17 := make([]string, len(lst))\n    stack18 := make([]string,\
    \ len(lst))\n    stack19 := make([]string, len(lst))\n    stack20 := make([]string,\
    \ len(lst))\n    stack21 := make([]string, len(lst))\n    stack22 := make([]string,\
    \ len(lst))\n    stack23 := make([]string, len(lst))\n    stack24 := make([]string,\
    \ len(lst))\n    stack25 := make([]string, len(lst))\n    stack26 := make([]string,\
    \ len(lst))\n    stack27 := make([]string, len(lst))\n    stack28 := make([]string,\
    \ len(lst))\n    stack29 := make([]string, len(lst))\n    stack30 := make([]string,\
    \ len(lst))\n    stack31 := make([]string, len(lst))\n    stack32 := make([]string,\
    \ len(lst))\n    stack33 := make([]string, len(lst))\n    stack34 := make([]string,\
    \ len(lst))\n    stack35 := make([]string, len(lst))\n    stack36 := make([]string,\
    \ len(lst))\n    stack37 := make([]string, len(lst))\n    stack38 := make([]string,\
    \ len(lst))\n    stack39 := make([]string, len(lst))\n    stack40 := make([]string,\
    \ len(lst))\n    stack41 := make([]string, len(lst))\n    stack42 := make([]string,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphkwn7ra5_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\n\
    \        if lst[i] == \")\" {\n            if stack[i] {\n                stack[i]\
    \ = false\n            } else {\n                return \"No\"\n            }\n\
    \        }\n    }\n    if !stack[len(stack)-1] {\n        return \"Yes\"\n   \
    \ }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmptxlz_0zz_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmptxlz_0zz_test.go:63: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmptxlz_0zz_test.go:63: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmptxlz_0zz_test.go:63: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmptxlz_0zz_test.go:63: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmptxlz_0zz_test.go:63: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmptxlz_0zz_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmptxlz_0zz_test.go:63: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else if lst[i] == \")\" {\n            stack[i] = -1\n      \
    \  } else if stack[i] == 1 {\n            stack[i] = -1\n        } else {\n  \
    \          stack[i] = 0\n        }\n    }\n    if stack[len(stack)-1] == 1 {\n\
    \        result = \"Yes\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpk5udpfgp_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpk5udpfgp_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpk5udpfgp_test.go:63: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpk5udpfgp_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpk5udpfgp_test.go:63: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n    stack1 :=\
    \ make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n    stack1[0],\
    \ stack2[0] = lst[0], lst[0]\n    stack1[1], stack2[1] = lst[1], lst[1]\n    for\
    \ i := 2; i < len(lst); i++ {\n        if stack1[i] == \")\" && stack2[i] == \"\
    (\" {\n            stack1[i] = \"(\"\n            stack2[i] = \")\"\n        \
    \    stack1[i-1], stack2[i-1] = stack1[i-1], stack2[i-1]\n        }\n    }\n \
    \   if stack1[0] == stack2[0] {\n        return \"Yes\"\n    }\n    return \"\
    No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpf9wdtmvr_test.go:64: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpf9wdtmvr_test.go:64: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpf9wdtmvr_test.go:64: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpf9wdtmvr_test.go:64: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpf9wdtmvr_test.go:64: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpf9wdtmvr_test.go:64: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    result := \"No\"\n    for _, s := range lst {\n        if result\
    \ == \"Yes\" {\n            break\n        }\n        result := \"Yes\"\n    \
    \    i := 0\n        for _, c := range s {\n            if c == '(' {\n      \
    \          i++\n            } else if c == ')' {\n                i--\n      \
    \      }\n            if i < 0 {\n                break\n            }\n     \
    \   }\n        if i == 0 {\n            result = \"No\"\n        }\n    }\n  \
    \  return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpynvqdxya_test.go:25:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool, len(lst))\n\
    \    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool, len(lst))\n\
    \    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool, len(lst))\n\
    \    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool, len(lst))\n\
    \    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool, len(lst))\n\
    \    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool, len(lst))\n\
    \    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool, len(lst))\n\
    \    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool, len(lst))\n\
    \    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool, len(lst))\n\
    \    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool, len(lst))\n\
    \    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool, len(lst))\n\
    \    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool, len(lst))\n\
    \    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool, len(lst))\n\
    \    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool, len(lst))\n\
    \    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool, len(lst))\n\
    \    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool, len(lst))\n\
    \    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool, len(lst))\n\
    \    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool, len(lst))\n\
    \    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool, len(lst))\n\
    \    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool, len(lst))\n\
    \    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47b29tef_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    var stack = []int{0}\n    for _, s := range\
    \ lst {\n        if s == '(' {\n            stack = append(stack, -1)\n      \
    \  } else {\n            stack = append(stack, len(stack)-1)\n        }\n    }\n\
    \    for len(stack) > 0 {\n        i := stack[len(stack)-1]\n        if i == -1\
    \ {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack\
    \ = stack[:len(stack)-1]\n            if lst[i] != '(' {\n                result\
    \ = \"No\"\n                break\n            }\n            stack[len(stack)-1]\
    \ = -1\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1phbi0ns_test.go:23:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmp1phbi0ns_test.go:35:26: invalid operation: lst[i] != ''('' (mismatched
    types string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else {\n            if stack[i] != 0 {\n                stack[i]--\n\
    \            } else {\n                result = \"Yes\"\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpucrom4g7_test.go:61: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpucrom4g7_test.go:61: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpucrom4g7_test.go:61: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpucrom4g7_test.go:61: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpucrom4g7_test.go:61: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpucrom4g7_test.go:61: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073967
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n    s := lst[0]\n\
    \    for _, v := range lst[1:] {\n        if v != s {\n            return \"No\"\
    \n        }\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpagqyh53k_test.go:56: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpagqyh53k_test.go:56: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpagqyh53k_test.go:56: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpagqyh53k_test.go:56: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpagqyh53k_test.go:56: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpagqyh53k_test.go:56: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpagqyh53k_test.go:56: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpagqyh53k_test.go:56: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073967
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    var stack = []int{0}\n    for _, s := range\
    \ lst {\n        if s == '(' {\n            stack = append(stack, -1)\n      \
    \  } else {\n            stack = append(stack, len(stack))\n        }\n    }\n\
    \    for len(stack) > 0 {\n        i := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n\
    \        if i == -1 {\n            result += \"(\"\n        } else {\n       \
    \     result += \"(\"\n            for _, s := range lst {\n                if\
    \ i == len(stack)-1 {\n                    result += s\n                } else\
    \ {\n                    result += s\n                    if stack[len(stack)-1]\
    \ == len(stack)-1 {\n                        result += \")\"\n               \
    \     }\n                }\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbcw0xu2p_test.go:23:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073966
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    result := \"No\"\n    for\
    \ _, s := range lst {\n        if s == '(' {\n            stack[len(stack)-1]\
    \ = true\n        } else {\n            if stack[len(stack)-1] == false {\n  \
    \              result = \"No\"\n                break\n            }\n       \
    \     stack[len(stack)-1] = false\n        }\n    }\n    return result\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1j9xlr77_test.go:23:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073967
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\
    \ else if lst[i] == \")\" {\n            if stack[i] {\n                return\
    \ \"No\"\n            }\n            stack[i] = false\n        }\n    }\n    return\
    \ \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmps2np79uy_test.go:58: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmps2np79uy_test.go:58: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmps2np79uy_test.go:58: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmps2np79uy_test.go:58: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmps2np79uy_test.go:58: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmps2np79uy_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073967
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := range lst {\n  \
    \      stack[i] = false\n    }\n    result := \"\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    \nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc6ptusk7_test.go:122:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else {\n            stack[i] = -1\n        }\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        if stack[i] < 0 {\n            result =\
    \ \"Yes\"\n            break\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmp242myo40_test.go:62: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmp242myo40_test.go:62: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmp242myo40_test.go:62: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmp242myo40_test.go:62: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmp242myo40_test.go:62: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmp242myo40_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073967
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    result += \"(\"\n    for _, v := range\
    \ lst {\n        if v == \"(\" {\n            result += \")\"\n        } else\
    \ {\n            result += \"(\"\n        }\n    }\n    result += \")\"\n    return\
    \ result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpdzjp2zad_test.go:57: expected 'Yes', got '((()'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpdzjp2zad_test.go:57:\
    \ expected 'No', got '((()'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpdzjp2zad_test.go:57: expected 'No', got '((()'\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpdzjp2zad_test.go:57: expected 'Yes', got '((()'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__4 (0.00s)\n        tmpdzjp2zad_test.go:57:\
    \ expected 'Yes', got '((()'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n\
    \        tmpdzjp2zad_test.go:57: expected 'No', got '((()'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpdzjp2zad_test.go:57: expected 'Yes', got '((()'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmpdzjp2zad_test.go:57:\
    \ expected 'No', got '((()'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpdzjp2zad_test.go:57: expected 'No', got '((()'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpdzjp2zad_test.go:57: expected 'No', got '((()'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpdzjp2zad_test.go:57:\
    \ expected 'Yes', got '()()'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpdzjp2zad_test.go:57: expected 'Yes', got '(())'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073967
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n    if len(lst)\
    \ == 1 {\n        return lst[0]\n    }\n    stack1 := make([]string, len(lst))\n\
    \    stack2 := make([]string, len(lst))\n    stack3 := make([]string, len(lst))\n\
    \    stack4 := make([]string, len(lst))\n    stack5 := make([]string, len(lst))\n\
    \    stack6 := make([]string, len(lst))\n    stack7 := make([]string, len(lst))\n\
    \    stack8 := make([]string, len(lst))\n    stack9 := make([]string, len(lst))\n\
    \    stack10 := make([]string, len(lst))\n    stack11 := make([]string, len(lst))\n\
    \    stack12 := make([]string, len(lst))\n    stack13 := make([]string, len(lst))\n\
    \    stack14 := make([]string, len(lst))\n    stack15 := make([]string, len(lst))\n\
    \    stack16 := make([]string, len(lst))\n    stack17 := make([]string, len(lst))\n\
    \    stack18 := make([]string, len(lst))\n    stack19 := make([]string, len(lst))\n\
    \    stack20 := make([]string, len(lst))\n    stack21 := make([]string, len(lst))\n\
    \    stack22 := make([]string, len(lst))\n    stack23 := make([]string, len(lst))\n\
    \    stack24 := make([]string, len(lst))\n    stack25 := make([]string, len(lst))\n\
    \    stack26 := make([]string, len(lst))\n    stack27 := make([]string, len(lst))\n\
    \    stack28 := make([]string, len(lst))\n    stack29 := make([]string, len(lst))\n\
    \    stack30 := make([]string, len(lst))\n    stack31 := make([]string, len(lst))\n\
    \    stack32 := make([]string, len(lst))\n    stack33 := make([]string, len(lst))\n\
    \    stack34 := make([]string, len(lst))\n    stack35 := make([]string, len(lst))\n\
    \    stack36 := make([]string, len(lst))\n    stack37 := make([]string, len(lst))\n\
    \    stack38 := make([]string, len(lst))\n    stack39 := make([]string, len(lst))\n\
    \    stack40 := make([]string, len(lst))\n    stack41 := make(\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgpo9vnid_test.go:67:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073966
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"No\"\n    i\
    \ := 0\n    for _, s := range lst {\n        if s == '(' {\n            stack[i]\
    \ = s\n            i++\n        } else if s == ')' {\n            if len(stack)\
    \ == 0 {\n                result = \"Yes\"\n                break\n          \
    \  }\n            i -= 1\n            stack[i] = s\n        } else {\n       \
    \     fmt.Printf(\"%v\", stack)\n            result = \"No\"\n            break\n\
    \        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppeyh8dli_test.go:24:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmppeyh8dli_test.go:27:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073967
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool, len(lst))\n\
    \    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool, len(lst))\n\
    \    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool, len(lst))\n\
    \    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool, len(lst))\n\
    \    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool, len(lst))\n\
    \    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool, len(lst))\n\
    \    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool, len(lst))\n\
    \    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool, len(lst))\n\
    \    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool, len(lst))\n\
    \    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool, len(lst))\n\
    \    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool, len(lst))\n\
    \    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool, len(lst))\n\
    \    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool, len(lst))\n\
    \    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool, len(lst))\n\
    \    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool, len(lst))\n\
    \    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool, len(lst))\n\
    \    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool, len(lst))\n\
    \    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool, len(lst))\n\
    \    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool, len(lst))\n\
    \    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool, len(lst))\n\
    \    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47b29tef_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    result := \"No\"\n    stack1 := make([]string, len(lst))\n   \
    \ stack2 := make([]string, len(lst))\n    for i := 0; i < len(lst); i++ {\n  \
    \      if lst[i] == \"(\" {\n            stack1[i] = lst[i]\n        } else if\
    \ lst[i] == \")\" {\n            stack2[i] = lst[i]\n        }\n    }\n    if\
    \ len(stack1) > len(stack2) {\n        stack1 = stack1[:len(stack2)]\n    }\n\
    \    if len(stack2) > len(stack1) {\n        stack2 = stack2[:len(stack1)]\n \
    \   }\n    for i := 0; i < len(stack1); i++ {\n        if stack1[i] == \"(\" &&\
    \ stack2[i] == \"(\" {\n            stack1[i] = stack2[i]\n        } else if stack1[i]\
    \ == \")\" && stack2[i] == \")\" {\n            stack1[i] = stack2[i]\n      \
    \  }\n    }\n    if len(stack1) == 0 {\n        result = \"Yes\"\n    }\n    return\
    \ result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpipdxigog_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpipdxigog_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpipdxigog_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpipdxigog_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpipdxigog_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpipdxigog_test.go:73: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073967
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = \"(\"\n        }\
    \ else if lst[i] == \")\" {\n            stack[i] = \")\"\n        } else {\n\
    \            return fmt.Sprintf(\"No\")\n        }\n    }\n    return fmt.Sprintf(\"\
    Yes\")\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpfqyfpqkc_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpfqyfpqkc_test.go:57: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpfqyfpqkc_test.go:57: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpfqyfpqkc_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpfqyfpqkc_test.go:57: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    stack := make([]string, len(lst))\n   \
    \ for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = lst[i]\n        } else if lst[i] == \")\" {\n            stack = stack[:len(stack)-1]\n\
    \            if stack[len(stack)-1] != \"\" {\n                result += \"(\"\
    \ + stack[len(stack)-1] + \")\"\n            }\n        } else {\n           \
    \ stack = stack[:len(stack)-1]\n            result += \"(\" + stack[len(stack)-1]\
    \ + lst[i] + \")\"\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens({0xc0000f5ca0, 0x2, 0x2?})\n\
    \t/tmp/tmpiwhaml2n_test.go:27 +0x225\ncommand-line-arguments_test.TestMatch_Parens(0x0?)\n\
    \t/tmp/tmpiwhaml2n_test.go:45 +0x99\ntesting.tRunner(0xc0001a0340, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073967
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\
    \ else if lst[i] == \")\" {\n            if stack[i] {\n                stack[i]\
    \ = false\n            } else {\n                return \"No\"\n            }\n\
    \        }\n    }\n    if !stack[len(stack)-1] {\n        return \"Yes\"\n   \
    \ }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqxka3e3h_test.go:62: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpqxka3e3h_test.go:62: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpqxka3e3h_test.go:62: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpqxka3e3h_test.go:62: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpqxka3e3h_test.go:62: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpqxka3e3h_test.go:62: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpqxka3e3h_test.go:62: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpqxka3e3h_test.go:62: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073956
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if stack[i] == true {\n            stack[i]\
    \ = false\n            result += \"Yes\"\n        } else {\n            stack[i]\
    \ = true\n            result += \"No\"\n        }\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpk1_lj77e_test.go:58: expected 'Yes', got 'NoNoNo'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpk1_lj77e_test.go:58:\
    \ expected 'No', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpk1_lj77e_test.go:58: expected 'No', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpk1_lj77e_test.go:58: expected 'Yes', got 'NoNoNo'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__4 (0.00s)\n        tmpk1_lj77e_test.go:58:\
    \ expected 'Yes', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n\
    \        tmpk1_lj77e_test.go:58: expected 'No', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpk1_lj77e_test.go:58: expected 'Yes', got 'NoNoNo'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmpk1_lj77e_test.go:58:\
    \ expected 'No', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpk1_lj77e_test.go:58: expected 'No', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpk1_lj77e_test.go:58: expected 'No', got 'NoNoNo'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpk1_lj77e_test.go:58:\
    \ expected 'Yes', got 'NoNoNo'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpk1_lj77e_test.go:58: expected 'Yes', got 'NoNoNo'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\n\
    \        if lst[i] == \")\" {\n            stack[i] = false\n        }\n    }\n\
    \    if stack[0] && stack[1] {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp24bdesky_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp24bdesky_test.go:59: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp24bdesky_test.go:59: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp24bdesky_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp24bdesky_test.go:59: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp24bdesky_test.go:59: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073962
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else {\n            stack[i] = -1\n        }\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        if stack[i] < 0 {\n            result =\
    \ \"No\"\n            break\n        }\n        if lst[i] == \"(\" {\n       \
    \     stack[i]++\n        } else {\n            stack[i]--\n        }\n    }\n\
    \    if result == \"Yes\" {\n        result = \"Yes\"\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpseljnojp_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpseljnojp_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpseljnojp_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpseljnojp_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpseljnojp_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpseljnojp_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else if lst[i] == \")\" {\n            stack[i] = -1\n      \
    \  } else if stack[i] == 1 {\n            stack[i] = -1\n        } else {\n  \
    \          stack[i] = 0\n        }\n    }\n    if stack[len(stack)-1] == 1 {\n\
    \        result = \"Yes\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpk5udpfgp_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpk5udpfgp_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpk5udpfgp_test.go:63: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpk5udpfgp_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpk5udpfgp_test.go:63: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\
    \ else {\n            if stack[i] {\n                return \"No\"\n         \
    \   }\n            stack[i] = false\n        }\n    }\n    return \"Yes\"\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmprgpixdsl_test.go:58: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmprgpixdsl_test.go:58: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmprgpixdsl_test.go:58: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmprgpixdsl_test.go:58: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmprgpixdsl_test.go:58: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmprgpixdsl_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = true\n        }\n        if lst[i] == \")\" {\n            stack[i] = false\n\
    \        }\n    }\n    if stack[0] {\n        result = \"Yes\"\n    }\n    return\
    \ result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmprx69nsvd_test.go:60: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmprx69nsvd_test.go:60: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmprx69nsvd_test.go:60: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmprx69nsvd_test.go:60: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmprx69nsvd_test.go:60: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = lst[i]\n        } else if lst[i] == \")\" {\n            if len(stack) ==\
    \ 0 {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack = stack[:len(stack)-1]\n            if stack[len(stack)-1]\
    \ == \"(\" {\n                stack[len(stack)-1] = lst[i]\n            } else\
    \ {\n                result = \"No\"\n                break\n            }\n \
    \       } else {\n            result = \"No\"\n            break\n        }\n\
    \    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpbh3w5viy_test.go:69: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpbh3w5viy_test.go:69: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpbh3w5viy_test.go:69: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpbh3w5viy_test.go:69: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpbh3w5viy_test.go:69: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpbh3w5viy_test.go:69: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack3 := make([]string, len(lst))\n    stack4 := make([]string,\
    \ len(lst))\n    stack5 := make([]string, len(lst))\n    stack6 := make([]string,\
    \ len(lst))\n    stack7 := make([]string, len(lst))\n    stack8 := make([]string,\
    \ len(lst))\n    stack9 := make([]string, len(lst))\n    stack10 := make([]string,\
    \ len(lst))\n    stack11 := make([]string, len(lst))\n    stack12 := make([]string,\
    \ len(lst))\n    stack13 := make([]string, len(lst))\n    stack14 := make([]string,\
    \ len(lst))\n    stack15 := make([]string, len(lst))\n    stack16 := make([]string,\
    \ len(lst))\n    stack17 := make([]string, len(lst))\n    stack18 := make([]string,\
    \ len(lst))\n    stack19 := make([]string, len(lst))\n    stack20 := make([]string,\
    \ len(lst))\n    stack21 := make([]string, len(lst))\n    stack22 := make([]string,\
    \ len(lst))\n    stack23 := make([]string, len(lst))\n    stack24 := make([]string,\
    \ len(lst))\n    stack25 := make([]string, len(lst))\n    stack26 := make([]string,\
    \ len(lst))\n    stack27 := make([]string, len(lst))\n    stack28 := make([]string,\
    \ len(lst))\n    stack29 := make([]string, len(lst))\n    stack30 := make([]string,\
    \ len(lst))\n    stack31 := make([]string, len(lst))\n    stack32 := make([]string,\
    \ len(lst))\n    stack33 := make([]string, len(lst))\n    stack34 := make([]string,\
    \ len(lst))\n    stack35 := make([]string, len(lst))\n    stack36 := make([]string,\
    \ len(lst))\n    stack37 := make([]string, len(lst))\n    stack38 := make([]string,\
    \ len(lst))\n    stack39 := make([]string, len(lst))\n    stack40 := make([]string,\
    \ len(lst))\n    stack41 := make([]string, len(lst))\n    stack42 := make([]string,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphkwn7ra5_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool, len(lst))\n\
    \    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool, len(lst))\n\
    \    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool, len(lst))\n\
    \    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool, len(lst))\n\
    \    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool, len(lst))\n\
    \    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool, len(lst))\n\
    \    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool, len(lst))\n\
    \    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool, len(lst))\n\
    \    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool, len(lst))\n\
    \    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool, len(lst))\n\
    \    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool, len(lst))\n\
    \    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool, len(lst))\n\
    \    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool, len(lst))\n\
    \    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool, len(lst))\n\
    \    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool, len(lst))\n\
    \    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool, len(lst))\n\
    \    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool, len(lst))\n\
    \    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool, len(lst))\n\
    \    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool, len(lst))\n\
    \    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool, len(lst))\n\
    \    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47b29tef_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: null
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        stack[i] = i\n    }\n    result := \"\"\n    i := 0\n    for\
    \ i < len(lst) {\n        if lst[i] == \"(\" {\n            i++\n            if\
    \ i == len(lst) {\n                return \"No\"\n            }\n            if\
    \ stack[i] == -1 {\n                stack[i] = i\n                result += \"\
    (\"\n            } else {\n                stack[i] = -1\n                result\
    \ += \"(\"\n            }\n        } else if lst[i] == \")\" {\n            i++\n\
    \            if i == len(lst) {\n                return \"No\"\n            }\n\
    \            if stack[i] == i {\n                stack[i] = -1\n             \
    \   result += \")\"\n            } else {\n                stack[i] = i\n    \
    \            result += \")\"\n            }\n        } else {\n            result\
    \ += lst[i]\n        }\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660073981
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n         \
    \   stack1[i] = true\n        } else {\n            stack1[i] = false\n      \
    \  }\n        if lst[i] == \")\" {\n            stack2[i] = true\n        } else\
    \ {\n            stack2[i] = false\n        }\n    }\n    result := \"No\"\n \
    \   for i := 0; i < len(lst); i++ {\n        if stack1[i] != stack2[i] {\n   \
    \         result = \"Yes\"\n            break\n        }\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmp0z_1xvr0_test.go:68: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp0z_1xvr0_test.go:68: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp0z_1xvr0_test.go:68: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp0z_1xvr0_test.go:68: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\n\
    \        if lst[i] == \")\" {\n            stack[i] = false\n        }\n    }\n\
    \    if stack[0] {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpcb9b67ic_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpcb9b67ic_test.go:59: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpcb9b67ic_test.go:59: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpcb9b67ic_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpcb9b67ic_test.go:59: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        stack[i] = lst[i]\n    }\n    result := \"No\"\n    for i :=\
    \ len(stack) - 1; i >= 0; i-- {\n        switch stack[i] {\n        case \"(\"\
    :\n            stack[i] = \")\"\n        case \"[\":\n            stack[i] = \"\
    ]\"\n        case \"{\":\n            stack[i] = \"}\"\n        default:\n   \
    \         stack[i] = \"\"\n        }\n        if stack[i] != \"\" {\n        \
    \    result = \"Yes\"\n            break\n        }\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpu0116dtj_test.go:68: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpu0116dtj_test.go:68: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpu0116dtj_test.go:68: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpu0116dtj_test.go:68: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    var stack = []int{0}\n    for _, s := range\
    \ lst {\n        if s == '(' {\n            stack = append(stack, -1)\n      \
    \  } else {\n            stack = append(stack, len(lst))\n        }\n    }\n \
    \   for i := len(stack) - 1; i >= 0; i-- {\n        j := stack[i]\n        if\
    \ j == -1 {\n            continue\n        }\n        result += \"(\"\n      \
    \  for k := j + 1; k < len(lst); k++ {\n            result += lst[k]\n       \
    \ }\n        result += \")\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7oe0anmd_test.go:23:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073968
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\n\
    \        if lst[i] == \")\" {\n            stack[i] = false\n        }\n    }\n\
    \    return matchParens(stack, len(lst))\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptz5fiyjz_test.go:29:12: undefined: matchParens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = 1\n        } else\
    \ if lst[i] == \")\" {\n            stack[i] = -1\n        } else {\n        \
    \    return \"\"\n        }\n    }\n    result := \"\"\n    for i := 0; i < len(lst);\
    \ i++ {\n        if stack[i] != 0 {\n            return \"\"\n        }\n    \
    \    if lst[i] == \"(\" {\n            stack[i]++\n        } else if lst[i] ==\
    \ \")\" {\n            stack[i]--\n        }\n    }\n    if stack[len(stack)-1]\
    \ == 0 {\n        result = \"Yes\"\n    } else {\n        result = \"No\"\n  \
    \  }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpc7qm_8hw_test.go:73: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpc7qm_8hw_test.go:73: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpc7qm_8hw_test.go:73:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpc7qm_8hw_test.go:73: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpc7qm_8hw_test.go:73: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpc7qm_8hw_test.go:73: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpc7qm_8hw_test.go:73:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpc7qm_8hw_test.go:73: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpc7qm_8hw_test.go:73: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpc7qm_8hw_test.go:73: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpc7qm_8hw_test.go:73:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpc7qm_8hw_test.go:73: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\n\
    \        if lst[i] == \")\" {\n            if stack[i] {\n                stack[i]\
    \ = false\n            } else {\n                return \"No\"\n            }\n\
    \        }\n    }\n    if !stack[len(stack)-1] {\n        return \"Yes\"\n   \
    \ }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmptxlz_0zz_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmptxlz_0zz_test.go:63: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmptxlz_0zz_test.go:63: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmptxlz_0zz_test.go:63: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmptxlz_0zz_test.go:63: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmptxlz_0zz_test.go:63: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmptxlz_0zz_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmptxlz_0zz_test.go:63: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    for _, s := range lst {\n        result\
    \ += \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n        result +=\
    \ \"(\" + s + \")\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'Yes', got '(()()())(()()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'No', got '())())())())'\n    --- FAIL: TestMatch_Parens/test_num__2\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'No', got '((()(()))(())()))((()(()))(())()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'Yes', got '()()))((()()()()()))((()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'Yes', got '((()))))((()())(()((()))))((()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'No', got '(())(()))(())(()))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'Yes', got '((()()(()))())((()()(()))())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'No', got '((((()(((()))((((()(((()))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'No', got '()(())((()()()(())((()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'No', got '()()()()()()()()'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'Yes', got '(()())(()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'Yes', got '())(()())(()'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073960
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = \"(\"\n        } else if lst[i] == \")\" {\n            stack[i] = \")\"\n\
    \        } else {\n            stack[i] = lst[i]\n        }\n    }\n    for i\
    \ := 0; i < len(stack); i++ {\n        if stack[i] == \"(\" {\n            result\
    \ += \")\"\n        } else if stack[i] == \")\" {\n            result += \"(\"\
    \n        } else {\n            result += stack[i]\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpt157gnir_test.go:67: expected 'Yes', got 'No()(('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpt157gnir_test.go:67:\
    \ expected 'No', got 'No(('\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpt157gnir_test.go:67: expected 'No', got 'No(()(())())())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpt157gnir_test.go:67:\
    \ expected 'Yes', got 'No)())(()()('\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpt157gnir_test.go:67: expected 'Yes', got 'No(())))(()())(('\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpt157gnir_test.go:67:\
    \ expected 'No', got 'No()())'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmpt157gnir_test.go:67: expected 'Yes', got 'No(()(()))()'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpt157gnir_test.go:67: expected\
    \ 'No', got 'No((((((())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpt157gnir_test.go:67: expected 'No', got 'No)(()(()('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpt157gnir_test.go:67: expected\
    \ 'No', got 'No)()('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n  \
    \      tmpt157gnir_test.go:67: expected 'Yes', got 'No)('\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpt157gnir_test.go:67: expected 'Yes', got 'No()'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073969
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool, len(lst))\n\
    \    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool, len(lst))\n\
    \    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool, len(lst))\n\
    \    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool, len(lst))\n\
    \    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool, len(lst))\n\
    \    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool, len(lst))\n\
    \    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool, len(lst))\n\
    \    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool, len(lst))\n\
    \    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool, len(lst))\n\
    \    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool, len(lst))\n\
    \    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool, len(lst))\n\
    \    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool, len(lst))\n\
    \    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool, len(lst))\n\
    \    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool, len(lst))\n\
    \    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool, len(lst))\n\
    \    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool, len(lst))\n\
    \    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool, len(lst))\n\
    \    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool, len(lst))\n\
    \    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool, len(lst))\n\
    \    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool, len(lst))\n\
    \    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47b29tef_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack3 := make([]string, len(lst))\n    stack4 := make([]string,\
    \ len(lst))\n    stack5 := make([]string, len(lst))\n    stack6 := make([]string,\
    \ len(lst))\n    stack7 := make([]string, len(lst))\n    stack8 := make([]string,\
    \ len(lst))\n    stack9 := make([]string, len(lst))\n    stack10 := make([]string,\
    \ len(lst))\n    stack11 := make([]string, len(lst))\n    stack12 := make([]string,\
    \ len(lst))\n    stack13 := make([]string, len(lst))\n    stack14 := make([]string,\
    \ len(lst))\n    stack15 := make([]string, len(lst))\n    stack16 := make([]string,\
    \ len(lst))\n    stack17 := make([]string, len(lst))\n    stack18 := make([]string,\
    \ len(lst))\n    stack19 := make([]string, len(lst))\n    stack20 := make([]string,\
    \ len(lst))\n    stack21 := make([]string, len(lst))\n    stack22 := make([]string,\
    \ len(lst))\n    stack23 := make([]string, len(lst))\n    stack24 := make([]string,\
    \ len(lst))\n    stack25 := make([]string, len(lst))\n    stack26 := make([]string,\
    \ len(lst))\n    stack27 := make([]string, len(lst))\n    stack28 := make([]string,\
    \ len(lst))\n    stack29 := make([]string, len(lst))\n    stack30 := make([]string,\
    \ len(lst))\n    stack31 := make([]string, len(lst))\n    stack32 := make([]string,\
    \ len(lst))\n    stack33 := make([]string, len(lst))\n    stack34 := make([]string,\
    \ len(lst))\n    stack35 := make([]string, len(lst))\n    stack36 := make([]string,\
    \ len(lst))\n    stack37 := make([]string, len(lst))\n    stack38 := make([]string,\
    \ len(lst))\n    stack39 := make([]string, len(lst))\n    stack40 := make([]string,\
    \ len(lst))\n    stack41 := make([]string, len(lst))\n    stack42 := make([]string,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphkwn7ra5_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = \"(\"\n        }\
    \ else {\n            if stack[len(stack)-1] == \"(\" {\n                stack[len(stack)-1]\
    \ += \")\"\n            } else {\n                return \"No\"\n            }\n\
    \        }\n    }\n    return stack[len(stack)-1]\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpp9czqeh7_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpp9czqeh7_test.go:59: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpp9czqeh7_test.go:59: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpp9czqeh7_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpp9czqeh7_test.go:59: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpp9czqeh7_test.go:59: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073969
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack3 := make([]string, len(lst))\n    stack4 := make([]string,\
    \ len(lst))\n    stack5 := make([]string, len(lst))\n    stack6 := make([]string,\
    \ len(lst))\n    stack7 := make([]string, len(lst))\n    stack8 := make([]string,\
    \ len(lst))\n    stack9 := make([]string, len(lst))\n    stack10 := make([]string,\
    \ len(lst))\n    stack11 := make([]string, len(lst))\n    stack12 := make([]string,\
    \ len(lst))\n    stack13 := make([]string, len(lst))\n    stack14 := make([]string,\
    \ len(lst))\n    stack15 := make([]string, len(lst))\n    stack16 := make([]string,\
    \ len(lst))\n    stack17 := make([]string, len(lst))\n    stack18 := make([]string,\
    \ len(lst))\n    stack19 := make([]string, len(lst))\n    stack20 := make([]string,\
    \ len(lst))\n    stack21 := make([]string, len(lst))\n    stack22 := make([]string,\
    \ len(lst))\n    stack23 := make([]string, len(lst))\n    stack24 := make([]string,\
    \ len(lst))\n    stack25 := make([]string, len(lst))\n    stack26 := make([]string,\
    \ len(lst))\n    stack27 := make([]string, len(lst))\n    stack28 := make([]string,\
    \ len(lst))\n    stack29 := make([]string, len(lst))\n    stack30 := make([]string,\
    \ len(lst))\n    stack31 := make([]string, len(lst))\n    stack32 := make([]string,\
    \ len(lst))\n    stack33 := make([]string, len(lst))\n    stack34 := make([]string,\
    \ len(lst))\n    stack35 := make([]string, len(lst))\n    stack36 := make([]string,\
    \ len(lst))\n    stack37 := make([]string, len(lst))\n    stack38 := make([]string,\
    \ len(lst))\n    stack39 := make([]string, len(lst))\n    stack40 := make([]string,\
    \ len(lst))\n    stack41 := make([]string, len(lst))\n    stack42 := make([]string,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphkwn7ra5_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    for _, s := range lst {\n        result\
    \ += \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n        result +=\
    \ \"(\" + s + \")\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'Yes', got '(()()())(()()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'No', got '())())())())'\n    --- FAIL: TestMatch_Parens/test_num__2\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'No', got '((()(()))(())()))((()(()))(())()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'Yes', got '()()))((()()()()()))((()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'Yes', got '((()))))((()())(()((()))))((()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'No', got '(())(()))(())(()))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'Yes', got '((()()(()))())((()()(()))())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'No', got '((((()(((()))((((()(((()))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'No', got '()(())((()()()(())((()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'No', got '()()()()()()()()'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmppm_2snmv_test.go:54: expected 'Yes', got '(()())(()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmppm_2snmv_test.go:54:\
    \ expected 'Yes', got '())(()())(()'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073960
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    for _, s := range lst {\n        if result\
    \ != \"\" {\n            result = result + \")\"\n        }\n        result =\
    \ result + s\n    }\n    if result != \"\" {\n        result = result + \"(\"\n\
    \    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpzqnojl28_test.go:57: expected 'Yes', got '()())('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpzqnojl28_test.go:57:\
    \ expected 'No', got ')))('\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpzqnojl28_test.go:57: expected 'No', got '(()(()))())())('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpzqnojl28_test.go:57:\
    \ expected 'Yes', got ')()))(()()(('\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpzqnojl28_test.go:57: expected 'Yes', got '(()))))(()())((('\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpzqnojl28_test.go:57:\
    \ expected 'No', got '())())('\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmpzqnojl28_test.go:57: expected 'Yes', got '(()()()))()('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpzqnojl28_test.go:57: expected\
    \ 'No', got '(((()((())('\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpzqnojl28_test.go:57: expected 'No', got ')(())(()(('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpzqnojl28_test.go:57: expected\
    \ 'No', got ')())(('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n  \
    \      tmpzqnojl28_test.go:57: expected 'Yes', got '())('\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpzqnojl28_test.go:57: expected 'Yes', got '))(('\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073960
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]string, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = \"(\"\n        } else if lst[i] == \")\" {\n            stack[i] = \")\"\n\
    \            if stack[len(stack)-1] == \"(\" {\n                stack[len(stack)-1]\
    \ = \")\"\n            } else {\n                result = \"Yes\"\n          \
    \  }\n        } else {\n            result = \"No\"\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmprtuxokc9_test.go:63: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmprtuxokc9_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmprtuxokc9_test.go:63: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmprtuxokc9_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073969
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = true\n        } else if lst[i] == \")\" {\n            stack[i] = false\n\
    \        } else if stack[i] {\n            result := \"No\"\n            break\n\
    \        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9mg47v6e_test.go:28:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073969
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack3 := make([]string, len(lst))\n    stack4 := make([]string,\
    \ len(lst))\n    stack5 := make([]string, len(lst))\n    stack6 := make([]string,\
    \ len(lst))\n    stack7 := make([]string, len(lst))\n    stack8 := make([]string,\
    \ len(lst))\n    stack9 := make([]string, len(lst))\n    stack10 := make([]string,\
    \ len(lst))\n    stack11 := make([]string, len(lst))\n    stack12 := make([]string,\
    \ len(lst))\n    stack13 := make([]string, len(lst))\n    stack14 := make([]string,\
    \ len(lst))\n    stack15 := make([]string, len(lst))\n    stack16 := make([]string,\
    \ len(lst))\n    stack17 := make([]string, len(lst))\n    stack18 := make([]string,\
    \ len(lst))\n    stack19 := make([]string, len(lst))\n    stack20 := make([]string,\
    \ len(lst))\n    stack21 := make([]string, len(lst))\n    stack22 := make([]string,\
    \ len(lst))\n    stack23 := make([]string, len(lst))\n    stack24 := make([]string,\
    \ len(lst))\n    stack25 := make([]string, len(lst))\n    stack26 := make([]string,\
    \ len(lst))\n    stack27 := make([]string, len(lst))\n    stack28 := make([]string,\
    \ len(lst))\n    stack29 := make([]string, len(lst))\n    stack30 := make([]string,\
    \ len(lst))\n    stack31 := make([]string, len(lst))\n    stack32 := make([]string,\
    \ len(lst))\n    stack33 := make([]string, len(lst))\n    stack34 := make([]string,\
    \ len(lst))\n    stack35 := make([]string, len(lst))\n    stack36 := make([]string,\
    \ len(lst))\n    stack37 := make([]string, len(lst))\n    stack38 := make([]string,\
    \ len(lst))\n    stack39 := make([]string, len(lst))\n    stack40 := make([]string,\
    \ len(lst))\n    stack41 := make([]string, len(lst))\n    stack42 := make([]string,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphkwn7ra5_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\
    \ else if lst[i] == \")\" {\n            stack[i] = false\n        } else if stack[i]\
    \ == false {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp42yepl90_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp42yepl90_test.go:57: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmp42yepl90_test.go:57: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp42yepl90_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmp42yepl90_test.go:57: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073969
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n    stack1 :=\
    \ make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n    stack1[0]\
    \ = lst[0]\n    stack2[0] = lst[0]\n    i := 1\n    for _, s := range lst[1:]\
    \ {\n        if stack1[i-1] == '(' && s == '(' {\n            stack1[i] = s\n\
    \            stack2[i] = s\n            i++\n        } else if stack1[i-1] ==\
    \ ')' && s == ')' {\n            stack1[i] = s\n            stack2[i] = s\n  \
    \          i++\n        } else if stack1[i-1] == '(' && s == ')' {\n         \
    \   stack1[i] = s\n            stack2[i] = s\n            i++\n        } else\
    \ if stack1[i-1] == ')' && s != '(' {\n            stack1[i] = s\n           \
    \ stack2[i] = s\n            i++\n        } else {\n            stack1[i] = s\n\
    \            stack2[i] = s\n            i++\n        }\n    }\n    if stack1[i-1]\
    \ == '(' && stack2[i-1] == ')' {\n        return fmt.Sprintf(\"Yes\")\n    } else\
    \ {\n        return fmt.Sprintf(\"No\")\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5in24bo6_test.go:29:27: invalid operation: stack1[i - 1] == ''('' (mismatched
    types string and untyped rune)

    /tmp/tmp5in24bo6_test.go:29:39: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmp5in24bo6_test.go:33:34: invalid operation: stack1[i - 1] == '')'' (mismatched
    types string and untyped rune)

    /tmp/tmp5in24bo6_test.go:33:46: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    /tmp/tmp5in24bo6_test.go:37:34: invalid operation: stack1[i - 1] == ''('' (mismatched
    types string and untyped rune)

    /tmp/tmp5in24bo6_test.go:37:46: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    /tmp/tmp5in24bo6_test.go:41:34: invalid operation: stack1[i - 1] == '')'' (mismatched
    types string and untyped rune)

    /tmp/tmp5in24bo6_test.go:41:46: invalid operation: s != ''('' (mismatched types
    string and untyped rune)

    /tmp/tmp5in24bo6_test.go:51:23: invalid operation: stack1[i - 1] == ''('' (mismatched
    types string and untyped rune)

    /tmp/tmp5in24bo6_test.go:51:45: invalid operation: stack2[i - 1] == '')'' (mismatched
    types string and untyped rune)

    /tmp/tmp5in24bo6_test.go:51:45: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073969
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"\"\n    i := 0\n\
    \    for _, s := range lst {\n        if s == '(' {\n            stack[i] = 1\n\
    \        } else if s == ')' {\n            stack[i] = 0\n        } else if stack[i]\
    \ != 0 {\n            return result\n        }\n        i++\n    }\n    if i ==\
    \ len(lst) {\n        return result\n    }\n    return \"\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm13jq3dt_test.go:24:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpm13jq3dt_test.go:26:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073969
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    for _, s := range lst {\n        result\
    \ += \"(\" + s + \")\"\n    }\n    result += \"()\"\n    return result == \"()()\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvbgg5h8x_test.go:25:12: cannot use result == "()()" (untyped bool value)
    as string value in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073969
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    result := \"No\"\n    for\
    \ _, s := range lst {\n        if s == \"(\" {\n            stack[len(stack)-1]\
    \ = true\n        } else if s == \")\" {\n            stack[len(stack)-1] = false\n\
    \        } else {\n            stack = append(stack, false)\n        }\n    }\n\
    \    if stack[len(stack)-1] == true {\n        result = \"Yes\"\n    }\n    return\
    \ result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpd6x8lj1p_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpd6x8lj1p_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpd6x8lj1p_test.go:61: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpd6x8lj1p_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpd6x8lj1p_test.go:61: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073969
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    var stack = []int{0}\n    for _, s := range\
    \ lst {\n        if s == '(' {\n            stack = append(stack, -1)\n      \
    \  } else {\n            stack = append(stack, len(stack)-1)\n        }\n    }\n\
    \    for len(stack) > 0 {\n        i := stack[len(stack)-1]\n        if i == -1\
    \ {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack\
    \ = stack[:len(stack)-1]\n            result += \"(\"\n        }\n        if i\
    \ == len(lst)-1 {\n            result += \")\"\n        } else {\n           \
    \ result += lst[i]\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptoeee2up_test.go:23:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073969
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\
    \ else {\n            if stack[i] {\n                return \"No\"\n         \
    \   }\n            stack[i] = false\n        }\n    }\n    return \"Yes\"\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmprgpixdsl_test.go:58: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmprgpixdsl_test.go:58: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmprgpixdsl_test.go:58: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmprgpixdsl_test.go:58: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmprgpixdsl_test.go:58: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmprgpixdsl_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n    stack1 :=\
    \ make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n    stack1[0],\
    \ stack2[0] = lst[0], lst[0]\n    stack1[1], stack2[1] = lst[1], lst[1]\n    stack1[2],\
    \ stack2[2] = lst[0], lst[1]\n    stack1[3], stack2[3] = lst[1], lst[0]\n    stack1[4],\
    \ stack2[4] = lst[1], lst[2]\n    stack1[5], stack2[5] = lst[2], lst[0]\n    stack1[6],\
    \ stack2[6] = lst[2], lst[1]\n    stack1[7], stack2[7] = lst[0], lst[2]\n    stack1[8],\
    \ stack2[8] = lst[0], lst[1]\n    stack1[9], stack2[9] = lst[1], lst[0]\n    stack1[10],\
    \ stack2[10] = lst[2], lst[0]\n    stack1[11], stack2[11] = lst[2], lst[1]\n \
    \   stack1[12], stack2[12] = lst[0], lst[2]\n    stack1[13], stack2[13] = lst[0],\
    \ lst[1]\n    stack1[14], stack2[14] = lst[1], lst[0]\n    stack1[15], stack2[15]\
    \ = lst[1], lst[2]\n    stack1[16], stack2[16] = lst[2], lst[0]\n    stack1[17],\
    \ stack2[17] = lst[2], lst[1]\n    stack1[18], stack2[18] = lst[0], lst[2]\n \
    \   stack1[19], stack2[19] = lst[0], lst[1]\n    stack1[20], stack2[20] = lst[1],\
    \ lst[0]\n    stack1[21], stack2[21] = lst[1], lst[2]\n    stack1[22], stack2[22]\
    \ = lst[2], lst[0]\n    stack1[23], stack2[23] = lst[2], lst[1]\n    stack1[24],\
    \ stack2[24] = lst[0], lst[2]\n    stack1[25], stack2[25] = lst[0], lst[1]\n \
    \   stack1[26], stack2[26] = lst[1], lst[0]\n    stack1[27], stack2[27] = lst[1],\
    \ lst[2]\n    stack1[28], stack2[28] = lst[2], lst[0]\n    stack1[29], stack2[29]\
    \ = lst[2], lst[1]\n    stack1[30], stack2[30] = lst[0], lst[2]\n    stack1[31],\
    \ stack2[31] = lst[0], lst[1]\n    stack1[32], stack2[32] = lst[1], lst[0]\n \
    \   stack1[33], stack2[33] = lst[1], lst[2]\n    stack1[34], stack2[34] = \nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx8ftirhx_test.go:60:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073969
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    result := \"No\"\n    for _, s := range lst {\n        result\
    \ += \"Yes\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0zzwe5dm_test.go:21:12: s declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073969
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var result string\n    for _, s := range lst {\n        if result\
    \ != \"\" {\n            result = result + \")\"\n        }\n        result =\
    \ result + s\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpmoxbrnsd_test.go:54: expected 'Yes', got '()())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpmoxbrnsd_test.go:54:\
    \ expected 'No', got ')))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpmoxbrnsd_test.go:54: expected 'No', got '(()(()))())())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpmoxbrnsd_test.go:54:\
    \ expected 'Yes', got ')()))(()()('\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpmoxbrnsd_test.go:54: expected 'Yes', got '(()))))(()())(('\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpmoxbrnsd_test.go:54:\
    \ expected 'No', got '())())'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmpmoxbrnsd_test.go:54: expected 'Yes', got '(()()()))()'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpmoxbrnsd_test.go:54: expected\
    \ 'No', got '(((()((())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpmoxbrnsd_test.go:54: expected 'No', got ')(())(()('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpmoxbrnsd_test.go:54: expected\
    \ 'No', got ')())('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n   \
    \     tmpmoxbrnsd_test.go:54: expected 'Yes', got '())'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpmoxbrnsd_test.go:54: expected 'Yes', got '))('\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073969
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = 1\n        } else\
    \ if lst[i] == \")\" {\n            stack[i] = -1\n        } else {\n        \
    \    return fmt.Sprintf(\"No\")\n        }\n    }\n    for i := 0; i < len(lst);\
    \ i++ {\n        if stack[i] < 0 {\n            return fmt.Sprintf(\"No\")\n \
    \       }\n    }\n    return fmt.Sprintf(\"Yes\")\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpv3f3j6ag_test.go:62: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpv3f3j6ag_test.go:62: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpv3f3j6ag_test.go:62: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpv3f3j6ag_test.go:62: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpv3f3j6ag_test.go:62: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpv3f3j6ag_test.go:62: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073969
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i] = true\n        }\
    \ else if lst[i] == \")\" {\n            stack[i] = false\n        } else if stack[i]\
    \ == true {\n            return fmt.Sprintf(\"No\")\n        }\n    }\n    return\
    \ fmt.Sprintf(\"Yes\")\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpb16a7mzi_test.go:57: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpb16a7mzi_test.go:57: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpb16a7mzi_test.go:57: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpb16a7mzi_test.go:57: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpb16a7mzi_test.go:57: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpb16a7mzi_test.go:57: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073969
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool, len(lst))\n\
    \    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool, len(lst))\n\
    \    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool, len(lst))\n\
    \    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool, len(lst))\n\
    \    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool, len(lst))\n\
    \    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool, len(lst))\n\
    \    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool, len(lst))\n\
    \    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool, len(lst))\n\
    \    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool, len(lst))\n\
    \    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool, len(lst))\n\
    \    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool, len(lst))\n\
    \    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool, len(lst))\n\
    \    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool, len(lst))\n\
    \    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool, len(lst))\n\
    \    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool, len(lst))\n\
    \    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool, len(lst))\n\
    \    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool, len(lst))\n\
    \    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool, len(lst))\n\
    \    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool, len(lst))\n\
    \    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool, len(lst))\n\
    \    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47b29tef_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool, len(lst))\n\
    \    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool, len(lst))\n\
    \    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool, len(lst))\n\
    \    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool, len(lst))\n\
    \    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool, len(lst))\n\
    \    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool, len(lst))\n\
    \    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool, len(lst))\n\
    \    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool, len(lst))\n\
    \    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool, len(lst))\n\
    \    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool, len(lst))\n\
    \    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool, len(lst))\n\
    \    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool, len(lst))\n\
    \    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool, len(lst))\n\
    \    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool, len(lst))\n\
    \    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool, len(lst))\n\
    \    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool, len(lst))\n\
    \    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool, len(lst))\n\
    \    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool, len(lst))\n\
    \    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool, len(lst))\n\
    \    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool, len(lst))\n\
    \    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool, len(lst))\n\
    \    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47b29tef_test.go:63:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073955
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]bool, len(lst))\n    result := \"\"\n    for _,\
    \ s := range lst {\n        if s == \"(\" || s == \")\" {\n            stack[len(stack)-1]\
    \ = true\n        } else {\n            stack[len(stack)] = false\n        }\n\
    \    }\n    for i := len(stack) - 1; i >= 0; i-- {\n        if stack[i] {\n  \
    \          result += \"(\"\n        } else {\n            result += \")\"\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range\
    \ [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens(...)\n\t/tmp/tmp95wko67a_test.go:26\n\
    command-line-arguments_test.TestMatch_Parens(0xc0001924e0?)\n\t/tmp/tmp95wko67a_test.go:46\
    \ +0x137f\ntesting.tRunner(0xc0001924e0, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073969
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var stack = []int{0, 1}\n    var result string\n    for _, s :=\
    \ range lst {\n        if s == '(' {\n            stack[stack[0]] = -1\n     \
    \       stack[0]++\n        } else if s == ')' {\n            stack[0]--\n   \
    \         if stack[0] == 0 {\n                result += \"(\" + s[1 : len(s)-1]\
    \ + \")\"\n            }\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa23oe2ck_test.go:23:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpa23oe2ck_test.go:26:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073969
- exit_code: null
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        stack[i] = i\n    }\n    result := \"No\"\n    for len(stack)\
    \ > 0 {\n        i := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n\
    \        if lst[i] == \"(\" {\n            stack = append(stack, i)\n        }\
    \ else if lst[i] == \")\" {\n            if len(stack) == 0 {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack =\
    \ stack[:len(stack)-1]\n        } else {\n            stack = append(stack, i)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660073983
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    stack := make([]int, len(lst))\n    result := \"No\"\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i]\
    \ = 1\n        } else if lst[i] == \")\" {\n            stack[i] = -1\n      \
    \  } else if stack[i] == 1 {\n            stack[i] = 0\n            if lst[i]\
    \ == \"(\" {\n                result += \"Yes\"\n            }\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmprgd39lsg_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmprgd39lsg_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmprgd39lsg_test.go:61: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmprgd39lsg_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmprgd39lsg_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmprgd39lsg_test.go:61: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073969
