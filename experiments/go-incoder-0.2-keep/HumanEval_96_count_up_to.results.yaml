language: go_test.go
name: HumanEval_96_count_up_to
results:
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  primes := make([]int, n+1)\n    primes[0] = 1\n    primes[1] = 1\n    for i\
    \ := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n            if i*j >\
    \ n {\n                break\n            }\n            if primes[i*j] == 0 {\n\
    \                primes[i*j] = i\n            }\n        }\n    }\n    return\
    \ primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp_w6wmf72_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp_w6wmf72_test.go:45\
    \ +0x173\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n  \
    \              break\n            }\n        }\n        if i == j {\n        \
    \    prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp87cta426_test.go:19:11: no new variables on left side of :=

    /tmp/tmp87cta426_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  if n < 2 {\n        return []int{}\n    }\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[prime[0]-1] == 0 || prime[prime[0]-1]\
    \ == i {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpnpxtmg9g_test.go:23\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpnpxtmg9g_test.go:37\
    \ +0xd8c\ntesting.tRunner(0xc0001201a0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    for i := 2; i < n; i++ {\n        if n%i == 0\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpf84zf8ug_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3\
    \ (0.00s)\n        tmpf84zf8ug_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]', got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmpf84zf8ug_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=2)\
    \ %!s(int=11)]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=2) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpf84zf8ug_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  primes := make([]int, n)\n    primes[0] = 1\n    for i := 1; i < n; i++ {\n\
    \        for j := 2; j < i; j++ {\n            if primes[j] == 0 {\n         \
    \       break\n            }\n            if i%primes[j] == 0 {\n            \
    \    primes[j] += 1\n                break\n            }\n        }\n    }\n\
    \    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpbtr8isx5_test.go:19\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpbtr8isx5_test.go:45\
    \ +0x196\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  if n < 2 {\n        return []\n    }\n    primes := make([]int, n+1)\n    primes[0]\
    \ = 2\n    primes[1] = 3\n    for i := 2; i <= n; i++ {\n        for j := 2; j\
    \ < i; j++ {\n            if i % primes[j] == 0 {\n                break\n   \
    \         }\n        }\n        if j > i {\n            primes[i+1] = i\n    \
    \    }\n    }\n    return primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw2vc3dmx_test.go:19:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075172
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[len(prime)-1]\
    \ < i {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp6ab6g592_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp6ab6g592_test.go:34\
    \ +0xd1d\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for _, j := range prime {\n            if i%j == 0 {\n   \
    \             break\n            }\n        }\n        if i == n {\n         \
    \   prime = append(prime, n)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpscdk1iuv_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        if prime[prime[len(prime)-1]-1] == i {\n            prime\
    \ = append(prime, i)\n        } else {\n            prime = append(prime, i+1)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpegdoxfw8_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  primes := make([]int, n)\n    for i := 0; i < n; i++ {\n        primes[i] =\
    \ 1\n    }\n    for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n \
    \           if primes[j] == 0 {\n                primes[j] = 1\n             \
    \   for k := i + 1; k < n; k++ {\n                    if primes[k] == 0 {\n  \
    \                      primes[k] = 1\n                        primes[j] = 0\n\
    \                        break\n                    }\n                }\n   \
    \         }\n        }\n    }\n    return primes[:n]\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpbzzzo_wn_test.go:61: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpbzzzo_wn_test.go:61: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpbzzzo_wn_test.go:61: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpbzzzo_wn_test.go:61:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpbzzzo_wn_test.go:61:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpbzzzo_wn_test.go:61: expected '[]', got '[%!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpbzzzo_wn_test.go:61:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpbzzzo_wn_test.go:61: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j == i {\n            prime = append(prime, i)\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsa0qidrz_test.go:19:11: no new variables on left side of :=

    /tmp/tmpsa0qidrz_test.go:20:11: no new variables on left side of :=

    /tmp/tmpsa0qidrz_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 43)\n    prime := append(prime, 49)\n    prime := append(prime, 57)\n    prime\
    \ := append(prime, 61)\n    prime := append(prime, 67)\n    prime := append(prime,\
    \ 73)\n    prime := append(prime, 79)\n    prime := append(prime, 83)\n    prime\
    \ := append(prime, 89)\n    prime := append(prime, 97)\n    prime := append(prime,\
    \ 101)\n    prime := append(prime, 103)\n    prime := append(prime, 107)\n   \
    \ prime := append(prime, 109)\n    prime := append(prime, 113)\n    prime := append(prime,\
    \ 127)\n    prime := append(prime, 131)\n    prime := append(prime, 137)\n   \
    \ prime := append(prime, 139)\n    prime := append(prime, 149)\n    prime := append(prime,\
    \ 151)\n    prime := append(prime, 157)\n    prime := append(prime, 163)\n   \
    \ prime := append(prime, 167)\n    prime := append(prime, 173)\n    prime := append(prime,\
    \ 179)\n    prime := append(prime, 181)\n    prime := append(prime, 191)\n   \
    \ prime := append(prime, 193)\n    prime := append(prime, 197)\n    prime := append(prime,\
    \ 199)\n    prime := append(prime, 211)\n    prime := append(prime, 223)\n   \
    \ prime := append(prime, 227)\n    prime := append(prime, 229)\n    prime := append(prime,\
    \ 233)\n    prime := append(prime, 239)\n    prime := append(prime, 241)\n   \
    \ prime := append(prime, 251)\n    prime := append(prime, 257)\n    prime := append(prime,\
    \ 263)\n    prime := append(prime, 269)\n    prime := append(prime, 271)\n   \
    \ prime := append(prime, 277)\n    prime := append(prime, 281)\n    prime := append(prime,\
    \ \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbrjdn1y1_test.go:76:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075172
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[0]-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 0;\
    \ j < i; j++ {\n            if prime[j] == 0 {\n                prime = append(prime,\
    \ j)\n                break\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpy1o8g3o4_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpy1o8g3o4_test.go:40\
    \ +0x12b6\ntesting.tRunner(0xc00019a680, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[i]\
    \ {\n            continue\n        }\n        for j := 2; j < i; j++ {\n     \
    \       if i%j == 0 {\n                prime = false\n                break\n\
    \            }\n        }\n        if prime {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl6gg0vua_test.go:20:12: non-boolean condition in if statement

    /tmp/tmpl6gg0vua_test.go:25:25: cannot use false (untyped bool constant) as []int
    value in assignment

    /tmp/tmpl6gg0vua_test.go:29:12: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n  \
    \              break\n            }\n        }\n        if j > i {\n         \
    \   prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphwtg6kg2_test.go:19:11: no new variables on left side of :=

    /tmp/tmphwtg6kg2_test.go:26:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        if isPrime(i) {\n            prime = append(prime, i)\n  \
    \      }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphrqwv5wh_test.go:19:11: no new variables on left side of :=

    /tmp/tmphrqwv5wh_test.go:21:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        if i%2 == 0 {\n            prime\
    \ = append(prime, 2)\n        }\n        for j := 3; j < i; j++ {\n          \
    \  if i%j == 0 {\n                prime = append(prime, j)\n            }\n  \
    \      }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyx5r5ap__test.go:19:11: no new variables on left side of :=

    /tmp/tmpyx5r5ap__test.go:20:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  primes := make([]int, n)\n    primes[0] = 2\n    primes[1] = 3\n    for i :=\
    \ 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if primes[j]\
    \ == i {\n                primes[j] = primes[j] + 1\n            }\n        }\n\
    \    }\n    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpsxupym3d_test.go:19\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpsxupym3d_test.go:42\
    \ +0x145\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i%j == 0 {\n                break\n            }\n        }\n      \
    \  if j == i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn4balp04_test.go:19:11: no new variables on left side of :=

    /tmp/tmpn4balp04_test.go:20:11: no new variables on left side of :=

    /tmp/tmpn4balp04_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        if i%2 == 0 {\n            continue\n        }\n        for\
    \ j := 3; j*j <= i; j++ {\n            if i%j == 0 {\n                prime =\
    \ append(prime, i)\n                break\n            }\n        }\n    }\n \
    \   return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptkh9m6v8_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    for i := 2; i <= n; i++ {\n        if isPrime(i)\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoox_l5x2_test.go:20:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        if prime[prime[len(prime)-1]-1] != i {\n            prime\
    \ = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph5d82d87_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 43)\n    prime := append(prime, 59)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 281)\n    prime := append(prime, 283)\n    prime := append(prime,\
    \ \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz0nabs0u_test.go:76:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[len(prime)-1]-1]\
    \ != i {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpzxqty18x_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpzxqty18x_test.go:34\
    \ +0xddd\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075174
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        if prime[len(prime)-1] == i {\n \
    \           prime[len(prime)-1]++\n        } else {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb5x42v5g_test.go:19:11: no new variables on left side of :=

    /tmp/tmpb5x42v5g_test.go:20:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 43)\n    prime := append(prime, 51)\n    prime := append(prime, 59)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 281)\n    prime := append(prime, 283)\n    prime := append(prime,\
    \ \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp92kh5b3__test.go:76:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075174
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 43)\n    prime := append(prime, 49)\n    prime := append(prime, 57)\n    prime\
    \ := append(prime, 61)\n    prime := append(prime, 67)\n    prime := append(prime,\
    \ 73)\n    prime := append(prime, 79)\n    prime := append(prime, 83)\n    prime\
    \ := append(prime, 89)\n    prime := append(prime, 97)\n    prime := append(prime,\
    \ 101)\n    prime := append(prime, 103)\n    prime := append(prime, 107)\n   \
    \ prime := append(prime, 109)\n    prime := append(prime, 113)\n    prime := append(prime,\
    \ 127)\n    prime := append(prime, 131)\n    prime := append(prime, 137)\n   \
    \ prime := append(prime, 139)\n    prime := append(prime, 149)\n    prime := append(prime,\
    \ 151)\n    prime := append(prime, 157)\n    prime := append(prime, 163)\n   \
    \ prime := append(prime, 167)\n    prime := append(prime, 173)\n    prime := append(prime,\
    \ 179)\n    prime := append(prime, 181)\n    prime := append(prime, 191)\n   \
    \ prime := append(prime, 193)\n    prime := append(prime, 197)\n    prime := append(prime,\
    \ 199)\n    prime := append(prime, 211)\n    prime := append(prime, 223)\n   \
    \ prime := append(prime, 227)\n    prime := append(prime, 229)\n    prime := append(prime,\
    \ 233)\n    prime := append(prime, 239)\n    prime := append(prime, 241)\n   \
    \ prime := append(prime, 243)\n    prime := append(prime, 247)\n    prime := append(prime,\
    \ 251)\n    prime := append(prime, 257)\n    prime := append(prime, 263)\n   \
    \ prime := append(prime, 269)\n    prime := append(prime, 271)\n    prime := append(prime,\
    \ \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbc6hdfup_test.go:76:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075174
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for j :=\
    \ 2; j < i; j++ {\n            if i % j == 0 {\n                break\n      \
    \      }\n        }\n        if i == j {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcmr6bf6w_test.go:25:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 43)\n    prime := append(prime, 59)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 281)\n    prime := append(prime, 283)\n    prime := append(prime,\
    \ \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz0nabs0u_test.go:76:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[0]-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 0;\
    \ j < i; j++ {\n            if prime[j] == 0 {\n                prime = append(prime,\
    \ j)\n                break\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpy1o8g3o4_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpy1o8g3o4_test.go:40\
    \ +0x12b6\ntesting.tRunner(0xc00019a680, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  if n < 2 {\n        return []\n    }\n    primes := make([]int, n+1)\n    primes[0]\
    \ = 2\n    primes[1] = 3\n    for i := 2; i < n; i++ {\n        for j := 2; j\
    \ < i; j++ {\n            if i*j > n {\n                break\n            }\n\
    \            if primes[i*j] == 0 {\n                primes[i*j] = primes[i] +\
    \ primes[j]\n            }\n        }\n    }\n    return primes[:n]\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj5rkzyyo_test.go:19:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075174
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, n)\n    prime[0] = prime[1] = 1\n    for i := 2; i < n;\
    \ i++ {\n        if prime[i] == 0 {\n            for j := i * i; j < n; j += i\
    \ {\n                prime[j] = i\n            }\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpssd3mbok_test.go:19:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075174
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        if prime[prime[len(prime)-1]-1] != i {\n            prime\
    \ = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph5d82d87_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n  \
    \              break\n            }\n        }\n        if i == j {\n        \
    \    prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp87cta426_test.go:19:11: no new variables on left side of :=

    /tmp/tmp87cta426_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n  \
    \              break\n            }\n        }\n        if j == i {\n        \
    \    prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqmij6xf1_test.go:19:11: no new variables on left side of :=

    /tmp/tmpqmij6xf1_test.go:26:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[0]-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 0;\
    \ j < i; j++ {\n            if prime[j] == 0 {\n                prime = append(prime,\
    \ j)\n                break\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpy1o8g3o4_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpy1o8g3o4_test.go:40\
    \ +0x12b6\ntesting.tRunner(0xc00019a680, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 43)\n    prime := append(prime, 59)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 281)\n    prime := append(prime, 283)\n    prime := append(prime,\
    \ \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz0nabs0u_test.go:76:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    for i := 3;\
    \ i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n\
    \                break\n            }\n        }\n        if j == i {\n      \
    \      prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkjk5wylw_test.go:19:11: no new variables on left side of :=

    /tmp/tmpkjk5wylw_test.go:26:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        if i%2 == 0 {\n            prime\
    \ = append(prime, 2)\n        }\n        for j := 3; j < i; j++ {\n          \
    \  if i%j == 0 {\n                prime = append(prime, j)\n            }\n  \
    \      }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyx5r5ap__test.go:19:11: no new variables on left side of :=

    /tmp/tmpyx5r5ap__test.go:20:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n    \
    \            break\n            }\n        }\n        if i == j {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpitp_xyxd_test.go:19:11: no new variables on left side of :=

    /tmp/tmpitp_xyxd_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[0]-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 1;\
    \ j < i; j++ {\n            if prime[j-1] == 0 {\n                prime = append(prime,\
    \ j)\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpurl608ba_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpurl608ba_test.go:39\
    \ +0x1274\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for j :=\
    \ 2; j < i; j++ {\n            if i%j == 0 {\n                break\n        \
    \    }\n        }\n        if i == n {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp36qfhchz_test.go:54: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmp36qfhchz_test.go:54:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp36qfhchz_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp36qfhchz_test.go:54:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp36qfhchz_test.go:54: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmp36qfhchz_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmp36qfhchz_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmp36qfhchz_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n    \
    \            break\n            }\n        }\n        if i == j {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmposnvq3ty_test.go:19:11: no new variables on left side of :=

    /tmp/tmposnvq3ty_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        if prime[prime[len(prime)-1]-1] == i {\n            prime\
    \ = append(prime, i)\n        } else {\n            prime = append(prime, i+1)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpegdoxfw8_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for _, j := range prime {\n            if i%j == 0 {\n   \
    \             break\n            }\n        }\n        if i == n {\n         \
    \   prime = append(prime, n)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpscdk1iuv_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    for i := 2; i < n; i++ {\n        for j := 2;\
    \ j < i; j++ {\n            if i%j == 0 {\n                break\n           \
    \ }\n        }\n        if i == n {\n            prime = append(prime, i)\n  \
    \      }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp1x5ycdwb_test.go:54: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmp1x5ycdwb_test.go:54:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp1x5ycdwb_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp1x5ycdwb_test.go:54:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp1x5ycdwb_test.go:54: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmp1x5ycdwb_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmp1x5ycdwb_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmp1x5ycdwb_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  if n < 2 {\n        return []\n    }\n    prime := make([]int, 0, n)\n    for\
    \ i := 2; i < n; i++ {\n        if prime[prime[0]-1] == 0 {\n            prime\
    \ = append(prime, i)\n        }\n        for j := 0; j < i; j++ {\n          \
    \  if prime[j] == 0 {\n                prime = append(prime, j)\n            }\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp94r9m1ep_test.go:19:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[len(prime)-1]\
    \ < i {\n            prime = append(prime, i)\n        }\n        for j := 0;\
    \ j < len(prime)-1; j++ {\n            if prime[j]*prime[j+1] < i {\n        \
    \        prime = append(prime, i)\n                break\n            }\n    \
    \    }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n \
    \ candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 20 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpzh0deyq9_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpzh0deyq9_test.go:40\
    \ +0x11f0\ntesting.tRunner(0xc0001036c0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075176
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n    \
    \            break\n            }\n        }\n        if j > i {\n           \
    \ prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5fte835v_test.go:19:11: no new variables on left side of :=

    /tmp/tmp5fte835v_test.go:26:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        if isPrime(i) {\n            prime = append(prime, i)\n  \
    \      }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphrqwv5wh_test.go:19:11: no new variables on left side of :=

    /tmp/tmphrqwv5wh_test.go:21:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        if i%2 == 0 {\n            continue\n        }\n        for\
    \ j := 3; j*j <= i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n            if j == i {\n                prime = append(prime,\
    \ i)\n                break\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppwlsp5ic_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n  \
    \              break\n            }\n        }\n        if j == i {\n        \
    \    prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqmij6xf1_test.go:19:11: no new variables on left side of :=

    /tmp/tmpqmij6xf1_test.go:26:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, n)\n    prime[0] = prime[1] = 1\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              for k := j; k < i; k++ {\n                    prime[k] = i\n  \
    \              }\n            }\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjrv5ib50_test.go:19:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    for i := 2; i < n; i++ {\n        if n%i == 0\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpf84zf8ug_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3\
    \ (0.00s)\n        tmpf84zf8ug_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]', got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmpf84zf8ug_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=2)\
    \ %!s(int=11)]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=2) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpf84zf8ug_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        if isPrime(i) {\n            prime = append(prime, i)\n  \
    \      }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphrqwv5wh_test.go:19:11: no new variables on left side of :=

    /tmp/tmphrqwv5wh_test.go:21:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for j :=\
    \ 2; j < i; j++ {\n            if i%j == 0 {\n                break\n        \
    \    }\n        }\n        if i == n {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp36qfhchz_test.go:54: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmp36qfhchz_test.go:54:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp36qfhchz_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp36qfhchz_test.go:54:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp36qfhchz_test.go:54: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmp36qfhchz_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmp36qfhchz_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmp36qfhchz_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        if i%2 == 0 {\n            continue\n        }\n        for\
    \ j := 3; j*j <= i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n            if j == i {\n                prime = append(prime,\
    \ i)\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6mhppk5g_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  if n < 2 {\n        return []\n    }\n    primes := make([]int, n)\n    primes[0]\
    \ = 2\n    primes[1] = 3\n    primes[2] = 5\n    primes[3] = 7\n    primes[4]\
    \ = 11\n    primes[5] = 13\n    primes[6] = 17\n    primes[7] = 19\n    primes[8]\
    \ = 23\n    primes[9] = 29\n    primes[10] = 31\n    primes[11] = 31\n    primes[12]\
    \ = 37\n    primes[13] = 41\n    primes[14] = 43\n    primes[15] = 47\n    primes[16]\
    \ = 53\n    primes[17] = 59\n    primes[18] = 61\n    primes[19] = 67\n    primes[20]\
    \ = 71\n    primes[21] = 73\n    primes[22] = 79\n    primes[23] = 83\n    primes[24]\
    \ = 89\n    primes[25] = 97\n    primes[26] = 101\n    primes[27] = 103\n    primes[28]\
    \ = 107\n    primes[29] = 109\n    primes[30] = 112\n    primes[31] = 116\n  \
    \  primes[32] = 113\n    primes[33] = 121\n    primes[34] = 123\n    primes[35]\
    \ = 127\n    primes[36] = 131\n    primes[37] = 301\n    primes[38] = 303\n  \
    \  primes[39] = 307\n    primes[40] = 311\n    primes[41] = 313\n    primes[42]\
    \ = 317\n    primes[43] = 319\n    primes[44] = 329\n    primes[45] = 331\n  \
    \  primes[46] = 333\n    primes[47] = 359\n    primes[48] = 371\n    primes[49]\
    \ = 373\n    primes[50] = 379\n    primes[51] = 381\n    primes[52] = 383\n  \
    \  primes[53] = 389\n    primes[54] = 391\n    primes[55] = 397\n    primes[56]\
    \ = 401\n    primes[57] = 403\n    primes[58] = 407\n    primes[59] = 411\n  \
    \  primes[60] = 417\n    primes[61] = 419\n    primes[62] = 429\n    primes[63]\
    \ = 431\n    primes[64] = 433\n    primes[65] = 439\n    primes[66] = 443\n  \
    \  \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgkbw061u_test.go:19:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  if n < 2 {\n        return []\n    }\n    primes := make([]int, n)\n    primes[0]\
    \ = 2\n    primes[1] = 3\n    for i := 2; i < n; i++ {\n        for j := 2; j\
    \ < i; j++ {\n            if i % j == 0 {\n                break\n           \
    \ }\n        }\n        if j > i {\n            primes[i] = i\n        }\n   \
    \ }\n    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwoqk6jyv_test.go:19:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  if n < 2 {\n        return []int{}\n    }\n\n    prime := make([]int, 0, n)\n\
    \    prime := append(prime, 2)\n\n    for i := 3; i < n; i++ {\n        if prime[i-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 2;\
    \ j < i; j++ {\n            if prime[j-1] == 0 {\n                prime = append(prime,\
    \ j)\n            }\n        }\n    }\n\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm4fesjai_test.go:23:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    for i := 2; i < n; i++ {\n        if n%i == 0\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpf84zf8ug_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3\
    \ (0.00s)\n        tmpf84zf8ug_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]', got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmpf84zf8ug_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=2)\
    \ %!s(int=11)]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=2) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpf84zf8ug_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        if prime[prime[len(prime)-1]-1] != i {\n            prime\
    \ = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph5d82d87_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n    \
    \            break\n            }\n        }\n        if i == j {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmposnvq3ty_test.go:19:11: no new variables on left side of :=

    /tmp/tmposnvq3ty_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for _, j := range prime {\n            if i%j == 0 {\n   \
    \             break\n            }\n        }\n        if i == n {\n         \
    \   prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplohxn5zl_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[len(prime)-1]-1]\
    \ < i {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmprigy1qaf_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmprigy1qaf_test.go:34\
    \ +0xddd\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075177
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, n)\n    prime[0] = prime[1] = 1\n    for i := 2; i < n;\
    \ i++ {\n        if prime[i] == 0 {\n            for j := i * i; j < n; j += i\
    \ {\n                prime[j] = i\n            }\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpssd3mbok_test.go:19:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075174
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n  \
    \              break\n            }\n        }\n        if j == i {\n        \
    \    prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkanll9tb_test.go:19:11: no new variables on left side of :=

    /tmp/tmpkanll9tb_test.go:26:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n    \
    \            break\n            }\n        }\n        if i == j {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpitp_xyxd_test.go:19:11: no new variables on left side of :=

    /tmp/tmpitp_xyxd_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j == i {\n            prime = append(prime, i)\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsa0qidrz_test.go:19:11: no new variables on left side of :=

    /tmp/tmpsa0qidrz_test.go:20:11: no new variables on left side of :=

    /tmp/tmpsa0qidrz_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[0]-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 1;\
    \ j < i; j++ {\n            if prime[j-1] == 0 {\n                prime = append(prime,\
    \ j)\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpurl608ba_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpurl608ba_test.go:39\
    \ +0x1274\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[0]-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 0;\
    \ j < i; j++ {\n            if prime[j] == 0 {\n                prime = append(prime,\
    \ j)\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpj4c8xbne_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpj4c8xbne_test.go:39\
    \ +0x1254\ntesting.tRunner(0xc0001a01a0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075177
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n    \
    \            break\n            }\n        }\n        if i == j {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpitp_xyxd_test.go:19:11: no new variables on left side of :=

    /tmp/tmpitp_xyxd_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, n)\n    prime[0] = 1\n    prime[1] = 1\n    prime[2] =\
    \ 2\n    prime[3] = 3\n    prime[4] = 5\n    prime[5] = 7\n    prime[6] = 11\n\
    \    prime[7] = 13\n    prime[8] = 17\n    prime[9] = 19\n    prime[10] = 23\n\
    \    prime[11] = 29\n    prime[12] = 31\n    prime[13] = 41\n    prime[14] = 67\n\
    \    prime[15] = 89\n    prime[16] = 101\n    prime[17] = 121\n    prime[18] =\
    \ 147\n    prime[19] = 159\n    prime[20] = 191\n    prime[21] = 223\n    prime[22]\
    \ = 313\n    prime[23] = 419\n    prime[24] = 647\n    prime[25] = 831\n    prime[26]\
    \ = 1023\n    prime[27] = 1229\n    prime[28] = 1439\n    prime[29] = 1647\n \
    \   prime[30] = 1855\n    prime[31] = 2047\n    prime[32] = 2277\n    prime[33]\
    \ = 2461\n    prime[34] = 2779\n    prime[35] = 2983\n    prime[36] = 3199\n \
    \   prime[37] = 3301\n    prime[38] = 3521\n    prime[39] = 3729\n    prime[40]\
    \ = 3937\n    prime[41] = 4157\n    prime[42] = 4331\n    prime[43] = 4529\n \
    \   prime[44] = 4743\n    prime[45] = 4947\n    prime[46] = 5149\n    prime[47]\
    \ = 5349\n    prime[48] = 5639\n    prime[49] = 5941\n    prime[50] = 6141\n \
    \   prime[51] = 6451\n    prime[52] = 6751\n    prime[53] = 7149\n    prime[54]\
    \ = 7457\n    prime[55] = 7771\n    prime[56] = 8089\n    prime[57] = 8491\n \
    \   prime[58] = 8719\n    prime[59] = 9031\n    prime[60] = 9337\n    prime[61]\
    \ = 9639\n    prime[62] = 9949\n    prime[63] = 10159\n    prime[64] = 10359\n\
    \    prime[65] = 10559\n    prime[66] = 10761\n    prime[67] = 10967\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps94crabt_test.go:87:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n    \
    \            break\n            }\n        }\n        if i != j {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp21tlztie_test.go:19:11: no new variables on left side of :=

    /tmp/tmp21tlztie_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 23)\n    prime\
    \ := append(prime, 29)\n    prime := append(prime, 31)\n    prime := append(prime,\
    \ 37)\n    prime := append(prime, 43)\n    prime := append(prime, 49)\n    prime\
    \ := append(prime, 57)\n    prime := append(prime, 61)\n    prime := append(prime,\
    \ 67)\n    prime := append(prime, 73)\n    prime := append(prime, 79)\n    prime\
    \ := append(prime, 83)\n    prime := append(prime, 89)\n    prime := append(prime,\
    \ 97)\n    prime := append(prime, 101)\n    prime := append(prime, 103)\n    prime\
    \ := append(prime, 107)\n    prime := append(prime, 109)\n    prime := append(prime,\
    \ 113)\n    prime := append(prime, 127)\n    prime := append(prime, 131)\n   \
    \ prime := append(prime, 137)\n    prime := append(prime, 139)\n    prime := append(prime,\
    \ 149)\n    prime := append(prime, 151)\n    prime := append(prime, 157)\n   \
    \ prime := append(prime, 163)\n    prime := append(prime, 167)\n    prime := append(prime,\
    \ 173)\n    prime := append(prime, 179)\n    prime := append(prime, 181)\n   \
    \ prime := append(prime, 191)\n    prime := append(prime, 193)\n    prime := append(prime,\
    \ 197)\n    prime := append(prime, 199)\n    prime := append(prime, 211)\n   \
    \ prime := append(prime, 223)\n    prime := append(prime, 227)\n    prime := append(prime,\
    \ 229)\n    prime := append(prime, 233)\n    prime := append(prime, 239)\n   \
    \ prime := append(prime, 241)\n    prime := append(prime, 251)\n    prime := append(prime,\
    \ 257)\n    prime := append(prime, 263)\n    prime := append(prime, 269)\n   \
    \ prime := append(prime, 271)\n    prime := append(prime, 277)\n    prime := append(prime,\
    \ 28\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppv3jz1iu_test.go:75:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 23)\n    prime\
    \ := append(prime, 29)\n    prime := append(prime, 31)\n    prime := append(prime,\
    \ 37)\n    prime := append(prime, 43)\n    prime := append(prime, 49)\n    prime\
    \ := append(prime, 57)\n    prime := append(prime, 61)\n    prime := append(prime,\
    \ 67)\n    prime := append(prime, 73)\n    prime := append(prime, 79)\n    prime\
    \ := append(prime, 83)\n    prime := append(prime, 89)\n    prime := append(prime,\
    \ 97)\n    prime := append(prime, 101)\n    prime := append(prime, 103)\n    prime\
    \ := append(prime, 107)\n    prime := append(prime, 109)\n    prime := append(prime,\
    \ 113)\n    prime := append(prime, 127)\n    prime := append(prime, 131)\n   \
    \ prime := append(prime, 137)\n    prime := append(prime, 139)\n    prime := append(prime,\
    \ 149)\n    prime := append(prime, 151)\n    prime := append(prime, 157)\n   \
    \ prime := append(prime, 163)\n    prime := append(prime, 167)\n    prime := append(prime,\
    \ 173)\n    prime := append(prime, 179)\n    prime := append(prime, 181)\n   \
    \ prime := append(prime, 191)\n    prime := append(prime, 193)\n    prime := append(prime,\
    \ 197)\n    prime := append(prime, 199)\n    prime := append(prime, 211)\n   \
    \ prime := append(prime, 223)\n    prime := append(prime, 227)\n    prime := append(prime,\
    \ 229)\n    prime := append(prime, 233)\n    prime := append(prime, 239)\n   \
    \ prime := append(prime, 241)\n    prime := append(prime, 251)\n    prime := append(prime,\
    \ 257)\n    prime := append(prime, 263)\n    prime := append(prime, 269)\n   \
    \ prime := append(prime, 271)\n    prime := append(prime, 277)\n    prime := append(prime,\
    \ 28\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppv3jz1iu_test.go:75:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[0]-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 0;\
    \ j < i; j++ {\n            if prime[j] == 0 {\n                prime = append(prime,\
    \ j)\n                break\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpy1o8g3o4_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpy1o8g3o4_test.go:40\
    \ +0x12b6\ntesting.tRunner(0xc00019a680, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, n)\n    prime[0] = 1\n    for i := 1; i < n; i++ {\n \
    \       for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime[i] = 1\n   \
    \     }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjyr6bsog_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 43)\n    prime := append(prime, 51)\n    prime := append(prime, 59)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 281)\n    prime := append(prime, 283)\n    prime := append(prime,\
    \ \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp92kh5b3__test.go:76:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075174
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[len(prime)-1]-1]\
    \ != i {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpzxqty18x_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpzxqty18x_test.go:34\
    \ +0xddd\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075174
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n    \
    \            break\n            }\n        }\n        if i == j {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpitp_xyxd_test.go:19:11: no new variables on left side of :=

    /tmp/tmpitp_xyxd_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    for i := 2; i < n; i++ {\n        if isPrime(i)\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmipbqck6_test.go:20:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for j :=\
    \ 2; j < i; j++ {\n            if i%j == 0 {\n                break\n        \
    \    }\n        }\n        if i == n {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp36qfhchz_test.go:54: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmp36qfhchz_test.go:54:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp36qfhchz_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp36qfhchz_test.go:54:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp36qfhchz_test.go:54: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmp36qfhchz_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmp36qfhchz_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmp36qfhchz_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[0]-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 1;\
    \ j < i; j++ {\n            if prime[j-1] != 0 && prime[j-1] != i {\n        \
    \        prime = append(prime, i)\n                break\n            }\n    \
    \    }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n \
    \ candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp3ccgjp7o_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp3ccgjp7o_test.go:40\
    \ +0x128c\ntesting.tRunner(0xc0001a01a0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075177
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, n)\n    prime[0] = prime[1] = 1\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              for k := j; k < i; k++ {\n                    prime[k] = i\n  \
    \              }\n                break\n            }\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvfa2l62m_test.go:19:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n  \
    \              break\n            }\n        }\n        if j > i {\n         \
    \   prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0a31r1we_test.go:19:11: no new variables on left side of :=

    /tmp/tmp0a31r1we_test.go:26:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 41)\n    prime := append(prime, 43)\n    prime := append(prime, 47)\n    prime\
    \ := append(prime, 53)\n    prime := append(prime, 59)\n    prime := append(prime,\
    \ 61)\n    prime := append(prime, 67)\n    prime := append(prime, 71)\n    prime\
    \ := append(prime, 73)\n    prime := append(prime, 79)\n    prime := append(prime,\
    \ 83)\n    prime := append(prime, 89)\n    prime := append(prime, 97)\n    prime\
    \ := append(prime, 101)\n    prime := append(prime, 103)\n    prime := append(prime,\
    \ 107)\n    prime := append(prime, 109)\n    prime := append(prime, 113)\n   \
    \ prime := append(prime, 127)\n    prime := append(prime, 131)\n    prime := append(prime,\
    \ 137)\n    prime := append(prime, 139)\n    prime := append(prime, 149)\n   \
    \ prime := append(prime, 151)\n    prime := append(prime, 157)\n    prime := append(prime,\
    \ 163)\n    prime := append(prime, 167)\n    prime := append(prime, 173)\n   \
    \ prime := append(prime, 179)\n    prime := append(prime, 181)\n    prime := append(prime,\
    \ 191)\n    prime := append(prime, 193)\n    prime := append(prime, 197)\n   \
    \ prime := append(prime, 199)\n    prime := append(prime, 211)\n    prime := append(prime,\
    \ 223)\n    prime := append(prime, 227)\n    prime := append(prime, 229)\n   \
    \ prime := append(prime, 233)\n    prime := append(prime, 239)\n    prime := append(prime,\
    \ 241)\n    prime := append(prime, 243)\n    prime := append(prime, 247)\n   \
    \ prime := append(prime, 251)\n    prime := append(prime, 257)\n    prime := append(prime,\
    \ \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy5en91lb_test.go:76:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 23)\n    prime\
    \ := append(prime, 29)\n    prime := append(prime, 31)\n    prime := append(prime,\
    \ 37)\n    prime := append(prime, 43)\n    prime := append(prime, 49)\n    prime\
    \ := append(prime, 57)\n    prime := append(prime, 61)\n    prime := append(prime,\
    \ 67)\n    prime := append(prime, 73)\n    prime := append(prime, 79)\n    prime\
    \ := append(prime, 83)\n    prime := append(prime, 89)\n    prime := append(prime,\
    \ 97)\n    prime := append(prime, 101)\n    prime := append(prime, 103)\n    prime\
    \ := append(prime, 107)\n    prime := append(prime, 109)\n    prime := append(prime,\
    \ 113)\n    prime := append(prime, 127)\n    prime := append(prime, 131)\n   \
    \ prime := append(prime, 137)\n    prime := append(prime, 139)\n    prime := append(prime,\
    \ 149)\n    prime := append(prime, 151)\n    prime := append(prime, 157)\n   \
    \ prime := append(prime, 163)\n    prime := append(prime, 167)\n    prime := append(prime,\
    \ 173)\n    prime := append(prime, 179)\n    prime := append(prime, 181)\n   \
    \ prime := append(prime, 191)\n    prime := append(prime, 193)\n    prime := append(prime,\
    \ 197)\n    prime := append(prime, 199)\n    prime := append(prime, 211)\n   \
    \ prime := append(prime, 223)\n    prime := append(prime, 227)\n    prime := append(prime,\
    \ 229)\n    prime := append(prime, 233)\n    prime := append(prime, 239)\n   \
    \ prime := append(prime, 241)\n    prime := append(prime, 251)\n    prime := append(prime,\
    \ 257)\n    prime := append(prime, 263)\n    prime := append(prime, 269)\n   \
    \ prime := append(prime, 271)\n    prime := append(prime, 277)\n    prime := append(prime,\
    \ 28\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppv3jz1iu_test.go:75:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[0]-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 1;\
    \ j < i; j++ {\n            if prime[j-1] == 0 {\n                prime = append(prime,\
    \ j)\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpurl608ba_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpurl608ba_test.go:39\
    \ +0x1274\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  if n < 2 {\n        return []int{}\n    }\n    prime := make([]int, 0, n)\n\
    \    prime := append(prime, 2)\n    for i := 3; i < n; i++ {\n        if prime[i-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 2;\
    \ j < i; j++ {\n            if i%j == 0 {\n                prime = append(prime,\
    \ i)\n                break\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi2edhu_y_test.go:22:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        if prime[prime[len(prime)-1]-1] == i {\n            prime\
    \ = append(prime, i)\n        } else {\n            prime = append(prime, i+1)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpegdoxfw8_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  primes := make([]int, n+1)\n    primes[0] = 2\n    primes[1] = 2\n    primes[2]\
    \ = 2\n    primes[3] = 1\n    primes[4] = 1\n    primes[5] = 1\n    primes[6]\
    \ = 1\n    primes[7] = 1\n    primes[8] = 1\n    primes[9] = 1\n    primes[10]\
    \ = 1\n    primes[11] = 1\n    primes[12] = 1\n    primes[13] = 1\n    primes[14]\
    \ = 1\n    primes[15] = 1\n    primes[16] = 1\n    primes[17] = 1\n    primes[18]\
    \ = 1\n    primes[19] = 1\n    primes[20] = 1\n    primes[21] = 1\n    primes[22]\
    \ = 1\n    primes[23] = 1\n    primes[24] = 1\n    primes[25] = 1\n    primes[26]\
    \ = 1\n    primes[27] = 1\n    primes[28] = 1\n    primes[29] = 1\n    primes[30]\
    \ = 1\n    primes[31] = 1\n    primes[32] = 1\n    primes[33] = 1\n    primes[34]\
    \ = 1\n    primes[35] = 1\n    primes[36] = 1\n    primes[37] = 1\n    primes[38]\
    \ = 1\n    primes[39] = 1\n    primes[40] = 1\n    primes[41] = 1\n    primes[42]\
    \ = 1\n    primes[43] = 1\n    primes[44] = 1\n    primes[45] = 1\n    primes[46]\
    \ = 1\n    primes[47] = 1\n    primes[48] = 1\n    primes[49] = 1\n    primes[50]\
    \ = 1\n    primes[51] = 1\n    primes[52] = 1\n    primes[53] = 1\n    primes[54]\
    \ = 1\n    primes[55] = 1\n    primes[56] = 1\n    primes[57] = 1\n    primes[58]\
    \ = 1\n    primes[59] = 1\n    primes[60] = 1\n    primes[61] = 1\n    primes[62]\
    \ = 1\n    primes[63] = 1\n    primes[64] = 1\n    primes[65] = 1\n    primes[66]\
    \ = 1\n    primes[67] = 1\n    primes[68] = 1\n    primes[69] = 1\n    primes[70]\
    \ = 1\n    primes[71] = 1\n    primes[72] = 1\n    primes[73] = 1\n    primes[74]\
    \ = 1\n    primes[75] = 1\n    primes[76] = 1\n    primes[77] = 1\n    primes[78]\
    \ = 1\n    primes[79] = 1\n    primes[80] = 1\n    primes[81] = 1\n    \nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl4qdu8ye_test.go:102:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if i == j {\n            prime = append(prime, i)\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt9crj9vl_test.go:19:11: no new variables on left side of :=

    /tmp/tmpt9crj9vl_test.go:20:11: no new variables on left side of :=

    /tmp/tmpt9crj9vl_test.go:27:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    for i := 2; i <= n; i++ {\n        if isPrime(i)\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoox_l5x2_test.go:20:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n  \
    \              break\n            }\n        }\n        if i == j {\n        \
    \    prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp87cta426_test.go:19:11: no new variables on left side of :=

    /tmp/tmp87cta426_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, n)\n    prime[0] = prime[1] = 1\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              for k := j; k < i; k++ {\n                    if prime[k] == 0\
    \ {\n                        prime[j] = prime[k]\n                        prime[j+1]++\n\
    \                        break\n                    }\n                }\n   \
    \         }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9u9b2lw5_test.go:19:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    for i := 2; i <= n; i++ {\n        if isprime(i)\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqmgjac3l_test.go:20:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  primes := make([]int, n+1)\n    primes[0] = 1\n    primes[1] = 1\n    for i\
    \ := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j ==\
    \ 0 {\n                break\n            }\n        }\n        if j > i {\n \
    \           primes[i+1] = i\n        }\n    }\n    return primes[:n]\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqornqb9e_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075178
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 43)\n    prime := append(prime, 49)\n    prime := append(prime, 57)\n    prime\
    \ := append(prime, 61)\n    prime := append(prime, 67)\n    prime := append(prime,\
    \ 73)\n    prime := append(prime, 79)\n    prime := append(prime, 83)\n    prime\
    \ := append(prime, 89)\n    prime := append(prime, 97)\n    prime := append(prime,\
    \ 101)\n    prime := append(prime, 103)\n    prime := append(prime, 107)\n   \
    \ prime := append(prime, 109)\n    prime := append(prime, 113)\n    prime := append(prime,\
    \ 127)\n    prime := append(prime, 131)\n    prime := append(prime, 137)\n   \
    \ prime := append(prime, 139)\n    prime := append(prime, 149)\n    prime := append(prime,\
    \ 151)\n    prime := append(prime, 157)\n    prime := append(prime, 163)\n   \
    \ prime := append(prime, 167)\n    prime := append(prime, 173)\n    prime := append(prime,\
    \ 179)\n    prime := append(prime, 181)\n    prime := append(prime, 191)\n   \
    \ prime := append(prime, 193)\n    prime := append(prime, 197)\n    prime := append(prime,\
    \ 199)\n    prime := append(prime, 211)\n    prime := append(prime, 223)\n   \
    \ prime := append(prime, 227)\n    prime := append(prime, 229)\n    prime := append(prime,\
    \ 233)\n    prime := append(prime, 239)\n    prime := append(prime, 241)\n   \
    \ prime := append(prime, 251)\n    prime := append(prime, 257)\n    prime := append(prime,\
    \ 263)\n    prime := append(prime, 269)\n    prime := append(prime, 271)\n   \
    \ prime := append(prime, 277)\n    prime := append(prime, 281)\n    prime := append(prime,\
    \ \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbrjdn1y1_test.go:76:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075172
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n    \
    \            break\n            }\n        }\n        if j > i {\n           \
    \ prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5fte835v_test.go:19:11: no new variables on left side of :=

    /tmp/tmp5fte835v_test.go:26:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n    \
    \            break\n            }\n        }\n        if i == j {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmposnvq3ty_test.go:19:11: no new variables on left side of :=

    /tmp/tmposnvq3ty_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        if prime[prime[len(prime)-1]-1] == i {\n            prime\
    \ = append(prime, i)\n        } else {\n            prime = append(prime, i+1)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpegdoxfw8_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j == i {\n            prime = append(prime, i)\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsa0qidrz_test.go:19:11: no new variables on left side of :=

    /tmp/tmpsa0qidrz_test.go:20:11: no new variables on left side of :=

    /tmp/tmpsa0qidrz_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n    \
    \            break\n            }\n        }\n        if j > i {\n           \
    \ prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1_p5milr_test.go:19:11: no new variables on left side of :=

    /tmp/tmp1_p5milr_test.go:26:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075178
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 43)\n    prime := append(prime, 49)\n    prime := append(prime, 57)\n    prime\
    \ := append(prime, 61)\n    prime := append(prime, 67)\n    prime := append(prime,\
    \ 73)\n    prime := append(prime, 79)\n    prime := append(prime, 83)\n    prime\
    \ := append(prime, 89)\n    prime := append(prime, 97)\n    prime := append(prime,\
    \ 101)\n    prime := append(prime, 103)\n    prime := append(prime, 107)\n   \
    \ prime := append(prime, 109)\n    prime := append(prime, 113)\n    prime := append(prime,\
    \ 127)\n    prime := append(prime, 131)\n    prime := append(prime, 137)\n   \
    \ prime := append(prime, 139)\n    prime := append(prime, 149)\n    prime := append(prime,\
    \ 151)\n    prime := append(prime, 157)\n    prime := append(prime, 163)\n   \
    \ prime := append(prime, 167)\n    prime := append(prime, 173)\n    prime := append(prime,\
    \ 179)\n    prime := append(prime, 181)\n    prime := append(prime, 191)\n   \
    \ prime := append(prime, 193)\n    prime := append(prime, 197)\n    prime := append(prime,\
    \ 199)\n    prime := append(prime, 211)\n    prime := append(prime, 223)\n   \
    \ prime := append(prime, 227)\n    prime := append(prime, 229)\n    prime := append(prime,\
    \ 233)\n    prime := append(prime, 239)\n    prime := append(prime, 241)\n   \
    \ prime := append(prime, 251)\n    prime := append(prime, 257)\n    prime := append(prime,\
    \ 263)\n    prime := append(prime, 269)\n    prime := append(prime, 271)\n   \
    \ prime := append(prime, 277)\n    prime := append(prime, 281)\n    prime := append(prime,\
    \ \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbrjdn1y1_test.go:76:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075172
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n    \
    \            break\n            }\n        }\n        if i == j {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpitp_xyxd_test.go:19:11: no new variables on left side of :=

    /tmp/tmpitp_xyxd_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i%j == 0 {\n                break\n            }\n        }\n      \
    \  if i == j {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg8esx8nb_test.go:19:11: no new variables on left side of :=

    /tmp/tmpg8esx8nb_test.go:20:11: no new variables on left side of :=

    /tmp/tmpg8esx8nb_test.go:27:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075178
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  if n < 2 {\n        return []int{}\n    }\n\n    prime := make([]int, 0, n)\n\
    \    prime := append(prime, 2)\n    prime := append(prime, 3)\n    prime := append(prime,\
    \ 5)\n    prime := append(prime, 7)\n    prime := append(prime, 11)\n    prime\
    \ := append(prime, 13)\n    prime := append(prime, 17)\n    prime := append(prime,\
    \ 19)\n\n    for i := 5; i <= n; i++ {\n        if prime[i-1] == 0 {\n       \
    \     prime = append(prime, i)\n        }\n    }\n\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl43grfr6_test.go:23:11: no new variables on left side of :=

    /tmp/tmpl43grfr6_test.go:24:11: no new variables on left side of :=

    /tmp/tmpl43grfr6_test.go:25:11: no new variables on left side of :=

    /tmp/tmpl43grfr6_test.go:26:11: no new variables on left side of :=

    /tmp/tmpl43grfr6_test.go:27:11: no new variables on left side of :=

    /tmp/tmpl43grfr6_test.go:28:11: no new variables on left side of :=

    /tmp/tmpl43grfr6_test.go:29:11: no new variables on left side of :=

    /tmp/tmpl43grfr6_test.go:30:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075178
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  primes := make([]int, n+1)\n    primes[0] = 1\n    for i := 2; i <= n; i++\
    \ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n           \
    \     break\n            }\n        }\n        if j > i {\n            primes[i]\
    \ = j\n        }\n    }\n    return primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt083807x_test.go:26:12: undefined: j

    /tmp/tmpt083807x_test.go:27:25: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075178
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j == i {\n            prime = append(prime, i)\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsa0qidrz_test.go:19:11: no new variables on left side of :=

    /tmp/tmpsa0qidrz_test.go:20:11: no new variables on left side of :=

    /tmp/tmpsa0qidrz_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for _, j := range prime {\n            if i%j == 0 {\n   \
    \             break\n            }\n        }\n        if i == n {\n         \
    \   prime = append(prime, n)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpscdk1iuv_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        if prime[len(prime)-1] != i {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp1580hdt_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075178
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n  \
    \              break\n            }\n        }\n        if i == j {\n        \
    \    prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp87cta426_test.go:19:11: no new variables on left side of :=

    /tmp/tmp87cta426_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 43)\n    prime := append(prime, 49)\n    prime := append(prime, 57)\n    prime\
    \ := append(prime, 61)\n    prime := append(prime, 67)\n    prime := append(prime,\
    \ 73)\n    prime := append(prime, 79)\n    prime := append(prime, 83)\n    prime\
    \ := append(prime, 89)\n    prime := append(prime, 97)\n    prime := append(prime,\
    \ 101)\n    prime := append(prime, 103)\n    prime := append(prime, 107)\n   \
    \ prime := append(prime, 109)\n    prime := append(prime, 113)\n    prime := append(prime,\
    \ 127)\n    prime := append(prime, 131)\n    prime := append(prime, 137)\n   \
    \ prime := append(prime, 139)\n    prime := append(prime, 149)\n    prime := append(prime,\
    \ 151)\n    prime := append(prime, 157)\n    prime := append(prime, 163)\n   \
    \ prime := append(prime, 167)\n    prime := append(prime, 173)\n    prime := append(prime,\
    \ 179)\n    prime := append(prime, 181)\n    prime := append(prime, 191)\n   \
    \ prime := append(prime, 193)\n    prime := append(prime, 197)\n    prime := append(prime,\
    \ 199)\n    prime := append(prime, 211)\n    prime := append(prime, 223)\n   \
    \ prime := append(prime, 227)\n    prime := append(prime, 229)\n    prime := append(prime,\
    \ 233)\n    prime := append(prime, 239)\n    prime := append(prime, 241)\n   \
    \ prime := append(prime, 251)\n    prime := append(prime, 257)\n    prime := append(prime,\
    \ 263)\n    prime := append(prime, 269)\n    prime := append(prime, 271)\n   \
    \ prime := append(prime, 277)\n    prime := append(prime, 281)\n    prime := append(prime,\
    \ \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbrjdn1y1_test.go:76:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075172
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    if n < 0 {\n        return nil\n  \
    \  }\n    if n == 0 {\n        return nil\n    }\n    if n > 0 {\n        for\
    \ i := 3; i <= n; i++ {\n            if n % i == 0 {\n                prime =\
    \ append(prime, i)\n            }\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr7yeid96_test.go:19:11: no new variables on left side of :=

    /tmp/tmpr7yeid96_test.go:20:11: no new variables on left side of :=

    /tmp/tmpr7yeid96_test.go:21:11: no new variables on left side of :=

    /tmp/tmpr7yeid96_test.go:22:11: no new variables on left side of :=

    /tmp/tmpr7yeid96_test.go:23:11: no new variables on left side of :=

    /tmp/tmpr7yeid96_test.go:24:11: no new variables on left side of :=

    /tmp/tmpr7yeid96_test.go:25:11: no new variables on left side of :=

    /tmp/tmpr7yeid96_test.go:26:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075178
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[len(prime)-1]-1]\
    \ == i {\n            prime = append(prime, i)\n        } else {\n           \
    \ prime = append(prime, i+1)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpacqrg9sg_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpacqrg9sg_test.go:36\
    \ +0xfbd\ntesting.tRunner(0xc0001a01a0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075179
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for _, j := range prime {\n            if i%j == 0 {\n   \
    \             break\n            }\n        }\n        if i == n {\n         \
    \   prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplohxn5zl_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[0]-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 1;\
    \ j < i; j++ {\n            if prime[j-1] != 0 {\n                break\n    \
    \        }\n            if i%prime[j] == 0 {\n                prime = append(prime,\
    \ i)\n                break\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpul_5ur_c_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpul_5ur_c_test.go:43\
    \ +0x14f9\ntesting.tRunner(0xc0001924e0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075179
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n  \
    \              break\n            }\n        }\n        if j > i {\n         \
    \   prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0a31r1we_test.go:19:11: no new variables on left side of :=

    /tmp/tmp0a31r1we_test.go:26:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    for i := 2; i < n; i++ {\n        if n%i == 0\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpf84zf8ug_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3\
    \ (0.00s)\n        tmpf84zf8ug_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]', got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmpf84zf8ug_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=2)\
    \ %!s(int=11)]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=2) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpf84zf8ug_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    for i := 2; i < n; i++ {\n        for j := 2;\
    \ j < i; j++ {\n            if i%j == 0 {\n                break\n           \
    \ }\n        }\n        if i == j {\n            prime = append(prime, i)\n  \
    \      }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2jfo4vzw_test.go:25:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075178
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j == i {\n            prime = append(prime, i)\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsa0qidrz_test.go:19:11: no new variables on left side of :=

    /tmp/tmpsa0qidrz_test.go:20:11: no new variables on left side of :=

    /tmp/tmpsa0qidrz_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[0]-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 0;\
    \ j < i; j++ {\n            if prime[j] == 0 {\n                prime = append(prime,\
    \ j)\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpj4c8xbne_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpj4c8xbne_test.go:39\
    \ +0x1254\ntesting.tRunner(0xc0001a01a0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075177
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i < n; i++ {\n        for j := 2; j < i; j++ {\n       \
    \     if i % j == 0 {\n                break\n            }\n        }\n     \
    \   if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmrmatpua_test.go:19:11: no new variables on left side of :=

    /tmp/tmpmrmatpua_test.go:20:11: no new variables on left side of :=

    /tmp/tmpmrmatpua_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075178
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j == i {\n            prime = append(prime, i)\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsa0qidrz_test.go:19:11: no new variables on left side of :=

    /tmp/tmpsa0qidrz_test.go:20:11: no new variables on left side of :=

    /tmp/tmpsa0qidrz_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n  \
    \              break\n            }\n        }\n        if j > i {\n         \
    \   prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphwtg6kg2_test.go:19:11: no new variables on left side of :=

    /tmp/tmphwtg6kg2_test.go:26:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[0]-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 1;\
    \ j < i; j++ {\n            if prime[j-1] == 0 {\n                prime = append(prime,\
    \ j)\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpurl608ba_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpurl608ba_test.go:39\
    \ +0x1274\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 43)\n    prime := append(prime, 59)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 281)\n    prime := append(prime, 283)\n    prime := append(prime,\
    \ \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz0nabs0u_test.go:76:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, n)\n    prime[0] = prime[1] = 1\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              for k := j; k < i; k++ {\n                    prime[k] = i\n  \
    \              }\n                break\n            }\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvfa2l62m_test.go:19:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 43)\n    prime := append(prime, 49)\n    prime := append(prime, 57)\n    prime\
    \ := append(prime, 61)\n    prime := append(prime, 67)\n    prime := append(prime,\
    \ 73)\n    prime := append(prime, 79)\n    prime := append(prime, 83)\n    prime\
    \ := append(prime, 89)\n    prime := append(prime, 97)\n    prime := append(prime,\
    \ 101)\n    prime := append(prime, 103)\n    prime := append(prime, 107)\n   \
    \ prime := append(prime, 109)\n    prime := append(prime, 113)\n    prime := append(prime,\
    \ 127)\n    prime := append(prime, 131)\n    prime := append(prime, 137)\n   \
    \ prime := append(prime, 139)\n    prime := append(prime, 149)\n    prime := append(prime,\
    \ 151)\n    prime := append(prime, 157)\n    prime := append(prime, 163)\n   \
    \ prime := append(prime, 167)\n    prime := append(prime, 173)\n    prime := append(prime,\
    \ 179)\n    prime := append(prime, 181)\n    prime := append(prime, 191)\n   \
    \ prime := append(prime, 193)\n    prime := append(prime, 197)\n    prime := append(prime,\
    \ 199)\n    prime := append(prime, 211)\n    prime := append(prime, 223)\n   \
    \ prime := append(prime, 227)\n    prime := append(prime, 229)\n    prime := append(prime,\
    \ 233)\n    prime := append(prime, 239)\n    prime := append(prime, 241)\n   \
    \ prime := append(prime, 251)\n    prime := append(prime, 257)\n    prime := append(prime,\
    \ 263)\n    prime := append(prime, 269)\n    prime := append(prime, 271)\n   \
    \ prime := append(prime, 277)\n    prime := append(prime, 281)\n    prime := append(prime,\
    \ \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbrjdn1y1_test.go:76:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075172
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n    \
    \            break\n            }\n        }\n        if i == j {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpitp_xyxd_test.go:19:11: no new variables on left side of :=

    /tmp/tmpitp_xyxd_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n  \
    \              break\n            }\n        }\n        if j == i {\n        \
    \    prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkanll9tb_test.go:19:11: no new variables on left side of :=

    /tmp/tmpkanll9tb_test.go:26:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    for i := 2; i < n; i++ {\n        if n%i == 0\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpf84zf8ug_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3\
    \ (0.00s)\n        tmpf84zf8ug_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]', got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmpf84zf8ug_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=2)\
    \ %!s(int=11)]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=2) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpf84zf8ug_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpf84zf8ug_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n    \
    \            break\n            }\n        }\n        if i == j {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmposnvq3ty_test.go:19:11: no new variables on left side of :=

    /tmp/tmposnvq3ty_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  if n < 2 {\n        return []int{}\n    }\n\n    result := make([]int, 0, n)\n\
    \    prime := make([]bool, len(primes))\n    for i := 0; i < len(primes); i++\
    \ {\n        prime[i] = true\n    }\n\n    for i := 2; i < n; i++ {\n        if\
    \ prime[i] {\n            for j := i * i; j < n; j += i {\n                prime[j]\
    \ = false\n            }\n        }\n    }\n\n    for i := 2; i < n; i++ {\n \
    \       if prime[i] {\n            result = append(result, i)\n        }\n   \
    \ }\n\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvsuhzc9e_test.go:23:31: undefined: primes

    /tmp/tmpvsuhzc9e_test.go:24:25: undefined: primes

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075178
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for _, j := range prime {\n            if i%j == 0 {\n   \
    \             break\n            }\n        }\n        if i == n {\n         \
    \   prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpducm2hny_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075179
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 43)\n    prime := append(prime, 49)\n    prime := append(prime, 57)\n    prime\
    \ := append(prime, 61)\n    prime := append(prime, 67)\n    prime := append(prime,\
    \ 73)\n    prime := append(prime, 79)\n    prime := append(prime, 83)\n    prime\
    \ := append(prime, 89)\n    prime := append(prime, 97)\n    prime := append(prime,\
    \ 101)\n    prime := append(prime, 103)\n    prime := append(prime, 107)\n   \
    \ prime := append(prime, 109)\n    prime := append(prime, 113)\n    prime := append(prime,\
    \ 127)\n    prime := append(prime, 131)\n    prime := append(prime, 137)\n   \
    \ prime := append(prime, 139)\n    prime := append(prime, 149)\n    prime := append(prime,\
    \ 151)\n    prime := append(prime, 157)\n    prime := append(prime, 163)\n   \
    \ prime := append(prime, 167)\n    prime := append(prime, 173)\n    prime := append(prime,\
    \ 179)\n    prime := append(prime, 181)\n    prime := append(prime, 191)\n   \
    \ prime := append(prime, 193)\n    prime := append(prime, 197)\n    prime := append(prime,\
    \ 199)\n    prime := append(prime, 211)\n    prime := append(prime, 223)\n   \
    \ prime := append(prime, 227)\n    prime := append(prime, 229)\n    prime := append(prime,\
    \ 233)\n    prime := append(prime, 239)\n    prime := append(prime, 241)\n   \
    \ prime := append(prime, 251)\n    prime := append(prime, 257)\n    prime := append(prime,\
    \ 263)\n    prime := append(prime, 269)\n    prime := append(prime, 271)\n   \
    \ prime := append(prime, 277)\n    prime := append(prime, 281)\n    prime := append(prime,\
    \ \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbrjdn1y1_test.go:76:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075172
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i < n; i++ {\n        for j := 2; j < i; j++ {\n       \
    \     if i%j == 0 {\n                break\n            }\n        }\n       \
    \ if i == j {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmdjvl8m8_test.go:19:11: no new variables on left side of :=

    /tmp/tmpmdjvl8m8_test.go:20:11: no new variables on left side of :=

    /tmp/tmpmdjvl8m8_test.go:27:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075179
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n  \
    \              break\n            }\n        }\n        if j > i {\n         \
    \   prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0a31r1we_test.go:19:11: no new variables on left side of :=

    /tmp/tmp0a31r1we_test.go:26:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n        if prime[prime[0]-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 1;\
    \ j < i; j++ {\n            if i%prime[j] == 0 {\n                break\n    \
    \        }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpwa6wu2s0_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpwa6wu2s0_test.go:39\
    \ +0x10ce\ntesting.tRunner(0xc0001a01a0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075179
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n  \
    \              break\n            }\n        }\n        if i == j {\n        \
    \    prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp87cta426_test.go:19:11: no new variables on left side of :=

    /tmp/tmp87cta426_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[len(prime)-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 0;\
    \ j < i; j++ {\n            if i%prime[j] == 0 {\n                break\n    \
    \        }\n            if j == len(prime)-1 {\n                prime = append(prime,\
    \ i)\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp4ge4fon__test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp4ge4fon__test.go:42\
    \ +0x13dd\ntesting.tRunner(0xc0001924e0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075179
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        if isPrime(i) {\n            prime = append(prime, i)\n  \
    \      }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_zc79l5w_test.go:19:11: no new variables on left side of :=

    /tmp/tmp_zc79l5w_test.go:21:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075179
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n    \
    \            break\n            }\n        }\n        if i == j {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmposnvq3ty_test.go:19:11: no new variables on left side of :=

    /tmp/tmposnvq3ty_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n  \
    \              break\n            }\n        }\n        if j > i {\n         \
    \   prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphwtg6kg2_test.go:19:11: no new variables on left side of :=

    /tmp/tmphwtg6kg2_test.go:26:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for _, j := range prime {\n            if j%i == 0 {\n   \
    \             break\n            }\n            if i == j {\n                prime\
    \ = append(prime, i)\n                break\n            }\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgsahzfsm_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075179
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 43)\n    prime := append(prime, 59)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 281)\n    prime := append(prime, 283)\n    prime := append(prime,\
    \ \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz0nabs0u_test.go:76:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for _, j := range prime {\n            if i%j == 0 {\n   \
    \             break\n            }\n            if j > i {\n                break\n\
    \            }\n            prime = append(prime, j)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp60l6_bcc_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075179
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n    \
    \            break\n            }\n        }\n        if i == j {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpitp_xyxd_test.go:19:11: no new variables on left side of :=

    /tmp/tmpitp_xyxd_test.go:26:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n  \
    \              break\n            }\n        }\n        if j > i {\n         \
    \   prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0a31r1we_test.go:19:11: no new variables on left side of :=

    /tmp/tmp0a31r1we_test.go:26:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  if n < 2 {\n        return []\n    }\n    prime := make([]int, 0, n)\n    for\
    \ i := 2; i < n; i++ {\n        if prime[prime[len(prime)-1]-1] != i {\n     \
    \       prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjtdhiwkm_test.go:19:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075178
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j == i {\n            prime = append(prime, i)\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsa0qidrz_test.go:19:11: no new variables on left side of :=

    /tmp/tmpsa0qidrz_test.go:20:11: no new variables on left side of :=

    /tmp/tmpsa0qidrz_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    for i := 2; i < n; i++ {\n        if isPrime(i)\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmipbqck6_test.go:20:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[0]-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 0;\
    \ j < i; j++ {\n            if prime[j] == 0 {\n                prime = append(prime,\
    \ j)\n                break\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpy1o8g3o4_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpy1o8g3o4_test.go:40\
    \ +0x12b6\ntesting.tRunner(0xc00019a680, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    if n < 0 {\n        return nil\n  \
    \  }\n    for i := 3; i <= n; i++ {\n        if prime[i] == true {\n         \
    \   prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphyh0j4_u_test.go:19:11: no new variables on left side of :=

    /tmp/tmphyh0j4_u_test.go:20:11: no new variables on left side of :=

    /tmp/tmphyh0j4_u_test.go:21:11: no new variables on left side of :=

    /tmp/tmphyh0j4_u_test.go:22:11: no new variables on left side of :=

    /tmp/tmphyh0j4_u_test.go:23:11: no new variables on left side of :=

    /tmp/tmphyh0j4_u_test.go:24:11: no new variables on left side of :=

    /tmp/tmphyh0j4_u_test.go:25:11: no new variables on left side of :=

    /tmp/tmphyh0j4_u_test.go:26:11: no new variables on left side of :=

    /tmp/tmphyh0j4_u_test.go:31:24: invalid operation: prime[i] == true (mismatched
    types int and untyped bool)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075179
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 43)\n    prime := append(prime, 49)\n    prime := append(prime, 57)\n    prime\
    \ := append(prime, 61)\n    prime := append(prime, 67)\n    prime := append(prime,\
    \ 73)\n    prime := append(prime, 79)\n    prime := append(prime, 83)\n    prime\
    \ := append(prime, 89)\n    prime := append(prime, 97)\n    prime := append(prime,\
    \ 101)\n    prime := append(prime, 103)\n    prime := append(prime, 107)\n   \
    \ prime := append(prime, 109)\n    prime := append(prime, 113)\n    prime := append(prime,\
    \ 127)\n    prime := append(prime, 131)\n    prime := append(prime, 137)\n   \
    \ prime := append(prime, 139)\n    prime := append(prime, 149)\n    prime := append(prime,\
    \ 151)\n    prime := append(prime, 157)\n    prime := append(prime, 163)\n   \
    \ prime := append(prime, 167)\n    prime := append(prime, 173)\n    prime := append(prime,\
    \ 179)\n    prime := append(prime, 181)\n    prime := append(prime, 191)\n   \
    \ prime := append(prime, 193)\n    prime := append(prime, 197)\n    prime := append(prime,\
    \ 199)\n    prime := append(prime, 211)\n    prime := append(prime, 223)\n   \
    \ prime := append(prime, 227)\n    prime := append(prime, 229)\n    prime := append(prime,\
    \ 233)\n    prime := append(prime, 239)\n    prime := append(prime, 241)\n   \
    \ prime := append(prime, 243)\n    prime := append(prime, 247)\n    prime := append(prime,\
    \ 251)\n    prime := append(prime, 257)\n    prime := append(prime, 263)\n   \
    \ prime := append(prime, 269)\n    prime := append(prime, 271)\n    prime := append(prime,\
    \ \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbc6hdfup_test.go:76:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075174
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        if i%2 == 0 {\n            continue\n\
    \        }\n        for j := 3; j < i; j++ {\n            if i%j == 0 {\n    \
    \            break\n            }\n            if j%i == 0 {\n               \
    \ prime = append(prime, j)\n                break\n            }\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp47400nov_test.go:19:11: no new variables on left side of :=

    /tmp/tmp47400nov_test.go:20:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075179
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[len(prime)-1]-1]\
    \ < i {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmprigy1qaf_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmprigy1qaf_test.go:34\
    \ +0xddd\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075177
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    for i := 2; i <= n; i++ {\n        if i%2 == 0\
    \ {\n            continue\n        }\n        for j := 3; j < i; j++ {\n     \
    \       if i%j == 0 {\n                break\n            }\n        }\n     \
    \   if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc4ede0q0_test.go:28:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075179
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i < n; i++ {\n        for j := 2; j < i; j++ {\n       \
    \     if i % j == 0 {\n                break\n            }\n        }\n     \
    \   if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmrmatpua_test.go:19:11: no new variables on left side of :=

    /tmp/tmpmrmatpua_test.go:20:11: no new variables on left side of :=

    /tmp/tmpmrmatpua_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075178
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    prime := append(prime, 23)\n    prime\
    \ := append(prime, 29)\n    prime := append(prime, 31)\n    prime := append(prime,\
    \ 37)\n    prime := append(prime, 43)\n    prime := append(prime, 49)\n    prime\
    \ := append(prime, 57)\n    prime := append(prime, 61)\n    prime := append(prime,\
    \ 67)\n    prime := append(prime, 73)\n    prime := append(prime, 79)\n    prime\
    \ := append(prime, 83)\n    prime := append(prime, 89)\n    prime := append(prime,\
    \ 97)\n    prime := append(prime, 101)\n    prime := append(prime, 103)\n    prime\
    \ := append(prime, 107)\n    prime := append(prime, 109)\n    prime := append(prime,\
    \ 113)\n    prime := append(prime, 127)\n    prime := append(prime, 131)\n   \
    \ prime := append(prime, 137)\n    prime := append(prime, 139)\n    prime := append(prime,\
    \ 149)\n    prime := append(prime, 151)\n    prime := append(prime, 157)\n   \
    \ prime := append(prime, 163)\n    prime := append(prime, 167)\n    prime := append(prime,\
    \ 173)\n    prime := append(prime, 179)\n    prime := append(prime, 181)\n   \
    \ prime := append(prime, 191)\n    prime := append(prime, 193)\n    prime := append(prime,\
    \ 197)\n    prime := append(prime, 199)\n    prime := append(prime, 211)\n   \
    \ prime := append(prime, 223)\n    prime := append(prime, 227)\n    prime := append(prime,\
    \ 229)\n    prime := append(prime, 233)\n    prime := append(prime, 239)\n   \
    \ prime := append(prime, 241)\n    prime := append(prime, 243)\n    prime := append(prime,\
    \ 247)\n    prime := append(prime, 251)\n    prime := append(prime, 257)\n   \
    \ prime := append(prime, 263)\n    prime := append(prime, 269)\n    prime := append(prime,\
    \ 27\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4mztucx_test.go:75:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075179
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    prime := append(prime, 5)\n    prime := append(prime, 7)\n    prime\
    \ := append(prime, 11)\n    prime := append(prime, 13)\n    prime := append(prime,\
    \ 17)\n    prime := append(prime, 19)\n    if n <= 0 {\n        return nil\n \
    \   }\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n     \
    \       if i % j == 0 {\n                break\n            }\n        }\n   \
    \     if j > i {\n            prime = append(prime, i)\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3zw1881x_test.go:19:11: no new variables on left side of :=

    /tmp/tmp3zw1881x_test.go:20:11: no new variables on left side of :=

    /tmp/tmp3zw1881x_test.go:21:11: no new variables on left side of :=

    /tmp/tmp3zw1881x_test.go:22:11: no new variables on left side of :=

    /tmp/tmp3zw1881x_test.go:23:11: no new variables on left side of :=

    /tmp/tmp3zw1881x_test.go:24:11: no new variables on left side of :=

    /tmp/tmp3zw1881x_test.go:25:11: no new variables on left side of :=

    /tmp/tmp3zw1881x_test.go:26:11: no new variables on left side of :=

    /tmp/tmp3zw1881x_test.go:36:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075179
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j == i {\n            prime = append(prime, i)\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnmlxdij7_test.go:19:11: no new variables on left side of :=

    /tmp/tmpnmlxdij7_test.go:20:11: no new variables on left side of :=

    /tmp/tmpnmlxdij7_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075179
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j == i {\n            prime = append(prime, i)\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsa0qidrz_test.go:19:11: no new variables on left side of :=

    /tmp/tmpsa0qidrz_test.go:20:11: no new variables on left side of :=

    /tmp/tmpsa0qidrz_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        if i%2 == 0 {\n            continue\n        }\n        for\
    \ j := 3; j*j <= i; j++ {\n            if i%j == 0 {\n                prime =\
    \ append(prime, i)\n                break\n            }\n        }\n    }\n \
    \   return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptkh9m6v8_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n        for j :=\
    \ 2; j < i; j++ {\n            if i%j == 0 {\n                break\n        \
    \    }\n        }\n        if i == n {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmph15xz7k5_test.go:54: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmph15xz7k5_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=6)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmph15xz7k5_test.go:54:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=7)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__3 (0.00s)\n        tmph15xz7k5_test.go:54: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=10)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmph15xz7k5_test.go:54: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[%!s(int=22)]'\n    --- FAIL: TestCount_Up_To/test_num__7\
    \ (0.00s)\n        tmph15xz7k5_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=18)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmph15xz7k5_test.go:54: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[%!s(int=47)]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n   \
    \     tmph15xz7k5_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31)\
    \ %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61)\
    \ %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]',\
    \ got '[%!s(int=101)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075179
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[0]-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 0;\
    \ j < i; j++ {\n            if prime[j] == 0 {\n                prime = append(prime,\
    \ j)\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpj4c8xbne_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpj4c8xbne_test.go:39\
    \ +0x1254\ntesting.tRunner(0xc0001a01a0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075177
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        for _, j := range prime {\n            if i%j == 0 {\n   \
    \             break\n            }\n        }\n        if i == n {\n         \
    \   prime = append(prime, n)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpscdk1iuv_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <=\
    \ n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n  \
    \              break\n            }\n        }\n        if j > i {\n         \
    \   prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0a31r1we_test.go:19:11: no new variables on left side of :=

    /tmp/tmp0a31r1we_test.go:26:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i := 3; i <\
    \ n; i++ {\n        if prime[prime[len(prime)-1]-1] == i {\n            prime\
    \ = append(prime, i)\n        } else {\n            prime = append(prime, i+1)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpegdoxfw8_test.go:19:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if i == j {\n            prime = append(prime, i)\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt9crj9vl_test.go:19:11: no new variables on left side of :=

    /tmp/tmpt9crj9vl_test.go:20:11: no new variables on left side of :=

    /tmp/tmpt9crj9vl_test.go:27:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, n)\n    for i := 0; i < n; i++ {\n        prime[i] = i\n\
    \    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < i; j++ {\n     \
    \       if prime[j] >= i {\n                break\n            }\n           \
    \ if prime[j] == i {\n                prime[j] = i\n                break\n  \
    \          }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpyavjrqy5_test.go:58: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpyavjrqy5_test.go:58: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpyavjrqy5_test.go:58: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpyavjrqy5_test.go:58:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpyavjrqy5_test.go:58:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpyavjrqy5_test.go:58: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpyavjrqy5_test.go:58:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpyavjrqy5_test.go:58:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075179
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0)\
    \ => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n\
    // count_up_to(18) => [2,3,5,7,11,13,17]\nfunc count_up_to(n int) []int {\n  \
    \  prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime := append(prime,\
    \ 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i; j++ {\n      \
    \      if i % j == 0 {\n                break\n            }\n        }\n    \
    \    if j > i {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bumvecg_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:20:11: no new variables on left side of :=

    /tmp/tmp4bumvecg_test.go:27:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075173
