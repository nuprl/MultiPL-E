language: go_test.go
name: HumanEval_10_make_palindrome
results:
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome += myString[i]\n\
    \    }\n    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n\
    \    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    longestPalindrome = longestPalindrome +\
    \ string([]rune(longestPalindrome)[len(longestPalindrome)-1:])\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwr2tc7pj_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength = 0\n        longestPalindrome = myString\n\
    \        for j := 0; j < len(myString); j++ {\n            if myString[j] != myString[len(myString)-1-j]\
    \ {\n                longestPalindromeLength++\n                longestPalindrome\
    \ = myString[:j+1] + myString[len(myString)-1-j:]\n                break\n   \
    \         }\n        }\n        if longestPalindromeLength > longestPalindromeLength\
    \ {\n            longestPalindrome = myString[:i+1] + myString[len(myString)-1-i:len(myString)]\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmpzin3xyg2_test.go:55: expected 'xyzyx', got 'xz'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpzin3xyg2_test.go:55:\
    \ expected 'jerryrrej', got 'jy'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075493
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        postfix := myString[longestPalindromeLen:]\
    \ + myString[:i]\n        postfix := append(postfix, myString[len(myString) -\
    \ i - 1])\n        postfix := append(postfix, myString[len(myString) - i - 1])\n\
    \        postfix := append(postfix, myString[len(myString) - i - 1])\n       \
    \ postfix := append(postfix, myString[len(myString) - i - 1])\n        postfix\
    \ := append(postfix, myString[len(myString) - i - 1])\n        postfix := append(postfix,\
    \ myString[len(myString) - i - 1])\n        postfix := append(postfix, myString[len(myString)\
    \ - i - 1])\n        postfix := append(postfix, myString[len(myString) - i - 1])\n\
    \        postfix := append(postfix, myString[len(myString) - i - 1])\n       \
    \ postfix := append(postfix, myString[len(myString) - i - 1])\n        postfix\
    \ := append(postfix, myString[len(myString) - i - 1])\n        postfix := append(postfix,\
    \ myString[len(myString) - i - 1])\n        postfix := append(postfix, myString[len(myString)\
    \ - i - 1])\n        postfix := append(postfix, myString[len(myString) - i - 1])\n\
    \        postfix := append(postfix, myString[len(myString) - i - 1])\n       \
    \ postfix := append(postfix, myString[len(myString) - i - 1])\n        postfix\
    \ := append(postfix, myString[len(myString) - i - 1])\n        postfix := append(postfix,\
    \ myString[len(myString) - i - 1])\n        postfix := append(postfix, myString[len(myString)\
    \ - i - 1])\n        postfix := append(postfix, myString[len(myString) - i - 1])\n\
    \        postfix := append(postfix, myString\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbwepao6g_test.go:53:44: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n\
    \        if isPalindrome(prefix, suffix) {\n            longestPalindrome = prefix\
    \ + suffix\n            longestPalindromeLen = len(longestPalindrome)\n      \
    \  }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnacz9t8b_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpnacz9t8b_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    // The longest postfix is found\
    \ by reversing all characters before it.\n    // The longest postfix is found\
    \ by reversing all characters before it.\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindrome += myString[len(myString)-1:]\n\
    \    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('cat')\n    // 'catac'\n\
    \    // >>> make_palindrome('cata')\n    // 'catac'\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjzpm1y50_test.go:28:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    // This will be the longest palindrome\
    \ that begins with myString.\n    // The longest postfix is found by reversing\
    \ myString and finding the\n    // longest prefix that comes before myString that\
    \ is a palindrome.\n    // The longest prefix is found by finding the longest\
    \ prefix of myString that is a palindrome.\n    // The longest prefix of myString\
    \ that is a palindrome is found by finding the longest prefix of myString that\
    \ is a palindrome.\n    // The longest prefix of myString that is a palindrome\
    \ is found by finding the longest prefix of myString that is a palindrome.\n \
    \   // The longest prefix of myString that is a palindrome is found by finding\
    \ the longest prefix of myString that is a palindrome.\n    // The longest prefix\
    \ of myString that is a palindrome is found by finding the longest prefix of myString\
    \ that is a palindrome.\n    // The longest prefix of myString that is a palindrome\
    \ is found by finding the longest prefix of myString that is a palindrome.\n \
    \   // The longest prefix of myString that is a palindrome is found by finding\
    \ the longest prefix of myString that is a palindrome.\n    // The longest prefix\
    \ of myString that is a palindrome is found by finding the longest prefix of myString\
    \ that is a palindrome.\n    // The longest prefix of myString that is a palindrome\
    \ is found by finding the longest prefix of myString that is a palindrome.\n \
    \   // The longest prefix of myString that is a palindrome is found by finding\
    \ the longest prefix of myString that is a palindrome.\n    // The longest prefix\
    \ of myString that is a palindrome is found by finding the longest prefix of myString\
    \ that is a palindrome.\n    // The longest prefix of myString that is a palindrome\
    \ is found by finding the longest prefix of myString that is a palindrome.\n \
    \   // The longest prefix of myString that is a palindrome is found by finding\
    \ the longest prefix of myString that is a palindrome.\n    // The longest prefix\
    \ of myString that is a palindrome is found by finding the longest prefix of myString\
    \ that is a palindrome.\n    // The longest prefix of myString \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9g0qeszs_test.go:38:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLength := len(myString)\n\
    \    for i := 0; i < longestPalindromeLength; i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    for i := 0; i < longestPalindromeLength; i++ {\n\
    \        longestPalindrome += myString[len(myString)-(i+1)]\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaegyjeug_test.go:21:29: no new variables on left side of :=

    /tmp/tmpaegyjeug_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpaegyjeug_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - (i + 1)] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix) {\n \
    \           longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    prefix := myString[:longestPalindromeLen]\n\
    \    suffix := myString[longestPalindromeLen:]\n    return prefix + reverse(suffix)\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdq8en_cw_test.go:20:5: longestPalindrome declared but not used

    /tmp/tmpdq8en_cw_test.go:24:12: undefined: isPalindrome

    /tmp/tmpdq8en_cw_test.go:33:21: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n \
    \       postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-len(postfix):]...)\n        postfix := append(postfix,\
    \ myString[:len(myString)-len(postfix)]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-len(postfix):]...)\n        postfix := append(postfix,\
    \ myString[:len(myString)-len(postfix)]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-len(postfix):]...)\n        postfix := append(postfix,\
    \ myString[:len(myString)-len(postfix)]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-len(postfix):]...)\n        postfix := append(postfix,\
    \ myString[:len(myString)-len(postfix)]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-len(postfix):]...)\n        postfix := append(postfix,\
    \ myString[:len(myString)-len(postfix)]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-len(postfix):]...)\n        postfix := append(postfix,\
    \ myString[:len(myString)-len(postfix)]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-len(postfix):]...)\n        postfix := append(postfix,\
    \ myString[:len(myString)-len(postfix)]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-len(postfix):]...)\n        postfix := append(postfix,\
    \ myString[:len(myString)-len(postfix)]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-len(postfix):]...)\n        postfix := append(postfi\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpksfqdt8q_test.go:51:33: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        thisChar := myString[i]\n        thisLen := 1\n        for j := 0;\
    \ j < i; j++ {\n            if thisChar == myString[j] {\n                thisLen++\n\
    \            } else {\n                break\n            }\n        }\n     \
    \   if thisLen > longestPalindromeLen {\n            longestPalindrome = myString[0:i]\n\
    \            longestPalindromeLen = thisLen\n        }\n    }\n    // Append to\
    \ the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    thisLen := len(myString)\n    for i := 0; i < longestPalindromeLen;\
    \ i++ {\n        thisChar := myString[thisLen-i]\n        thisLen -= 1\n     \
    \   if thisLen > 0 {\n            thisChar = myString[thisLen]\n            thisLen++\n\
    \        }\n        myString = myString + thisChar\n    }\n    return myString\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4s10nz4e_test.go:20:5: longestPalindrome declared but not used

    /tmp/tmp4s10nz4e_test.go:46:20: invalid operation: myString + thisChar (mismatched
    types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[longestPalindromeLen:i]\n        postfix += myString[longestPalindromeLen:i]\n\
    \        postfix += myString[longestPalindromeLen:i]\n        postfix += myString[longestPalindromeLen:i]\n\
    \        postfix += myString[longestPalindromeLen:i]\n        postfix += myString[longestPalindromeLen:i]\n\
    \        postfix += myString[longestPalindromeLen:i]\n        postfix += myString[longestPalindromeLen:i]\n\
    \        postfix += myString[longestPalindromeLen:i]\n        postfix += myString[longestPalindromeLen:i]\n\
    \        postfix += myString[longestPalindromeLen:i]\n        postfix += myString[longestPalindromeLen:i]\n\
    \        postfix += myString[longestPalindromeLen:i]\n        postfix += myString[longestPalindromeLen:i]\n\
    \        postfix += myString[longestPalindromeLen:i]\n        postfix += myString[longestPalindromeLen:i]\n\
    \        postfix += myString[longestPalindromeLen:i]\n        postfix += myString[longestPalindromeLen:i]\n\
    \        postfix += myString[longestPalindromeLen:i]\n        postfix += myString[longestPalindromeLen:i]\n\
    \        postfix += myString[longestPalindromeLen:i]\n        postfix += myString[longestPalindromeLen:i]\n\
    \        postfix += myString[longestPalindromeLen:i]\n        postfix += myString[longestPalindromeLen:i]\n\
    \        postfix += myString[longestPalindromeLen:i]\n        postfix += myString[longestPalindromeLen:i]\n\
    \        postfix += myString[longestPalindromeLen:i]\n        postfix += myString[longestPalindromeLen:i]\n\
    \        postfix += myString[longestPalindromeLen:i]\n        postfix += myString[longestPalindromeLen:i]\n\
    \        \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5qsyrlic_test.go:53:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[longestPalindromeLen:i]\n        postfix += myString[:longestPalindromeLen]\n\
    \        postfix += myString[len(myString)-i:len(myString)]\n        postfix +=\
    \ myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbgcispv6_test.go:55:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome('')\n\
    \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindrom\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpizt9x9ox_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    var longestPalindrome string = \"\"\n    var longestPalindromeLen\
    \ int = 0\n    for i := 0; i < len(myString); i++ {\n        longestPalindromeLen\
    \ += 1\n        longestPalindrome += myString[i]\n    }\n    \n    // Append to\
    \ the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    var reversedString string = \"\"\n    for i := 0; i < longestPalindromeLen;\
    \ i++ {\n        reversedString += myString[len(myString)-(i+1)]\n    }\n    \n\
    \    // Return the palindrome string.\n    return reversedString + longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjyt5eoog_test.go:35:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpjyt5eoog_test.go:41:9: invalid operation: reversedString += myString[len(myString)
    - (i + 1)] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < i; j++ {\n   \
    \         if myString[j] != myString[len(myString)-j-1] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr5r6w7wx_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Initialize\
    \ a variable to store the longest postfix of myString\n    var longestPostfix\
    \ string\n    // Initialize a variable to store the reverse of myString\n    var\
    \ reverseOfMyString string\n    // Initialize a variable to store the length of\
    \ the longest postfix of myString\n    var longestPostfixLength int\n    // Initialize\
    \ a variable to store the length of the reverse of myString\n    var reverseOfMyStringLength\
    \ int\n    // Initialize a variable to store the length of the longest postfix\
    \ of myString\n    var longestPostfixLength2 int\n    // Initialize a variable\
    \ to store the length of the reverse of myString\n    var reverseOfMyStringLength2\
    \ int\n    // Initialize a variable to store the length of the longest postfix\
    \ of myString\n    var longestPostfixLength3 int\n    // Initialize a variable\
    \ to store the length of the reverse of myString\n    var reverseOfMyStringLength3\
    \ int\n    // Initialize a variable to store the length of the longest postfix\
    \ of myString\n    var longestPostfixLength4 int\n    // Initialize a variable\
    \ to store the length of the reverse of myString\n    var reverseOfMyStringLength4\
    \ int\n    // Initialize a variable to store the length of the longest postfix\
    \ of myString\n    var longestPostfixLength5 int\n    // Initialize a variable\
    \ to store the length of the reverse of myString\n    var reverseOfMyStringLength5\
    \ int\n    // Initialize a variable to store the length of the longest postfix\
    \ of myString\n    var longestPostfixLength6 int\n    // Initialize a variable\
    \ to store the length of the reverse of myString\n    var reverseOfMyStringLength6\
    \ int\n    // Initialize a variable to store the length of the longest postfix\
    \ of myString\n    var longestPostfixLength7 int\n    // Initialize a variable\
    \ to store the length of the reverse of myString\n    var reverseOfMyStringLength7\
    \ int\n    // Initialize a variable to store the length of the longest postfix\
    \ of myString\n    var longestPostfixLength8 int\n    // Initialize a variable\
    \ to store the length of the reverse of myString\n    var reverseOfMyStringLength8\
    \ int\n    // Initialize a variable to store the length of the longest postfix\
    \ of myString\n    var longestPostfixLength9 int\n    // Initialize a variable\
    \ to store the length of the reverse of myString\n    var reverseOfMyStringLength9\
    \ int\n    // Initialize a variable to store the length of the longest postfix\
    \ of myString\n    var longestPostfixLength10 int\n    // Initialize a variable\
    \ to store the length of the reverse of myString\n    var reverseOfMyStringLength10\
    \ int\n    // Initialize a variable to store the length of the longest postfix\
    \ of myString\n    var longestPostfixLength11 int\n    // Initialize a variable\
    \ to store the length of the reverse of myString\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ct5rpyg_test.go:66:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    longestPalindrome := \"\"\n \
    \   longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i-- {\n\
    \        postfix := myString[:i+1]\n        if isPalindrome(postfix) {\n     \
    \       longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n\n    // Append the reverse of the string prefix that comes\
    \ before the palindromic suffix.\n    prefix := myString[:longestPalindromeLen]\n\
    \    return prefix + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo7lpx_ox_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    // This will be the longest palindrome\
    \ that starts with myString.\n    // The longest palindrome is one that ends with\
    \ myString and begins with myString's reverse.\n    // This algorithm is O(n).\n\
    \    // The longest palindrome is one that ends with myString and begins with\
    \ myString's reverse.\n    // This algorithm is O(n).\n    longestPalindrome :=\
    \ \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[:i]\n        reverse := myString[len(postfix):]\n\
    \        if myString[len(postfix)] != myString[len(reverse)] {\n            longestPalindrome\
    \ = \"\"\n            longestPalindromeLen = 0\n            break\n        }\n\
    \        longestPalindrome = append(longestPalindrome, postfix)\n        longestPalindromeLen\
    \ = len(longestPalindrome)\n    }\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // This algorithm\
    \ is O(n).\n    longestPalindrome = append(longestPalindrome, myString[len(longestPalindrome):]...)\n\
    \    // Return longest palindrome that starts with myString.\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptwwa7mvy_test.go:26:5: longestPalindromeLen declared but not used

    /tmp/tmptwwa7mvy_test.go:35:36: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    /tmp/tmptwwa7mvy_test.go:40:32: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        longestPalindromeLen += len(myString)\
    \ - i\n        longestPalindrome += myString[:i]\n        longestPalindrome +=\
    \ myString[len(myString) - i:len(myString)]\n    }\n    longestPalindromeLen -=\
    \ len(myString)\n    longestPalindrome += myString\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmpe28upbce_test.go:58: expected 'xyzyx', got 'xzxyyzxyz'\n\
    \    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpe28upbce_test.go:58:\
    \ expected 'xyx', got 'xxxyyxxyx'\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmpe28upbce_test.go:58: expected 'jerryrrej', got 'jyjeryjerrryjerrerryjerry'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n  \
    \      suffix := myString[i:]\n        if suffix == reverse(prefix) {\n      \
    \      longestPalindrome = prefix + suffix\n            longestPalindromeLen +=\
    \ len(longestPalindrome)\n        }\n    }\n    return longestPalindrome\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqhxbagve_test.go:25:22: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[longestPalindromeLen:] + myString[:longestPalindromeLen]\n\
    \        if postfix != make_palindrome(postfix) {\n            longestPalindrome\
    \ = \"\"\n            longestPalindromeLen = 0\n        }\n        longestPalindrome\
    \ += myString[i]\n        longestPalindromeLen++\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd4clw3le_test.go:27:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        postfix := myString[i:]\n        postfix += myString[:i]\n  \
    \      postfix += myString[i:] + myString[:i]\n        postfix += myString[:i]\
    \ + myString[i:]\n        postfix += myString[:i] + myString[i:] + myString[:i]\n\
    \        postfix += myString[:i] + myString[i:] + myString[:i] + myString[i:]\n\
    \        postfix += myString[:i] + myString[i:] + myString[:i] + myString[i:]\
    \ + myString[:i]\n        postfix += myString[:i] + myString[i:] + myString[:i]\
    \ + myString[i:] + myString[:i] + myString[i:]\n        postfix += myString[:i]\
    \ + myString[i:] + myString[:i] + myString[i:] + myString[:i] + myString[i:] +\
    \ myString[:i]\n        postfix += myString[:i] + myString[i:] + myString[:i]\
    \ + myString[i:] + myString[:i] + myString[i:] + myString[:i] + myString[i:]\n\
    \        postfix += myString[:i] + myString[i:] + myString[:i] + myString[i:]\
    \ + myString[:i] + myString[i:] + myString[:i] + myString[i:] + myString[:i]\n\
    \        postfix += myString[:i] + myString[i:] + myString[:i] + myString[i:]\
    \ + myString[:i] + myString[i:] + myString[:i] + myString[i:] + myString[:i] +\
    \ myString[i:]\n        postfix += myString[:i] + myString[i:] + myString[:i]\
    \ + myString[i:] + myString[:i] + myString[i:] + myString[:i] + myString[i:] +\
    \ myString[:i] + myString[i:] + myString[:i]\n        postfix += myString[:i]\
    \ + myString[i:] + myString[:i] + myString[i:] + myString[:i] + myString[i:] +\
    \ myString[:i] + myString[i:] + myString[:i] + myString[i:] + myString[:i] + myString[i:]\n\
    \        postfix += myString[:i] + myString[i:] + myString[:i] + \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpya6jxr4f_test.go:37:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString)\
    \ - 1; i >= 0; i-- {\n        longestPalindrome += myString[i]\n    }\n    \n\
    \    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    longestPalindrome += myString[len(longestPalindrome):]\n\
    \    \n    // Return the result.\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprokxqvdv_test.go:33:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n      \
    \  longestPalindrome += myString[len(myString)-i-1]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqpaome4o_test.go:21:26: no new variables on left side of :=

    /tmp/tmpqpaome4o_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpqpaome4o_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    var longestPalindrome string = \"\"\n    for i := 0; i\
    \ < len(myString); i++ {\n        longestPalindrome += myString[i]\n    }\n  \
    \  \n    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    for i := 0; i < len(longestPalindrome);\
    \ i++ {\n        if myString[len(myString)-len(longestPalindrome)+i] != longestPalindrome[i]\
    \ {\n            longestPalindrome += myString[len(myString)-len(longestPalindrome)+i][len(myString)-len(longestPalindrome)-i:]\n\
    \        }\n    }\n    \n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzg1wdke3_test.go:33:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpzg1wdke3_test.go:39:34: invalid operation: cannot slice myString[len(myString)
    - len(longestPalindrome) + i] (value of type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n      \
    \  postfix := longestPalindrome[:longestPalindromeLen]\n        longestPalindromeLen\
    \ += len(postfix)\n        if suffix == postfix {\n            longestPalindrome\
    \ = prefix + postfix\n        }\n    }\n    return longestPalindrome\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1\
    \ (0.00s)\n        tmp_3m_ksg3_test.go:50: expected 'x', got ''\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__2 (0.00s)\n        tmp_3m_ksg3_test.go:50: expected\
    \ 'xyzyx', got 'xy'\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n \
    \       tmp_3m_ksg3_test.go:50: expected 'xyx', got 'xy'\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmp_3m_ksg3_test.go:50: expected 'jerryrrej', got 'jerr'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075494
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        postfix := myString[i:]\n        postfix += myString[:i]\n  \
    \      postfix += myString[i:len(myString)]\n        postfix += myString[:len(myString)-i]\n\
    \        postfix += myString[len(myString)-i:]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ myString[len(myString)-len(postfix):len(myString)]\n        postfix += myString[:len(myString)-len(postfix)-1]\n\
    \        postfix += myString[len(myString)-len(postfix)-1:len(myString)]\n   \
    \     postfix += myString[:len(myString)-len(postfix)-2]\n        postfix += myString[len(myString)-len(postfix)-2:len(myString)]\n\
    \        postfix += myString[:len(myString)-len(postfix)-3]\n        postfix +=\
    \ myString[len(myString)-len(postfix)-3:len(myString)]\n        postfix += myString[:len(myString)-len(postfix)-4]\n\
    \        postfix += myString[len(myString)-len(postfix)-4:len(myString)]\n   \
    \     postfix += myString[:len(myString)-len(postfix)-5]\n        postfix += myString[len(myString)-len(postfix)-5:len(myString)]\n\
    \        postfix += myString[:len(myString)-len(postfix)-6]\n        postfix +=\
    \ myString[len(myString)-len(postfix)-6:len(myString)]\n        postfix += myString[:len(myString)-len(postfix)-7]\n\
    \        postfix += myString[len(myString)-len(postfix)-7:len(myString)]\n   \
    \     postfix += myString[:len(myString)-len(postfix)-8]\n        postfix += myString[len(myString)-len(postfix)-8:len(myString)]\n\
    \        postfix += myString[:len(myString)-len(postfix)-9]\n        postfix +=\
    \ myString[len(myString)-len(postfix)-9:len(myString)]\n        postfix += myString[:len(myString)-len(postfix)-10]\n\
    \        postfix += myString[len(myString)-len(postfix)-10:len(myString)]\n  \
    \      postfix += myString[:len(my\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_dbbidl__test.go:50:36: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix) {\n \
    \           longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    prefix := myString[:longestPalindromeLen]\n\
    \    reversedPrefix := append(prefix, reverse(prefix)...)\n    return reversedPrefix\
    \ + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpchkhjwrc_test.go:24:12: undefined: isPalindrome

    /tmp/tmpchkhjwrc_test.go:32:30: first argument to append must be a slice; have
    prefix (variable of type string)

    /tmp/tmpchkhjwrc_test.go:32:38: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := len(myString) - 1; i\
    \ >= 0; i-- {\n        postfix := myString[:i+1]\n        postfix += reverseString(myString[:i])\n\
    \        if postfix != myString {\n            longestPalindrome = postfix\n \
    \           longestPalindromeLength = i + 1\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5qf8xa24_test.go:20:5: longestPalindromeLength declared but not used

    /tmp/tmp5qf8xa24_test.go:23:20: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        postfix := myString[i:]\n\
    \        if isPalindrome(prefix, postfix) {\n            longestPalindrome = prefix\
    \ + longestPalindrome\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl4crdqla_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpl4crdqla_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        longestPalindromeLen\
    \ := len(longestPalindrome)\n        longestPalindrome = longestPalindrome + suffix\n\
    \        if longestPalindrome == prefix {\n            longestPalindrome = longestPalindrome[:longestPalindromeLen]\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp21bgzvvg_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    longestPalindrome := \"\"\n    longestPalindromeLen\
    \ := 0\n    for i := len(myString) - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n\
    \        postfix += string(myString[len(myString)-i-1:])\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    prefix :=\
    \ myString[:longestPalindromeLen]\n    prefix += string(myString[longestPalindromeLen-1:])\n\
    \    return prefix + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj3d3bwur_test.go:28:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    var myStringLen\
    \ int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix string\n\
    \    var myStringReversedSuffix string\n    var myStringReversedPrefix string\n\
    \    var myStringReversedString string\n\n    for i := 0; i < myStringLen; i++\
    \ {\n        myStringPrefix = myString[:i]\n        myStringSuffix = myString[i:]\n\
    \        myStringReversedSuffix = myStringSuffix[::-1]\n        myStringReversedPrefix\
    \ = myStringPrefix[::-1]\n        myStringReversedString = myStringReversedPrefix\
    \ + myStringReversedSuffix\n        if myStringReversedString == myString {\n\
    \            return myString\n        }\n    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8sh997_j_test.go:29:49: 2nd index required in 3-index slice

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[i : i+longestPalindromeLen]\n    }\n    longestPalindromeLen +=\
    \ len(myString) - longestPalindromeLen\n    longestPalindrome += myString[len(myString)\
    \ - longestPalindromeLen : len(myString)]\n    return longestPalindrome\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:6] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:6] with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmprx0g1_um_test.go:23\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmprx0g1_um_test.go:39\
    \ +0x645\ntesting.tRunner(0xc0001a0340, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075495
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix) {\n \
    \           longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    prefix := myString[:longestPalindromeLen]\n\
    \    return prefix + append([]rune(longestPalindrome)..., 'x')\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpesn3y7yq_test.go:31:58: expected '')'', found ''x''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        longestPalindromeLen := 0\n\
    \        for j := 0; j < i; j++ {\n            if myString[j] != myString[len(myString)-j-1]\
    \ {\n                longestPalindromeLen += 1\n            }\n        }\n   \
    \     if longestPalindromeLen > longestPalindromeLen {\n            longestPalindrome\
    \ = myString\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxuj6_zza_test.go:30:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength++\n        longestPalindrome += myString[i]\n\
    \    }\n    for i := 0; i < longestPalindromeLength; i++ {\n        longestPalindrome\
    \ += myString[len(myString)-1-i]\n    }\n    return longestPalindrome\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphlge_1_2_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmphlge_1_2_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := len(myString) - 1; i >= 0; i-- {\n        prefix := myString[:i]\n\
    \        suffix := myString[i+1:]\n        longestPalindromeLen := len(longestPalindrome)\n\
    \        longestPalindrome += suffix\n        if longestPalindrome == prefix {\n\
    \            longestPalindromeLen += 1\n            longestPalindrome = suffix\n\
    \        }\n    }\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    return\
    \ myString + strings.Repeat(string(myString[len(longestPalindrome):]), longestPalindromeLen)\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzixcylh2_test.go:42:23: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        postfix += myString[:i]\n      \
    \  postfix += myString[:i+1]\n        postfix += myString[:i+2]\n        postfix\
    \ += myString[:i+3]\n        postfix += myString[:i+4]\n        postfix += myString[:i+5]\n\
    \        postfix += myString[:i+6]\n        postfix += myString[:i+7]\n      \
    \  postfix += myString[:i+8]\n        postfix += myString[:i+9]\n        postfix\
    \ += myString[:i+10]\n        postfix += myString[:i+11]\n        postfix += myString[:i+12]\n\
    \        postfix += myString[:i+13]\n        postfix += myString[:i+14]\n    \
    \    postfix += myString[:i+15]\n        postfix += myString[:i+16]\n        postfix\
    \ += myString[:i+17]\n        postfix += myString[:i+18]\n        postfix += myString[:i+19]\n\
    \        postfix += myString[:i+20]\n        postfix += myString[:i+21]\n    \
    \    postfix += myString[:i+22]\n        postfix += myString[:i+23]\n        postfix\
    \ += myString[:i+24]\n        postfix += myString[:i+25]\n        postfix += myString[:i+26]\n\
    \        postfix += myString[:i+27]\n        postfix += myString[:i+28]\n    \
    \    postfix += myString[:i+29]\n        postfix += myString[:i+30]\n        postfix\
    \ += myString[:i+31]\n        postfix += myString[:i+32]\n        postfix += myString[:i+33]\n\
    \        postfix += myString[:i+34]\n        postfix += myString[:i+35]\n    \
    \    postfix += myString[:i+36]\n        postfix += myString[:i+37]\n        postfix\
    \ += myString[:i+38]\n        postfix += myString[:i+39]\n        postfix += myString[:i+40]\n\
    \        postfix += myString[:i+41]\n        postfix += myString[:i+42]\n    \
    \    postfix += myString[:i+43]\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt6c12mxu_test.go:68:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    var longestPalindrome string\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindrome += myString[i]\n    }\n    \n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    for i := 0; i < len(longestPalindrome); i++ {\n        myString\
    \ += string(myString[len(longestPalindrome)-i-1:len(myString)])\n    }\n    \n\
    \    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpekzvfopl_test.go:33:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix) {\n \
    \           longestPalindrome = longestPalindrome + postfix\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    // Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    longestPalindrome = longestPalindrome + myString[:longestPalindromeLen]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq4i4un8z_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n      \
    \  longestPalindrome += myString[len(myString)-i-1]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqpaome4o_test.go:21:26: no new variables on left side of :=

    /tmp/tmpqpaome4o_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpqpaome4o_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome('')\n\
    \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindrom\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpizt9x9ox_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome\n    longestPalindrome := \"\"\n  \
    \  longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n     \
    \   postfix := myString[i:]\n        postfix := append(postfix, myString[:i]...)\n\
    \        postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd8xae38p_test.go:57:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    longestPalindrome := \"\"\n \
    \   longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i-- {\n\
    \        prefix := myString[:i]\n        postfix := myString[i+1:]\n        if\
    \ isPalindrome(prefix, postfix) {\n            longestPalindrome = prefix + longestPalindrome\n\
    \            longestPalindromeLen = len(longestPalindrome)\n        }\n    }\n\
    \    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    suffix := myString[:longestPalindromeLen]\n\
    \    return longestPalindrome + suffix\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0sfc6m9p_test.go:25:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i:]\n \
    \       postfix := reversePostfix(prefix)\n        if postfix != suffix {\n  \
    \          longestPalindrome = prefix + postfix\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    if longestPalindromeLen > 0\
    \ {\n        return longestPalindrome + reversePostfix(myString[:longestPalindromeLen])\n\
    \    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi6dbuwjt_test.go:24:20: undefined: reversePostfix

    /tmp/tmpi6dbuwjt_test.go:31:36: undefined: reversePostfix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        postfix := myString[i:]\n\
    \        postfix += strings.Reverse(prefix)\n        postfix += postfix\n    \
    \    postfix += strings.Reverse(postfix)\n        if postfix != prefix {\n   \
    \         longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6orne0hl_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmp6orne0hl_test.go:24:20: undefined: strings

    /tmp/tmp6orne0hl_test.go:26:20: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[i : i+longestPalindromeLen]\n    }\n    longestPalindrome += myString[len(myString)\
    \ - longestPalindromeLen : len(myString)]\n    return longestPalindrome\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:6] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:6] with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpi5ah9xqu_test.go:23\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpi5ah9xqu_test.go:38\
    \ +0x6f2\ntesting.tRunner(0xc000192680, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075496
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < i; j++ {\n   \
    \         if myString[j] != myString[len(myString)-j-1] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString[:i]\n            longestPalindromeLen\
    \ = i\n        }\n    }\n    return longestPalindrome + myString[len(longestPalindrome):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmmtrfis9_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength = 0\n        for j := 0; j < i; j++ {\n\
    \            if myString[j] != myString[len(myString)-j-1] {\n               \
    \ longestPalindromeLength++\n            }\n        }\n        if longestPalindromeLength\
    \ > longestPalindromeLength {\n            longestPalindrome = myString[:i+longestPalindromeLength]\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1\
    \ (0.00s)\n        tmpaertbvt2_test.go:52: expected 'x', got ''\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__2 (0.00s)\n        tmpaertbvt2_test.go:52: expected\
    \ 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n   \
    \     tmpaertbvt2_test.go:52: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmpaertbvt2_test.go:52: expected 'jerryrrej', got ''\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075496
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        longestPalindromeLen += 1 //\
    \ Increment the length of the longest palindrome so far.\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindromeLen -= 1 // Decrement the length\
    \ of the longest palindrome to account for the last character.\n    longestPalindrome\
    \ += myString[len(myString)-longestPalindromeLen:]\n    // Append to the end of\
    \ the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    longestPalindrome = longestPalindrome[0 : len(longestPalindrome)-longestPalindromeLen]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeol3w732_test.go:33:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075496
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n      \
    \  postfix := reverse(prefix)\n        if suffix == postfix {\n            longestPalindrome\
    \ = prefix + postfix\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    if longestPalindromeLen == 0 {\n        return \"\"\n \
    \   }\n    return longestPalindrome + myString[:longestPalindromeLen]\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6lew0835_test.go:24:20: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075496
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    // The longest postfix is always\
    \ one character longer than the original string.\n    longestPostfix := \"\"\n\
    \    longestPostfixLen := 0\n    for i := 0; i < len(myString); i++ {\n      \
    \  postfix := myString[:i+1]\n        postfix += myString[len(myString)-i-1:]\n\
    \        if postfix != myString {\n            postfix += myString[len(myString)-i-1:]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[:i+1]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[len(myString)-i-1:]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[:i+1]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[len(myString)-i-1:]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[:i+1]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[len(myString)-i-1:]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[:i+1]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[len(myString)-i-1:]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[:i+1]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[len(myString)-i-1:]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[:i+1]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[len(myString)-i-1:]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[:i+1]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[len(myString)-i-1:]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[:i+1]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[len(myString)-i-1:]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[:i+1]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[len(myString)-i-1:]\n\
    \        }\n        if postfix != myString {\n            postfix += myString[:i+1]\n\
    \        }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvn3i04ep_test.go:87:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        postfix += string(myString[len(myString)-i-1:])\n\
    \        if postfix != make_palindrome(postfix) {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLen = len(postfix)\n        }\n    }\n\
    \    if longestPalindromeLen > 1 {\n        // Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n     \
    \   prefix := myString[:longestPalindromeLen-1]\n        postfix := myString[longestPalindromeLen-1:]\n\
    \        return prefix + string(append([]rune(postfix), reverse(prefix)...)...)\n\
    \    }\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjgwc8mo5_test.go:20:5: longestPalindrome declared but not used

    /tmp/tmpjgwc8mo5_test.go:34:16: invalid operation: prefix + string(append([]rune(postfix),
    reverse(prefix)...)...) (mismatched types string and []rune)

    /tmp/tmpjgwc8mo5_test.go:34:32: invalid use of ... in type conversion to string

    /tmp/tmpjgwc8mo5_test.go:34:56: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075496
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Initialize\
    \ our result string\n    var result string\n\n    // Find the longest postfix\
    \ of supplied string that is a palindrome\n    longestPalindrome := findLongestPalindrome(myString)\n\
    \n    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    result += myString[len(longestPalindrome):]\n\
    \    result += myString[:len(longestPalindrome)]\n\n    // Return the result\n\
    \    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjrp2vs7i_test.go:23:26: undefined: findLongestPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075496
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n\
    \        postfix := reverseString(prefix)\n        if suffix == postfix {\n  \
    \          longestPalindrome = prefix + postfix\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    return longestPalindrome\n}\n\
    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1zrw1rd0_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmp1zrw1rd0_test.go:24:20: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075496
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome('')\n\
    \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindrom\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpizt9x9ox_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := longestPalindromeLen + 1\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindromeLen -= 1 // Remove last character\
    \ from longest palindrome\n    longestPalindrome = longestPalindrome[0 : longestPalindromeLen]\n\
    \    longestPalindrome = longestPalindrome + make_palindrome(myString[longestPalindromeLen:])\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpykloosyd_test.go:22:9: longestPalindromeLen declared but not used

    /tmp/tmpykloosyd_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075496
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome('')\n\
    \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindrom\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpizt9x9ox_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n \
    \       postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i:]...)\n        postfix := append(postfix, myString[len(myString)-i:len(myString)-i+1]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+1:]...)\n       \
    \ postfix := append(postfix, myString[len(myString)-i+1:len(myString)-i+2]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+2:len(myString)-i+3]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+3:len(myString)-i+4]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+4:len(myString)-i+5]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+5:len(myString)-i+6]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+6:len(myString)-i+7]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+7:len(myString)-i+8]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+8:len(myString)-i+9]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+9:len(myString)-i+10]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+10:len(myString)-i+11]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+11:len(myString)-i+12]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+12:len(myString)-i+13]\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt243xvji_test.go:48:83: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[:i+1]\n        longestPalindrome += myString[len(myString) - longestPalindromeLen:]\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [-2:] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [-2:]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmprrme4p6a_test.go:24\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmprrme4p6a_test.go:38\
    \ +0x665\ntesting.tRunner(0xc0001a01a0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075496
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    var myStringLen\
    \ int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix string\n\
    \    var myStringReversedSuffix string\n    var myStringReversedPrefix string\n\
    \    var myStringReversedString string\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReverse\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdencde59_test.go:76:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        longestPalindrome += myString[i]\n\
    \        for j := i; j < len(myString); j++ {\n            if myString[j] != myString[len(myString)-1-j]\
    \ {\n                longestPalindromeLen += 1\n                break\n      \
    \      }\n        }\n        if longestPalindromeLen > longestPalindromeLen {\n\
    \            longestPalindrome = myString[:i]\n            longestPalindromeLen\
    \ = longestPalindromeLen - i\n        }\n    }\n    return longestPalindrome +\
    \ myString[len(longestPalindrome):]\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmlv4rnfw_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpmlv4rnfw_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome('')\n\
    \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindrom\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpizt9x9ox_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[:i]\n        longestPalindrome += myString[len(myString) - i:]\n\
    \    }\n    longestPalindrome += myString\n    longestPalindromeLen += len(myString)\n\
    \    longestPalindrome = longestPalindrome[:longestPalindromeLen]\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:2] with length 1 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:2] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmphb355x1k_test.go:28\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmphb355x1k_test.go:40\
    \ +0x6cf\ntesting.tRunner(0xc0001924e0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075497
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[i : i+longestPalindromeLen]\n    }\n    longestPalindromeLen +=\
    \ len(myString) - longestPalindromeLen\n    longestPalindrome += myString[len(myString)\
    \ - longestPalindromeLen : len(myString)]\n    return longestPalindrome\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:6] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:6] with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmprx0g1_um_test.go:23\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmprx0g1_um_test.go:39\
    \ +0x645\ntesting.tRunner(0xc0001a0340, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[:i]\n        longestPalindrome += myString[len(myString)-i:]\n \
    \   }\n    longestPalindromeLen -= len(myString)\n    longestPalindrome += myString\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome +=\
    \ myString[len(myString)-i]\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwdffz_le_test.go:29:9: invalid operation: longestPalindrome += myString[len(myString)
    - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLengthPalindrome\
    \ := 0\n    longestPalindromeLengthPalindromePalindrome := 0\n    longestPalindromeLengthPalindromePalindromePalindrome\
    \ := 0\n    longestPalindromeLengthPalindromePalindromePalindromePalindrome :=\
    \ 0\n    longestPalindromeLengthPalindromePalindromePalindromePalindromePalindrome\
    \ := 0\n    longestPalindromeLengthPalindromePalindromePalindromePalindromePalindromePalindrome\
    \ := 0\n    longestPalindromeLengthPalindromePalindromePalindromePalindromePalindromePalindromePalindrome\
    \ := 0\n    longestPalindromeLengthPalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindrome\
    \ := 0\n    longestPalindromeLengthPalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindrome\
    \ := 0\n    longestPalindromeLengthPalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindrome\
    \ := 0\n    longestPalindromeLengthPalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindrome\
    \ := 0\n    longestPalindromeLengthPalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindromePalindrome\
    \ := 0\n    longestPalindromeLengthPalindromePalindromePalindromePalindromeP\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt4yppb4f_test.go:34:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075496
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        prefix := myString[:i]\n       \
    \ postfix = append(postfix, reverse(prefix))\n        longestPalindrome = append(longestPalindrome,\
    \ postfix...)\n        longestPalindromeLen = longestPalindromeLen + len(postfix)\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb6ingf26_test.go:24:26: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmpb6ingf26_test.go:24:35: undefined: reverse

    /tmp/tmpb6ingf26_test.go:25:36: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n      \
    \  longestPalindromeLen := len(longestPalindrome)\n        longestPalindrome =\
    \ longestPalindrome + string(append(append([]rune(longestPalindrome), []rune(prefix)...),\
    \ []rune(suffix)...))\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4l6dmidt_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmp4l6dmidt_test.go:24:9: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        postfix := myString[:i]\n \
    \       postfix += string(myString[len(myString)-i:]) + myString[:i]\n       \
    \ postfix += string(myString[len(myString)-i:]) + myString[:i]\n        postfix\
    \ += string(myString[len(myString)-i:]) + myString[:i]\n        postfix += string(myString[len(myString)-i:])\
    \ + myString[:i]\n        postfix += string(myString[len(myString)-i:]) + myString[:i]\n\
    \        postfix += string(myString[len(myString)-i:]) + myString[:i]\n      \
    \  postfix += string(myString[len(myString)-i:]) + myString[:i]\n        postfix\
    \ += string(myString[len(myString)-i:]) + myString[:i]\n        postfix += string(myString[len(myString)-i:])\
    \ + myString[:i]\n        postfix += string(myString[len(myString)-i:]) + myString[:i]\n\
    \        postfix += string(myString[len(myString)-i:]) + myString[:i]\n      \
    \  postfix += string(myString[len(myString)-i:]) + myString[:i]\n        postfix\
    \ += string(myString[len(myString)-i:]) + myString[:i]\n        postfix += string(myString[len(myString)-i:])\
    \ + myString[:i]\n        postfix += string(myString[len(myString)-i:]) + myString[:i]\n\
    \        postfix += string(myString[len(myString)-i:]) + myString[:i]\n      \
    \  postfix += string(myString[len(myString)-i:]) + myString[:i]\n        postfix\
    \ += string(myString[len(myString)-i:]) + myString[:i]\n        postfix += string(myString[len(myString)-i:])\
    \ + myString[:i]\n        postfix += string(myString[len(myString)-i:]) + myString[:i]\n\
    \        \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr4vfnbtt_test.go:54:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075496
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        postfix += myString[:i]\n      \
    \  postfix += myString[len(myString) - i:]\n        postfix += myString[:len(myString)\
    \ - i]\n        postfix += myString[len(myString) - i:len(myString)]\n       \
    \ postfix += myString[:len(myString) - i:len(myString)]\n        postfix += myString[len(myString)\
    \ - i:len(myString)]\n        postfix += myString[:len(myString) - i:len(myString)]\n\
    \        postfix += myString[len(myString) - i:len(myString)]\n        postfix\
    \ += myString[:len(myString) - i:len(myString)]\n        postfix += myString[len(myString)\
    \ - i:len(myString)]\n        postfix += myString[:len(myString) - i:len(myString)]\n\
    \        postfix += myString[len(myString) - i:len(myString)]\n        postfix\
    \ += myString[:len(myString) - i:len(myString)]\n        postfix += myString[len(myString)\
    \ - i:len(myString)]\n        postfix += myString[:len(myString) - i:len(myString)]\n\
    \        postfix += myString[len(myString) - i:len(myString)]\n        postfix\
    \ += myString[:len(myString) - i:len(myString)]\n        postfix += myString[len(myString)\
    \ - i:len(myString)]\n        postfix += myString[:len(myString) - i:len(myString)]\n\
    \        postfix += myString[len(myString) - i:len(myString)]\n        postfix\
    \ += myString[:len(myString) - i:len(myString)]\n        postfix += myString[len(myString)\
    \ - i:len(myString)]\n        postfix += myString[:len(myString) - i:len(myString)]\n\
    \        postfix += myString[len(myString) - i:len(myString)]\n        postfix\
    \ += myString[:len(myString) - i:len(myString)]\n        postfix += myString[len(myString)\
    \ - i:len(myString)]\n        postfix += myString[:len(myString) - i:len(myString)]\n\
    \        postfix += myString[len(myString) - i:len(myString)]\n        postfix\
    \ += myString[:len(myString) - i:len(myString)]\n        postfix += myString[len(my\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptxszft7l_test.go:52:35: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075496
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome('')\n\
    \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindrom\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpizt9x9ox_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    longestPalindrome += myString[len(myString)-1:]\n  \
    \  longestPalindrome = reverse(longestPalindrome)\n    // Append to the end of\
    \ the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    result := myString\n    for i := len(longestPalindrome) - 1; i >= 0; i--\
    \ {\n        result += longestPalindrome[i]\n    }\n    return result\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphvqh7wr6_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmphvqh7wr6_test.go:25:25: undefined: reverse

    /tmp/tmphvqh7wr6_test.go:29:9: invalid operation: result += longestPalindrome[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[longestPalindromeLen:i]\n        postfix += myString[0:longestPalindromeLen]\n\
    \        postfix += myString[i:len(myString)]\n        postfix += myString[len(myString):len(myString)]\n\
    \        postfix += myString[len(myString):0]\n        postfix += myString[0:0]\n\
    \        postfix += myString[0:1]\n        postfix += myString[1:len(myString)]\n\
    \        postfix += myString[len(myString):len(myString)]\n        postfix +=\
    \ myString[len(myString):0]\n        postfix += myString[0:1]\n        postfix\
    \ += myString[1:len(myString)]\n        postfix += myString[len(myString):len(myString)]\n\
    \        postfix += myString[len(myString):0]\n        postfix += myString[0:1]\n\
    \        postfix += myString[1:len(myString)]\n        postfix += myString[len(myString):len(myString)]\n\
    \        postfix += myString[len(myString):0]\n        postfix += myString[0:1]\n\
    \        postfix += myString[1:len(myString)]\n        postfix += myString[len(myString):len(myString)]\n\
    \        postfix += myString[len(myString):0]\n        postfix += myString[0:1]\n\
    \        postfix += myString[1:len(myString)]\n        postfix += myString[len(myString):len(myString)]\n\
    \        postfix += myString[len(myString):0]\n        postfix += myString[0:1]\n\
    \        postfix += myString[1:len(myString)]\n        postfix += myString[len(myString):len(myString)]\n\
    \        postfix += myString[len(myString):0]\n        postfix += myString[0:1]\n\
    \        postfix += myString[1:len(myString)]\n        postfix += myString[len(myString):len(myString)]\n\
    \        postfix += myString[len(myString):0]\n        postfix += myString[0:1]\n\
    \        postfix += myString[1:len(myString)]\n        postfix += myString[len(myString):len(myString)]\n\
    \        postfix += myString[len(myString):0]\n        postfix += myString[0:1]\n\
    \        postfix += myString[1:len(my\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpammteozu_test.go:61:37: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075496
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n      \
    \  longestPalindromeLen := len(longestPalindrome)\n        longestPalindrome =\
    \ longestPalindrome + suffix\n        if longestPalindrome == prefix {\n     \
    \       longestPalindrome = longestPalindrome[:longestPalindromeLen]\n       \
    \ }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptb6e5pqv_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        postfix := myString[:i]\n \
    \       reversedPostfix := myString[len(postfix):]\n        if myString[i] ==\
    \ reversedPostfix[len(reversedPostfix)-1] {\n            longestPalindrome = postfix\
    \ + reversedPostfix\n            longestPalindromeLen = len(postfix)\n       \
    \ }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2m69ramb_test.go:30:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome('')\n\
    \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindrom\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpizt9x9ox_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    var longestPalindrome string\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindrome += myString[i]\n    }\n    \n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    longestPalindrome += myString[len(myString)-len(longestPalindrome):]\n\
    \    \n    // Return the result.\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpryese40w_test.go:33:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    var myStringLen\
    \ int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix string\n\
    \    var myStringReversedSuffix string\n    var myStringReversedPrefix string\n\
    \n    // Find the longest postfix of supplied string that is a palindrome.\n \
    \   for i := 0; i < myStringLen; i++ {\n        myStringPrefix = myString[:i]\n\
    \        myStringSuffix = myString[i:]\n        myStringReversedSuffix = myStringSuffix[:len(myStringSuffix)/2:]\n\
    \        myStringReversedPrefix = myStringPrefix[len(myStringPrefix)-len(myStringReversedSuffix):]\n\
    \        if myStringSuffix == myStringReversedSuffix {\n            return myStringPrefix\
    \ + myStringReversedPrefix\n        }\n    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbvh_yfwb_test.go:29:71: 3rd index required in 3-index slice

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        prefix := myString[:i]\n       \
    \ postfix += make_palindrome_reverse(prefix)\n        if postfix != \"\" {\n \
    \           longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n    if longestPalindromeLen > 0 {\n        return longestPalindrome\
    \ + myString[:longestPalindromeLen]\n    } else {\n        return myString\n \
    \   }\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppivryq70_test.go:24:20: undefined: make_palindrome_reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075498
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        postfix += myString[i+1:]\n\
    \        if postfix != make_palindrome(postfix) {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLen = len(postfix)\n        }\n    }\n\
    \    return longestPalindrome + string(myString[:longestPalindromeLen])\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0378\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f361?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\nruntime.concatstrings(0x0?, {0xc0201e03a8?,\
    \ 0x2?, 0x2?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/string.go:25\
    \ +0x270 fp=0xc0201e0388 sp=0xc0201e0380 pc=0x44d5d0\nruntime.concatstring2(0xc0201e0428?,\
    \ {0x51d187?, 0x0?}, {0x51d187?, 0x0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/string.go:60\
    \ +0x50 fp=0xc0201e03d8 sp=0xc0201e0388 pc=0x44d650\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmprs2d2dxe_test.go:23 +0x92 fp=0xc0201e0438 sp=0xc0201e03d8 pc=0x4ef6f2\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmprs2d2dxe_test.go:24\
    \ +0xa5 fp=0xc0201e0498 sp=0xc0201e0438 pc=0x4ef705\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmprs2d2dxe_test.go:24 +0xa5 fp=0xc0201e04f8 sp=0xc0201e0498 pc=0x4ef705\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmprs2d2dxe_test.go:24\
    \ +0xa5 fp=0xc0201e0558 sp=0xc0201e04f8 pc=0x4ef705\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmprs2d2dxe_test.go:24 +0xa5 fp=0xc0201e05b8 sp=0xc0201e0558 pc=0x4ef705\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmprs2d2dxe_test.go:24\
    \ +0xa5 fp=0xc0201e0618 sp=0xc0201e05b8 pc=0x4ef705\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmprs2d2dxe_test.go:24 +0xa5 fp=0xc0201e0678 sp=0xc0201e0618 pc=0x4ef705\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmprs2d2dxe_test.go:24\
    \ +0xa5 fp=0xc0201e06d8 sp=0xc0201e0678 pc=0x4ef705\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmprs2d2dxe_test.go:24 +0xa5 "
  timestamp: 1660075499
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        postfix := myString[longestPalindromeLen:]\
    \ + myString[:i]\n        longestPalindromeLen += len(postfix)\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6r1mm709_test.go:34:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075498
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        postfix := myString[i+1:]\n\
    \        postfix += string(Reverse(prefix))\n        if postfix != prefix {\n\
    \            longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpej9e234b_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpej9e234b_test.go:24:27: undefined: Reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075498
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix) {\n \
    \           longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    prefix := myString[:longestPalindromeLen]\n\
    \    suffix := myString[longestPalindromeLen:]\n    return prefix + reverseString(suffix)\
    \ + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp78cp9364_test.go:24:12: undefined: isPalindrome

    /tmp/tmp78cp9364_test.go:32:21: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075498
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        prefix := myString[:i]\n\
    \        suffix := myString[i+1:]\n        if suffix == reverse(prefix) {\n  \
    \          longestPalindrome = prefix + suffix\n            longestPalindromeLen\
    \ = i\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpas_sq_td_test.go:21:26: no new variables on left side of :=

    /tmp/tmpas_sq_td_test.go:25:22: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075498
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n \
    \       postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i:len(myString)]...)\n        postfix := append(postfix,\
    \ myString[:len(myString)-i]...)\n        postfix := append(postfix, myString[len(myString)-i:len(myString)]...)\n\
    \        postfix := append(postfix, myString[:len(myString)-i]...)\n        postfix\
    \ := append(postfix, myString[len(myString)-i:len(myString)]...)\n        postfix\
    \ := append(postfix, myString[:len(myString)-i]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i:len(myString)]...)\n        postfix := append(postfix,\
    \ myString[:len(myString)-i]...)\n        postfix := append(postfix, myString[len(myString)-i:len(myString)]...)\n\
    \        postfix := append(postfix, myString[:len(myString)-i]...)\n        postfix\
    \ := append(postfix, myString[len(myString)-i:len(myString)]...)\n        postfix\
    \ := append(postfix, myString[:len(myString)-i]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i:len(myString)]...)\n        postfix := append(postfix,\
    \ myString[:len(myString)-i]...)\n        postfix := append(postfix, myString[len(myString)-i:len(myString)]...)\n\
    \        postfix := append(postfix, myString[:len(myString)-i]...)\n        postfix\
    \ := append(postfix, myString[len(myString)-i:len(myString)]...)\n        postfix\
    \ := append(postfix, myString[:len(myString)\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjze2iatx_test.go:51:59: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    // This will be the length of\
    \ the palindrome plus one.\n    longestPalindrome := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindrome = longestPalindrome + 1\n        if myString[len(myString)-i-1]\
    \ != myString[len(myString)-i-longestPalindrome] {\n            break\n      \
    \  }\n    }\n\n    // Append the reverse of the string prefix that comes before\
    \ the palindromic suffix.\n    // This will be the length of the palindrome minus\
    \ one.\n    longestPalindrome = longestPalindrome - 1\n\n    // Append the palindrome\
    \ suffix.\n    // This will be the length of the palindrome plus one.\n    longestPalindrome\
    \ = longestPalindrome + 1\n\n    // Append the palindrome prefix.\n    // This\
    \ will be the length of the palindrome minus one.\n    longestPalindrome = longestPalindrome\
    \ - 1\n\n    // Append the palindrome prefix.\n    // This will be the length\
    \ of the palindrome minus one.\n    longestPalindrome = longestPalindrome - 1\n\
    \n    // Append the palindrome prefix.\n    // This will be the length of the\
    \ palindrome minus one.\n    longestPalindrome = longestPalindrome - 1\n\n   \
    \ // Append the palindrome prefix.\n    // This will be the length of the palindrome\
    \ minus one.\n    longestPalindrome = longestPalindrome - 1\n\n    // Append the\
    \ palindrome prefix.\n    // This will be the length of the palindrome minus one.\n\
    \    longestPalindrome = longestPalindrome - 1\n\n    // Append the palindrome\
    \ prefix.\n    // This will be the length of the palindrome minus one.\n    longestPalindrome\
    \ = longestPalindrome - 1\n\n    // Append the palindrome prefix.\n    // This\
    \ will be the length of the palindrome minus one.\n    longestPalindrome = longestPalindrome\
    \ - 1\n\n    // Append the palindrome prefix.\n    // This will be the length\
    \ of the palindrome minus one.\n    longestPalindrome = longestPalindrome - 1\n\
    \n    // Append the palindrome prefix.\n    // This will be the length of the\
    \ palindrome minus one.\n    longestPalindrome = longestPalindrome - 1\n\n   \
    \ // Append the palindrome prefix.\n    // This will be the length of the \nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw2hhg11y_test.go:75:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        reversedPostfix := myString[:i]\
    \ + myString[i+1:]\n        if postfix != reversedPostfix {\n            longestPalindrome\
    \ = longestPalindrome[:longestPalindromeLen] + postfix\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    return longestPalindrome\n}\n\
    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmp85qd2jup_test.go:49: expected 'xyzyx', got 'xyzyzz'\n  \
    \  --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp85qd2jup_test.go:49:\
    \ expected 'xyx', got 'xyxyxx'\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmp85qd2jup_test.go:49: expected 'jerryrrej', got 'jerryerryrryryy'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075498
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        longestPalindrome += myString[i]\n\
    \        for j := 0; j < i; j++ {\n            if myString[j] != myString[len(myString)-j-1]\
    \ {\n                longestPalindromeLen += 1\n            }\n        }\n   \
    \     if longestPalindromeLen > longestPalindromeLen {\n            longestPalindrome\
    \ = myString[:i]\n            longestPalindromeLen = i\n        }\n    }\n   \
    \ return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8x_puaq3_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmp8x_puaq3_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075498
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n\
    \        if isPalindrome(prefix, suffix) {\n            longestPalindrome = prefix\
    \ + suffix\n            longestPalindromeLen = len(longestPalindrome)\n      \
    \  }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnacz9t8b_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpnacz9t8b_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // >>> make_palindrome('cat')\n    // 'catac'\n\
    \    // >>> make_palindrome('cata')\n    // 'catac'\n    longestPalindrome :=\
    \ \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0;\
    \ i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n  \
    \      longestPalindromeLen := len(longestPalindrome)\n        if longestPalindromeLen\
    \ > len(prefix) + len(suffix) {\n            longestPalindrome = prefix\n    \
    \        longestPalindromeLen = len(prefix)\n        }\n        if longestPalindromeLen\
    \ > len(suffix) {\n            longestPalindrome += suffix\n            longestPalindromeLen\
    \ = len(suffix)\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpud3sonc1_test.go:27:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075498
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        longestPalindromeLen := 0\n\
    \        for j := 0; j < len(myString); j++ {\n            if myString[i] == myString[j]\
    \ {\n                longestPalindromeLen += 1\n            }\n        }\n   \
    \     if longestPalindromeLen > longestPalindromeLen {\n            longestPalindrome\
    \ = myString\n            longestPalindromeLen = longestPalindromeLen\n      \
    \  }\n    }\n    // Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n    // >>> make_palindrome('')\n\
    \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    return longestPalindrome + string(myString[len(longestPalindrome):])\
    \ + string(myString[:len(longestPalindrome)])\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprvx4t6um_test.go:30:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075498
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[:i]\n        postfix += myString[len(myString)-i:]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)-i]\n        postfix +=\
    \ myString[len(myString)-len(postfix)-len(postfix):]\n        postfix += myString[:len(myString)-len(postfix)-len(postfix)-i]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)-len(postfix)-len(postfix)-i]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-i]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix):]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix):]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix):]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix):]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix):]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix):]\n\
    \        postfix += my\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu1ri_fph_test.go:34:108: 3rd index required in 3-index slice

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075498
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength = 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLength\
    \ += 1\n            }\n        }\n        if longestPalindromeLength > longestPalindromeLength\
    \ {\n            longestPalindrome = myString\n            longestPalindromeLength\
    \ = longestPalindromeLength\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1\
    \ (0.00s)\n        tmpjuy5hqga_test.go:53: expected 'x', got ''\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__2 (0.00s)\n        tmpjuy5hqga_test.go:53: expected\
    \ 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n   \
    \     tmpjuy5hqga_test.go:53: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmpjuy5hqga_test.go:53: expected 'jerryrrej', got ''\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075499
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        postfix := myString[:i]\n \
    \       postfix += myString[len(myString)-i:]\n        postfix += myString[:len(myString)-i]\n\
    \        postfix += myString[len(myString)-len(postfix):]\n        postfix +=\
    \ myString[:len(myString)-len(postfix)]\n        postfix += myString[len(myString)-len(postfix):len(myString)]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ myString[len(myString)-len(postfix):len(myString)]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)]\n     \
    \   postfix += myString[:len(myString)-len(postfix)]\n        postfix += myString[len(myString)-len(postfix):len(myString)]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ myString[len(myString)-len(postfix):len(myString)]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)]\n     \
    \   postfix += myString[:len(myString)-len(postfix)]\n        postfix += myString[len(myString)-len(postfix):len(myString)]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ myString[len(myString)-len(postfix):len(myString)]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)]\n     \
    \   postfix += myString[:len(myString)-len(postfix)]\n        postfix += myString[len(myString)\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv8c9ea4g_test.go:55:42: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075498
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n      \
    \  longestPalindrome += myString[len(myString)-(i+1)]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphwme51h7_test.go:21:26: no new variables on left side of :=

    /tmp/tmphwme51h7_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmphwme51h7_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - (i + 1)] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix) {\n \
    \           longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    suffix := myString[longestPalindromeLen:]\n\
    \    return longestPalindrome + suffix\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy5xvv1ac_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        postfix := myString[i : len(myString)-i]\n        postfix :=\
    \ append(postfix, postfix[len(postfix)-1:])\n        postfix := append(postfix,\
    \ postfix[:len(postfix)-1])\n        if postfix != myString {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLength = len(postfix)\n        }\n \
    \   }\n    if longestPalindromeLength < len(myString) {\n        longestPalindrome\
    \ = append(myString[len(myString)-longestPalindromeLength:len(myString)], longestPalindrome)\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp49d0ejte_test.go:23:17: no new variables on left side of :=

    /tmp/tmp49d0ejte_test.go:23:27: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmp49d0ejte_test.go:24:17: no new variables on left side of :=

    /tmp/tmp49d0ejte_test.go:24:27: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmp49d0ejte_test.go:31:44: first argument to append must be a slice; have
    myString[len(myString) - longestPalindromeLength:len(myString)] (value of type
    string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    var myStringLen\
    \ int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix string\n\
    \    var myStringReverse string\n    var myStringPalindrome string\n\n    // Find\
    \ the longest postfix of supplied string that is a palindrome.\n    for i := 0;\
    \ i < myStringLen; i++ {\n        myStringPrefix = myString[:i]\n        myStringSuffix\
    \ = myString[i:]\n        myStringReverse = reverse(myStringPrefix)\n        if\
    \ myStringSuffix == myStringReverse {\n            myStringPalindrome = myStringPrefix\
    \ + myStringSuffix\n            break\n        }\n    }\n    return myStringPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb4wfmjcx_test.go:29:27: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        longestPalindromeLen += len(myString)\
    \ - i\n        longestPalindrome += myString[i : i+longestPalindromeLen]\n   \
    \ }\n    longestPalindromeLen -= len(myString)\n    longestPalindrome += myString[0\
    \ : longestPalindromeLen]\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:6] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:6] with length 3\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpyv5z19nr_test.go:33\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpyv5z19nr_test.go:49\
    \ +0x6a5\ntesting.tRunner(0xc00019e1a0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075500
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        longestPalindromeLen +=\
    \ len(myString) - i\n        if myString[len(myString)-i] == myString[len(myString)-(i+1)]\
    \ {\n            longestPalindrome = myString[:len(myString)-(i+1)] + longestPalindrome\n\
    \        }\n    }\n    \n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    longestPalindrome = longestPalindrome\
    \ + myString[len(myString)-longestPalindromeLen:]\n    \n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp0ij53_43_test.go:35\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp0ij53_43_test.go:54\
    \ +0x76c\ntesting.tRunner(0xc0001a0340, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075500
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLength := len(myString)\n\
    \    for i := 0; i < longestPalindromeLength; i++ {\n        prefix := myString[0:i]\n\
    \        suffix := myString[i+1:]\n        postfix := reverseString(prefix)\n\
    \        if suffix == postfix {\n            longestPalindrome = prefix + postfix\n\
    \            longestPalindromeLength = len(longestPalindrome)\n        }\n   \
    \ }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu85ikzlk_test.go:21:29: no new variables on left side of :=

    /tmp/tmpu85ikzlk_test.go:25:20: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        longestPalindrome += myString[i]\n\
    \        for j := i; j < len(myString); j++ {\n            if myString[j] != myString[len(myString)-j-1]\
    \ {\n                longestPalindromeLen += 1\n            }\n        }\n   \
    \     if longestPalindromeLen > longestPalindromeLen {\n            longestPalindrome\
    \ = myString[:i]\n            longestPalindromeLen = longestPalindromeLen - i\n\
    \        }\n    }\n    return longestPalindrome + myString[len(longestPalindrome):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbf3t0rrt_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpbf3t0rrt_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        prefix := myString[:i]\n       \
    \ postfix += make_palindrome_recursive(prefix, postfix)\n        if len(postfix)\
    \ > longestPalindromeLen {\n            longestPalindrome = postfix\n        \
    \    longestPalindromeLen = len(postfix)\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdl5o4duh_test.go:24:20: undefined: make_palindrome_recursive

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString); i >= 0;\
    \ i-- {\n        prefix := myString[:i]\n        suffix := myString[i:]\n    \
    \    if isPalindrome(prefix, suffix) {\n            longestPalindrome = prefix\
    \ + suffix\n            longestPalindromeLen = len(longestPalindrome)\n      \
    \  }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy1ikwrm5_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpy1ikwrm5_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[i:]\n        postfix := append(postfix, postfix[len(postfix)-len(longestPalindrome):]...)\n\
    \        postfix := append(postfix, myString[:i]...)\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    prefix :=\
    \ myString[:longestPalindromeLen]\n    prefix := append(prefix, longestPalindrome...)\n\
    \    prefix := append(prefix, myString[len(myString)-len(prefix):]...)\n    return\
    \ prefix\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_mb0ecjf_test.go:24:17: no new variables on left side of :=

    /tmp/tmp_mb0ecjf_test.go:24:27: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmp_mb0ecjf_test.go:25:17: no new variables on left side of :=

    /tmp/tmp_mb0ecjf_test.go:25:27: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmp_mb0ecjf_test.go:26:12: undefined: isPalindrome

    /tmp/tmp_mb0ecjf_test.go:33:12: no new variables on left side of :=

    /tmp/tmp_mb0ecjf_test.go:33:22: first argument to append must be a slice; have
    prefix (variable of type string)

    /tmp/tmp_mb0ecjf_test.go:34:12: no new variables on left side of :=

    /tmp/tmp_mb0ecjf_test.go:34:22: first argument to append must be a slice; have
    prefix (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n \
    \       postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i:]...)\n        postfix := append(postfix, myString[len(myString)-i:len(myString)-(i+1)]...)\n\
    \        postfix := append(postfix, myString[len(myString)-(i+1):]...)\n     \
    \   postfix := append(postfix, myString[len(myString)-(i+1):len(myString)-(i+2)]...)\n\
    \        postfix := append(postfix, myString[len(myString)-(i+2):len(myString)-(i+3)]...)\n\
    \        postfix := append(postfix, myString[len(myString)-(i+3):]...)\n     \
    \   postfix := append(postfix, myString[len(myString)-(i+3):len(myString)-(i+4)]...)\n\
    \        postfix := append(postfix, myString[len(myString)-(i+4):]...)\n     \
    \   postfix := append(postfix, myString[len(myString)-(i+4):len(myString)-(i+5)]...)\n\
    \        postfix := append(postfix, myString[len(myString)-(i+5):]...)\n     \
    \   postfix := append(postfix, myString[len(myString)-(i+5):len(myString)-(i+6)]...)\n\
    \        postfix := append(postfix, myString[len(myString)-(i+6):]...)\n     \
    \   postfix := append(postfix, myString[len(myString)-(i+6):len(myString)-(i+7)]...)\n\
    \        postfix := append(postfix, myString[len(myString)-(i+7):]...)\n     \
    \   postfix := append(postfix, myString[len(myString)-(i+7):len(myString)-(i+8)]...)\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptw0f17_2_test.go:49:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    // This will be the prefix of\
    \ the palindromic suffix.\n    // The longest postfix is found by iterating over\
    \ myString backwards.\n    // The longest postfix is found by iterating over myString\
    \ backwards.\n    // The longest postfix is found by iterating over myString backwards.\n\
    \    // The longest postfix is found by iterating over myString backwards.\n \
    \   // The longest postfix is found by iterating over myString backwards.\n  \
    \  // The longest postfix is found by iterating over myString backwards.\n   \
    \ // The longest postfix is found by iterating over myString backwards.\n    //\
    \ The longest postfix is found by iterating over myString backwards.\n    // The\
    \ longest postfix is found by iterating over myString backwards.\n    // The longest\
    \ postfix is found by iterating over myString backwards.\n    // The longest postfix\
    \ is found by iterating over myString backwards.\n    // The longest postfix is\
    \ found by iterating over myString backwards.\n    // The longest postfix is found\
    \ by iterating over myString backwards.\n    // The longest postfix is found by\
    \ iterating over myString backwards.\n    // The longest postfix is found by iterating\
    \ over myString backwards.\n    // The longest postfix is found by iterating over\
    \ myString backwards.\n    // The longest postfix is found by iterating over myString\
    \ backwards.\n    // The longest postfix is found by iterating over myString backwards.\n\
    \    // The longest postfix is found by iterating over myString backwards.\n \
    \   // The longest postfix is found by iterating over myString backwards.\n  \
    \  // The longest postfix is found by iterating over myString backwards.\n   \
    \ // The longest postfix is found by iterating over myString backwards.\n    //\
    \ The longest postfix is found by iterating over myString backwards.\n    // The\
    \ longest postfix is found by iterating over myString backwards.\n    // The longest\
    \ postfix is found by iterating over myString backwards.\n    // The longest postfix\
    \ is found by iterating over myString backwards.\n    // The longest postfix is\
    \ found by iterating over myString backwards.\n    // The longest postfix is found\
    \ by iterating over myString backwards.\n    // The longest postfix \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpck6gxi0d_test.go:50:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    var myStringLen\
    \ int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix string\n\
    \    var myStringPrefixLen int\n    var myStringSuffixLen int\n    var myStringReversedLen\
    \ int\n    var myStringReversedPrefix string\n    var myStringReversedSuffix string\n\
    \    var myStringReversedPrefixLen int\n    var myStringReversedSuffixLen int\n\
    \    var myStringReversedReversedLen int\n    var myStringReversedReversedPrefix\
    \ string\n    var myStringReversedReversedSuffix string\n    var myStringReversedReversedPrefixLen\
    \ int\n    var myStringReversedReversedSuffixLen int\n    var myStringReversedReversedReversedLen\
    \ int\n\n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    for myStringLen = myStringLen - 1; myStringLen >= 0; myStringLen-- {\n  \
    \      myStringPrefix = myString[0:myStringLen]\n        myStringSuffixLen = len(myString)\
    \ - myStringLen + 1\n        myStringSuffixLen = myStringLen - myStringLen + 1\n\
    \        myStringReversedLen = myStringLen + 1\n        myStringReversedPrefix\
    \ = myString[0:myStringLen]\n        myStringReversedSuffixLen = len(myString)\
    \ - myStringLen + 1\n        myStringReversedSuffixLen = myStringLen - myStringLen\
    \ + 1\n        myStringReversedReversedLen = myStringLen + 1\n        myStringReversedReversedPrefix\
    \ = myString[0:myStringLen]\n        myStringReversedReversedSuffixLen = len(myString)\
    \ - myStringLen + 1\n        myStringReversedReversedSuffixLen = myStringLen -\
    \ myStringLen + 1\n        myStringReversedReversedReversedLen = myStringLen +\
    \ 1\n\n        // If postfix is a palindrome then append the reverse of the postfix\
    \ to the end of the string.\n        if myStringLen == 0 {\n            return\
    \ myString\n        }\n        if myStringLen == 1 {\n            return myStringPrefix\
    \ + myStringSuffix\n        }\n        if myStringLen == myStringLen / 2 {\n \
    \           return myStringPrefix + myStringSuffix + myStringReversedPrefix +\
    \ myStringReversedSuffix\n        }\n        if myStringLen > myStringLen / 2\
    \ {\n            return myStringPrefix + myStringSuffix + myStringReversedPrefix\
    \ + myStringReversedSuffix + myStringReversedReversedPrefix + myStringReversedReversedSuffix\n\
    \        }\n    }\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6z2fd_sr_test.go:22:9: myStringPrefixLen declared but not used

    /tmp/tmp6z2fd_sr_test.go:23:9: myStringSuffixLen declared but not used

    /tmp/tmp6z2fd_sr_test.go:24:9: myStringReversedLen declared but not used

    /tmp/tmp6z2fd_sr_test.go:27:9: myStringReversedPrefixLen declared but not used

    /tmp/tmp6z2fd_sr_test.go:28:9: myStringReversedSuffixLen declared but not used

    /tmp/tmp6z2fd_sr_test.go:29:9: myStringReversedReversedLen declared but not used

    /tmp/tmp6z2fd_sr_test.go:32:9: myStringReversedReversedPrefixLen declared but
    not used

    /tmp/tmp6z2fd_sr_test.go:33:9: myStringReversedReversedSuffixLen declared but
    not used

    /tmp/tmp6z2fd_sr_test.go:34:9: myStringReversedReversedReversedLen declared but
    not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[:i]\n        postfix += myString[len(myString)-i:]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ myString[len(myString)-len(postfix):]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):]\n        postfix +=\
    \ myString[:len(myString)-len(postfix)]\n        postfix += myString[len(myString)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ myString[len(myString)-len(postfix):]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):]\n        postfix +=\
    \ myString[:len(myString)-len(postfix)]\n        postfix += myString[len(myString)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ myString[len(myString)-len(postfix):]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):]\n        postfix +=\
    \ myString[:len(myString)-len(postfix)]\n        postfix += myString[len(myString)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ myString[len(myString)-len(postfix):]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):]\n        postfix +=\
    \ myString[:len(myString)-len(postfix)]\n        postfix += myString[len(myString)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ myString[len(myString)-len(postfix):]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):]\n        postfix +=\
    \ myString[:len(myString)-len(\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplzx27eim_test.go:55:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2cx8a0qo_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    // This will be the longest palindrome\
    \ that begins with myString.\n    // The longest postfix is found by reversing\
    \ myString and finding the\n    // longest palindrome that begins with myString\
    \ + the reverse of myString.\n    // The longest palindrome is found by reversing\
    \ myString and finding the\n    // longest palindrome that begins with myString\
    \ + the reverse of myString + the reverse of myString.\n    // The longest palindrome\
    \ is found by reversing myString and finding the\n    // longest palindrome that\
    \ begins with myString + the reverse of myString + the reverse of myString + the\
    \ reverse of myString.\n    // The longest palindrome is found by reversing myString\
    \ and finding the\n    // longest palindrome that begins with myString + the reverse\
    \ of myString + the reverse of myString + the reverse of myString + the reverse\
    \ of myString.\n    // The longest palindrome is found by reversing myString and\
    \ finding the\n    // longest palindrome that begins with myString + the reverse\
    \ of myString + the reverse of myString + the reverse of myString + the reverse\
    \ of myString + the reverse of myString.\n    // The longest palindrome is found\
    \ by reversing myString and finding the\n    // longest palindrome that begins\
    \ with myString + the reverse of myString + the reverse of myString + the reverse\
    \ of myString + the reverse of myString + the reverse of myString + the reverse\
    \ of myString.\n    // The longest palindrome is found by reversing myString and\
    \ finding the\n    // longest palindrome that begins with myString + the reverse\
    \ of myString + the reverse of myString + the reverse of myString + the reverse\
    \ of myString + the reverse of myString + the reverse of myString + the reverse\
    \ of myString.\n    // The longest palindrome is found by reversing myString and\
    \ finding the\n    // longest palindrome that begins with myString + the reverse\
    \ of myString + the reverse of myString + the reverse of myString + the reverse\
    \ of myString + the reverse of myString + the reverse of myString + the reverse\
    \ of myString + the reverse of myString.\n    // The longest palindrome is foun\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp51bgz55x_test.go:38:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        longestPalindrome += myString[i]\n\
    \        for j := i; j < len(myString); j++ {\n            if myString[j] != myString[len(myString)-j-1]\
    \ {\n                longestPalindromeLen += 1\n            }\n        }\n   \
    \     if longestPalindromeLen > longestPalindromeLen {\n            longestPalindrome\
    \ = myString[:i]\n            longestPalindromeLen = longestPalindromeLen - i\n\
    \        }\n    }\n    return longestPalindrome + myString[len(longestPalindrome):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbf3t0rrt_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpbf3t0rrt_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromePos := 0\n    for\
    \ i := 0; i < len(myString); i++ {\n        currString := myString[:i]\n     \
    \   currStringLen := len(currString)\n        currStringPos := i\n        if currStringLen\
    \ > longestPalindromeLen {\n            longestPalindrome = currString\n     \
    \       longestPalindromeLen = currStringLen\n            longestPalindromePos\
    \ = currStringPos\n        }\n    }\n    longestPalindrome = longestPalindrome[:longestPalindromePos]\
    \ + make_palindrome(myString[longestPalindromePos:])\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f361?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.make_palindrome({0x0?,\
    \ 0x0?})\n\t/tmp/tmp2vsatvla_test.go:18 +0xb5 fp=0xc0201e0390 sp=0xc0201e0388\
    \ pc=0x4ef715\ncommand-line-arguments_test.make_palindrome({0x0?, 0x0?})\n\t/tmp/tmp2vsatvla_test.go:32\
    \ +0x6a fp=0xc0201e03d8 sp=0xc0201e0390 pc=0x4ef6ca\ncommand-line-arguments_test.make_palindrome({0x0?,\
    \ 0x0?})\n\t/tmp/tmp2vsatvla_test.go:32 +0x6a fp=0xc0201e0420 sp=0xc0201e03d8\
    \ pc=0x4ef6ca\ncommand-line-arguments_test.make_palindrome({0x0?, 0x0?})\n\t/tmp/tmp2vsatvla_test.go:32\
    \ +0x6a fp=0xc0201e0468 sp=0xc0201e0420 pc=0x4ef6ca\ncommand-line-arguments_test.make_palindrome({0x0?,\
    \ 0x0?})\n\t/tmp/tmp2vsatvla_test.go:32 +0x6a fp=0xc0201e04b0 sp=0xc0201e0468\
    \ pc=0x4ef6ca\ncommand-line-arguments_test.make_palindrome({0x0?, 0x0?})\n\t/tmp/tmp2vsatvla_test.go:32\
    \ +0x6a fp=0xc0201e04f8 sp=0xc0201e04b0 pc=0x4ef6ca\ncommand-line-arguments_test.make_palindrome({0x0?,\
    \ 0x0?})\n\t/tmp/tmp2vsatvla_test.go:32 +0x6a fp=0xc0201e0540 sp=0xc0201e04f8\
    \ pc=0x4ef6ca\ncommand-line-arguments_test.make_palindrome({0x0?, 0x0?})\n\t/tmp/tmp2vsatvla_test.go:32\
    \ +0x6a fp=0xc0201e0588 sp=0xc0201e0540 pc=0x4ef6ca\ncommand-line-arguments_test.make_palindrome({0x0?,\
    \ 0x0?})\n\t/tmp/tmp2vsatvla_test.go:32 +0x6a fp=0xc0201e05d0 sp=0xc0201e0588\
    \ pc=0x4ef6ca\ncommand-line-arguments_test.make_palindrome({0x0?, 0x0?})\n\t/tmp/tmp2vsatvla_test.go:32\
    \ +0x6a fp=0xc0201e0618 sp=0xc0201e05d0 pc=0x4ef6ca\ncommand-line-arguments_test.make_palindrome({0x0?,\
    \ 0x0?})\n\t/tmp/tmp2vsatvla_test.go:32 +0x6a fp=0xc0201e0660 sp=0xc0201e0618\
    \ pc=0x4ef6ca\ncommand-line-arguments_test.make_palindrome({0x0?, 0x0?})\n\t/tmp/tmp2v"
  timestamp: 1660075501
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[i : i+longestPalindromeLen]\n    }\n    longestPalindromeLen -=\
    \ len(myString)\n    longestPalindrome += myString[len(myString) - longestPalindromeLen\
    \ : len(myString)]\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:6] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:6] with length 3\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp5vy9wse8_test.go:23\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp5vy9wse8_test.go:39\
    \ +0x70a\ntesting.tRunner(0xc0001036c0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075501
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString[:longestPalindromeLen]\n       \
    \ }\n    }\n    return longestPalindrome + myString[len(longestPalindrome):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqua_vu3y_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLength :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[0:i]\n\
    \        postfix += myString[len(myString)-i:]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLength\
    \ = len(postfix)\n        }\n    }\n    if longestPalindromeLength == 0 {\n  \
    \      return \"\"\n    }\n    // Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    prefix := myString[0:longestPalindromeLength]\n\
    \    prefix += myString[longestPalindromeLength:]\n    return prefix + longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8gzjz15k_test.go:34:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n  \
    \      suffix := myString[i:]\n        postfix := reversePostfix(prefix)\n   \
    \     postfix += suffix\n        postfix += reversePostfix(suffix)\n        postfix\
    \ += reversePostfix(prefix)\n        if postfix != \"\" {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLen = len(postfix)\n        }\n    }\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphw0wh2vk_test.go:25:20: undefined: reversePostfix

    /tmp/tmphw0wh2vk_test.go:27:20: undefined: reversePostfix

    /tmp/tmphw0wh2vk_test.go:28:20: undefined: reversePostfix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[0 :\
    \ len(myString)-i]\n        postfix += myString[len(myString)-i : len(myString)]\n\
    \        postfix += myString[len(myString)-i : len(myString)-i]\n        postfix\
    \ += myString[len(myString)-i : len(myString)-i]\n        postfix += myString[len(myString)-i\
    \ : len(myString)-i]\n        postfix += myString[len(myString)-i : len(myString)-i]\n\
    \        postfix += myString[len(myString)-i : len(myString)-i]\n        postfix\
    \ += myString[len(myString)-i : len(myString)-i]\n        postfix += myString[len(myString)-i\
    \ : len(myString)-i]\n        postfix += myString[len(myString)-i : len(myString)-i]\n\
    \        postfix += myString[len(myString)-i : len(myString)-i]\n        postfix\
    \ += myString[len(myString)-i : len(myString)-i]\n        postfix += myString[len(myString)-i\
    \ : len(myString)-i]\n        postfix += myString[len(myString)-i : len(myString)-i]\n\
    \        postfix += myString[len(myString)-i : len(myString)-i]\n        postfix\
    \ += myString[len(myString)-i : len(myString)-i]\n        postfix += myString[len(myString)-i\
    \ : len(myString)-i]\n        postfix += myString[len(myString)-i : len(myString)-i]\n\
    \        postfix += myString[len(myString)-i : len(myString)-i]\n        postfix\
    \ += myString[len(myString)-i : len(myString)-i]\n        postfix += myString[len(myString)-i\
    \ : len(myString)-i]\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate :=\
    \ make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmwysikrb_test.go:55:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        postfix := myString[i+1:]\n\
    \        if isPalindrome(prefix, postfix) {\n            longestPalindrome = prefix\
    \ + reverseString(postfix)\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    if longestPalindromeLen > 0 {\n        return longestPalindrome\n\
    \    } else {\n        return \"\"\n    }\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7avzyv8u_test.go:24:12: undefined: isPalindrome

    /tmp/tmp7avzyv8u_test.go:25:42: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += 1 // Increment the length of the longest\
    \ palindrome found\n        longestPalindrome += myString[i]\n    }\n    longestPalindromeLen\
    \ -= 1 // Decrement the length of the longest palindrome found\n    for i := 0;\
    \ i < longestPalindromeLen; i++ {\n        longestPalindrome += myString[len(myString)-i-1]\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpseu576ul_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpseu576ul_test.go:27:9: invalid operation: longestPalindrome += myString[len(myString)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    longestPalindrome := \"\"\n \
    \   longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i-- {\n\
    \        prefix := myString[:i]\n        postfix := myString[i:]\n        if isPalindrome(prefix,\
    \ postfix) {\n            longestPalindrome = prefix + longestPalindrome\n   \
    \         longestPalindromeLen = len(longestPalindrome)\n        }\n    }\n  \
    \  // Append the reverse of the longest postfix of myString that comes before\
    \ the palindromic suffix.\n    longestPalindrome = longestPalindrome + myString[:longestPalindromeLen]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0wjgrvnj_test.go:25:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        postfix\
    \ := make_palindrome_test(suffix)\n        if postfix != \"\" {\n            longestPalindrome\
    \ = prefix + postfix\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    if longestPalindromeLen > 0 {\n        return longestPalindrome\n\
    \    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp24pqf90d_test.go:24:20: undefined: make_palindrome_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    // This will be the prefix of\
    \ the palindrome we want.\n    // e.g. 'cat' -> 'cata'\n    longestPalindrome\
    \ := \"\"\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n\n    // Reverse the prefix of the longest postfix that\
    \ is a palindrome.\n    // e.g. 'cata' -> 'tac'\n    longestPalindromeReverse\
    \ := \"\"\n    for i := 0; i < len(longestPalindrome); i++ {\n        longestPalindromeReverse\
    \ += longestPalindrome[len(longestPalindrome)-i-1]\n    }\n\n    // Append the\
    \ reverse of the longest postfix to the end of the supplied string.\n    // e.g.\
    \ 'catac' -> 'catacata'\n    return longestPalindromeReverse + myString\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjsb3z7cc_test.go:24:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpjsb3z7cc_test.go:31:9: invalid operation: longestPalindromeReverse +=
    longestPalindrome[len(longestPalindrome) - i - 1] (mismatched types string and
    byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ = myString[:longestPalindromeLen] + myString[len(myString) - longestPalindromeLen:]\n\
    \        if myString[len(myString) - longestPalindromeLen:] == longestPalindrome\
    \ {\n            return longestPalindrome\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:5] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:5] with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpet1mrhpy_test.go:23\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpet1mrhpy_test.go:40\
    \ +0x72c\ntesting.tRunner(0xc0001924e0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075501
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome('')\n\
    \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindrom\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpizt9x9ox_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    // Assume that myString is at\
    \ least 1 character long.\n    longestPostfix := \"\"\n    longestPostfixLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix := append(postfix, myString[:i]...)\n        if isPalindrome(postfix)\
    \ {\n            longestPostfix = postfix\n            longestPostfixLen = len(postfix)\n\
    \        }\n    }\n\n    // Append the reverse of the longest postfix to the end\
    \ of myString.\n    // Assume that myString is at least 1 character long.\n  \
    \  longestPostfixReverse := make([]rune, longestPostfixLen)\n    for i := 0; i\
    \ < len(longestPostfix); i++ {\n        longestPostfixReverse[i] = longestPostfix[len(longestPostfix)-i-1]\n\
    \    }\n    return append(myString, longestPostfixReverse...)\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6bf_vuvd_test.go:25:17: no new variables on left side of :=

    /tmp/tmp6bf_vuvd_test.go:25:27: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmp6bf_vuvd_test.go:26:12: undefined: isPalindrome

    /tmp/tmp6bf_vuvd_test.go:36:36: cannot use longestPostfix[len(longestPostfix)
    - i - 1] (value of type byte) as type rune in assignment

    /tmp/tmp6bf_vuvd_test.go:38:19: first argument to append must be a slice; have
    myString (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n      \
    \  longestPalindrome += myString[len(myString)-(i+1)]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphwme51h7_test.go:21:26: no new variables on left side of :=

    /tmp/tmphwme51h7_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmphwme51h7_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - (i + 1)] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome\
    \ = myString[:longestPalindromeLen] + myString[i] + longestPalindrome\n      \
    \  longestPalindromeLen = len(longestPalindrome)\n    }\n    \n    // Append to\
    \ the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    longestPalindrome = longestPalindrome[:longestPalindromeLen-len(myString)]\
    \ + myString[len(myString):]\n    \n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdfaf9psg_test.go:34:37: invalid operation: myString[:longestPalindromeLen]
    + myString[i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    var myStringLen\
    \ int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix string\n\
    \    var myStringReversedSuffix string\n    var myStringReversedPrefix string\n\
    \    var myStringReversedString string\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReversedStringLen int\n    var myStringReversedStringLen int\n\
    \    var myStringReverse\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdencde59_test.go:76:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[i : i+longestPalindromeLen]\n    }\n    longestPalindromeLen +=\
    \ len(myString) - longestPalindromeLen\n    longestPalindrome += myString[len(myString)\
    \ - longestPalindromeLen : len(myString)]\n    return longestPalindrome\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:6] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:6] with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmprx0g1_um_test.go:23\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmprx0g1_um_test.go:39\
    \ +0x645\ntesting.tRunner(0xc0001a0340, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n\
    \        if isPalindrome(prefix, suffix) {\n            longestPalindrome = prefix\
    \ + suffix\n            longestPalindromeLen = len(longestPalindrome)\n      \
    \  }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnacz9t8b_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpnacz9t8b_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLength := len(myString)\n\
    \    for i := 0; i < longestPalindromeLength; i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    for i := 0; i < longestPalindromeLength; i++ {\n\
    \        longestPalindrome += myString[len(myString)-i-1]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx580iwhj_test.go:21:29: no new variables on left side of :=

    /tmp/tmpx580iwhj_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpx580iwhj_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n  \
    \      postfix := reverse(prefix)\n        if postfix != suffix {\n          \
    \  longestPalindrome = append(longestPalindrome, postfix)\n            longestPalindromeLength\
    \ = len(postfix)\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpegj7z9wa_test.go:24:20: undefined: reverse

    /tmp/tmpegj7z9wa_test.go:26:40: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    // This will be the prefix of\
    \ the palindromic suffix.\n    var longestPalindromeLen int\n    for i := 0; i\
    \ < len(myString); i++ {\n        if myString[i] != myString[len(myString)-i-1]\
    \ {\n            longestPalindromeLen = i\n            break\n        }\n    }\n\
    \n    // Append the reverse of the string prefix that comes before longestPalindromeLen.\n\
    \    // This will be the suffix of the palindromic prefix.\n    var reversedString\
    \ string\n    for i := 0; i < longestPalindromeLen; i++ {\n        reversedString\
    \ += myString[len(myString)-1-i]\n    }\n\n    // Append the palindromic suffix\
    \ to the end of the string.\n    // This will be the palindromic string.\n   \
    \ return reversedString + myString[longestPalindromeLen:]\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpew_8uhli_test.go:33:9: invalid operation: reversedString += myString[len(myString)
    - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix) {\n \
    \           longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    prefix := myString[:longestPalindromeLen]\n\
    \    return prefix + reverseString(prefix)\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpthozg4oj_test.go:20:5: longestPalindrome declared but not used

    /tmp/tmpthozg4oj_test.go:24:12: undefined: isPalindrome

    /tmp/tmpthozg4oj_test.go:32:21: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Initialize\
    \ a variable to hold the longest postfix of myString that is a palindrome.\n \
    \   // Initialize a variable to hold the reverse of the longest postfix of myString\
    \ that is a palindrome.\n    var longestPalindrome string\n    var longestPalindromeReverse\
    \ string\n\n    // Iterate through each character in myString.\n    for i := 0;\
    \ i < len(myString); i++ {\n        // Initialize a variable to hold the current\
    \ character in myString.\n        var currentCharacter string\n\n        // Iterate\
    \ through each character in myString.\n        for j := 0; j < len(myString);\
    \ j++ {\n            // If the current character in myString is equal to the current\
    \ character in longestPalindrome,\n            // then append the reverse of the\
    \ longest postfix of myString that is a palindrome.\n            if myString[i]\
    \ == myString[j] {\n                currentCharacter = currentCharacter + myString[len(myString)-1-j]\n\
    \            } else {\n                // If the current character in myString\
    \ is not equal to the current character in longestPalindrome,\n              \
    \  // then append the longest postfix of myString that is a palindrome.\n    \
    \            currentCharacter = currentCharacter + myString[j]\n            }\n\
    \        }\n\n        // If the current character in myString is equal to the\
    \ current character in longestPalindrome,\n        // then append the reverse\
    \ of the longest postfix of myString that is a palindrome.\n        if myString[i]\
    \ == myString[len(myString)-1-i] {\n            longestPalindrome = longestPalindrome\
    \ + currentCharacter\n        } else {\n            // If the current character\
    \ in myString is not equal to the current character in longestPalindrome,\n  \
    \          // then append the longest postfix of myString that is a palindrome.\n\
    \            longestPalindrome = longestPalindrome + currentCharacter\n      \
    \  }\n    }\n\n    // Append the reverse of the longest postfix of myString that\
    \ is a palindrome.\n    longestPalindromeReverse = longestPalindrome + longestPalindromeReverse\n\
    \n    // Return the longest postfix of myString that is a palindrome.\n    return\
    \ longestPalindromeReverse\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmploii8dba_test.go:34:36: invalid operation: currentCharacter + myString[len(myString)
    - 1 - j] (mismatched types string and byte)

    /tmp/tmploii8dba_test.go:38:36: invalid operation: currentCharacter + myString[j]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    var myStringLen\
    \ int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix string\n\
    \    var myStringReversedSuffix string\n    var myStringReversedPrefix string\n\
    \    var myStringReversedString string\n\n    for i := 0; i < myStringLen; i++\
    \ {\n        myStringPrefix = myString[:i]\n        myStringSuffix = myString[i:]\n\
    \        myStringReversedSuffix = reverse(myStringSuffix)\n        myStringReversedPrefix\
    \ = reverse(myStringPrefix)\n        myStringReversedString = myStringReversedPrefix\
    \ + myStringReversedSuffix\n        if myStringReversedString == myString {\n\
    \            return myString\n        }\n    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphslr5dow_test.go:29:34: undefined: reverse

    /tmp/tmphslr5dow_test.go:30:34: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    // This will be the length of\
    \ the palindrome plus one.\n    longestPalindrome := 0\n    for i := len(myString)\
    \ - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = i + 1\n        }\n    }\n\n    // Append\
    \ the reverse of the string prefix that comes before the palindromic suffix.\n\
    \    // This will be the length of the palindrome plus one.\n    result := myString\n\
    \    for i := 0; i < longestPalindrome; i++ {\n        result = result[:len(result)-1]\
    \ + myString[len(myString)-(i+1):]\n    }\n\n    return result\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwvv4adu1_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        postfix\
    \ := longestPalindrome[longestPalindromeLen:] + suffix\n        longestPalindromeLen\
    \ += len(postfix)\n        if postfix != prefix {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLen = len(postfix)\n        }\n    }\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmp86kxgcxs_test.go:51: expected 'xyzyx', got 'z'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp86kxgcxs_test.go:51:\
    \ expected 'xyx', got 'x'\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n\
    \        tmp86kxgcxs_test.go:51: expected 'jerryrrej', got 'y'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n      \
    \  longestPalindromeLen := len(longestPalindrome)\n        if longestPalindromeLen\
    \ > len(prefix) + len(suffix) {\n            longestPalindrome = prefix\n    \
    \    }\n        if longestPalindromeLen < len(prefix) + len(suffix) {\n      \
    \      longestPalindrome += suffix\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpguwrm7nc_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        longestPalindrome += myString[i]\n\
    \        for j := i + 1; j < len(myString); j++ {\n            if myString[j]\
    \ != myString[j] {\n                longestPalindromeLen += 1\n              \
    \  if longestPalindromeLen > longestPalindromeLen {\n                    longestPalindrome\
    \ = myString[:j] + myString[j:]\n                    longestPalindromeLen = j\n\
    \                }\n                break\n            }\n        }\n    }\n \
    \   return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn4r0b29c_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpn4r0b29c_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := longestPalindromeLen + 1\n        longestPalindrome\
    \ += myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n   \
    \     longestPalindrome += myString[len(myString)-i-1]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0chel4d2_test.go:22:9: longestPalindromeLen declared but not used

    /tmp/tmp0chel4d2_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmp0chel4d2_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        postfix := myString[i:]\n       \
    \ if isPalindrome(prefix, postfix) {\n            longestPalindrome = prefix +\
    \ reverseString(postfix)\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppc9zy2iu_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmppc9zy2iu_test.go:24:12: undefined: isPalindrome

    /tmp/tmppc9zy2iu_test.go:25:42: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        longestPalindromeLen\
    \ := len(longestPalindrome)\n        longestPalindrome = longestPalindrome + suffix\n\
    \        if longestPalindrome == prefix {\n            longestPalindrome = longestPalindrome[:longestPalindromeLen]\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp21bgzvvg_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome('')\n\
    \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindrom\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpizt9x9ox_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    var myStringLen\
    \ int = len(myString)\n    var myStringPrefix string = \"\"\n    var myStringSuffix\
    \ string = \"\"\n    var myStringPalindrome string = \"\"\n\n    for i := 0; i\
    \ < myStringLen; i++ {\n        myStringPrefix = myStringPrefix + myString[i]\n\
    \    }\n\n    for i := 0; i < myStringLen; i++ {\n        myStringSuffix = myStringSuffix\
    \ + myString[i]\n    }\n\n    for i := 0; i < myStringLen; i++ {\n        if myStringSuffix\
    \ == myStringPrefix {\n            myStringPalindrome = myStringPalindrome + myStringSuffix\n\
    \            myStringPrefix = myStringPrefix + myString[i]\n            myStringSuffix\
    \ = myStringSuffix + myString[i]\n        }\n    }\n\n    return myStringPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm1djsdce_test.go:25:26: invalid operation: myStringPrefix + myString[i]
    (mismatched types string and byte)

    /tmp/tmpm1djsdce_test.go:29:26: invalid operation: myStringSuffix + myString[i]
    (mismatched types string and byte)

    /tmp/tmpm1djsdce_test.go:35:30: invalid operation: myStringPrefix + myString[i]
    (mismatched types string and byte)

    /tmp/tmpm1djsdce_test.go:36:30: invalid operation: myStringSuffix + myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        longestPalindromeLen += len(myString)\
    \ - i\n        longestPalindrome += myString[:i]\n        longestPalindrome +=\
    \ myString[len(myString) - i:len(myString)]\n    }\n    longestPalindromeLen +=\
    \ len(myString) - len(longestPalindrome)\n    longestPalindrome += myString[len(myString)\
    \ - longestPalindromeLen:]\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [-1:] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [-1:]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpjn22h_ml_test.go:37\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpjn22h_ml_test.go:49\
    \ +0x799\ntesting.tRunner(0xc0001a0340, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        postfix\
    \ := make_palindrome_test(prefix, suffix)\n        if postfix != \"\" {\n    \
    \        if postfix < longestPalindrome {\n                longestPalindrome =\
    \ postfix\n                longestPalindromeLen = len(postfix)\n            }\n\
    \        }\n    }\n    if longestPalindromeLen > 0 {\n        return longestPalindrome\
    \ + myString[:longestPalindromeLen]\n    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_hk12gw0_test.go:24:20: undefined: make_palindrome_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := len(myString) - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n\
    \        postfix += string(myString[i+1:])\n        if isPalindrome(postfix) {\n\
    \            longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome('')\n\
    \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    return longestPalindrome + string(myString[:longestPalindromeLen])\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprjpm4cdr_test.go:34:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[len(myString)-i:] + myString[:len(myString)-i]\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmpjo_8886z_test.go:45: expected 'xyzyx', got 'xyzzxyyzx'\n\
    \    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpjo_8886z_test.go:45:\
    \ expected 'xyx', got 'xyxxxyyxx'\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmpjo_8886z_test.go:45: expected 'jerryrrej', got 'jerryyjerrryjerrryjeerryj'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    var myStringLen\
    \ int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix string\n\
    \    var myStringReversedPrefix string\n    var myStringReversedSuffix string\n\
    \    var myStringReversedSuffixLen int\n    var myStringReversedSuffixPrefix string\n\
    \    var myStringReversedSuffixSuffixLen int\n    var myStringReversedSuffixSuffixPrefix\
    \ string\n    var myStringReversedSuffixSuffixSuffix string\n\n    // Find the\
    \ longest postfix of supplied string that is a palindrome.\n    for myStringLen\
    \ > 0 {\n        myStringPrefix = myString[0:myStringLen]\n        myStringSuffix\
    \ = myString[myStringLen:]\n        myStringReversedPrefix = myStringPrefix[0\
    \ : len(myStringPrefix)-len(myStringSuffix)]\n        myStringReversedSuffix =\
    \ myStringSuffix[0:len(myStringSuffix) - len(myStringReversedPrefix)]\n      \
    \  myStringReversedSuffixLen = len(myStringReversedSuffix)\n        myStringReversedSuffixPrefix\
    \ = myStringReversedSuffix[0:myStringReversedSuffixLen]\n        myStringReversedSuffixSuffixLen\
    \ = len(myStringReversedSuffixSuffix)\n        myStringReversedSuffixSuffixPrefix\
    \ = myStringReversedSuffixSuffix[0:myStringReversedSuffixSuffixLen]\n        myStringReversedSuffixSuffixSuffix\
    \ = myStringReversedSuffixSuffix[0:myStringReversedSuffixSuffixLen]\n        if\
    \ myStringPrefix == myStringReversedSuffixSuffixPrefix {\n            myStringLen\
    \ = myStringLen - 1\n        } else {\n            myStringLen = myStringLen +\
    \ 1\n        }\n    }\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp25wmdg7i_test.go:25:9: myStringReversedSuffixPrefix declared but not used

    /tmp/tmp25wmdg7i_test.go:38:47: undefined: myStringReversedSuffixSuffix

    /tmp/tmp25wmdg7i_test.go:39:46: undefined: myStringReversedSuffixSuffix

    /tmp/tmp25wmdg7i_test.go:40:46: undefined: myStringReversedSuffixSuffix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    longestPalindrome := \"\"\n    longestPalindromeLen\
    \ := 0\n    for i := len(myString) - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n\
    \        postfix += string(myString[i+1:])\n        if postfix != make_palindrome(postfix)\
    \ {\n            continue\n        }\n        longestPalindrome = postfix\n  \
    \      longestPalindromeLen = len(postfix)\n    }\n    if longestPalindromeLen\
    \ > 0 {\n        return longestPalindrome\n    }\n    return myString\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0378\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f361?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\nruntime.concatstrings(0x0?, {0xc0201e03a8?,\
    \ 0x2?, 0x2?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/string.go:25\
    \ +0x270 fp=0xc0201e0388 sp=0xc0201e0380 pc=0x44d5d0\nruntime.concatstring2(0xc0201e0428?,\
    \ {0x51d187?, 0x0?}, {0x51d187?, 0x0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/string.go:60\
    \ +0x50 fp=0xc0201e03d8 sp=0xc0201e0388 pc=0x44d650\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmp428udxjm_test.go:27 +0x95 fp=0xc0201e0438 sp=0xc0201e03d8 pc=0x4ef6f5\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmp428udxjm_test.go:28\
    \ +0xa5 fp=0xc0201e0498 sp=0xc0201e0438 pc=0x4ef705\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmp428udxjm_test.go:28 +0xa5 fp=0xc0201e04f8 sp=0xc0201e0498 pc=0x4ef705\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmp428udxjm_test.go:28\
    \ +0xa5 fp=0xc0201e0558 sp=0xc0201e04f8 pc=0x4ef705\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmp428udxjm_test.go:28 +0xa5 fp=0xc0201e05b8 sp=0xc0201e0558 pc=0x4ef705\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmp428udxjm_test.go:28\
    \ +0xa5 fp=0xc0201e0618 sp=0xc0201e05b8 pc=0x4ef705\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmp428udxjm_test.go:28 +0xa5 fp=0xc0201e0678 sp=0xc0201e0618 pc=0x4ef705\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmp428udxjm_test.go:28\
    \ +0xa5 fp=0xc0201e06d8 sp=0xc0201e0678 pc=0x4ef705\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmp428udxjm_test.go:28 +0xa5 f"
  timestamp: 1660075505
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        postfix := myString[:i]\n \
    \       postfix += myString[len(myString)-i:]\n        postfix += myString[:len(myString)-i]\n\
    \        postfix += myString[len(myString)-len(postfix):]\n        postfix +=\
    \ myString[len(myString)-len(postfix):len(myString)]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)]\n     \
    \   postfix += myString[:len(myString)-len(postfix)]\n        postfix += myString[len(myString)-len(postfix):len(myString)]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ myString[len(myString)-len(postfix):len(myString)]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)]\n     \
    \   postfix += myString[:len(myString)-len(postfix)]\n        postfix += myString[len(myString)-len(postfix):len(myString)]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ myString[len(myString)-len(postfix):len(myString)]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)]\n     \
    \   postfix += myString[:len(myString)-len(postfix)]\n        postfix += myString[len(myString)-len(postfix):len(myString)]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ myString[len(myString)-len(postfix):len(myString)]\n        postfix += myString\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1azj0bk3_test.go:56:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[i : i+longestPalindromeLen]\n    }\n    longestPalindrome += myString[len(myString)\
    \ - longestPalindromeLen : len(myString)]\n    return longestPalindrome\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:6] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:6] with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpi5ah9xqu_test.go:23\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpi5ah9xqu_test.go:38\
    \ +0x6f2\ntesting.tRunner(0xc000192680, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075496
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        longestPalindromeLen += myString[i]\n\
    \    }\n    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome\
    \ += myString[len(myString)-i-1]\n    }\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindrome += myString[len(myString)-i-1]\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptlwt6si8_test.go:23:9: invalid operation: longestPalindromeLen += myString[i]
    (mismatched types int and byte)

    /tmp/tmptlwt6si8_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i - 1] (mismatched types string and byte)

    /tmp/tmptlwt6si8_test.go:29:9: invalid operation: longestPalindrome += myString[len(myString)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n      \
    \  postfix := reversePostfix(prefix)\n        postfix += suffix\n        postfix\
    \ += reversePostfix(suffix)\n        postfix += reversePostfix(prefix)\n     \
    \   if postfix != \"\" {\n            longestPalindrome = postfix\n          \
    \  longestPalindromeLen = len(postfix)\n        }\n    }\n    if longestPalindromeLen\
    \ > len(myString) {\n        return \"\"\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6njwkaxd_test.go:24:20: undefined: reversePostfix

    /tmp/tmp6njwkaxd_test.go:26:20: undefined: reversePostfix

    /tmp/tmp6njwkaxd_test.go:27:20: undefined: reversePostfix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromePrefix := \"\
    \"\n    longestPalindromeSuffix := \"\"\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        longestPalindromeLength\
    \ = len(longestPalindrome) + len(prefix) + len(suffix)\n        if longestPalindromeLength\
    \ > longestPalindromeLength {\n            longestPalindrome = prefix\n      \
    \      longestPalindromePrefix = prefix\n            longestPalindromeSuffix =\
    \ suffix\n        } else {\n            longestPalindrome = prefix + suffix\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9dpxaih3_test.go:21:5: longestPalindromePrefix declared but not used

    /tmp/tmp9dpxaih3_test.go:22:5: longestPalindromeSuffix declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[longestPalindromeLen:] + myString[:longestPalindromeLen]\n\
    \        postfix += myString[len(myString) - longestPalindromeLen - i:] + myString[:len(myString)\
    \ - longestPalindromeLen - i]\n        longestPalindromeLen += len(postfix)\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = postfix\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphexj4xx3_test.go:25:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    longestPalindrome := \"\"\n    longestPalindromeLen\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[:i]\n\
    \        postfix += myString[len(myString)-i:]\n        postfix += myString[:len(myString)-i]\n\
    \        postfix += myString[len(myString)-len(postfix):]\n        postfix +=\
    \ myString[:len(myString)-len(postfix)-i]\n        postfix += myString[len(myString)-len(postfix)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)-len(postfix)-i]\n   \
    \     postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)-len(postfix)-len(postfix)-i]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-i]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-i]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-i]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqqc3973w_test.go:43:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := len(myString) - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n\
    \        postfix += myString[len(myString)-i-1:]\n        postfix += myString[len(myString)-i:]\n\
    \        if postfix != myString {\n            longestPalindrome = postfix\n \
    \           longestPalindromeLen = len(postfix)\n        }\n    }\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    return\
    \ longestPalindrome + myString[:longestPalindromeLen]\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:2] with length 1 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:2] with length 1\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpcvdlxwnv_test.go:47\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpcvdlxwnv_test.go:58\
    \ +0x8c5\ntesting.tRunner(0xc000103380, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075504
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8e7cjpkk_test.go:87:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        postfix\
    \ := make_palindrome_test(prefix)\n        if postfix != \"\" {\n            longestPalindromeLen\
    \ := len(postfix)\n            if longestPalindromeLen > longestPalindromeLen\
    \ {\n                longestPalindrome = postfix\n            }\n        }\n \
    \   }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkw1oqv8f_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpkw1oqv8f_test.go:23:9: suffix declared but not used

    /tmp/tmpkw1oqv8f_test.go:24:20: undefined: make_palindrome_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8e7cjpkk_test.go:87:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    longestPalindrome += myString[len(myString)-len(longestPalindrome):]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp35mgdlz2_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075504
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        postfix += myString[:i]\n      \
    \  postfix += myString[i:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[len(myString)-i:]\n        postfix += myString[:len(myString)-i]\n\
    \        postfix += myString[len(myString)-i:len(myString)]\n        postfix +=\
    \ myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:len(myString)-i]\n\
    \        postfix += myString[len(myString)-i:len(myString)]\n        postfix +=\
    \ myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2ufmqlho_test.go:61:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n  \
    \      suffix := myString[i:]\n        postfix := reversePostfix(prefix)\n   \
    \     if postfix != \"\" {\n            longestPalindromeLen += len(postfix)\n\
    \            if longestPalindromeLen > longestPalindromeLen {\n              \
    \  longestPalindrome = postfix\n                longestPalindromeLen = len(postfix)\n\
    \            }\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn58ps6ha_test.go:24:9: suffix declared but not used

    /tmp/tmpn58ps6ha_test.go:25:20: undefined: reversePostfix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075504
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n  \
    \      suffix := myString[i:]\n        longestPalindromeLen += len(prefix)\n \
    \       longestPalindromeLen += len(suffix)\n        if longestPalindromeLen >\
    \ len(longestPalindrome) {\n            longestPalindrome = prefix\n         \
    \   longestPalindromeLen = len(prefix)\n        }\n        if longestPalindromeLen\
    \ < len(longestPalindrome) {\n            longestPalindrome = suffix\n       \
    \     longestPalindromeLen = len(suffix)\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1\
    \ (0.00s)\n        tmpt5ynvgky_test.go:56: expected 'x', got ''\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__2 (0.00s)\n        tmpt5ynvgky_test.go:56: expected\
    \ 'xyzyx', got 'xy'\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n \
    \       tmpt5ynvgky_test.go:56: expected 'xyx', got 'xy'\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmpt5ynvgky_test.go:56: expected 'jerryrrej', got 'jerr'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075504
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[i : i+longestPalindromeLen]\n    }\n    longestPalindromeLen -=\
    \ len(myString)\n    longestPalindrome += myString[len(myString) - longestPalindromeLen\
    \ : len(myString)]\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:6] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:6] with length 3\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp5vy9wse8_test.go:23\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp5vy9wse8_test.go:39\
    \ +0x70a\ntesting.tRunner(0xc0001036c0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075501
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength = 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLength++\n\
    \            }\n        }\n        if longestPalindromeLength > longestPalindromeLength\
    \ {\n            longestPalindrome = myString[:longestPalindromeLength]\n    \
    \    }\n    }\n    return longestPalindrome + myString[len(longestPalindrome):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmpnui0wp_6_test.go:52: expected 'xyzyx', got 'xyz'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpnui0wp_6_test.go:52:\
    \ expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660075504
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome('')\n\
    \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindrom\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpizt9x9ox_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    // If no such postfix exists,\
    \ return myString unchanged.\n    longestPostfix := \"\"\n    for i := 0; i <\
    \ len(myString); i++ {\n        postfix := myString[:i]\n        if isPalindrome(postfix)\
    \ {\n            longestPostfix = postfix\n            break\n        }\n    }\n\
    \    if longestPostfix == \"\" {\n        return myString\n    }\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    suffix := myString[len(longestPostfix):]\n    return longestPostfix\
    \ + suffix[0 : len(suffix)/2] + suffix[len(suffix)/2:]\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm92dm68l_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075504
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[i : i+longestPalindromeLen]\n    }\n    longestPalindromeLen -=\
    \ len(myString)\n    longestPalindrome += myString[0 : longestPalindromeLen]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:6] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:6] with length 3\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpww5bu_6m_test.go:23\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpww5bu_6m_test.go:39\
    \ +0x6a5\ntesting.tRunner(0xc00019aea0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075505
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        postfix := myString[:i]\n        postfix += string(reverse(postfix))\n\
    \        postfix += myString[i:]\n        postfix += string(reverse(postfix))\n\
    \        if postfix != longestPalindrome {\n            longestPalindrome = postfix\n\
    \            longestPalindromeLength = len(postfix)\n        }\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu3cua_j5_test.go:20:5: longestPalindromeLength declared but not used

    /tmp/tmpu3cua_j5_test.go:23:27: undefined: reverse

    /tmp/tmpu3cua_j5_test.go:25:27: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075504
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := longestPalindromeLen + 1\n        longestPalindrome\
    \ += myString[i]\n    }\n    for i := 0; i < longestPalindromeLen/2; i++ {\n \
    \       longestPalindrome += myString[len(myString)-i-1]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpun5yxqwh_test.go:22:9: longestPalindromeLen declared but not used

    /tmp/tmpun5yxqwh_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpun5yxqwh_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075504
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[:len(myString)-i]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[len(myString)-1:]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcguj6qox_test.go:58:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075504
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    var myStringLen\
    \ int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix string\n\
    \    var myStringReversedSuffix string\n    var myStringReversedPrefix string\n\
    \    var myStringReversedReversedSuffix string\n    var myStringReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedSuffix string\n    var myStringReversedReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myStringReversedReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myStringReversedReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myStringReversedReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myStringReversedReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myStringReversedReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myStringReversedReversedReversedReversedReversedSuffix string\n    var\
    \ my\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5e5v_ka0_test.go:53:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075504
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := len(myString) - 1; i >= 0; i-- {\n        char := myString[i]\n\
    \        \n        // Find longest postfix of supplied string that is a palindrome.\n\
    \        // Algorithm idea is simple:\n        // - Find the longest postfix of\
    \ supplied string that is a palindrome.\n        // - Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        // >>> make_palindrome('')\n        // ''\n        // >>> make_palindrome('cat')\n\
    \        // 'catac'\n        // >>> make_palindrome('cata')\n        // 'catac'\n\
    \        if char == myString[len(myString)-i+1] {\n            longestPalindrome\
    \ = append(longestPalindrome, char)\n            longestPalindromeLen++\n    \
    \    }\n    }\n    \n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffi\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9w_v1uts_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075504
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    // This will be the longest palindrome\
    \ that begins with myString.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest postfix is found by iterating\
    \ through myString backwards.\n    // The longest \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoyuet1fv_test.go:50:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075504
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    var myStringLen\
    \ int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix string\n\
    \    var myStringReversedPrefix string\n    var myStringReversedSuffix string\n\
    \    var myStringReversedSuffixLen int\n    var myStringReversedSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixLen int\n    var myStringReversedSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixLen int\n    var\
    \ myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixLen int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5g_g_7l6_test.go:44:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075504
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n      \
    \  postfix := reverse(prefix)\n        if suffix == postfix {\n            longestPalindrome\
    \ = prefix + postfix\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    if longestPalindromeLen > 0 {\n        return longestPalindrome\n\
    \    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdz0vrwdg_test.go:24:20: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075505
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    // This will be the longest palindrome\
    \ that starts with myString.\n    // The longest postfix of myString is myString\
    \ + myString[0:len(myString)-1]\n    // >>> make_palindrome('cat')\n    // 'cat'\n\
    \    // >>> make_palindrome('cats')\n    // 'cats'\n    // >>> make_palindrome('cats')\n\
    \    // 'cats'\n    // >>> make_palindrome('cats')\n    // 'cats'\n    // >>>\
    \ make_palindrome('cats')\n    // 'cats'\n    // >>> make_palindrome('cats')\n\
    \    // 'cats'\n    // >>> make_palindrome('cats')\n    // 'cats'\n    // >>>\
    \ make_palindrome('cats')\n    // 'cats'\n    // >>> make_palindrome('cats')\n\
    \    // 'cats'\n    // >>> make_palindrome('cats')\n    // 'cats'\n    // >>>\
    \ make_palindrome('cats')\n    // 'cats'\n    // >>> make_palindrome('cats')\n\
    \    // 'cats'\n    // >>> make_palindrome('cats')\n    // 'cats'\n    // >>>\
    \ make_palindrome('cats')\n    // 'cats'\n    // >>> make_palindrome('cats')\n\
    \    // 'cats'\n    // >>> make_palindrome('cats')\n    // 'cats'\n    // >>>\
    \ make_palindrome('cats')\n    // 'cats'\n    // >>> make_palindrome('cats')\n\
    \    // 'cats'\n    // >>> make_palindrome('cats')\n    // 'cats'\n    // >>>\
    \ make_palindrome('cats')\n    // 'cats'\n    // >>> make_palindrome('cats')\n\
    \    // 'cats'\n    // >>> make_palindrome('cats')\n    // 'cats'\n    // >>>\
    \ make_palindrome('cats')\n    // 'cats'\n    // >>> make_palindrome('cats')\n\
    \    // 'cats'\n    // >>> make_palindrome('cats')\n    // 'cats'\n    // >>>\
    \ make_palindrome('cats')\n    // 'cats'\n    // >>> make_palindrome('cats')\n\
    \    // 'cats'\n    // >>> make_palindrome('cats')\n    // 'cats'\n    // >>>\
    \ make_palindrome('cats')\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnk4lpqqr_test.go:80:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075504
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ = myString[:i+1] + myString[i+longestPalindromeLen:]\n        if longestPalindrome\
    \ == myString[:i+1] + myString[i+longestPalindromeLen:] {\n            return\
    \ longestPalindrome\n        }\n    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmp72j_38tw_test.go:48: expected 'xyzyx', got 'x'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp72j_38tw_test.go:48:\
    \ expected 'xyx', got 'x'\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n\
    \        tmp72j_38tw_test.go:48: expected 'jerryrrej', got 'j'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075505
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := longestPalindromeLen + 1\n        longestPalindrome\
    \ += myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n   \
    \     longestPalindrome += myString[len(myString)-i]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdbpc3_m7_test.go:22:9: longestPalindromeLen declared but not used

    /tmp/tmpdbpc3_m7_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpdbpc3_m7_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075505
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[longestPalindromeLen:] + myString[:i]\n     \
    \   postfix += make_palindrome(postfix)\n        longestPalindromeLen += len(postfix)\n\
    \        if longestPalindromeLen > len(longestPalindrome) {\n            longestPalindrome\
    \ = postfix\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0388\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f361?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\nruntime.concatstrings(0x0?, {0xc0201e03b8?,\
    \ 0x2?, 0x2?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/string.go:25\
    \ +0x270 fp=0xc0201e0398 sp=0xc0201e0390 pc=0x44d5d0\nruntime.concatstring2(0x1?,\
    \ {0x51d187?, 0x44d650?}, {0x51d187?, 0xc0201e0420?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/string.go:60\
    \ +0x50 fp=0xc0201e03e8 sp=0xc0201e0398 pc=0x44d650\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmp3tvevq84_test.go:22 +0x96 fp=0xc0201e0450 sp=0xc0201e03e8 pc=0x4ef6f6\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmp3tvevq84_test.go:23\
    \ +0xa5 fp=0xc0201e04b8 sp=0xc0201e0450 pc=0x4ef705\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmp3tvevq84_test.go:23 +0xa5 fp=0xc0201e0520 sp=0xc0201e04b8 pc=0x4ef705\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmp3tvevq84_test.go:23\
    \ +0xa5 fp=0xc0201e0588 sp=0xc0201e0520 pc=0x4ef705\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmp3tvevq84_test.go:23 +0xa5 fp=0xc0201e05f0 sp=0xc0201e0588 pc=0x4ef705\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmp3tvevq84_test.go:23\
    \ +0xa5 fp=0xc0201e0658 sp=0xc0201e05f0 pc=0x4ef705\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmp3tvevq84_test.go:23 +0xa5 fp=0xc0201e06c0 sp=0xc0201e0658 pc=0x4ef705\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmp3tvevq84_test.go:23\
    \ +0xa5 fp=0xc0201e0728 sp=0xc0201e06c0 pc=0x4ef705\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmp3tvevq84_test.go:23 +0"
  timestamp: 1660075506
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome('')\n\
    \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n\
    \    // 'catac'\n    // >>> make_palindrome('cata')\n    // 'catac'\n    \n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindrom\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpizt9x9ox_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        longestPalindromeLen += 1 //\
    \ Increment the length of the longest palindrome so far.\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindromeLen -= 1 // Decrement the length\
    \ of the longest palindrome so far.\n    longestPalindrome += myString[longestPalindromeLen:]\n\
    \    longestPalindromeLen -= 1 // Decrement the length of the longest palindrome\
    \ so far.\n    longestPalindrome += myString[:longestPalindromeLen]\n    longestPalindromeLen\
    \ -= 1 // Decrement the length of the longest palindrome so far.\n    longestPalindrome\
    \ += myString[longestPalindromeLen:]\n    longestPalindromeLen -= 1 // Decrement\
    \ the length of the longest palindrome so far.\n    longestPalindrome += myString[:longestPalindromeLen]\n\
    \    longestPalindromeLen -= 1 // Decrement the length of the longest palindrome\
    \ so far.\n    longestPalindrome += myString[longestPalindromeLen:]\n    longestPalindromeLen\
    \ -= 1 // Decrement the length of the longest palindrome so far.\n    longestPalindrome\
    \ += myString[:longestPalindromeLen]\n    longestPalindromeLen -= 1 // Decrement\
    \ the length of the longest palindrome so far.\n    longestPalindrome += myString[longestPalindromeLen:]\n\
    \    longestPalindromeLen -= 1 // Decrement the length of the longest palindrome\
    \ so far.\n    longestPalindrome += myString[:longestPalindromeLen\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9un1v3v4_test.go:50:56: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075504
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    longestPalindrome := \"\"\n    longestPalindromeLen\
    \ := 0\n    for i := len(myString) - 1; i >= 0; i-- {\n        prefix := myString[:i]\n\
    \        postfix := myString[i:]\n        if isPalindrome(prefix, postfix) {\n\
    \            longestPalindrome = prefix + reverseString(postfix)\n           \
    \ longestPalindromeLen = len(longestPalindrome)\n        }\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphbnylr72_test.go:24:5: longestPalindromeLen declared but not used

    /tmp/tmphbnylr72_test.go:28:12: undefined: isPalindrome

    /tmp/tmphbnylr72_test.go:29:42: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075505
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[:i+1]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+2]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+3]\n        postfix += \"-\"\n    \
    \    postfix += myString[:i+4]\n        postfix += \"-\"\n        postfix += myString[:i+5]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+6]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+7]\n        postfix += \"-\"\n    \
    \    postfix += myString[:i+8]\n        postfix += \"-\"\n        postfix += myString[:i+9]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+10]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+11]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+12]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+13]\n        postfix += \"-\"\n        postfix += myString[:i+14]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+15]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+16]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+17]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+18]\n        postfix += \"-\"\n        postfix += myString[:i+19]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+20]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+21]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+22]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+23]\n        postfix += \"-\"\n        postfix += myString[:i+24]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+25]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+26]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+27]\n        postfix += \"-\"\n        post\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiuug95o6_test.go:81:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075505
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[:i+1]\n        if isPalindrome(postfix) {\n     \
    \       longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    prefix := myString[:longestPalindromeLen]\n\
    \    suffix := myString[longestPalindromeLen:]\n    return prefix + reverse(suffix)\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1nav4_5i_test.go:20:5: longestPalindrome declared but not used

    /tmp/tmp1nav4_5i_test.go:24:12: undefined: isPalindrome

    /tmp/tmp1nav4_5i_test.go:33:21: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075505
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLength2 := 0\n\
    \    longestPalindromeLength3 := 0\n    longestPalindromeLength4 := 0\n    longestPalindromeLength5\
    \ := 0\n    longestPalindromeLength6 := 0\n    longestPalindromeLength7 := 0\n\
    \    longestPalindromeLength8 := 0\n    longestPalindromeLength9 := 0\n    longestPalindromeLength10\
    \ := 0\n    longestPalindromeLength11 := 0\n    longestPalindromeLength12 := 0\n\
    \    longestPalindromeLength13 := 0\n    longestPalindromeLength14 := 0\n    longestPalindromeLength15\
    \ := 0\n    longestPalindromeLength16 := 0\n    longestPalindromeLength17 := 0\n\
    \    longestPalindromeLength18 := 0\n    longestPalindromeLength19 := 0\n    longestPalindromeLength20\
    \ := 0\n    longestPalindromeLength21 := 0\n    longestPalindromeLength22 := 0\n\
    \    longestPalindromeLength23 := 0\n    longestPalindromeLength24 := 0\n    longestPalindromeLength25\
    \ := 0\n    longestPalindromeLength26 := 0\n    longestPalindromeLength27 := 0\n\
    \    longestPalindromeLength28 := 0\n    longestPalindromeLength29 := 0\n    longestPalindromeLength30\
    \ := 0\n    longestPalindromeLength31 := 0\n    longestPalindromeLength32 := 0\n\
    \    longestPalindromeLength33 := 0\n    longestPalindromeLength34 := 0\n    longestPalindromeLength35\
    \ := 0\n    longestPalindromeLength36 := 0\n    longestPalindromeLength37 := 0\n\
    \    longestPalindromeLength38 := 0\n    longestPalindromeLength39 := 0\n    longestPalindromeLength40\
    \ := 0\n    longestPalindromeLength41 := 0\n    longestPalindromeLength42 := 0\n\
    \    longestPalindromeLength43 := 0\n    longestPalindromeLength44 := 0\n    longestPalindromeLength45\
    \ := 0\n    longest\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate :=\
    \ make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsmm6fo32_test.go:66:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075505
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := len(myString) - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n\
    \        postfix += string(myString[len(myString)-i-1:])\n        postfix += string(myString[:i])\n\
    \        \n        // If postfix is a palindrome.\n        if isPalindrome(postfix)\
    \ {\n            // If this postfix is longer than the longest palindrome so far.\n\
    \            if len(postfix) > longestPalindromeLen {\n                longestPalindrome\
    \ = postfix\n                longestPalindromeLen = len(postfix)\n           \
    \ }\n        }\n    }\n    \n    // Append to the end of the string reverse of\
    \ a string prefix that comes before the palindromic suffix.\n    longestPalindrome\
    \ += string(myString[:longestPalindromeLen])\n    \n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9qngjsz0_test.go:39:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075505
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    longestPalindrome := \"\"\n    longestPalindromeLen\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[:i]\n\
    \        postfix += myString[len(postfix)-i:]\n        postfix += myString[:len(postfix)-i]\n\
    \        postfix += myString[len(postfix)-i:]\n        postfix += myString[:len(postfix)-i]\n\
    \        postfix += myString[len(postfix)-i:]\n        postfix += myString[:len(postfix)-i]\n\
    \        postfix += myString[len(postfix)-i:]\n        postfix += myString[:len(postfix)-i]\n\
    \        postfix += myString[len(postfix)-i:]\n        postfix += myString[:len(postfix)-i]\n\
    \        postfix += myString[len(postfix)-i:]\n        postfix += myString[:len(postfix)-i]\n\
    \        postfix += myString[len(postfix)-i:]\n        postfix += myString[:len(postfix)-i]\n\
    \        postfix += myString[len(postfix)-i:]\n        postfix += myString[:len(postfix)-i]\n\
    \        postfix += myString[len(postfix)-i:]\n        postfix += myString[:len(postfix)-i]\n\
    \        postfix += myString[len(postfix)-i:]\n        postfix += myString[:len(postfix)-i]\n\
    \        postfix += myString[len(postfix)-i:]\n        postfix += myString[:len(postfix)-i]\n\
    \        postfix += myString[len(postfix)-i:]\n        postfix += myString[:len(postfix)-i]\n\
    \        postfix += myString[len(postfix)-i:]\n        postfix += myString[:len(postfix)-i]\n\
    \        postfix += myString[len(postfix)-i:]\n        postfix += myString[:len(postfix)-i]\n\
    \        postfix += myString[len(postfix)-i:]\n        postfix += myString[:len(postfix)-i]\n\
    \        postfix += myString[len(postfix)-i:]\n        postfix += myString[:len(postfix)-i]\n\
    \        postfix += myString[len(postfix\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl9myiiko_test.go:59:40: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075505
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n      \
    \  longestPalindrome += myString[len(myString)-(i+1)]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphwme51h7_test.go:21:26: no new variables on left side of :=

    /tmp/tmphwme51h7_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmphwme51h7_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - (i + 1)] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ postfix of myString that is a palindrome.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n  \
    \  // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find longest postfix of myString that is a palindrome.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // >>> make_palindrome('')\n\
    \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find longest postfix of myString that is a palindrome.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // >>> make_palindrome('')\n\
    \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find longest postfix of myString that is a palindrome.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // >>> make_palindrome('')\n\
    \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    \n    // Find longest postfix of myString that is a palindrome.\n\
    \    // The longest postfix is found by reversing a \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpes3mt__0_test.go:61:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075505
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    var myStringLen\
    \ int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix string\n\
    \    var myStringPalindrome string\n\n    // Find the longest postfix of supplied\
    \ string that is a palindrome.\n    for i := 0; i < myStringLen; i++ {\n     \
    \   myStringPrefix = myString[:i]\n        myStringSuffix = myString[i:]\n   \
    \     myStringPalindrome = myStringPrefix + reverse(myStringSuffix) + myStringSuffix\n\
    \        if myStringPalindrome == myString {\n            return myStringPalindrome\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5o_iqy9h_test.go:28:47: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075505
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    longestPalindrome := \"\"\n    longestPalindromeLen\
    \ := 0\n    for i := len(myString) - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n\
    \        postfix += myString[len(myString)-i:len(myString)]\n        postfix +=\
    \ myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n \
    \       postfix += myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25o0lfki_test.go:59:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075505
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLength := len(myString)\n\
    \    for i := 0; i < longestPalindromeLength; i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    for i := 0; i < longestPalindromeLength; i++ {\n\
    \        longestPalindrome += myString[len(myString)-i-1]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx580iwhj_test.go:21:29: no new variables on left side of :=

    /tmp/tmpx580iwhj_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpx580iwhj_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome('')\n    // ''\n\
    \    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := len(myString) - 1; i >= 0; i-- {\n        postfix := myString[0:i+1]\n\
    \        reverse := myString[i+1:]\n        if postfix != reverse {\n        \
    \    longestPalindrome = postfix + reverse\n            longestPalindromeLen =\
    \ len(postfix)\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpir8301ss_test.go:30:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075505
