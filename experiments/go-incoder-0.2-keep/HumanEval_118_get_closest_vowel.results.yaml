language: go_test.go
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    vowelsCount\
    \ += len(word) - len(vowels)\n    for _, v := range word {\n        if v == 'a'\
    \ || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n            vowelsCount++\n\
    \        }\n    }\n    if vowelsCount > len(vowels)-1 {\n        return \"\"\n\
    \    }\n    for _, v := range vowels {\n        if word[len(word)-vowelsCount]\
    \ == v {\n            return v\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvn52mfil_test.go:37:43: invalid operation: word[len(word) - vowelsCount]
    == v (mismatched types byte and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpquhwcwi7_test.go:90:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount *= 2\n    if vowelsCount\
    \ > len(vowels)-1 {\n        vowelsCount = len(vowels)-1\n    }\n    vowelsCount\
    \ /= 2\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount\
    \ *= 2\n    if vowelsCount > len(vowels)-1 {\n        vowelsCount = len(vowels)-1\n\
    \    }\n    vowelsCount /= 2\n    if vowelsCount < 0 {\n        vowelsCount =\
    \ 0\n    }\n    vowelsCount *= 2\n    if vowelsCount > len(vowels)-1 {\n     \
    \   vowelsCount = len(vowels)-1\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount *= 2\n    if vowelsCount\
    \ > len(vowels)-1 {\n        vowelsCount = len(vowels)-1\n    }\n    vowelsCount\
    \ /= 2\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount\
    \ *= 2\n    if vowelsCount > len(vowels)-1 {\n        vowelsCount = len(vowels)-1\n\
    \    }\n    vowelsCount /= 2\n    if vowelsCount < 0 {\n        vowelsCount =\
    \ 0\n    }\n    vowelsCount *= 2\n    if vowelsCount > len(vowels)-1 {\n     \
    \   vowelsCount = len(vowels)-1\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount *= 2\n    if vowelsCount\
    \ > len(vowels)-1 {\n        vowelsCount = len(vowels)-1\n    }\n    vowelsCount\
    \ /= 2\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount\
    \ *= 2\n    if vowelsCount > len(vowels)-1 {\n        vowelsCount = len(vowels)-1\n\
    \    }\n    vowelsCount /= 2\n    if vowelsCount < 0 {\n        vowelsCount =\
    \ 0\n    }\n    vowelsCount *= 2\n    if vowelsCount > len(vowels)-1 {\n     \
    \   vowelsCount = len(vowels)\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsatx7xiz_test.go:101:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount /= len(vowels)\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount /= len(vowels)\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount /= len(vowels)\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount \nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptmpeeo27_test.go:80:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 3\n    vowelsLen -= 4\n    vowelsLen -= 5\n    vowelsLen -= 6\n    vowelsLen\
    \ -= 7\n    vowelsLen -= 8\n    vowelsLen -= 9\n    vowelsLen -= 10\n    vowelsLen\
    \ -= 11\n    vowelsLen -= 12\n    vowelsLen -= 13\n    vowelsLen -= 14\n    vowelsLen\
    \ -= 15\n    vowelsLen -= 16\n    vowelsLen -= 17\n    vowelsLen -= 18\n    vowelsLen\
    \ -= 19\n    vowelsLen -= 20\n    vowelsLen -= 21\n    vowelsLen -= 22\n    vowelsLen\
    \ -= 23\n    vowelsLen -= 24\n    vowelsLen -= 25\n    vowelsLen -= 26\n    vowelsLen\
    \ -= 27\n    vowelsLen -= 28\n    vowelsLen -= 29\n    vowelsLen -= 30\n    vowelsLen\
    \ -= 31\n    vowelsLen -= 32\n    vowelsLen -= 33\n    vowelsLen -= 34\n    vowelsLen\
    \ -= 35\n    vowelsLen -= 36\n    vowelsLen -= 37\n    vowelsLen -= 38\n    vowelsLen\
    \ -= 39\n    vowelsLen -= 40\n    vowelsLen -= 41\n    vowelsLen -= 42\n    vowelsLen\
    \ -= 43\n    vowelsLen -= 44\n    vowelsLen -= 45\n    vowelsLen -= 46\n    vowelsLen\
    \ -= 47\n    vowelsLen -= 48\n    vowelsLen -= 49\n    vowelsLen -= 50\n    vowelsLen\
    \ -= 51\n    vowelsLen -= 52\n    vowelsLen -= 53\n    vowelsLen -= 54\n    vowelsLen\
    \ -= 55\n    vowelsLen -= 56\n    vowelsLen -= 57\n    vowelsLen -= 58\n    vowelsLen\
    \ -= 59\n    vowelsLen -= 60\n    vowelsLen -= 61\n    vowelsLen -= 62\n    vowelsLen\
    \ -= 63\n    vowelsLen -= 64\n    vowelsLen -= 65\n    vowelsLen -= 66\n    vowelsLen\
    \ -= 67\n    vowelsLen -= 68\n    vowelsLen -= 69\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_x51n_7a_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphmqd3dsk_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb0d1rz2e_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074713
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsyaim82f_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1167zrff_test.go:71:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    i\
    \ := len(word) - 1\n    for {\n        if i == 0 {\n            break\n      \
    \  }\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            i -= 1\n        } else {\n         \
    \   break\n        }\n    }\n    return word[i]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvfb2s_ir_test.go:22:12: undefined: strings

    /tmp/tmpvfb2s_ir_test.go:46:12: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowel\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr86n_mlm_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n   \
    \ \n    vowels\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqvob0aq6_test.go:114:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    i := len(word)\
    \ - 1\n    for i := len(word) - 2; i >= 0; i-- {\n        if word[i] == word[i+1]\
    \ {\n            return word[i]\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1japlyw8_test.go:23:12: undefined: strings

    /tmp/tmp1japlyw8_test.go:37:5: i declared but not used

    /tmp/tmp1japlyw8_test.go:40:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1167zrff_test.go:71:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpofja0s41_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmkz79rh4_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9bue61ef_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n\
    \    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen +=\
    \ 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg4j04t9v_test.go:97:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb0d1rz2e_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074713
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels) - len(strings.Split(word,\
    \ \"\")) - 2\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n\
    \        return word[strings.LastIndex(word, \"e\")+1:]\n    }\n    return \"\"\
    \n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1a21azjb_test.go:21:38: undefined: strings

    /tmp/tmp1a21azjb_test.go:23:12: undefined: strings

    /tmp/tmp1a21azjb_test.go:28:21: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb0d1rz2e_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074713
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1167zrff_test.go:71:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb0d1rz2e_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074713
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ /= len(vowels)\n    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount /= len(vowels)\n    vowelsCount %=\
    \ len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ /= len(vowels)\n    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount /= len(vowels)\n    vowelsCount %=\
    \ len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ /= len(vowels)\n    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount /= len(vowels)\n    vowelsCount %=\
    \ len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ /= len(vowels)\n    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount /= len(vowels)\n    vowelsCount %=\
    \ len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ /= len(vowels)\n    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount /= len(vowels)\n    vowelsCount %=\
    \ len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ /= len(vowels)\n    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount /= len(vowels)\n    vowelsCount %=\
    \ len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ /= len(vowels)\n    vowelsCount %= len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpult61jb__test.go:104:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount < 2 {\n     \
    \   return \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount %= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    i := len(word) - 1\n\
    \    for ; i >= 0; i-- {\n        if word[i] == vowels[vowelsCount] {\n      \
    \      vowelsCount++\n            if vowelsCount == len(vowels) {\n          \
    \      return word[i]\n            }\n        }\n    }\n    return \"\"\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3mkwmvux_test.go:36:23: invalid operation: word[i] == vowels[vowelsCount]
    (mismatched types byte and string)

    /tmp/tmp3mkwmvux_test.go:39:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1167zrff_test.go:71:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n     \
    \   return word\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if\
    \ word[i] == word[len(word)-1] {\n            return word[i]\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjwogbdbr_test.go:31:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_jzurh7g_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount \nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplfeo8te6_test.go:84:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount <= 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    lastVowel := \"\"\n   \
    \ lastVowelCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            lastVowel = v\n            lastVowelCount++\n        }\n \
    \   }\n    if lastVowelCount <= 0 {\n        return \"\"\n    }\n    lastVowelCount\
    \ -= 1\n    if lastVowelCount > vowelsCount {\n        return \"\"\n    }\n  \
    \  if lastVowelCount < vowelsCount {\n        return lastVowel\n    }\n    lastVowel\
    \ = lastVowel[:len(lastVowel)-1]\n    return lastVowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwc_n2f4z_test.go:22:12: undefined: strings

    /tmp/tmpwc_n2f4z_test.go:33:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount <= 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 1\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowels\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfqkeye27_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word, \"_\"\
    ))) / 2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word,\
    \ \"_\"))) % 2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word)\
    \ - len(strings.Split(word, \"_\"))) % len(vowels)\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += (len(word) - len(strings.Split(word, \"_\"))) % len(vowels)\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word,\
    \ \"_\"))) % len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word)\
    \ - len(strings.Split(word, \"_\"))) % len(vowels)\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += (len(word) - len(strings.Split(word, \"_\"))) % len(vowels)\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word,\
    \ \"_\"))) % len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word)\
    \ - len(strings.Split(word, \"_\"))) % len(vowels)\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += (len(word) - len(strings.Split(word, \"_\"))) % len(vowels)\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word,\
    \ \"_\"))) % len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word)\
    \ - len(strings.Split(word, \"_\"))) % len(vowels)\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += (len(word) - len(strings.Split(word, \"_\"))) % len(vowels)\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word,\
    \ \"_\"))) % len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word)\
    \ - len(strings.Split(word, \"\nfunc TestGet_Closest_Vowel(t *testing.T) {\n \
    \ candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp3jtc0au_test.go:60:57: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpofja0s41_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    lastVowel := \"\"\n   \
    \ lastVowelCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            lastVowel = v\n            lastVowelCount++\n        }\n \
    \   }\n    if lastVowelCount < vowelsCount {\n        return \"\"\n    }\n   \
    \ if lastVowelCount > vowelsCount {\n        return lastVowel\n    }\n    lastVowelCount\
    \ -= 1\n    for _, v := range vowels {\n        if strings.Contains(word, v) {\n\
    \            lastVowel = v\n            lastVowelCount++\n        }\n    }\n \
    \   if lastVowelCount < vowelsCount {\n        return \"\"\n    }\n    if lastVowelCount\
    \ > vowelsCount {\n        return lastVowel\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpglkh_n72_test.go:22:12: undefined: strings

    /tmp/tmpglkh_n72_test.go:33:12: undefined: strings

    /tmp/tmpglkh_n72_test.go:46:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpofja0s41_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbi756moq_test.go:83:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ *= 2\n    vowelsCount /= 2\n    vowelsCount *= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount *= 2\n    vowelsCount /= 2\n    vowelsCount *= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount *= 2\n    vowelsCount /= 2\n    vowelsCount *= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount *= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ *= 2\n    vowelsCount /= 2\n    vowelsCount *= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount *= 2\n    vowelsCount /= 2\n    vowelsCount *= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount *= 2\n    vowelsCount /= 2\n    vowelsCount *= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount *= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ *= 2\n    vowelsCount /= 2\n    vowelsCount *= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount *= 2\n    vowelsCount /= 2\n    vowelsCount *= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount *= 2\n    vowelsCount /= 2\n    vowelsCount *= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount *= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ *= 2\n    vowelsCount /= 2\n    vowelsCount *= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount *= 2\n    vowelsCount /= 2\n    vowelsCount *= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount *= 2\n    vowelsCount /= 2\n    vowelsCount *= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount *= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ *= 2\n    vowelsCount /= 2\n    vowelsCount *= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount *= 2\n    vowelsCount /= 2\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdju6kacs_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowel\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoz68x0b0_test.go:80:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsyaim82f_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := \"aeiouAEIOU\"\n    vowelLen := len(vowel)\n\
    \    vowelPos := len(word) - vowelLen - 1\n    vowelPos %= len(word)\n    vowelPos\
    \ -= vowelPos%2\n    vowelPos /= 2\n    vowelPos %= len(vowel)\n    vowelPos /=\
    \ 2\n    vowelPos %= len(vowel)\n    vowelPos /= 2\n    vowelPos %= len(vowel)\n\
    \    vowelPos /= 2\n    vowelPos %= len(vowel)\n    vowelPos /= 2\n    vowelPos\
    \ %= len(vowel)\n    vowelPos /= 2\n    vowelPos %= len(vowel)\n    vowelPos /=\
    \ 2\n    vowelPos %= len(vowel)\n    vowelPos /= 2\n    vowelPos %= len(vowel)\n\
    \    vowelPos /= 2\n    vowelPos %= len(vowel)\n    vowelPos /= 2\n    vowelPos\
    \ %= len(vowel)\n    vowelPos /= 2\n    vowelPos %= len(vowel)\n    vowelPos /=\
    \ 2\n    vowelPos %= len(vowel)\n    vowelPos /= 2\n    vowelPos %= len(vowel)\n\
    \    vowelPos /= 2\n    vowelPos %= len(vowel)\n    vowelPos /= 2\n    vowelPos\
    \ %= len(vowel)\n    vowelPos /= 2\n    vowelPos %= len(vowel)\n    vowelPos /=\
    \ 2\n    vowelPos %= len(vowel)\n    vowelPos /= 2\n    vowelPos %= len(vowel)\n\
    \    vowelPos /= 2\n    vowelPos %= len(vowel)\n    vowelPos /= 2\n    vowelPos\
    \ %= len(vowel)\n    vowelPos /= 2\n    vowelPos %= len(vowel)\n    vowelPos /=\
    \ 2\n    vowelPos %= len(vowel)\n    vowelPos /= 2\n    vowelPos %= len(vowel)\n\
    \    vowelPos /= 2\n    vowelPos %= len(vowel)\n    vowelPos /= 2\n    vowelPos\
    \ %= len(vowel)\n    vowelPos /= 2\n    vowelPos %= len(vowel)\n    vowelPos /=\
    \ 2\n    vowelPos %= len(vowel)\n    vowelPos /= 2\n    vowelPos %= len(vowel)\n\
    \    vowelPos /= 2\n    vowelPos %= len(vowel\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgu1g6i1r_test.go:81:26: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb0d1rz2e_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074713
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    for _, r := range word {\n        if vowel_count < len(vowel) {\n\
    \            if r == vowel[vowel_count] {\n                vowel_count++\n   \
    \         }\n        }\n    }\n    if vowel_count == 0 {\n        return \"\"\n\
    \    }\n    vowel_count -= 1\n    vowel_count %= len(vowel)\n    if vowel_count\
    \ == 0 {\n        return word[vowel_count:]\n    }\n    return word[vowel_count:]\
    \ + word[:vowel_count]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpsu4ovnzi_test.go:64: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpsu4ovnzi_test.go:64: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n     \
    \   tmpsu4ovnzi_test.go:64: expected '', got 'easy'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpsu4ovnzi_test.go:64: expected '', got 'ali'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__5 (0.00s)\n        tmpsu4ovnzi_test.go:64: expected\
    \ 'a', got 'bad'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n  \
    \      tmpsu4ovnzi_test.go:64: expected 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpsu4ovnzi_test.go:64: expected '', got 'ab'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpsu4ovnzi_test.go:64: expected\
    \ '', got 'ba'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n   \
    \     tmpsu4ovnzi_test.go:64: expected 'i', got 'nimea'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmpsu4ovnzi_test.go:64: expected '', got 'Asia'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpsu4ovnzi_test.go:64:\
    \ expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074717
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word, \"_\"\
    ))) / 2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word,\
    \ \"_\"))) % 2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word)\
    \ - len(strings.Split(word, \"_\"))) % len(vowels)\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += (len(word) - len(strings.Split(word, \"_\"))) % len(vowels)\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word,\
    \ \"_\"))) % len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word)\
    \ - len(strings.Split(word, \"_\"))) % len(vowels)\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += (len(word) - len(strings.Split(word, \"_\"))) % len(vowels)\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word,\
    \ \"_\"))) % len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word)\
    \ - len(strings.Split(word, \"_\"))) % len(vowels)\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += (len(word) - len(strings.Split(word, \"_\"))) % len(vowels)\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word,\
    \ \"_\"))) % len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word)\
    \ - len(strings.Split(word, \"_\"))) % len(vowels)\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += (len(word) - len(strings.Split(word, \"_\"))) % len(vowels)\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word,\
    \ \"_\"))) % len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word)\
    \ - len(strings.Split(word, \"\nfunc TestGet_Closest_Vowel(t *testing.T) {\n \
    \ candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp3jtc0au_test.go:60:57: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := \"aeiouAEIOU\"\n    vowelCount := 0\n    i :=\
    \ len(word) - 1\n    for i >= 0 {\n        if word[i] == vowel[0] {\n        \
    \    vowelCount++\n        }\n        if word[i] == vowel[len(vowel)-1] {\n  \
    \          vowelCount++\n        }\n        i--\n    }\n    if vowelCount == 0\
    \ {\n        return \"\"\n    }\n    i := len(word) - 1\n    for i >= 0 {\n  \
    \      if word[i] == vowel[len(vowel)-1] {\n            return vowel[len(vowel)-1]\n\
    \        }\n        i--\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp32u64s1__test.go:34:7: no new variables on left side of :=

    /tmp/tmp32u64s1__test.go:37:20: cannot use vowel[len(vowel) - 1] (value of type
    byte) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa25c2n1f_test.go:84:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowel\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_dp627ln_test.go:110:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    lastVowel := \"\"\n    lastVowelLen := 0\n    \n    for i :=\
    \ len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' ||\
    \ word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            lastVowel\
    \ = word[i]\n            lastVowelLen = 1\n        } else {\n            if lastVowelLen\
    \ > 0 {\n                if lastVowelLen > vowelsLen {\n                    lastVowel\
    \ = \"\"\n                    lastVowelLen = 0\n                } else {\n   \
    \                 lastVowelLen -= vowelsLen\n                }\n            }\n\
    \            lastVowel = \"\"\n            lastVowelLen = 0\n        }\n    }\n\
    \    return lastVowel\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm_ka7dnc_test.go:30:25: cannot use word[i] (value of type byte) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // write your code here\n    vowel := \"\"\n    vowelCount\
    \ := 0\n    vowelCount := 0\n    for i := len(word) - 1; i >= 0; i-- {\n     \
    \   if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' ||\
    \ word[i] == 'u' {\n            vowelCount += 1\n            if vowelCount > 1\
    \ {\n                vowel = word[i]\n                break\n            }\n \
    \       }\n    }\n    return vowel\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpon6nhetp_test.go:22:16: no new variables on left side of :=

    /tmp/tmpon6nhetp_test.go:27:25: cannot use word[i] (value of type byte) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsyaim82f_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmkz79rh4_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpofja0s41_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    return vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbmbn4dxs_test.go:23:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n\
    \    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen +=\
    \ 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg4j04t9v_test.go:97:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpofja0s41_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Write your code here\n    vowels := []rune(\"aeiou\"\
    )\n    vowelsLen := len(vowels)\n    vowelsCount := 0\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount > 0 {\n        for i := len(word) - 1; i >= 0;\
    \ i-- {\n            if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u' {\n                vowelsCount--\n        \
    \    }\n            if vowelsCount == 0 {\n                return word[i]\n  \
    \          }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8q1g45y5_test.go:21:5: vowelsLen declared but not used

    /tmp/tmp8q1g45y5_test.go:34:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_jzurh7g_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo47yqofq_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word, \"e\"\
    ))) / 2\n    vowelsCount -= (len(word) - len(strings.Split(word, \"i\"))) / 2\n\
    \    vowelsCount -= (len(word) - len(strings.Split(word, \"o\"))) / 2\n    vowelsCount\
    \ -= (len(word) - len(strings.Split(word, \"u\"))) / 2\n    vowelsCount /= len(vowels)\n\
    \    vowelsCount -= (len(word) - len(strings.Split(word, \"a\"))) / 2\n    vowelsCount\
    \ -= (len(word) - len(strings.Split(word, \"b\"))) / 2\n    vowelsCount -= (len(word)\
    \ - len(strings.Split(word, \"c\"))) / 2\n    vowelsCount -= (len(word) - len(strings.Split(word,\
    \ \"d\"))) / 2\n    vowelsCount -= (len(word) - len(strings.Split(word, \"e\"\
    ))) / 2\n    vowelsCount -= (len(word) - len(strings.Split(word, \"f\"))) / 2\n\
    \    vowelsCount -= (len(word) - len(strings.Split(word, \"g\"))) / 2\n    vowelsCount\
    \ -= (len(word) - len(strings.Split(word, \"h\"))) / 2\n    vowelsCount -= (len(word)\
    \ - len(strings.Split(word, \"i\"))) / 2\n    vowelsCount -= (len(word) - len(strings.Split(word,\
    \ \"j\"))) / 2\n    vowelsCount -= (len(word) - len(strings.Split(word, \"k\"\
    ))) / 2\n    vowelsCount -= (len(word) - len(strings.Split(word, \"l\"))) / 2\n\
    \    vowelsCount -= (len(word) - len(strings.Split(word, \"m\"))) / 2\n    vowelsCount\
    \ -= (len(word) - len(strings.Split(word, \"n\"))) / 2\n    vowelsCount -= (len(word)\
    \ - len(strings.Split(word, \"o\"))) / 2\n    vowelsCount -= (len(word) - len(strings.Split(word,\
    \ \"p\"))) / 2\n    vowelsCount -= (len(word) - len(strings.Split(word, \"q\"\
    ))) / 2\n    vowelsCount -= (len(word) - len(strings.Split(word, \"r\"))) / 2\n\
    \    vowelsCount -= (len(word) - len(strings.Split(word, \"s\"))) / 2\n    vowelsCount\
    \ -= (len(word\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8676bu8u_test.go:56:29: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpofja0s41_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbi756moq_test.go:83:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpofja0s41_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmkz79rh4_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb0d1rz2e_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074713
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += (len(word) - len(word)) % len(vowels)\n \
    \   return vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpgl5u1hex_test.go:61: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpgl5u1hex_test.go:61: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpgl5u1hex_test.go:61: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpgl5u1hex_test.go:61: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpgl5u1hex_test.go:61:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpgl5u1hex_test.go:61: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074717
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpofja0s41_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word[len(word)-len(v)-1] == v {\n            vowelsCount--\n \
    \       }\n    }\n    if vowelsCount <= 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ += len(vowels)\n    for _, v := range vowels {\n        if word[len(word)-len(v)-1]\
    \ != v {\n            vowelsCount--\n        }\n    }\n    if vowelsCount <= 0\
    \ {\n        return \"\"\n    }\n    vowelsCount += len(vowels)\n    for _, v\
    \ := range vowels {\n        if word[len(word)-len(v)-1] == v {\n            vowelsCount--\n\
    \        }\n    }\n    if vowelsCount <= 0 {\n        return \"\"\n    }\n   \
    \ vowelsCount += len(vowels)\n    for _, v := range vowels {\n        if word[len(word)-len(v)-1]\
    \ != v {\n            vowelsCount--\n        }\n    }\n    if vowelsCount <= 0\
    \ {\n        return \"\"\n    }\n    return vowels[len(vowels)-1]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbcgemfwp_test.go:23:40: invalid operation: word[len(word) - len(v) - 1]
    == v (mismatched types byte and string)

    /tmp/tmpbcgemfwp_test.go:32:40: invalid operation: word[len(word) - len(v) - 1]
    != v (mismatched types byte and string)

    /tmp/tmpbcgemfwp_test.go:41:40: invalid operation: word[len(word) - len(v) - 1]
    == v (mismatched types byte and string)

    /tmp/tmpbcgemfwp_test.go:50:40: invalid operation: word[len(word) - len(v) - 1]
    != v (mismatched types byte and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074717
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo47yqofq_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo47yqofq_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune(\"aeiouAEIOU\")\n    vowelLen := len(vowel)\n\
    \    vowelIndex := 0\n    vowelLen := len(word)\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex = 0\n    vowelIndex\
    \ = 0\n    vowelIndex = 0\n    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvx5p9etb_test.go:119:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n     \
    \   return word\n    }\n    vowelsCount = 0\n    for _, v := range vowels {\n\
    \        if word[len(word)-1:] == v {\n            vowelsCount++\n        }\n\
    \    }\n    if vowelsCount > 0 {\n        return word\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpth4_l893_test.go:66: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpth4_l893_test.go:66: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpth4_l893_test.go:66: expected '', got 'ali'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpth4_l893_test.go:66: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpth4_l893_test.go:66: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpth4_l893_test.go:66: expected '', got 'ba'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpth4_l893_test.go:66: expected 'i', got 'anime'\n    ---\
    \ FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpth4_l893_test.go:66:\
    \ expected '', got 'Asia'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpth4_l893_test.go:66: expected 'o', got 'Above'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074717
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount < 2 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    return vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnhfhdqje_test.go:22:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo47yqofq_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjjvxffa4_test.go:111:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074717
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(word) - len(strings.Split(word,\
    \ \"a\")[0])\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    return\
    \ vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphj99ft3k_test.go:22:12: undefined: strings

    /tmp/tmphj99ft3k_test.go:29:36: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    lastVowel := \"\"\n   \
    \ for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == word[len(word)-1]\
    \ {\n            lastVowel = word[i]\n            break\n        }\n    }\n  \
    \  if lastVowel == \"\" {\n        return \"\"\n    }\n    lastVowel = strings.ToLower(lastVowel)\n\
    \    for _, v := range vowels {\n        if strings.Contains(lastVowel, v) {\n\
    \            return v\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc5q92_eh_test.go:22:12: undefined: strings

    /tmp/tmpc5q92_eh_test.go:33:25: cannot use word[i] (value of type byte) as type
    string in assignment

    /tmp/tmpc5q92_eh_test.go:40:17: undefined: strings

    /tmp/tmpc5q92_eh_test.go:42:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ += 1\n    vowelsCount /= 2\n    vowelsCount += 1\n    vowelsCount /= 2\n   \
    \ vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount += 1\n    vowelsCount\
    \ /= 2\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount += 1\n   \
    \ vowelsCount /= 2\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ += 1\n    vowelsCount /= 2\n    vowelsCount += 1\n    vowelsCount /= 2\n   \
    \ vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount += 1\n    vowelsCount\
    \ /= 2\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount += 1\n   \
    \ vowelsCount /= 2\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ += 1\n    vowelsCount /= 2\n    vowelsCount += 1\n    vowelsCount /= 2\n   \
    \ vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount += 1\n    vowelsCount\
    \ /= 2\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount += 1\n   \
    \ vowelsCount /= 2\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ += 1\n    vowelsCount /= 2\n    vowelsCount += 1\n    vowelsCount /= 2\n   \
    \ vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount += 1\n    vowelsCount\
    \ /= 2\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount += 1\n   \
    \ vowelsCount /= 2\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ += 1\n    vowelsCount /= 2\n    vowelsCount += 1\n    vowelsCount /= 2\n   \
    \ vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount += 1\n    vowelsCount\
    \ /= 2\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount += 1\n   \
    \ vowelsCount \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgght2aen_test.go:99:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074717
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word, \"_\"\
    ))) / 2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word,\
    \ \"-\"))) / 2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word)\
    \ - len(strings.Split(word, \".\"))) / 2\n    vowelsCount %= len(vowels)\n   \
    \ vowelsCount += (len(word) - len(strings.Split(word, \"!\"))) / 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word, \"?\"\
    ))) / 2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word,\
    \ \"-\"))) / 2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word)\
    \ - len(strings.Split(word, \".\"))) / 2\n    vowelsCount %= len(vowels)\n   \
    \ vowelsCount += (len(word) - len(strings.Split(word, \"!\"))) / 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word, \"?\"\
    ))) / 2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word,\
    \ \"-\"))) / 2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word)\
    \ - len(strings.Split(word, \".\"))) / 2\n    vowelsCount %= len(vowels)\n   \
    \ vowelsCount += (len(word) - len(strings.Split(word, \"!\"))) / 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word, \"?\"\
    ))) / 2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word,\
    \ \"-\"))) / 2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word)\
    \ - len(strings.Split(word, \".\"))) / 2\n    vowelsCount %= len(vowels)\n   \
    \ vowelsCount += (len(word) - len(strings.Split(word, \"!\"))) / 2\n    vowelsCount\
    \ %= len(\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp85khdf39_test.go:64:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074717
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb0d1rz2e_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074713
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // write your code here\n    vowels := []string{\"a\"\
    , \"e\", \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    for _, v := range vowels\
    \ {\n        if word == v {\n            vowelsCount++\n        }\n    }\n   \
    \ if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= 1\n  \
    \  vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word)\
    \ - len(word))/2\n    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += (len(word) - len(word))/2\n    vowelsCount\
    \ %= len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 1\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += (len(word) - len(word))/2\n    vowelsCount %= len(vowels)\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /=\
    \ 2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word) - len(word))/2\n\
    \    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\
    \n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += (len(word) - len(word))/2\n    vowelsCount %= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= 1\n\
    \    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(word)\
    \ - len(word))/2\n    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += (len(word) - len(word))/2\n    vowelsCount\
    \ %= len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 1\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += (len(word) - len(word))/2\n    vowelsCount %= len(vowels)\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv6x76igc_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074717
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_jzurh7g_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowel\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_dp627ln_test.go:110:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmkz79rh4_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjjvxffa4_test.go:111:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074717
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpofja0s41_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowel\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_dp627ln_test.go:110:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpofja0s41_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb0d1rz2e_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074713
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word[len(word)-len(v)-1] == v {\n            return v\n      \
    \  }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvlouzzeq_test.go:23:40: invalid operation: word[len(word) - len(v) - 1]
    == v (mismatched types byte and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    \n\
    \    vowelsLen -= 1\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n\
    \    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n\
    \    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n\
    \    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n\
    \    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwcmurvdi_test.go:119:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074717
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb0d1rz2e_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074713
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb0d1rz2e_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074713
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbi756moq_test.go:83:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 1\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= \nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi4bq5_di_test.go:86:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb0d1rz2e_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074713
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsyaim82f_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += (len(word) - len(word)) % len(vowels)\n \
    \   return vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpgl5u1hex_test.go:61: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpgl5u1hex_test.go:61: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpgl5u1hex_test.go:61: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpgl5u1hex_test.go:61: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpgl5u1hex_test.go:61:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpgl5u1hex_test.go:61: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074717
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 3\n    vowelsLen -= 4\n    vowelsLen -= 5\n    vowelsLen -= 6\n    vowelsLen\
    \ -= 7\n    vowelsLen -= 8\n    vowelsLen -= 9\n    vowelsLen -= 10\n    vowelsLen\
    \ -= 11\n    vowelsLen -= 12\n    vowelsLen -= 13\n    vowelsLen -= 14\n    vowelsLen\
    \ -= 15\n    vowelsLen -= 16\n    vowelsLen -= 17\n    vowelsLen -= 18\n    vowelsLen\
    \ -= 19\n    vowelsLen -= 20\n    vowelsLen -= 21\n    vowelsLen -= 22\n    vowelsLen\
    \ -= 23\n    vowelsLen -= 24\n    vowelsLen -= 25\n    vowelsLen -= 26\n    vowelsLen\
    \ -= 27\n    vowelsLen -= 28\n    vowelsLen -= 29\n    vowelsLen -= 30\n    vowelsLen\
    \ -= 31\n    vowelsLen -= 32\n    vowelsLen -= 33\n    vowelsLen -= 34\n    vowelsLen\
    \ -= 35\n    vowelsLen -= 36\n    vowelsLen -= 37\n    vowelsLen -= 38\n    vowelsLen\
    \ -= 39\n    vowelsLen -= 40\n    vowelsLen -= 41\n    vowelsLen -= 42\n    vowelsLen\
    \ -= 43\n    vowelsLen -= 44\n    vowelsLen -= 45\n    vowelsLen -= 46\n    vowelsLen\
    \ -= 47\n    vowelsLen -= 48\n    vowelsLen -= 49\n    vowelsLen -= 50\n    vowelsLen\
    \ -= 51\n    vowelsLen -= 52\n    vowelsLen -= 53\n    vowelsLen -= 54\n    vowelsLen\
    \ -= 55\n    vowelsLen -= 56\n    vowelsLen -= 57\n    vowelsLen -= 58\n    vowelsLen\
    \ -= 59\n    vowelsLen -= 60\n    vowelsLen -= 61\n    vowelsLen -= 62\n    vowelsLen\
    \ -= 63\n    vowelsLen -= 64\n    vowelsLen -= 65\n    vowelsLen -= 66\n    vowelsLen\
    \ -= 67\n    vowelsLen -= 68\n    vowelsLen -= 69\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_x51n_7a_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune(\"aeiouAEIOU\")\n    vowelLen := len(vowel)\n\
    \    \n    lastVowel := -1\n    lastConsonant := -1\n    \n    i := len(word)\
    \ - 1\n    \n    for i := 0; i < len(word); i++ {\n        if word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n   \
    \         lastVowel = i\n        }\n        if word[i] == 'A' || word[i] == 'E'\
    \ || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            lastVowel\
    \ = i\n        }\n        if word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' {\n            lastConsonant = i\n        }\n        if word[i]\
    \ == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n           \
    \ lastConsonant = i\n        }\n    }\n    \n    if lastVowel == -1 && lastConsonant\
    \ == -1 {\n        return \"\"\n    }\n    \n    if lastVowel == -1 {\n      \
    \  return word[lastConsonant:]\n    }\n    if lastConsonant == -1 {\n        return\
    \ word[:lastVowel]\n    }\n    \n    if lastVowel > lastConsonant {\n        return\
    \ word[lastVowel+1 : lastConsonant]\n    }\n    return word[lastConsonant+1 :\
    \ lastVowel]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate :=\
    \ get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpay2uj3ck_test.go:20:5: vowelLen declared but not used

    /tmp/tmpay2uj3ck_test.go:25:5: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo47yqofq_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1167zrff_test.go:71:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsyaim82f_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1167zrff_test.go:71:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1167zrff_test.go:71:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"a\", \"A\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"e\", \"E\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"i\", \"I\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"o\", \"O\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"u\", \"U\", -1))\n    if vowelsCount < 0 {\n        return \"\"\n    }\n \
    \   return vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0rjcld3z_test.go:22:12: undefined: strings

    /tmp/tmp0rjcld3z_test.go:29:36: undefined: strings

    /tmp/tmp0rjcld3z_test.go:30:36: undefined: strings

    /tmp/tmp0rjcld3z_test.go:31:36: undefined: strings

    /tmp/tmp0rjcld3z_test.go:32:36: undefined: strings

    /tmp/tmp0rjcld3z_test.go:33:36: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpofja0s41_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb0d1rz2e_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074713
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsyaim82f_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpofja0s41_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Write your code here\n    vowels := []string{\"a\"\
    , \"e\", \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    for _, v := range word\
    \ {\n        if v == 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n \
    \           vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n      \
    \  for _, v := range word {\n            if v == 'a' || v == 'e' || v == 'i' ||\
    \ v == 'o' || v == 'u' {\n                return v\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv9aotdy6_test.go:20:5: vowels declared but not used

    /tmp/tmpv9aotdy6_test.go:30:24: cannot use v (variable of type rune) as type string
    in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune(\"aeiou\")\n    vowelLen := len(vowel)\n\
    \    vowelIdx := len(word) - vowelLen\n    vowelIdx -= vowelIdx%2\n    vowelIdx\
    \ -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx\
    \ -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx\
    \ -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx\
    \ -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx\
    \ -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx\
    \ -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx\
    \ -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx\
    \ -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx\
    \ -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx\
    \ -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx\
    \ -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx\
    \ -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx\
    \ -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx\
    \ -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx\
    \ -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    vowelIdx\
    \ -= vowelIdx%2\n    vowelIdx -= vowelIdx%2\n    \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplo2bcx6x_test.go:71:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6qt5kd49_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 2; i >= 0; i-- {\n        if word[i] == word[i+1] {\n       \
    \     vowelsCount++\n        }\n    }\n    if vowelsCount < 2 {\n        return\
    \ \"\"\n    }\n    for _, v := range vowels {\n        if word == v {\n      \
    \      return v\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpi6edgtia_test.go:68: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpi6edgtia_test.go:68: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpi6edgtia_test.go:68: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpi6edgtia_test.go:68: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpi6edgtia_test.go:68:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpi6edgtia_test.go:68: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfp_kb7ux_test.go:86:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpofja0s41_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo47yqofq_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -= 1\n   \
    \ vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n\
    \    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -=\
    \ 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvore1ft4_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e'\
    \ || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n\
    \            if vowelsCount > len(vowels) {\n                return \"\"\n   \
    \         }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp4bwhx9d2_test.go:63: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp4bwhx9d2_test.go:63: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmp4bwhx9d2_test.go:63: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp4bwhx9d2_test.go:63: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp4bwhx9d2_test.go:63:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp4bwhx9d2_test.go:63: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb0d1rz2e_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074713
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels) - 2\n    for _, v := range\
    \ vowels {\n        if word == v {\n            return v\n        }\n    }\n \
    \   for _, v := range vowels {\n        if word[len(word)-1] == v {\n        \
    \    return v\n        }\n    }\n    for _, v := range vowels {\n        if word[len(word)-2]\
    \ == v {\n            return v\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv4nbnvub_test.go:28:33: invalid operation: word[len(word) - 1] == v (mismatched
    types byte and string)

    /tmp/tmpv4nbnvub_test.go:33:33: invalid operation: word[len(word) - 2] == v (mismatched
    types byte and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += (len(word) - len(word)) % len(vowels)\n \
    \   return vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpgl5u1hex_test.go:61: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpgl5u1hex_test.go:61: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpgl5u1hex_test.go:61: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpgl5u1hex_test.go:61: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpgl5u1hex_test.go:61:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpgl5u1hex_test.go:61: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074717
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphmqd3dsk_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 2; i >= 0; i-- {\n        if word[i] == word[i+1] {\n       \
    \     if word[i] == \"a\" || word[i] == \"e\" || word[i] == \"i\" || word[i] ==\
    \ \"o\" || word[i] == \"u\" {\n                return word[i]\n            }\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk_jjsj8h_test.go:29:27: invalid operation: word[i] == "a" (mismatched
    types byte and untyped string)

    /tmp/tmpk_jjsj8h_test.go:29:45: invalid operation: word[i] == "e" (mismatched
    types byte and untyped string)

    /tmp/tmpk_jjsj8h_test.go:29:63: invalid operation: word[i] == "i" (mismatched
    types byte and untyped string)

    /tmp/tmpk_jjsj8h_test.go:29:81: invalid operation: word[i] == "o" (mismatched
    types byte and untyped string)

    /tmp/tmpk_jjsj8h_test.go:29:99: invalid operation: word[i] == "u" (mismatched
    types byte and untyped string)

    /tmp/tmpk_jjsj8h_test.go:30:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount /= len(vowels)\n    if vowelsCount\
    \ == 1 {\n        return vowels[vowelsCount]\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmpy8u92v_test.go:23:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmkz79rh4_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -= 1\n   \
    \ vowelsLen -= 2\n    vowelsLen -= 3\n    vowelsLen -= 4\n    vowelsLen -= 5\n\
    \    vowelsLen -= 6\n    vowelsLen -= 7\n    vowelsLen -= 8\n    vowelsLen -=\
    \ 9\n    vowelsLen -= 10\n    vowelsLen -= 11\n    vowelsLen -= 12\n    vowelsLen\
    \ -= 13\n    vowelsLen -= 14\n    vowelsLen -= 15\n    vowelsLen -= 16\n    vowelsLen\
    \ -= 17\n    vowelsLen -= 18\n    vowelsLen -= 19\n    vowelsLen -= 20\n    vowelsLen\
    \ -= 21\n    vowelsLen -= 22\n    vowelsLen -= 23\n    vowelsLen -= 24\n    vowelsLen\
    \ -= 25\n    vowelsLen -= 26\n    vowelsLen -= 27\n    vowelsLen -= 28\n    vowelsLen\
    \ -= 29\n    vowelsLen -= 30\n    vowelsLen -= 31\n    vowelsLen -= 32\n    vowelsLen\
    \ -= 33\n    vowelsLen -= 34\n    vowelsLen -= 35\n    vowelsLen -= 36\n    vowelsLen\
    \ -= 37\n    vowelsLen -= 38\n    vowelsLen -= 39\n    vowelsLen -= 40\n    vowelsLen\
    \ -= 41\n    vowelsLen -= 42\n    vowelsLen -= 43\n    vowelsLen -= 44\n    vowelsLen\
    \ -= 45\n    vowelsLen -= 46\n    vowelsLen -= 47\n    vowelsLen -= 48\n    vowelsLen\
    \ -= 49\n    vowelsLen -= 50\n    vowelsLen -= 51\n    vowelsLen -= 52\n    vowelsLen\
    \ -= 53\n    vowelsLen -= 54\n    vowelsLen -= 55\n    vowelsLen -= 56\n    vowelsLen\
    \ -= 57\n    vowelsLen -= 58\n    vowelsLen -= 59\n    vowelsLen -= 60\n    vowelsLen\
    \ -= 61\n    vowelsLen -= 62\n    vowelsLen -= 63\n    vowelsLen -= 64\n    vowelsLen\
    \ -= 65\n    vowelsLen -= 66\n    vowelsLen -= 67\n    vowelsLen -= 68\n    vowelsLen\
    \ -= 69\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7t8s8jcl_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpofja0s41_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbi756moq_test.go:83:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 3\n    vowelsLen -= 4\n    vowelsLen -= 5\n    vowelsLen -= 6\n    vowelsLen\
    \ -= 7\n    vowelsLen -= 8\n    vowelsLen -= 9\n    vowelsLen -= 10\n    vowelsLen\
    \ -= 11\n    vowelsLen -= 12\n    vowelsLen -= 13\n    vowelsLen -= 14\n    vowelsLen\
    \ -= 15\n    vowelsLen -= 16\n    vowelsLen -= 17\n    vowelsLen -= 18\n    vowelsLen\
    \ -= 19\n    vowelsLen -= 20\n    vowelsLen -= 21\n    vowelsLen -= 22\n    vowelsLen\
    \ -= 23\n    vowelsLen -= 24\n    vowelsLen -= 25\n    vowelsLen -= 26\n    vowelsLen\
    \ -= 27\n    vowelsLen -= 28\n    vowelsLen -= 29\n    vowelsLen -= 30\n    vowelsLen\
    \ -= 31\n    vowelsLen -= 32\n    vowelsLen -= 33\n    vowelsLen -= 34\n    vowelsLen\
    \ -= 35\n    vowelsLen -= 36\n    vowelsLen -= 37\n    vowelsLen -= 38\n    vowelsLen\
    \ -= 39\n    vowelsLen -= 40\n    vowelsLen -= 41\n    vowelsLen -= 42\n    vowelsLen\
    \ -= 43\n    vowelsLen -= 44\n    vowelsLen -= 45\n    vowelsLen -= 46\n    vowelsLen\
    \ -= 47\n    vowelsLen -= 48\n    vowelsLen -= 49\n    vowelsLen -= 50\n    vowelsLen\
    \ -= 51\n    vowelsLen -= 52\n    vowelsLen -= 53\n    vowelsLen -= 54\n    vowelsLen\
    \ -= 55\n    vowelsLen -= 56\n    vowelsLen -= 57\n    vowelsLen -= 58\n    vowelsLen\
    \ -= 59\n    vowelsLen -= 60\n    vowelsLen -= 61\n    vowelsLen -= 62\n    vowelsLen\
    \ -= 63\n    vowelsLen -= 64\n    vowelsLen -= 65\n    vowelsLen -= 66\n    vowelsLen\
    \ -= 67\n    vowelsLen -= 68\n    vowelsLen -= 69\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_x51n_7a_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpofja0s41_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    for i := len(word) - 2; i >= 0; i-- {\n        if word[i]\
    \ == word[i+1] {\n            if strings.Contains(word, word[i+2]) {\n       \
    \         vowelsCount++\n            }\n        }\n    }\n    if vowelsCount ==\
    \ 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n    for i :=\
    \ len(word) - 3; i >= 0; i-- {\n        if word[i] == word[i+1] && word[i] ==\
    \ word[i+2] {\n            if strings.Contains(word, word[i+3]) {\n          \
    \      vowelsCount++\n            }\n        }\n    }\n    if vowelsCount == 0\
    \ {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n    for i :=\
    \ len(word) - 4; i >= 0; i-- {\n        if word[i] == word[i+1] && word[i] ==\
    \ word[i+2] && word[i] == word[i+3] {\n            if strings.Contains(word, word[i+4])\
    \ {\n                vowelsCount++\n            }\n        }\n    }\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n    for\
    \ i := len(word) - 5; i >= 0; i-- {\n        if word[i] == word[i+1] && word[i]\
    \ == word[i+2] && word[i] == word[i+3] && word[i] == word[i+4] {\n           \
    \ if strings.Contains(word, word[i+5]) {\n                vowelsCount++\n    \
    \        }\n        }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n\
    \    }\n    vowelsCount -= len(vowels)\n    for i := len(word) - 6; i >= 0; i--\
    \ {\n        if word[i] == word[i+1] && word[i] == word[i+2] && word[i] == word[i+3]\
    \ && word[i] == word[i+4] && word[i] == word[i+5] {\n            if strings.Contains(word,\
    \ word[i+6]) {\n                vowelsCount++\n            }\n        }\n    }\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    for i := len(word) - 7; i >= 0; i-- {\n        if word[i] == word[i+1] &&\
    \ word[i] == word[i+2] && word[i] == word[i+3] && word[i] == word[i+4] && word[i]\
    \ == word[i+5] && word[i] == word[i+6] {\n            if strings.Contain\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpubw1cpka_test.go:89:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbi756moq_test.go:83:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Write your code here\n    vowels := []string{\"a\"\
    , \"e\", \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -=\
    \ 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    i := len(word) - 1\n  \
    \  j := len(word) - 2\n    \n    vowelsCount := 0\n    \n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == vowels[j] {\n            vowelsCount++\n\
    \        }\n        j--\n    }\n    \n    if vowelsCount >= vowelsLen {\n    \
    \    return \"\"\n    }\n    \n    return vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2t_w01d2_test.go:26:5: i declared but not used

    /tmp/tmp2t_w01d2_test.go:32:23: invalid operation: word[i] == vowels[j] (mismatched
    types byte and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmkz79rh4_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb0d1rz2e_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074713
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmkz79rh4_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Write your code here\n    vowels := []string{\"a\"\
    , \"e\", \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    for _, v := range vowels\
    \ {\n        if word == v {\n            vowelsCount++\n        }\n    }\n   \
    \ if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= 1\n  \
    \  vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt2uc3wuu_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount > 0 {\n        vowelsCount -= 1\n    }\n    if\
    \ vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxq_zpd1w_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 2; i >= 0; i-- {\n        if word[i] == word[i+1] {\n       \
    \     if word[i] == \"a\" || word[i] == \"e\" || word[i] == \"i\" || word[i] ==\
    \ \"o\" || word[i] == \"u\" {\n                return word[i]\n            }\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk_jjsj8h_test.go:29:27: invalid operation: word[i] == "a" (mismatched
    types byte and untyped string)

    /tmp/tmpk_jjsj8h_test.go:29:45: invalid operation: word[i] == "e" (mismatched
    types byte and untyped string)

    /tmp/tmpk_jjsj8h_test.go:29:63: invalid operation: word[i] == "i" (mismatched
    types byte and untyped string)

    /tmp/tmpk_jjsj8h_test.go:29:81: invalid operation: word[i] == "o" (mismatched
    types byte and untyped string)

    /tmp/tmpk_jjsj8h_test.go:29:99: invalid operation: word[i] == "u" (mismatched
    types byte and untyped string)

    /tmp/tmpk_jjsj8h_test.go:30:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmkz79rh4_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune(\"aeiouAEIOU\")\n    vowelLen := len(vowel)\n\
    \    vowelPos := 0\n    vowelLen -= len(word) % vowelLen\n    for i := 0; i <\
    \ len(word); i++ {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelPos = i\n      \
    \      break\n        }\n    }\n    if vowelPos == 0 {\n        return \"\"\n\
    \    }\n    vowelPos += vowelLen\n    vowelPos %= vowelLen\n    vowelPos -= len(word)\
    \ % vowelLen\n    vowelPos %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos\
    \ %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos\
    \ %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos\
    \ %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos\
    \ %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos\
    \ %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos\
    \ %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos\
    \ %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos\
    \ %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos\
    \ %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos\
    \ %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos\
    \ %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos\
    \ %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos\
    \ %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos\
    \ %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos\
    \ %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos %= vowelLen\n    vowelPos\
    \ %= vowelLen\n    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate :=\
    \ get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8op8rlm4_test.go:84:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphmqd3dsk_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1167zrff_test.go:71:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1167zrff_test.go:71:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount \nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmperb3s8u9_test.go:86:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount > 0 {\n        vowelsCount -= len(vowels)\n \
    \   }\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ /= 2\n    if word[len(word)-1] == 'a' || word[len(word)-1] == 'e' || word[len(word)-1]\
    \ == 'i' || word[len(word)-1] == 'o' || word[len(word)-1] == 'u' {\n        vowelsCount++\n\
    \    }\n    if vowelsCount > 0 {\n        vowelsCount -= len(vowels)\n    }\n\
    \    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ /= 2\n    if word[len(word)-2] == 'a' || word[len(word)-2] == 'e' || word[len(word)-2]\
    \ == 'i' || word[len(word)-2] == 'o' || word[len(word)-2] == 'u' {\n        vowelsCount++\n\
    \    }\n    if vowelsCount > 0 {\n        vowelsCount -= len(vowels)\n    }\n\
    \    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ /= 2\n    if word[len(word)-3] == 'a' || word[len(word)-3] == 'e' || word[len(word)-3]\
    \ == 'i' || word[len(word)-3] == 'o' || word[len(word)-3] == 'u' {\n        vowelsCount++\n\
    \    }\n    if vowelsCount > 0 {\n        vowelsCount -= len(vowels)\n    }\n\
    \    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ /= 2\n    if word[len(word)-4] == 'a' || word[len(word)-4] == 'e' || word[len(word)-4]\
    \ == 'i' || word[len(word)-4] == 'o' || word[len(word)-4] == 'u' {\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0w96rvnx_test.go:81:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 3\n    vowelsLen -= 4\n    vowelsLen -= 5\n    vowelsLen -= 6\n    vowelsLen\
    \ -= 7\n    vowelsLen -= 8\n    vowelsLen -= 9\n    vowelsLen -= 10\n    vowelsLen\
    \ -= 11\n    vowelsLen -= 12\n    vowelsLen -= 13\n    vowelsLen -= 14\n    vowelsLen\
    \ -= 15\n    vowelsLen -= 16\n    vowelsLen -= 17\n    vowelsLen -= 18\n    vowelsLen\
    \ -= 19\n    vowelsLen -= 20\n    vowelsLen -= 21\n    vowelsLen -= 22\n    vowelsLen\
    \ -= 23\n    vowelsLen -= 24\n    vowelsLen -= 25\n    vowelsLen -= 26\n    vowelsLen\
    \ -= 27\n    vowelsLen -= 28\n    vowelsLen -= 29\n    vowelsLen -= 30\n    vowelsLen\
    \ -= 31\n    vowelsLen -= 32\n    vowelsLen -= 33\n    vowelsLen -= 34\n    vowelsLen\
    \ -= 35\n    vowelsLen -= 36\n    vowelsLen -= 37\n    vowelsLen -= 38\n    vowelsLen\
    \ -= 39\n    vowelsLen -= 40\n    vowelsLen -= 41\n    vowelsLen -= 42\n    vowelsLen\
    \ -= 43\n    vowelsLen -= 44\n    vowelsLen -= 45\n    vowelsLen -= 46\n    vowelsLen\
    \ -= 47\n    vowelsLen -= 48\n    vowelsLen -= 49\n    vowelsLen -= 50\n    vowelsLen\
    \ -= 51\n    vowelsLen -= 52\n    vowelsLen -= 53\n    vowelsLen -= 54\n    vowelsLen\
    \ -= 55\n    vowelsLen -= 56\n    vowelsLen -= 57\n    vowelsLen -= 58\n    vowelsLen\
    \ -= 59\n    vowelsLen -= 60\n    vowelsLen -= 61\n    vowelsLen -= 62\n    vowelsLen\
    \ -= 63\n    vowelsLen -= 64\n    vowelsLen -= 65\n    vowelsLen -= 66\n    vowelsLen\
    \ -= 67\n    vowelsLen -= 68\n    vowelsLen -= 69\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_x51n_7a_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 3\n    vowelsLen -= 4\n    vowelsLen -= 5\n    vowelsLen -= 6\n    vowelsLen\
    \ -= 7\n    vowelsLen -= 8\n    vowelsLen -= 9\n    vowelsLen -= 10\n    vowelsLen\
    \ -= 11\n    vowelsLen -= 12\n    vowelsLen -= 13\n    vowelsLen -= 14\n    vowelsLen\
    \ -= 15\n    vowelsLen -= 16\n    vowelsLen -= 17\n    vowelsLen -= 18\n    vowelsLen\
    \ -= 19\n    vowelsLen -= 20\n    vowelsLen -= 21\n    vowelsLen -= 22\n    vowelsLen\
    \ -= 23\n    vowelsLen -= 24\n    vowelsLen -= 25\n    vowelsLen -= 26\n    vowelsLen\
    \ -= 27\n    vowelsLen -= 28\n    vowelsLen -= 29\n    vowelsLen -= 30\n    vowelsLen\
    \ -= 31\n    vowelsLen -= 32\n    vowelsLen -= 33\n    vowelsLen -= 34\n    vowelsLen\
    \ -= 35\n    vowelsLen -= 36\n    vowelsLen -= 37\n    vowelsLen -= 38\n    vowelsLen\
    \ -= 39\n    vowelsLen -= 40\n    vowelsLen -= 41\n    vowelsLen -= 42\n    vowelsLen\
    \ -= 43\n    vowelsLen -= 44\n    vowelsLen -= 45\n    vowelsLen -= 46\n    vowelsLen\
    \ -= 47\n    vowelsLen -= 48\n    vowelsLen -= 49\n    vowelsLen -= 50\n    vowelsLen\
    \ -= 51\n    vowelsLen -= 52\n    vowelsLen -= 53\n    vowelsLen -= 54\n    vowelsLen\
    \ -= 55\n    vowelsLen -= 56\n    vowelsLen -= 57\n    vowelsLen -= 58\n    vowelsLen\
    \ -= 59\n    vowelsLen -= 60\n    vowelsLen -= 61\n    vowelsLen -= 62\n    vowelsLen\
    \ -= 63\n    vowelsLen -= 64\n    vowelsLen -= 65\n    vowelsLen -= 66\n    vowelsLen\
    \ -= 67\n    vowelsLen -= 68\n    vowelsLen -= 69\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_x51n_7a_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmkz79rh4_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2xp30ey_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074714
