language: go_test.go
name: HumanEval_79_decimal_to_binary
results:
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n   \
    \ if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n  \
    \  decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx9zxfvop_test.go:115:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    decimalString := fmt.Sprintf(\"\
    %d\", decimal)\n    for i := 0; i < len(decimalString); i++ {\n        binaryString\
    \ += fmt.Sprintf(\"%d\", decimalString[i] - '0')\n    }\n    return binaryString\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpgsyx_3zb_test.go:41: expected 'db0db', got '0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpgsyx_3zb_test.go:41:\
    \ expected 'db100000db', got '32'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpgsyx_3zb_test.go:41: expected 'db1100111db', got '103'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpgsyx_3zb_test.go:41:\
    \ expected 'db1111db', got '15'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    for i := decimal - 1; i >= 0; i--\
    \ {\n        result += \"1\"\n    }\n    return \"db\" + result + \"db\"\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpdxivjk_0_test.go:44: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpdxivjk_0_test.go:44:\
    \ expected 'db100000db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpdxivjk_0_test.go:44: expected 'db1100111db', got 'db01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpdxivjk_0_test.go:44:\
    \ expected 'db1111db', got 'db01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    binary[0] = 'b'\n    binary[1]\
    \ = 'a'\n    binary[2] = 'c'\n    binary[3] = 'a'\n    binary[4] = 'b'\n    binary[5]\
    \ = 'a'\n    binary[6] = 'b'\n    binary[7] = 'c'\n    binary[8] = 'a'\n    binary[9]\
    \ = 'b'\n    binary[10] = 'a'\n    binary[11] = 'b'\n    binary[12] = 'c'\n  \
    \  binary[13] = 'a'\n    binary[14] = 'b'\n    binary[15] = 'a'\n    binary[16]\
    \ = 'b'\n    binary[17] = 'c'\n    binary[18] = 'a'\n    binary[19] = 'b'\n  \
    \  binary[20] = 'a'\n    binary[21] = 'b'\n    binary[22] = 'c'\n    binary[23]\
    \ = 'a'\n    binary[24] = 'b'\n    binary[25] = 'a'\n    binary[26] = 'b'\n  \
    \  binary[27] = 'c'\n    binary[28] = 'a'\n    binary[29] = 'b'\n    binary[30]\
    \ = 'a'\n    binary[31] = 'b'\n    binary[32] = 'c'\n    binary[33] = 'a'\n  \
    \  binary[34] = 'b'\n    binary[35] = 'a'\n    binary[36] = 'b'\n    binary[37]\
    \ = 'c'\n    binary[38] = 'a'\n    binary[39] = 'b'\n    binary[40] = 'a'\n  \
    \  binary[41] = 'b'\n    binary[42] = 'c'\n    binary[43] = 'a'\n    binary[44]\
    \ = 'b'\n    binary[45] = 'a'\n    binary[46] = 'b'\n    binary[47] = 'c'\n  \
    \  binary[48] = 'a'\n    binary[49] = 'b'\n    binary[50] = 'a'\n    binary[51]\
    \ = 'b'\n    binary[52] = 'c'\n    binary[53] = 'a'\n    binary[54] = 'b'\n  \
    \  binary[55] = 'a'\n    binary[56] = 'b'\n    binary[57] = 'c'\n    binary[58]\
    \ = 'a'\n    binary[59] = 'b'\n    binary[60] = 'a'\n    binary[61] = 'b'\n  \
    \  binary[62] = 'c'\n    binary[63] = 'a'\n    binary[64] = 'b'\n    binary[65]\
    \ = 'a'\n    binary[66] = 'b'\n    binary[67] = 'c'\n    binary[68] = 'a'\n  \
    \  binary[69] = 'b'\n    binary[70] = 'a'\n    binary[71] = 'b'\n    binary[72]\
    \ = 'c'\n    binary[\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpazwo5xe5_test.go:92:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"1\"\n    }\n    decimal /= 2\n    for i := 0; i <\
    \ decimal; i++ {\n        result += \"0\"\n    }\n    result += \"db\"\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkqaprryf_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkqaprryf_test.go:46:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpkqaprryf_test.go:46: expected 'db1100111db', got '1db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpkqaprryf_test.go:46:\
    \ expected 'db1111db', got '1db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(fmt.Sprintf(\"\
    %d\", decimal)); i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n\
    \    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp7brdre6l_test.go:43: expected 'db0db', got '01db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp7brdre6l_test.go:43:\
    \ expected 'db100000db', got '01db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp7brdre6l_test.go:43: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp7brdre6l_test.go:43:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n   \
    \ if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n  \
    \  decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx9zxfvop_test.go:115:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += fmt.Sprintf(\"%d\", decimal)\n    }\n    for i := 0; i < len(result);\
    \ i++ {\n        if result[i] == '1' {\n            result += fmt.Sprintf(\"%d\"\
    , decimal)\n        }\n        decimal /= 2\n    }\n    return \"db\" + result\
    \ + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpc9tnyqaz_test.go:47: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpc9tnyqaz_test.go:47:\
    \ expected 'db100000db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpc9tnyqaz_test.go:47: expected 'db1100111db', got 'db110db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpc9tnyqaz_test.go:47:\
    \ expected 'db1111db', got 'db110db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    for i := 0; i < len(binary);\
    \ i++ {\n        binary[i] = byte(decimal % 2)\n        decimal /= 2\n    }\n\
    \    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpjj4i1xjn_test.go:41: expected 'db0db', got '\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpjj4i1xjn_test.go:41: expected 'db100000db', got '\0\0\0\0\
    \0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpjj4i1xjn_test.go:41: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpjj4i1xjn_test.go:41: expected\
    \ 'db1111db', got '\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpa66hm09o_test.go:44: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpa66hm09o_test.go:44: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpa66hm09o_test.go:44: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpa66hm09o_test.go:44: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpiic4hp0r_test.go:42: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpiic4hp0r_test.go:42:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpiic4hp0r_test.go:42: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpiic4hp0r_test.go:42:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n   \
    \ if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n  \
    \  decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx9zxfvop_test.go:115:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db100000db', got '1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Write your code here\n    result := \"\"\n    temp :=\
    \ decimal % 2\n    if temp == 0 {\n        result += \"0\"\n    } else {\n   \
    \     result += \"1\"\n    }\n    decimal /= 2\n    for decimal > 0 {\n      \
    \  temp = decimal % 2\n        if temp == 0 {\n            result += \"0\"\n \
    \       } else {\n            result += \"1\"\n        }\n        decimal /= 2\n\
    \    }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpgsygklz3_test.go:54: expected 'db100000db', got 'db000001db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpgsygklz3_test.go:54:\
    \ expected 'db1100111db', got 'db1110011db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Write your code here\n    result := \"\"\n    i := 0\n\
    \    for i < decimal {\n        if decimal % 2 == 0 {\n            result += fmt.Sprintf(\"\
    %c\", 0)\n        } else {\n            result += fmt.Sprintf(\"%c\", 1)\n   \
    \     }\n        decimal = decimal / 2\n        i++\n    }\n    result += \"db\"\
    \n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpyzwf99cx_test.go:49: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpyzwf99cx_test.go:49:\
    \ expected 'db100000db', got '\0\0\0\0db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpyzwf99cx_test.go:49: expected 'db1100111db', got '\x01\x01\
    \x01\0\0db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n       \
    \ tmpyzwf99cx_test.go:49: expected 'db1111db', got '\x01\x01\x01db'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpiic4hp0r_test.go:42: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpiic4hp0r_test.go:42:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpiic4hp0r_test.go:42: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpiic4hp0r_test.go:42:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n   \
    \ if decimal > 0 {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n  \
    \  decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\", decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %d\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n\
    \    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\"\
    , decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %d\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n\
    \    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\"\
    , decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %d\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n\
    \    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\"\
    , decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %d\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n\
    \    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\"\
    , decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %d\", decimal)\n    }\n    decimal /= \nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7uj8rdmv_test.go:115:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    for i := decimal - 1; i >= 0; i--\
    \ {\n        result += \"1\"\n    }\n    return \"db\" + result + \"db\"\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpdxivjk_0_test.go:44: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpdxivjk_0_test.go:44:\
    \ expected 'db100000db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpdxivjk_0_test.go:44: expected 'db1100111db', got 'db01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpdxivjk_0_test.go:44:\
    \ expected 'db1111db', got 'db01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpa66hm09o_test.go:44: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpa66hm09o_test.go:44: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpa66hm09o_test.go:44: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpa66hm09o_test.go:44: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal>0\
    \ {\n        binary[i] = byte(decimal%2)\n        decimal /= 2\n        i++\n\
    \    }\n    binary[i] = 'b'\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpfajw1pb7_test.go:44: expected 'db0db', got 'b\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpfajw1pb7_test.go:44: expected 'db100000db', got '\0\0\0\0\
    \0\x01b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpfajw1pb7_test.go:44: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpfajw1pb7_test.go:44: expected\
    \ 'db1111db', got '\x01\x01\x01\x01b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    for i := 0; i < decimal; i++ {\n\
    \        binaryString += \"0\"\n    }\n    for i := decimal - 1; i >= 0; i-- {\n\
    \        binaryString += \"1\"\n    }\n    return \"db\" + binaryString\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp4oaejxo0_test.go:43: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp4oaejxo0_test.go:43:\
    \ expected 'db100000db', got 'db0000000000000000000000000000000011111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp4oaejxo0_test.go:43:\
    \ expected 'db1100111db', got 'db00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp4oaejxo0_test.go:43:\
    \ expected 'db1111db', got 'db000000000000000111111111111111'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal>0\
    \ {\n        binary[i] = byte(decimal%2)\n        decimal = decimal/2\n      \
    \  i++\n    }\n    binary[i] = 'b'\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp92anq25n_test.go:44: expected 'db0db', got 'b\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp92anq25n_test.go:44: expected 'db100000db', got '\0\0\0\0\
    \0\x01b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp92anq25n_test.go:44: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp92anq25n_test.go:44: expected\
    \ 'db1111db', got '\x01\x01\x01\x01b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal>0\
    \ {\n        binary[i] = byte(decimal%2)\n        decimal /= 2\n        i++\n\
    \    }\n    binary[i] = 'b'\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpfajw1pb7_test.go:44: expected 'db0db', got 'b\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpfajw1pb7_test.go:44: expected 'db100000db', got '\0\0\0\0\
    \0\x01b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpfajw1pb7_test.go:44: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpfajw1pb7_test.go:44: expected\
    \ 'db1111db', got '\x01\x01\x01\x01b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074435
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal >= 2 {\n            result += fmt.Sprintf(\"%c\",\
    \ decimal%2)\n            decimal /= 2\n        } else {\n            result +=\
    \ fmt.Sprintf(\"%c\", '0')\n        }\n    }\n    return result + \"db\"\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiud4xwt6_test.go:19:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074435
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    j := 0\n    for\
    \ ; i < len(binary); i++ {\n        binary[i] = '0'\n    }\n    for ; i < 32;\
    \ i++ {\n        if decimal >= 2 {\n            binary[i] = '1'\n            decimal\
    \ -= 2\n        } else {\n            binary[i] = '0'\n        }\n    }\n    return\
    \ string(binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1s4pc1tz_test.go:19:5: j declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n   \
    \ if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n  \
    \  decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx9zxfvop_test.go:115:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db100000db', got '1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Your code here\n    result := \"\"\n    switch decimal\
    \ {\n    case 0:\n        result = \"0\"\n    case 1:\n        result = \"1\"\n\
    \    default:\n        fmt.Println(\"decimal error\")\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "decimal error\ndecimal error\ndecimal error\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpobbqjvm9_test.go:46:\
    \ expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n\
    \        tmpobbqjvm9_test.go:46: expected 'db100000db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpobbqjvm9_test.go:46: expected\
    \ 'db1100111db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n\
    \        tmpobbqjvm9_test.go:46: expected 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        binary += \"1\"\n        decimal -= 1\n    }\n    for i := 0; i < decimal;\
    \ i++ {\n        binary += \"0\"\n    }\n    return binary + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp_zp8efw6_test.go:45: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp_zp8efw6_test.go:45:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp_zp8efw6_test.go:45: expected 'db1100111db', got '1db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp_zp8efw6_test.go:45:\
    \ expected 'db1111db', got '1db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Your code here\n    result := \"\"\n    for i := 0; i\
    \ < decimal; i++ {\n        result += \"1\"\n    }\n    return result\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp215xx_a0_test.go:41: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp215xx_a0_test.go:41: expected\
    \ 'db100000db', got '11111111111111111111111111111111'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp215xx_a0_test.go:41: expected 'db1100111db', got '1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp215xx_a0_test.go:41:\
    \ expected 'db1111db', got '111111111111111'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n        decimal -= 1\n    }\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpbamt4wyv_test.go:45: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpbamt4wyv_test.go:45: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpbamt4wyv_test.go:45: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpbamt4wyv_test.go:45: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Your code here\n    result := \"\"\n    switch decimal\
    \ {\n    case 0:\n        result = \"0\"\n    case 1:\n        result = \"1\"\n\
    \    default:\n        fmt.Println(\"Invalid input\")\n    }\n    return result\
    \ + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpctel_60u_test.go:46:\
    \ expected 'db0db', got '0db'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpctel_60u_test.go:46: expected 'db100000db', got 'db'\n \
    \   --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpctel_60u_test.go:46:\
    \ expected 'db1100111db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpctel_60u_test.go:46: expected 'db1111db', got 'db'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    for\
    \ i := 0; i < decimal; i++ {\n        binaryString += \"0\"\n    }\n    return\
    \ binaryString\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate :=\
    \ decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpfwep9nwx_test.go:41: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpfwep9nwx_test.go:41:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpfwep9nwx_test.go:41: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpfwep9nwx_test.go:41:\
    \ expected 'db1111db', got 'db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074436
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := \"\"\n    for i := 0; i < len(decimal); i++ {\n\
    \        if decimal % 2 == 0 {\n            binary += \"1\"\n        } else {\n\
    \            binary += \"0\"\n        }\n        decimal /= 2\n    }\n    return\
    \ \"db\" + binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcibpvg35_test.go:18:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal > 0 {\n            result += \"1\"\n        } else\
    \ {\n            result += \"0\"\n        }\n        decimal = decimal / 2\n \
    \   }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxy45a0rn_test.go:19:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    binaryString\
    \ += fmt.Sprintf(\"%0*d\", decimal, decimal)\n    binaryString += \"db\"\n   \
    \ return binaryString\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpni_dejzb_test.go:40: expected 'db100000db', got 'db00000000000000000000000000000032db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpni_dejzb_test.go:40:\
    \ expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpni_dejzb_test.go:40:\
    \ expected 'db1111db', got 'db000000000000015db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074437
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal_to_binary_test.pattern);\
    \ i++ {\n        if decimal > 0 {\n            result += decimal_to_binary_test.pattern[i]\n\
    \            decimal -= 2\n        } else {\n            result += decimal_to_binary_test.pattern[i]\n\
    \            decimal = 2\n        }\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeill6nat_test.go:19:25: undefined: decimal_to_binary_test

    /tmp/tmpeill6nat_test.go:21:23: undefined: decimal_to_binary_test

    /tmp/tmpeill6nat_test.go:24:23: undefined: decimal_to_binary_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    i := 0\n    for {\n        if decimal\
    \ < 2 {\n            break\n        }\n        result += \"0\"\n        decimal\
    \ = decimal / 2\n    }\n    for decimal == 0 {\n        result += \"1\"\n    \
    \    decimal = 1\n    }\n    for decimal == 1 {\n        result += \"0\"\n   \
    \     decimal = 0\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf4qleg2o_test.go:18:5: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Write your code here\n    result := \"\"\n    result +=\
    \ \"db\"\n    for i := 0; i < decimal; i++ {\n        if decimal % 2 == 0 {\n\
    \            result += fmt.Sprintf(\"%c\", decimal%2)\n        } else {\n    \
    \        result += fmt.Sprintf(\"%c\", '0')\n        }\n        decimal /= 2\n\
    \    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpcwcnfnfv_test.go:48: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpcwcnfnfv_test.go:48:\
    \ expected 'db100000db', got 'db\0\0\0\0db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpcwcnfnfv_test.go:48: expected 'db1100111db', got 'db000\0\
    \0db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpcwcnfnfv_test.go:48:\
    \ expected 'db1111db', got 'db000db'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(fmt.Sprintf(\"\
    %d\", decimal)); i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"\
    %d\", decimal%2)\n            decimal /= 2\n        } else {\n            result\
    \ += \"0\"\n        }\n    }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp0gynsyia_test.go:46: expected 'db100000db', got 'db0db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp0gynsyia_test.go:46:\
    \ expected 'db1100111db', got 'db1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmp0gynsyia_test.go:46: expected 'db1111db', got 'db1db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal /= 2\n   \
    \ if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n  \
    \  decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n\
    \    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\"\
    , decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n\
    \    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\"\
    , decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n\
    \    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\"\
    , decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n\
    \    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp212a1uvy_test.go:107:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    switch decimal {\n    case 0:\n     \
    \   result = \"0\"\n    case 1:\n        result = \"1\"\n    default:\n      \
    \  for i := 0; i < decimal; i++ {\n            result += \"0\"\n        }\n  \
    \  }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpcyepsqi3_test.go:48: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpcyepsqi3_test.go:48:\
    \ expected 'db100000db', got '00000000000000000000000000000000db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpcyepsqi3_test.go:48: expected\
    \ 'db1100111db', got '0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpcyepsqi3_test.go:48:\
    \ expected 'db1111db', got '000000000000000db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    binary := \"\"\n    decimal %= 2\n  \
    \  for i := 0; i < decimal; i++ {\n        binary += \"0\"\n    }\n    binary\
    \ += \"1\"\n    result += binary\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp9kj8lt91_test.go:44: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp9kj8lt91_test.go:44:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp9kj8lt91_test.go:44: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp9kj8lt91_test.go:44:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    for i := 0; i < len(binary);\
    \ i++ {\n        binary[i] = byte(decimal % 2)\n        decimal /= 2\n    }\n\
    \    binary[0] = 'b'\n    binary[len(binary)-1] = 'b'\n    return string(binary)\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp2py1d2az_test.go:43: expected 'db0db', got 'b\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp2py1d2az_test.go:43: expected 'db100000db', got 'b\0\0\0\
    \0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp2py1d2az_test.go:43: expected 'db1100111db', got 'b\x01\x01\
    \0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp2py1d2az_test.go:43: expected\
    \ 'db1111db', got 'b\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0b'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal%2\
    \ == 0 {\n        binary[i] = '0'\n        decimal = decimal/2\n        i++\n\
    \    }\n    for decimal%2 == 1 {\n        binary[i] = '1'\n        decimal = decimal/2\n\
    \        i++\n    }\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmppwt0ga3y_test.go:20\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmppwt0ga3y_test.go:39\
    \ +0x573\ntesting.tRunner(0xc0000da1a0, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    binary := \"\"\n    decimalToBinary :=\
    \ make([]string, decimal)\n    for i := 0; i < decimal; i++ {\n        decimalToBinary[i]\
    \ = fmt.Sprintf(\"%d\", decimalToBinary[i])\n    }\n    for i := 0; i < decimal;\
    \ i++ {\n        binary += decimalToBinary[i]\n    }\n    result += \"db\" + binary\
    \ + \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpvpga2qf7_test.go:21:30: fmt.Sprintf format %d has arg decimalToBinary[i]
    of wrong type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n   \
    \ if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n  \
    \  decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx9zxfvop_test.go:115:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    for\
    \ i := 0; i < decimal; i++ {\n        if decimal % 2 == 0 {\n            binaryString\
    \ += \"1\"\n        } else {\n            binaryString += \"0\"\n        }\n \
    \       decimal = decimal / 2\n    }\n    return binaryString\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp84ycugkt_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp84ycugkt_test.go:46:\
    \ expected 'db100000db', got 'db1111'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp84ycugkt_test.go:46: expected 'db1100111db', got 'db00011'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp84ycugkt_test.go:46:\
    \ expected 'db1111db', got 'db000'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n   \
    \ if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n  \
    \  decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx9zxfvop_test.go:115:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db100000db', got '1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    temp := decimal\n    for temp > 0 {\n\
    \        result += \"0\"\n        temp--\n    }\n    for temp > 0 {\n        result\
    \ += \"1\"\n        temp--\n    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp9unj8t2d_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp9unj8t2d_test.go:46:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp9unj8t2d_test.go:46: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp9unj8t2d_test.go:46:\
    \ expected 'db1111db', got 'db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    for i := decimal; i < 32; i++ {\n\
    \        result += \"1\"\n    }\n    return \"db\" + result + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpol1oxg7g_test.go:44: expected 'db0db', got 'db11111111111111111111111111111111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpol1oxg7g_test.go:44:\
    \ expected 'db100000db', got 'db11111111111111111111111111111111db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpol1oxg7g_test.go:44: expected\
    \ 'db1100111db', got 'db01111111111111111111111111111111db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpol1oxg7g_test.go:44: expected 'db1111db', got 'db01111111111111111111111111111111db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    decimalString := fmt.Sprintf(\"\
    %d\", decimal)\n    for i := 0; i < len(decimalString); i++ {\n        if decimalString[i]\
    \ == '1' {\n            binaryString += \"1\"\n        } else {\n            binaryString\
    \ += \"0\"\n        }\n    }\n    return binaryString + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpoqmmml8o_test.go:45: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoqmmml8o_test.go:45:\
    \ expected 'db100000db', got '00db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpoqmmml8o_test.go:45: expected 'db1100111db', got '100db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoqmmml8o_test.go:45:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074438
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \            decimal /= 2\n        } else {\n            result += fmt.Sprintf(\"\
    %c\", decimal%2)\n            decimal *= 2\n        }\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1s6vwzbx_test.go:19:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpvbty_9e2_test.go:44: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpvbty_9e2_test.go:44: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpvbty_9e2_test.go:44: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpvbty_9e2_test.go:44: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    for\
    \ i := 0; i < decimal; i++ {\n        if i%2 == 0 {\n            binaryString\
    \ += \"1\"\n        } else {\n            binaryString += \"0\"\n        }\n \
    \   }\n    return binaryString\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp7vbv94j__test.go:45: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp7vbv94j__test.go:45:\
    \ expected 'db100000db', got 'db10101010101010101010101010101010'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp7vbv94j__test.go:45: expected\
    \ 'db1100111db', got 'db1010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp7vbv94j__test.go:45:\
    \ expected 'db1111db', got 'db101010101010101'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    i := 0\n    for ; decimal > 0; decimal--\
    \ {\n        result += \"0\"\n    }\n    for ; decimal > 0; decimal-- {\n    \
    \    result += \"1\"\n    }\n    result += \"db\"\n    return result\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp52e64uwr_test.go:18:5: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal_to_binary_test);\
    \ i++ {\n        if decimal > 0 {\n            result += decimal_to_binary_test[i]\n\
    \            decimal--\n        } else {\n            result += decimal_to_binary_test[i]\n\
    \        }\n    }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj4s5pwfx_test.go:19:25: undefined: decimal_to_binary_test

    /tmp/tmpj4s5pwfx_test.go:21:23: undefined: decimal_to_binary_test

    /tmp/tmpj4s5pwfx_test.go:24:23: undefined: decimal_to_binary_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    decimalString := fmt.Sprintf(\"\
    %d\", decimal)\n    for i := 0; i < len(decimalString); i++ {\n        if decimalString[i]\
    \ == '1' {\n            binaryString += \"1\"\n        } else {\n            binaryString\
    \ += \"0\"\n        }\n    }\n    return binaryString + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpoqmmml8o_test.go:45: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoqmmml8o_test.go:45:\
    \ expected 'db100000db', got '00db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpoqmmml8o_test.go:45: expected 'db1100111db', got '100db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoqmmml8o_test.go:45:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Your code here\n    result := \"\"\n    for i := 0; i\
    \ < decimal; i++ {\n        if i%2 == 0 {\n            result += \"1\"\n     \
    \   } else {\n            result += \"0\"\n        }\n    }\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpo5hrbaz9_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpo5hrbaz9_test.go:46:\
    \ expected 'db100000db', got '10101010101010101010101010101010db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpo5hrbaz9_test.go:46: expected\
    \ 'db1100111db', got '1010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpo5hrbaz9_test.go:46:\
    \ expected 'db1111db', got '101010101010101db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal%2\
    \ == 0 {\n        binary[i] = '0'\n        decimal = decimal / 2\n        i++\n\
    \    }\n    for decimal%2 == 1 {\n        binary[i] = '1'\n        decimal = decimal\
    \ / 2\n        i++\n    }\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmpck1raz6c_test.go:20\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmpck1raz6c_test.go:39\
    \ +0x573\ntesting.tRunner(0xc0000cc4e0, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n    }\n\
    \    for i := 0; i < decimal; i++ {\n        result += fmt.Sprintf(\"%c\", '0')\n\
    \    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n \
    \ candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmplli4vfla_test.go:45: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmplli4vfla_test.go:45: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmplli4vfla_test.go:45: expected 'db1100111db', got '\x01'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmplli4vfla_test.go:45: expected\
    \ 'db1111db', got '\x01'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    decimalString := fmt.Sprintf(\"\
    %d\", decimal)\n    for i := 0; i < len(decimalString); i++ {\n        if decimalString[i]\
    \ == '1' {\n            binaryString += \"1\"\n        } else {\n            binaryString\
    \ += \"0\"\n        }\n    }\n    return binaryString + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpoqmmml8o_test.go:45: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoqmmml8o_test.go:45:\
    \ expected 'db100000db', got '00db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpoqmmml8o_test.go:45: expected 'db1100111db', got '100db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoqmmml8o_test.go:45:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    temp := decimal\n    for temp > 0 {\n\
    \        result += \"0\"\n        temp--\n    }\n    for temp > 0 {\n        result\
    \ += \"1\"\n        temp--\n    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp9unj8t2d_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp9unj8t2d_test.go:46:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp9unj8t2d_test.go:46: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp9unj8t2d_test.go:46:\
    \ expected 'db1111db', got 'db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        binary += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        binary\
    \ += \"0\"\n    }\n    return binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp15jsdlqm_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp15jsdlqm_test.go:44:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp15jsdlqm_test.go:44: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp15jsdlqm_test.go:44:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074439
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6v3pfq_d_test.go:20:19: undefined: binary_to_decimal

    /tmp/tmp6v3pfq_d_test.go:24:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpvbty_9e2_test.go:44: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpvbty_9e2_test.go:44: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpvbty_9e2_test.go:44: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpvbty_9e2_test.go:44: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    for i := 0; i < decimal; i++ {\n\
    \        binaryString += \"0\"\n    }\n    for i := decimal; i > 0; i-- {\n  \
    \      binaryString += \"1\"\n    }\n    return \"db\" + binaryString\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpgjzftlaf_test.go:43: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpgjzftlaf_test.go:43:\
    \ expected 'db100000db', got 'db0000000000000000000000000000000011111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpgjzftlaf_test.go:43:\
    \ expected 'db1100111db', got 'db00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpgjzftlaf_test.go:43:\
    \ expected 'db1111db', got 'db000000000000000111111111111111'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074440
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        binary += \"1\"\n        decimal -= 1\n    }\n    for i := 0; i < decimal;\
    \ i++ {\n        binary += \"0\"\n    }\n    return binary + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp_zp8efw6_test.go:45: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp_zp8efw6_test.go:45:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp_zp8efw6_test.go:45: expected 'db1100111db', got '1db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp_zp8efw6_test.go:45:\
    \ expected 'db1111db', got '1db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal>0\
    \ {\n        binary[i] = byte(decimal%2)\n        decimal /= 2\n        i++\n\
    \    }\n    return string(binary[0:i])\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpzklk7nvt_test.go:43: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzklk7nvt_test.go:43: expected\
    \ 'db100000db', got '\0\0\0\0\0\x01'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpzklk7nvt_test.go:43: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n \
    \       tmpzklk7nvt_test.go:43: expected 'db1111db', got '\x01\x01\x01\x01'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074440
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    decimalString := fmt.Sprintf(\"\
    %d\", decimal)\n    decimalLen := len(decimalString)\n    binaryLen := decimalLen\
    \ / 2\n    for i := 0; i < decimalLen; i++ {\n        if decimalString[i] == '1'\
    \ {\n            binaryString += \"1\"\n        } else {\n            binaryString\
    \ += \"0\"\n        }\n    }\n    binaryString += \"db\"\n    for i := decimalLen\
    \ - binaryLen; i < decimalLen; i++ {\n        binaryString += \"0\"\n    }\n \
    \   return binaryString\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp66jumx_k_test.go:51: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp66jumx_k_test.go:51:\
    \ expected 'db100000db', got '00db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp66jumx_k_test.go:51: expected 'db1100111db', got '100db0'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp66jumx_k_test.go:51:\
    \ expected 'db1111db', got '10db0'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074440
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n   \
    \ if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n  \
    \  decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx9zxfvop_test.go:115:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \        }\n        decimal = decimal/2\n    }\n    return \"db\" + result + \"\
    db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcsexvtui_test.go:19:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074440
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    binary := make([]byte, 32)\n    for i\
    \ := 0; i < len(binary); i++ {\n        binary[i] = byte(decimal % 2)\n      \
    \  decimal /= 2\n    }\n    for i := 0; i < len(binary); i++ {\n        if binary[i]\
    \ == 0 {\n            result += \"0\"\n        } else {\n            result +=\
    \ \"1\"\n        }\n    }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpruma5bpm_test.go:49: expected 'db0db', got 'db00000000000000000000000000000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpruma5bpm_test.go:49:\
    \ expected 'db100000db', got 'db00000100000000000000000000000000db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpruma5bpm_test.go:49: expected\
    \ 'db1100111db', got 'db11100110000000000000000000000000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpruma5bpm_test.go:49: expected 'db1111db', got 'db11110000000000000000000000000000db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074440
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Write your code here\n    result := \"\"\n    temp :=\
    \ decimal\n    for temp > 0 {\n        result += \"0\"\n        temp--\n    }\n\
    \    for temp > 0 {\n        result += \"1\"\n        temp--\n    }\n    return\
    \ \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmprzlt2hhn_test.go:47: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmprzlt2hhn_test.go:47:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmprzlt2hhn_test.go:47: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmprzlt2hhn_test.go:47:\
    \ expected 'db1111db', got 'db000000000000000db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074440
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 1 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 2 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 3 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 4 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 5 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 6 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 7 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 8 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 9 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 10 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 11 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 12 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 13 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 14 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 15 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 16 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 17 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 18 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 19 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 20 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 21 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 22 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 23 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 24 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 25 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 26 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 27 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 28 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 29 {\n\
    \        result += decimal_to_binary(decimal/2)\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpztc8bxab_test.go:108:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n   \
    \ if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n  \
    \  decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx9zxfvop_test.go:115:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    i := 0\n    for ; decimal > 0; decimal--\
    \ {\n        if decimal % 2 == 0 {\n            result += fmt.Sprintf(\"%c\",\
    \ decimal)\n        } else {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \        }\n        i++\n    }\n    result += \"db\"\n    for ; i > 0; i-- {\n\
    \        result += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpsgvzw50t_test.go:50: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpsgvzw50t_test.go:50:\
    \ expected 'db100000db', got ' \x01\x1E\x01\x1C\x01\x1A\x01\x18\x01\x16\x01\x14\
    \x01\x12\x01\x10\x01\x0E\x01\f\x01\n            \x01\b\x01\x06\x01\x04\x01\x02\
    \x01db00000000000000000000000000000000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpsgvzw50t_test.go:50: expected 'db1100111db', got '\x01f\x01\
    d\x01b\x01`\x01^\x01\\\x01Z\x01X\x01V\x01T\x01R\x01P\x01N\x01L\x01J\x01H\x01F\x01\
    D\x01B\x01@\x01>\x01<\x01:\x018\x016\x014\x012\x010\x01.\x01,\x01*\x01(\x01&\x01\
    $\x01\"\x01 \x01\x1E\x01\x1C\x01\x1A\x01\x18\x01\x16\x01\x14\x01\x12\x01\x10\x01\
    \x0E\x01\f\x01\n            \x01\b\x01\x06\x01\x04\x01\x02\x01db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpsgvzw50t_test.go:50:\
    \ expected 'db1111db', got '\x01\x0E\x01\f\x01\n            \x01\b\x01\x06\x01\
    \x04\x01\x02\x01db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074440
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Write your code here\n    result := \"\"\n    result +=\
    \ \"db\"\n    result += fmt.Sprintf(\"%0*d\", len(strconv.Itoa(decimal)), decimal)\n\
    \    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvzwdhvlg_test.go:20:39: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074440
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \            decimal /= 2\n        } else {\n            result += fmt.Sprintf(\"\
    %c\", decimal%2)\n            decimal *= 2\n        }\n    }\n    return \"db\"\
    \ + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb1bppnqf_test.go:19:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074440
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n \
    \   }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgtj1ch7r_test.go:115:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    binary := \"\"\n    decimal %= 2\n  \
    \  if decimal > 0 {\n        binary += \"1\"\n        decimal--\n    }\n    for\
    \ i := 0; i < decimal; i++ {\n        binary += \"0\"\n    }\n    result += binary\n\
    \    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpytqipe8s_test.go:47: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpytqipe8s_test.go:47: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpytqipe8s_test.go:47: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpytqipe8s_test.go:47: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074440
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \            decimal /= 2\n        } else {\n            result += fmt.Sprintf(\"\
    %c\", decimal%2)\n            decimal = decimal / 2\n        }\n    }\n    return\
    \ \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1k_j5e8s_test.go:19:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074440
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db100000db', got '1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db100000db', got '1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Write your code here\n    result := \"\"\n    temp :=\
    \ decimal\n    for temp > 0 {\n        result += \"0\"\n        temp--\n    }\n\
    \    for temp > 0 {\n        result += \"1\"\n        temp--\n    }\n    return\
    \ \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmprzlt2hhn_test.go:47: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmprzlt2hhn_test.go:47:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmprzlt2hhn_test.go:47: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmprzlt2hhn_test.go:47:\
    \ expected 'db1111db', got 'db000000000000000db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074440
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"1\"\n    }\n    for i := decimal - 1; i >= 0; i--\
    \ {\n        result += \"0\"\n    }\n    return \"db\" + result + \"db\"\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmprhsrld3g_test.go:44: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmprhsrld3g_test.go:44:\
    \ expected 'db100000db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmprhsrld3g_test.go:44: expected 'db1100111db', got 'db10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmprhsrld3g_test.go:44:\
    \ expected 'db1111db', got 'db10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074441
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    temp := decimal\n    for temp > 0 {\n\
    \        result += \"0\"\n        temp--\n    }\n    result += \"db\"\n    temp\
    \ = decimal\n    for temp > 0 {\n        result += \"1\"\n        temp--\n   \
    \ }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpru38g17o_test.go:48: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpru38g17o_test.go:48:\
    \ expected 'db100000db', got '00000000000000000000000000000000db11111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpru38g17o_test.go:48:\
    \ expected 'db1100111db', got '0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000db1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpru38g17o_test.go:48:\
    \ expected 'db1111db', got '000000000000000db111111111111111'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074441
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    decimal %= 2\n    decimal /= 2\n\
    \    for i := 0; i < decimal; i++ {\n        binaryString += \"0\"\n    }\n  \
    \  binaryString += \"1\"\n    return binaryString\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp88lfd2k6_test.go:43: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp88lfd2k6_test.go:43:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp88lfd2k6_test.go:43: expected 'db1100111db', got '1'\n \
    \   --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp88lfd2k6_test.go:43:\
    \ expected 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074441
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db100000db', got '1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    for\
    \ i := 0; i < decimal; i++ {\n        binaryString += \"0\"\n    }\n    for i\
    \ := decimal; i < 16; i++ {\n        binaryString += \"1\"\n    }\n    return\
    \ binaryString\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate :=\
    \ decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpxhdmicfz_test.go:44: expected 'db0db', got 'db1111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpxhdmicfz_test.go:44:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpxhdmicfz_test.go:44: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpxhdmicfz_test.go:44:\
    \ expected 'db1111db', got 'db0000000000000001'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074441
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    temp := decimal\n    for temp > 0 {\n\
    \        result += \"0\"\n        temp--\n    }\n    for temp > 0 {\n        result\
    \ += \"1\"\n        temp--\n    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp9unj8t2d_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp9unj8t2d_test.go:46:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp9unj8t2d_test.go:46: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp9unj8t2d_test.go:46:\
    \ expected 'db1111db', got 'db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    i := 0\n    for ; i < decimal; i++ {\n\
    \        if decimal % 2 == 0 {\n            result += fmt.Sprintf(\"%c\", decimal)\n\
    \        } else {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n    \
    \    }\n    }\n    if decimal > 0 {\n        result += \"db\"\n    }\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpspon42_6_test.go:48: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpspon42_6_test.go:48: expected\
    \ 'db100000db', got '                                db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpspon42_6_test.go:48: expected 'db1100111db', got '\x01\x01\
    \x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\
    \x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\
    \x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\
    \x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\
    \x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\
    \x01db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpspon42_6_test.go:48:\
    \ expected 'db1111db', got '\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\
    \x01\x01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074441
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n   \
    \ if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n  \
    \  decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx9zxfvop_test.go:115:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal>0\
    \ {\n        binary[i] = byte(decimal%2)\n        decimal = decimal/2\n      \
    \  i++\n    }\n    binary[i] = byte(decimal)\n    return string(binary)\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpt9lcg91f_test.go:44: expected 'db0db', got '\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpt9lcg91f_test.go:44: expected 'db100000db', got '\0\0\0\0\
    \0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpt9lcg91f_test.go:44: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpt9lcg91f_test.go:44: expected\
    \ 'db1111db', got '\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074441
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    for i := 0; i < decimal; i++ {\n\
    \        binaryString += \"0\"\n    }\n    for i := decimal; i > 0; i-- {\n  \
    \      binaryString += \"1\"\n    }\n    return \"db\" + binaryString\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpgjzftlaf_test.go:43: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpgjzftlaf_test.go:43:\
    \ expected 'db100000db', got 'db0000000000000000000000000000000011111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpgjzftlaf_test.go:43:\
    \ expected 'db1100111db', got 'db00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpgjzftlaf_test.go:43:\
    \ expected 'db1111db', got 'db000000000000000111111111111111'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074440
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(fmt.Sprintf(\"\
    %d\", decimal)); i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"\
    %d\", decimal%2)\n            decimal /= 2\n        } else {\n            result\
    \ += fmt.Sprintf(\"%d\", decimal%2)\n            decimal *= 2\n        }\n   \
    \ }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpd3hpkukt_test.go:47: expected 'db0db', got '0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpd3hpkukt_test.go:47:\
    \ expected 'db100000db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpd3hpkukt_test.go:47: expected 'db1100111db', got '1'\n \
    \   --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpd3hpkukt_test.go:47:\
    \ expected 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074441
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        for i := 0; i < decimal; i++ {\n            result += \"1\"\n       \
    \ }\n    } else {\n        for i := 0; i < decimal; i++ {\n            result\
    \ += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp_zy88sch_test.go:47: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp_zy88sch_test.go:47: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp_zy88sch_test.go:47: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp_zy88sch_test.go:47: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074441
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal_to_binary_test.pattern);\
    \ i++ {\n        if decimal > 0 {\n            result += decimal_to_binary_test.pattern[i]\n\
    \            decimal -= 2\n        } else {\n            result += decimal_to_binary_test.pattern[i]\n\
    \        }\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpock4vh6f_test.go:19:25: undefined: decimal_to_binary_test

    /tmp/tmpock4vh6f_test.go:21:23: undefined: decimal_to_binary_test

    /tmp/tmpock4vh6f_test.go:24:23: undefined: decimal_to_binary_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074441
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Write your code here\n    result := \"\"\n    for i :=\
    \ 0; i < decimal; i++ {\n        if decimal % 2 == 0 {\n            result +=\
    \ \"1\"\n        } else {\n            result += \"0\"\n        }\n        decimal\
    \ = decimal / 2\n    }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp8qsp4fzy_test.go:46: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp8qsp4fzy_test.go:46:\
    \ expected 'db100000db', got 'db1111db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp8qsp4fzy_test.go:46: expected 'db1100111db', got 'db00011db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp8qsp4fzy_test.go:46:\
    \ expected 'db1111db', got 'db000db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074442
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 1 {\n\
    \        result += \"1\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp8h2nklrb_test.go:44: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp8h2nklrb_test.go:44: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp8h2nklrb_test.go:44: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp8h2nklrb_test.go:44: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074442
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Your code here\n    result := \"\"\n    decimal %= 2\n\
    \    for i := 0; i < decimal; i++ {\n        result += \"1\"\n    }\n    for i\
    \ := decimal; i < 32; i++ {\n        result += \"0\"\n    }\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpoyrzv3wk_test.go:46: expected 'db0db', got '00000000000000000000000000000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoyrzv3wk_test.go:46:\
    \ expected 'db100000db', got '00000000000000000000000000000000db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoyrzv3wk_test.go:46: expected\
    \ 'db1100111db', got '10000000000000000000000000000000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpoyrzv3wk_test.go:46: expected 'db1111db', got '10000000000000000000000000000000db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074442
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    switch decimal {\n    case 0:\n\
    \        binaryString = \"0\"\n    case 1:\n        binaryString = \"1\"\n   \
    \ default:\n        binaryString = fmt.Sprintf(\"%v\", decimal)\n    }\n    return\
    \ binaryString + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpvkx0cih8_test.go:45: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpvkx0cih8_test.go:45:\
    \ expected 'db100000db', got '32db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpvkx0cih8_test.go:45: expected 'db1100111db', got '103db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpvkx0cih8_test.go:45:\
    \ expected 'db1111db', got '15db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074442
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n   \
    \ if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n  \
    \  decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx9zxfvop_test.go:115:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db100000db', got '1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal_to_binary_test);\
    \ i++ {\n        if decimal >= decimal_to_binary_test[i].decimal {\n         \
    \   result += decimal_to_binary_test[i].binary\n            decimal -= decimal_to_binary_test[i].decimal\n\
    \        }\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu49_y9pb_test.go:19:25: undefined: decimal_to_binary_test

    /tmp/tmpu49_y9pb_test.go:20:23: undefined: decimal_to_binary_test

    /tmp/tmpu49_y9pb_test.go:21:23: undefined: decimal_to_binary_test

    /tmp/tmpu49_y9pb_test.go:22:24: undefined: decimal_to_binary_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074442
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"1\"\n    }\n    for i := decimal; i < 32; i++ {\n\
    \        result += \"0\"\n    }\n    return \"db\" + result + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptig2mhco_test.go:44: expected 'db0db', got 'db00000000000000000000000000000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptig2mhco_test.go:44:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmptig2mhco_test.go:44: expected\
    \ 'db1100111db', got 'db10000000000000000000000000000000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmptig2mhco_test.go:44: expected 'db1111db', got 'db10000000000000000000000000000000db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074443
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        for i := 0; i < decimal; i++ {\n            result += \"1\"\n       \
    \ }\n    } else {\n        for i := 0; i < decimal; i++ {\n            result\
    \ += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp_zy88sch_test.go:47: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp_zy88sch_test.go:47: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp_zy88sch_test.go:47: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp_zy88sch_test.go:47: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074441
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    temp := decimal\n    for temp > 0 {\n\
    \        result += \"0\"\n        temp--\n    }\n    for temp > 0 {\n        result\
    \ += \"1\"\n        temp--\n    }\n    return \"db\" + result + \"db\"\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmperi2b0li_test.go:46: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmperi2b0li_test.go:46:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmperi2b0li_test.go:46: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmperi2b0li_test.go:46:\
    \ expected 'db1111db', got 'db000000000000000db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074443
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpa66hm09o_test.go:44: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpa66hm09o_test.go:44: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpa66hm09o_test.go:44: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpa66hm09o_test.go:44: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    switch decimal {\n    case 0:\n     \
    \   result = \"0\"\n    case 1:\n        result = \"1\"\n    default:\n      \
    \  fmt.Println(\"Invalid input\")\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp8ajgc3gq_test.go:45:\
    \ expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n\
    \        tmp8ajgc3gq_test.go:45: expected 'db100000db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp8ajgc3gq_test.go:45: expected\
    \ 'db1100111db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n\
    \        tmp8ajgc3gq_test.go:45: expected 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074443
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    decimalString := fmt.Sprintf(\"\
    %d\", decimal)\n    for i := 0; i < len(decimalString); i++ {\n        binaryString\
    \ += fmt.Sprintf(\"%c\", decimalString[i] - '0')\n    }\n    return binaryString\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp3211rjz3_test.go:41: expected 'db0db', got '\0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp3211rjz3_test.go:41:\
    \ expected 'db100000db', got '\x03\x02'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp3211rjz3_test.go:41: expected 'db1100111db', got '\x01\0\
    \x03'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp3211rjz3_test.go:41:\
    \ expected 'db1111db', got '\x01\x05'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074443
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(strconv.Itoa(decimal));\
    \ i++ {\n        if decimal > 0 {\n            result += strconv.Itoa((decimal\
    \ % 2) + 1)\n        }\n        decimal = decimal / 2\n    }\n    return \"db\"\
    \ + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnr7b7tq8_test.go:19:25: undefined: strconv

    /tmp/tmpnr7b7tq8_test.go:21:23: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074442
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(fmt.Sprintf(\"\
    %d\", decimal)); i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"\
    %d\", decimal%2)\n        }\n        decimal = decimal/2\n    }\n    return \"\
    db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp0jgu76ye_test.go:44: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp0jgu76ye_test.go:44:\
    \ expected 'db100000db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp0jgu76ye_test.go:44: expected 'db1100111db', got 'db1db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp0jgu76ye_test.go:44:\
    \ expected 'db1111db', got 'db1db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074443
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    switch decimal {\n    case 0:\n\
    \        binaryString = \"0\"\n    case 1:\n        binaryString = \"1\"\n   \
    \ }\n    return binaryString + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpt7s6jwfq_test.go:43: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpt7s6jwfq_test.go:43:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpt7s6jwfq_test.go:43: expected 'db1100111db', got 'db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpt7s6jwfq_test.go:43:\
    \ expected 'db1111db', got 'db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074443
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    for\
    \ i := 0; i < decimal; i++ {\n        if decimal % 2 == 0 {\n            binaryString\
    \ += \"1\"\n        } else {\n            binaryString += \"0\"\n        }\n \
    \       decimal = decimal / 2\n    }\n    return binaryString\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp84ycugkt_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp84ycugkt_test.go:46:\
    \ expected 'db100000db', got 'db1111'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp84ycugkt_test.go:46: expected 'db1100111db', got 'db00011'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp84ycugkt_test.go:46:\
    \ expected 'db1111db', got 'db000'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal%2\
    \ == 0 {\n        binary[i] = '1'\n        decimal = decimal / 2\n        i++\n\
    \    }\n    for decimal%2 == 1 {\n        binary[i] = '0'\n        decimal = decimal\
    \ / 2\n        i++\n    }\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmpg0zu4o79_test.go:20\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmpg0zu4o79_test.go:39\
    \ +0x573\ntesting.tRunner(0xc0000da1a0, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074443
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    for\
    \ i := 0; i < decimal; i++ {\n        binaryString += \"0\"\n    }\n    for i\
    \ := decimal - 1; i >= 0; i-- {\n        binaryString += \"1\"\n    }\n    return\
    \ binaryString\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate :=\
    \ decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp9cw5pjpz_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp9cw5pjpz_test.go:44:\
    \ expected 'db100000db', got 'db0000000000000000000000000000000011111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp9cw5pjpz_test.go:44:\
    \ expected 'db1100111db', got 'db00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp9cw5pjpz_test.go:44:\
    \ expected 'db1111db', got 'db000000000000000111111111111111'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074443
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db100000db', got '1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpiic4hp0r_test.go:42: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpiic4hp0r_test.go:42:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpiic4hp0r_test.go:42: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpiic4hp0r_test.go:42:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    switch decimal {\n    case 0:\n     \
    \   result = \"0\"\n    case 1:\n        result = \"1\"\n    case 2:\n       \
    \ result = \"10\"\n    case 3:\n        result = \"11\"\n    case 4:\n       \
    \ result = \"100\"\n    case 5:\n        result = \"101\"\n    case 6:\n     \
    \   result = \"110\"\n    case 7:\n        result = \"111\"\n    case 8:\n   \
    \     result = \"1000\"\n    case 9:\n        result = \"1001\"\n    case 10:\n\
    \        result = \"1010\"\n    case 11:\n        result = \"1011\"\n    case\
    \ 12:\n        result = \"1100\"\n    case 13:\n        result = \"1101\"\n  \
    \  case 14:\n        result = \"1110\"\n    case 15:\n        result = \"1111\"\
    \n    case 16:\n        result = \"10000\"\n    case 17:\n        result = \"\
    10001\"\n    case 18:\n        result = \"10010\"\n    case 19:\n        result\
    \ = \"10011\"\n    case 20:\n        result = \"10100\"\n    case 21:\n      \
    \  result = \"10101\"\n    case 22:\n        result = \"10110\"\n    case 23:\n\
    \        result = \"10111\"\n    case 24:\n        result = \"11000\"\n    case\
    \ 25:\n        result = \"11001\"\n    case 26:\n        result = \"11010\"\n\
    \    case 27:\n        result = \"11011\"\n    case 28:\n        result = \"11100\"\
    \n    case 29:\n        result = \"11101\"\n    case 30:\n        result = \"\
    11110\"\n    case 31:\n        result = \"11111\"\n    case 32:\n        result\
    \ = \"100000\"\n    case 33:\n        result = \"100001\"\n    case 34:\n    \
    \    result = \"100010\"\n    case 35:\n        result = \"100011\"\n    case\
    \ 36:\n        result = \"100100\"\n    case 37:\n        result = \"100101\"\n\
    \    case 38:\n        result = \"100110\"\n    case 39:\n        result = \"\
    100111\"\n    case 40:\n        result = \"101000\"\n    case 41:\n        result\
    \ = \"101001\"\n    case 42:\n        result = \"101010\"\n    case 43:\n    \
    \    result = \"101011\"\n    case 44:\n        result = \"101100\"\n    case\
    \ 45:\n        result = \"101101\"\n    case 46:\n        result = \"101110\"\n\
    \    case 47:\n        result = \"101111\"\n    case 48:\n        result = \"\
    110000\"\n    case 49:\n        result = \"110001\"\n    case 50:\n        result\
    \ = \"110010\"\n    case 51:\n        result = \"110011\"\n    case 52:\n    \
    \    result = \"110100\"\n    case 53:\n        result = \"110101\"\n    case\
    \ 54:\n        result = \"110110\"\n    case 55:\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpslksx2yq_test.go:131:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074442
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    decimalString := fmt.Sprintf(\"\
    %d\", decimal)\n    for i := 0; i < len(decimalString); i++ {\n        binaryString\
    \ += fmt.Sprintf(\"%c\", decimalString[i] - '0')\n    }\n    return binaryString\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp3211rjz3_test.go:41: expected 'db0db', got '\0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp3211rjz3_test.go:41:\
    \ expected 'db100000db', got '\x03\x02'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp3211rjz3_test.go:41: expected 'db1100111db', got '\x01\0\
    \x03'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp3211rjz3_test.go:41:\
    \ expected 'db1111db', got '\x01\x05'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074443
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"1\"\n    }\n    for i := decimal; i < 32; i++ {\n\
    \        result += \"0\"\n    }\n    result += \"db\"\n    return result\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp1xo79e_w_test.go:45: expected 'db0db', got '00000000000000000000000000000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp1xo79e_w_test.go:45:\
    \ expected 'db100000db', got '00000000000000000000000000000000db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp1xo79e_w_test.go:45: expected\
    \ 'db1100111db', got '10000000000000000000000000000000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmp1xo79e_w_test.go:45: expected 'db1111db', got '10000000000000000000000000000000db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074443
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    temp := decimal\n    for temp > 0 {\n\
    \        result += \"0\"\n        temp--\n    }\n    for temp > 0 {\n        result\
    \ += \"1\"\n        temp--\n    }\n    return \"db\" + result + \"db\"\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmperi2b0li_test.go:46: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmperi2b0li_test.go:46:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmperi2b0li_test.go:46: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmperi2b0li_test.go:46:\
    \ expected 'db1111db', got 'db000000000000000db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074443
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    binary := \"\"\n    for i := 0; i < decimal;\
    \ i++ {\n        if decimal % 2 == 0 {\n            binary += \"1\"\n        }\
    \ else {\n            binary += \"0\"\n        }\n        decimal /= 2\n    }\n\
    \    result += \"db\" + binary + \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp0rjpb5ap_test.go:47: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp0rjpb5ap_test.go:47:\
    \ expected 'db100000db', got 'db1111db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp0rjpb5ap_test.go:47: expected 'db1100111db', got 'db00011db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp0rjpb5ap_test.go:47:\
    \ expected 'db1111db', got 'db000db'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074443
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := \"\"\n    for i := 0; i < decimal; i++ {\n    \
    \    binary += \"0\"\n    }\n    for i := decimal - 1; i >= 0; i-- {\n       \
    \ binary += \"1\"\n    }\n    return \"db\" + binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpt13xx779_test.go:43: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpt13xx779_test.go:43:\
    \ expected 'db100000db', got 'db0000000000000000000000000000000011111111111111111111111111111111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpt13xx779_test.go:43:\
    \ expected 'db1100111db', got 'db00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpt13xx779_test.go:43:\
    \ expected 'db1111db', got 'db000000000000000111111111111111db'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074443
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    binary := make([]byte, 32)\n    for i\
    \ := 0; i < 32; i++ {\n        binary[i] = byte(decimal % 2)\n        decimal\
    \ /= 2\n    }\n    result += \"db\" + string(binary) + \"db\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp5yda96_4_test.go:43: expected 'db0db', got 'db\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0db'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp5yda96_4_test.go:43: expected 'db100000db', got 'db\0\0\0\
    \0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp5yda96_4_test.go:43: expected\
    \ 'db1100111db', got 'db\x01\x01\x01\0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n\
    \        tmp5yda96_4_test.go:43: expected 'db1111db', got 'db\x01\x01\x01\x01\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074443
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    decimalToBinary := decimal / 2\n\
    \    decimalToBinaryToString := fmt.Sprintf(\"%d\", decimalToBinary)\n    for\
    \ i := 0; i < len(decimalToBinaryToString); i++ {\n        if decimalToBinary\
    \ == 0 {\n            break\n        }\n        if decimalToBinary > 0 {\n   \
    \         binaryString += \"1\"\n            decimalToBinary -= 1\n        } else\
    \ {\n            binaryString += \"0\"\n        }\n    }\n    return binaryString\
    \ + decimalToBinaryToString\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp6s1xkg16_test.go:50: expected 'db0db', got '0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp6s1xkg16_test.go:50:\
    \ expected 'db100000db', got '1116'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp6s1xkg16_test.go:50: expected 'db1100111db', got '1151'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp6s1xkg16_test.go:50:\
    \ expected 'db1111db', got '17'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074444
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db100000db', got '1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := \"\"\n    for i := 0; i < decimal; i++ {\n    \
    \    binary += \"0\"\n    }\n    for i := decimal; i < 32; i++ {\n        binary\
    \ += \"1\"\n    }\n    return \"db\" + binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpbh4goiiu_test.go:43: expected 'db0db', got 'db11111111111111111111111111111111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpbh4goiiu_test.go:43:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpbh4goiiu_test.go:43: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpbh4goiiu_test.go:43:\
    \ expected 'db1111db', got 'db00000000000000011111111111111111db'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074444
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Your code here\n    result := \"\"\n    decimal %= 2\n\
    \    for i := 0; i < decimal; i++ {\n        result += \"1\"\n    }\n    for i\
    \ := decimal; i > 0; i-- {\n        result += \"0\"\n    }\n    return \"db\"\
    \ + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp449wucw3_test.go:45: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp449wucw3_test.go:45:\
    \ expected 'db100000db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp449wucw3_test.go:45: expected 'db1100111db', got 'db10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp449wucw3_test.go:45:\
    \ expected 'db1111db', got 'db10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074444
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    decimalString := fmt.Sprintf(\"\
    %d\", decimal)\n    for i := 0; i < len(decimalString); i++ {\n        binaryString\
    \ += fmt.Sprintf(\"%c\", decimalString[i] == '1' ? '1' : '0')\n    }\n    return\
    \ \"db\" + binaryString\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe4l5qy35_test.go:20:67: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074443
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    for i := 0; i < len(binary);\
    \ i++ {\n        binary[i] = '0'\n    }\n    binary[decimal] = '1'\n    return\
    \ string(binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmp56ro027f_test.go:21\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmp56ro027f_test.go:33\
    \ +0x65\ntesting.tRunner(0xc0001031e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074444
- exit_code: null
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    switch decimal {\n    case 0:\n     \
    \   result = \"0\"\n    case 1:\n        result = \"1\"\n    default:\n      \
    \  result += \"0\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += result\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074457
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal>0\
    \ {\n        binary[i] = byte(decimal%2)\n        decimal /= 2\n        i++\n\
    \    }\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp131ldny__test.go:43: expected 'db0db', got '\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp131ldny__test.go:43: expected 'db100000db', got '\0\0\0\0\
    \0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp131ldny__test.go:43: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp131ldny__test.go:43: expected\
    \ 'db1111db', got '\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074444
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpiic4hp0r_test.go:42: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpiic4hp0r_test.go:42:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpiic4hp0r_test.go:42: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpiic4hp0r_test.go:42:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal%2\
    \ == 0 {\n        binary[i] = '0'\n        decimal = decimal / 2\n        i++\n\
    \    }\n    for decimal%2 != 0 {\n        binary[i] = '1'\n        decimal = decimal\
    \ / 2\n        i++\n    }\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmp3sf0z_3c_test.go:20\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmp3sf0z_3c_test.go:39\
    \ +0x533\ntesting.tRunner(0xc0000d04e0, 0x527f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074444
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    binary := \"\"\n    for i := 0; i < decimal;\
    \ i++ {\n        if decimal % 2 == 0 {\n            binary += \"1\"\n        }\
    \ else {\n            binary += \"0\"\n        }\n        decimal /= 2\n    }\n\
    \    result += \"db\" + binary + \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp0rjpb5ap_test.go:47: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp0rjpb5ap_test.go:47:\
    \ expected 'db100000db', got 'db1111db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp0rjpb5ap_test.go:47: expected 'db1100111db', got 'db00011db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp0rjpb5ap_test.go:47:\
    \ expected 'db1111db', got 'db000db'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074443
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        for i := 0; i < decimal; i++ {\n            result += \"1\"\n       \
    \ }\n    } else {\n        for i := 0; i < decimal; i++ {\n            result\
    \ += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp_zy88sch_test.go:47: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp_zy88sch_test.go:47: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp_zy88sch_test.go:47: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp_zy88sch_test.go:47: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074441
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n   \
    \ if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n  \
    \  decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx9zxfvop_test.go:115:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    decimalString := fmt.Sprintf(\"\
    %d\", decimal)\n    for i := 0; i < len(decimalString); i++ {\n        if decimalString[i]\
    \ == '1' {\n            binaryString += \"1\"\n        } else {\n            binaryString\
    \ += \"0\"\n        }\n    }\n    return binaryString + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpoqmmml8o_test.go:45: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoqmmml8o_test.go:45:\
    \ expected 'db100000db', got '00db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpoqmmml8o_test.go:45: expected 'db1100111db', got '100db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoqmmml8o_test.go:45:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"1\"\n    }\n    for i := decimal; i > 0; i-- {\n\
    \        result += \"0\"\n    }\n    return \"db\" + result + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp95h21jlo_test.go:44: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp95h21jlo_test.go:44:\
    \ expected 'db100000db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp95h21jlo_test.go:44: expected 'db1100111db', got 'db10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp95h21jlo_test.go:44:\
    \ expected 'db1111db', got 'db10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074444
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    for i := 0; i < decimal; i++ {\n    \
    \    if i%2 == 0 {\n            result += \"1\"\n        } else {\n          \
    \  result += \"0\"\n        }\n    }\n    return \"db\" + result + \"db\"\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpm5kku24e_test.go:44: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpm5kku24e_test.go:44:\
    \ expected 'db100000db', got 'db10101010101010101010101010101010db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpm5kku24e_test.go:44: expected\
    \ 'db1100111db', got 'db1010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpm5kku24e_test.go:44:\
    \ expected 'db1111db', got 'db101010101010101db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    for\
    \ i := 0; i < decimal; i++ {\n        binaryString += \"0\"\n    }\n    for i\
    \ := decimal; i < 32; i++ {\n        binaryString += \"1\"\n    }\n    return\
    \ binaryString\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate :=\
    \ decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp8i3qg2cy_test.go:44: expected 'db0db', got 'db11111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp8i3qg2cy_test.go:44:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp8i3qg2cy_test.go:44: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp8i3qg2cy_test.go:44:\
    \ expected 'db1111db', got 'db00000000000000011111111111111111'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpiic4hp0r_test.go:42: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpiic4hp0r_test.go:42:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpiic4hp0r_test.go:42: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpiic4hp0r_test.go:42:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    for i := 0; i < len(binary);\
    \ i++ {\n        binary[i] = '0'\n    }\n    binary[32] = '1'\n    binary[33]\
    \ = '1'\n    binary[34] = '1'\n    binary[35] = '1'\n    binary[36] = '1'\n  \
    \  binary[37] = '1'\n    binary[38] = '1'\n    binary[39] = '1'\n    binary[40]\
    \ = '1'\n    binary[41] = '1'\n    binary[42] = '1'\n    binary[43] = '1'\n  \
    \  binary[44] = '1'\n    binary[45] = '1'\n    binary[46] = '1'\n    binary[47]\
    \ = '1'\n    binary[48] = '1'\n    binary[49] = '1'\n    binary[50] = '1'\n  \
    \  binary[51] = '1'\n    binary[52] = '1'\n    binary[53] = '1'\n    binary[54]\
    \ = '1'\n    binary[55] = '1'\n    binary[56] = '1'\n    binary[57] = '1'\n  \
    \  binary[58] = '1'\n    binary[59] = '1'\n    binary[60] = '1'\n    binary[61]\
    \ = '1'\n    binary[62] = '1'\n    binary[63] = '1'\n    binary[64] = '1'\n  \
    \  binary[65] = '1'\n    binary[66] = '1'\n    binary[67] = '1'\n    binary[68]\
    \ = '1'\n    binary[69] = '1'\n    binary[70] = '1'\n    binary[71] = '1'\n  \
    \  binary[72] = '1'\n    binary[73] = '1'\n    binary[74] = '1'\n    binary[75]\
    \ = '1'\n    binary[76] = '1'\n    binary[77] = '1'\n    binary[78] = '1'\n  \
    \  binary[79] = '1'\n    binary[80] = '1'\n    binary[81] = '1'\n    binary[82]\
    \ = '1'\n    binary[83] = '1'\n    binary[84] = '1'\n    binary[85] = '1'\n  \
    \  binary[86] = '1'\n    binary[87] = '1'\n    binary[88] = '1'\n    binary[89]\
    \ = '1'\n    binary[90] = '1'\n    binary[91] = '1'\n    binary[92] = '1'\n  \
    \  binary[93] = '1'\n    binary[94] = '1'\n    binary[95] = '1'\n    binary[96]\
    \ = '1'\n    binary[97] = '1'\n    binary[98] = '1'\n    binary[99] = '1'\n  \
    \  binary[100] = '1'\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph4284qvz_test.go:91:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074444
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Your code here\n    result := \"\"\n    decimal %= 2\n\
    \    for i := 0; i < decimal; i++ {\n        result += \"1\"\n    }\n    for i\
    \ := decimal; i > 0; i-- {\n        result += \"0\"\n    }\n    return \"db\"\
    \ + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp449wucw3_test.go:45: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp449wucw3_test.go:45:\
    \ expected 'db100000db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp449wucw3_test.go:45: expected 'db1100111db', got 'db10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp449wucw3_test.go:45:\
    \ expected 'db1111db', got 'db10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074444
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for ; i < 32;\
    \ i++ {\n        binary[i] = byte(decimal % 2)\n        decimal /= 2\n    }\n\
    \    binary[0] = 'b'\n    binary[32] = 'b'\n    return string(binary)\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmprso0_fbc_test.go:24\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmprso0_fbc_test.go:35\
    \ +0x28\ntesting.tRunner(0xc0000cc4e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal%2\
    \ == 0 {\n        binary[i] = '1'\n        decimal = decimal / 2\n        i++\n\
    \    }\n    for decimal%2 == 1 {\n        binary[i] = '0'\n        decimal = decimal\
    \ / 2\n        i++\n    }\n    binary[i] = 'b'\n    return string(binary)\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmphof963l7_test.go:20\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmphof963l7_test.go:40\
    \ +0x5ec\ntesting.tRunner(0xc0000cc4e0, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal%2\
    \ == 0 {\n        binary[i] = '1'\n        decimal = decimal / 2\n        i++\n\
    \    }\n    for decimal%2 == 1 {\n        binary[i] = '0'\n        decimal = decimal\
    \ / 2\n        i++\n    }\n    binary[i] = 'd'\n    binary[i+4] = 'b'\n    return\
    \ string(binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmpnrz1xpfx_test.go:20\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmpnrz1xpfx_test.go:41\
    \ +0x685\ntesting.tRunner(0xc0000da1a0, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    decimalString := fmt.Sprintf(\"\
    %d\", decimal)\n    decimalLen := len(decimalString)\n    binaryLen := decimalLen\
    \ * 2\n    for i := 0; i < decimalLen; i++ {\n        binaryString += fmt.Sprintf(\"\
    %c\", decimalString[i*2] == '1')\n    }\n    binaryString += \"db\"\n    for i\
    \ := decimalLen - 1; i >= 0; i-- {\n        binaryString += fmt.Sprintf(\"%c\"\
    , decimalString[i*2+1] == '1')\n    }\n    return binaryString\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp064njtof_test.go:20:5: binaryLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Write your code here\n    \n    return \"\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpw3mytc2r_test.go:38: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpw3mytc2r_test.go:38: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpw3mytc2r_test.go:38: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpw3mytc2r_test.go:38: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    result += fmt.Sprintf(\"\
    %c\", decimal%2)\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpgqe3in5y_test.go:42: expected 'db0db', got '\0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpgqe3in5y_test.go:42:\
    \ expected 'db100000db', got '\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpgqe3in5y_test.go:42: expected 'db1100111db', got '\0\x01\
    '\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpgqe3in5y_test.go:42:\
    \ expected 'db1111db', got '\0\x01'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    decimal %= 2\n    for decimal>0\
    \ {\n        binaryString += \"0\"\n        decimal--\n    }\n    for decimal>0\
    \ {\n        binaryString += \"1\"\n        decimal--\n    }\n    return binaryString\
    \ + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp5ax4lm_h_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp5ax4lm_h_test.go:46:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp5ax4lm_h_test.go:46: expected 'db1100111db', got '0db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp5ax4lm_h_test.go:46:\
    \ expected 'db1111db', got '0db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    decimal /= 2\n    for i := 0; i <\
    \ decimal; i++ {\n        result += \"1\"\n    }\n    result += \"db\"\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpqk3uut43_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpqk3uut43_test.go:46:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpqk3uut43_test.go:46: expected 'db1100111db', got '0db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpqk3uut43_test.go:46:\
    \ expected 'db1111db', got '0db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    decimalString := fmt.Sprintf(\"\
    %d\", decimal)\n    decimalLen := len(decimalString)\n    binaryLen := decimalLen\
    \ / 2\n    for i := 0; i < binaryLen; i++ {\n        binaryString += \"0\"\n \
    \   }\n    for i := decimalLen - 1; i >= 0; i-- {\n        binaryString += \"\
    1\"\n    }\n    return binaryString + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpdebphook_test.go:46: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpdebphook_test.go:46:\
    \ expected 'db100000db', got '011db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpdebphook_test.go:46: expected 'db1100111db', got '0111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpdebphook_test.go:46:\
    \ expected 'db1111db', got '011db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074446
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal%2\
    \ == 0 {\n        binary[i] = '1'\n        decimal /= 2\n        i++\n    }\n\
    \    for decimal%2 == 1 {\n        binary[i] = '0'\n        decimal /= 2\n   \
    \     i++\n    }\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmp9zvto0yt_test.go:20\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmp9zvto0yt_test.go:39\
    \ +0x573\ntesting.tRunner(0xc0000da340, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    switch decimal {\n    case 0:\n     \
    \   result = \"0\"\n    case 1:\n        result = \"1\"\n    case 2:\n       \
    \ result = \"10\"\n    case 3:\n        result = \"11\"\n    case 4:\n       \
    \ result = \"100\"\n    case 5:\n        result = \"101\"\n    case 6:\n     \
    \   result = \"110\"\n    case 7:\n        result = \"111\"\n    case 8:\n   \
    \     result = \"1000\"\n    case 9:\n        result = \"1001\"\n    case 10:\n\
    \        result = \"1010\"\n    case 11:\n        result = \"1011\"\n    case\
    \ 12:\n        result = \"1100\"\n    case 13:\n        result = \"1101\"\n  \
    \  case 14:\n        result = \"1110\"\n    case 15:\n        result = \"1111\"\
    \n    }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpsi14s0rm_test.go:71: expected 'db100000db', got 'dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpsi14s0rm_test.go:71:\
    \ expected 'db1100111db', got 'dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    for i := 0; i < decimal; i++ {\n    \
    \    if decimal % 2 == 0 {\n            result += \"1\"\n        } else {\n  \
    \          result += \"0\"\n        }\n    }\n    if decimal > 0 {\n        result\
    \ = \"db\" + result\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpb5d1th_2_test.go:47: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpb5d1th_2_test.go:47: expected\
    \ 'db100000db', got 'db11111111111111111111111111111111'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpb5d1th_2_test.go:47: expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpb5d1th_2_test.go:47:\
    \ expected 'db1111db', got 'db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    i := 0\n    for i < len(decimal) {\n\
    \        if decimal[i] > 0 {\n            result += fmt.Sprintf(\"%c\", decimal[i])\n\
    \        } else {\n            result += \"0\"\n        }\n        i++\n    }\n\
    \    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpycdxue0r_test.go:19:17: invalid argument: decimal (variable of type int)
    for len

    /tmp/tmpycdxue0r_test.go:20:19: invalid operation: cannot index decimal (variable
    of type int)

    /tmp/tmpycdxue0r_test.go:21:48: invalid operation: cannot index decimal (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074446
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db100000db', got '1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Your code here\n    result := \"\"\n    decimal %= 2\n\
    \    if decimal > 0 {\n        result += \"1\"\n    }\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpq1t5f5yv_test.go:45: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpq1t5f5yv_test.go:45: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpq1t5f5yv_test.go:45: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpq1t5f5yv_test.go:45: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074446
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        binary += \"1\"\n    }\n    for decimal > 0 {\n        binary += \"0\"\
    \n        decimal -= 1\n    }\n    return binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp4gbqr_oa_test.go:45: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp4gbqr_oa_test.go:45:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp4gbqr_oa_test.go:45: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp4gbqr_oa_test.go:45:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074446
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n   \
    \ if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n  \
    \  decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx9zxfvop_test.go:115:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db100000db', got '1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmptod8gbe__test.go:43: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptod8gbe__test.go:43:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    temp := decimal\n    for temp > 0 {\n\
    \        result += \"0\"\n        temp--\n    }\n    result += \"db\"\n    temp\
    \ = decimal\n    for temp > 0 {\n        result += \"1\"\n        temp--\n   \
    \ }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpru38g17o_test.go:48: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpru38g17o_test.go:48:\
    \ expected 'db100000db', got '00000000000000000000000000000000db11111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpru38g17o_test.go:48:\
    \ expected 'db1100111db', got '0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000db1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpru38g17o_test.go:48:\
    \ expected 'db1111db', got '000000000000000db111111111111111'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074441
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal % 2 ==\
    \ 0 {\n        result += \"1\"\n    } else {\n        result += \"0\"\n    }\n\
    \    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmphw6aabww_test.go:46: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmphw6aabww_test.go:46:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmphw6aabww_test.go:46: expected 'db1100111db', got '10'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmphw6aabww_test.go:46:\
    \ expected 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074446
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    switch decimal {\n    case 0:\n     \
    \   result = \"0\"\n    case 1:\n        result = \"1\"\n    default:\n      \
    \  result += \"0\"\n    }\n    result += \"db\"\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpab41qgxt_test.go:49: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpab41qgxt_test.go:49:\
    \ expected 'db100000db', got '0db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpab41qgxt_test.go:49: expected\
    \ 'db1100111db', got '0db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpab41qgxt_test.go:49:\
    \ expected 'db1111db', got '0db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074446
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Your code here\n    result := \"\"\n    result += \"db\"\
    \n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result +=\
    \ \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps4sfb__u_test.go:120:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074446
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal ==\
    \ 0 {\n        binary[i] = '0'\n        i++\n        decimal = decimal >> 1\n\
    \    }\n    for decimal == 1 {\n        binary[i] = '1'\n        i++\n       \
    \ decimal = decimal >> 1\n    }\n    binary[i] = 'b'\n    return string(binary)\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmp6qgazj1j_test.go:20\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmp6qgazj1j_test.go:40\
    \ +0x56c\ntesting.tRunner(0xc0000da1a0, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074446
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binaryString := \"\"\n    decimalToBinary := decimal / 2\n\
    \    decimal = decimal % 2\n    for i := 0; i < decimalToBinary; i++ {\n     \
    \   binaryString += \"0\"\n    }\n    binaryString += \"1\"\n    for i := decimalToBinary;\
    \ i < decimal; i++ {\n        binaryString += \"0\"\n    }\n    return binaryString\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmphkwzi0vz_test.go:46: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmphkwzi0vz_test.go:46:\
    \ expected 'db100000db', got '00000000000000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmphkwzi0vz_test.go:46: expected 'db1100111db', got '0000000000000000000000000000000000000000000000000001'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmphkwzi0vz_test.go:46:\
    \ expected 'db1111db', got '00000001'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074446
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result = fmt.Sprintf(\"%cdb%c\", decimal, decimal)\n    } else {\n  \
    \      result = fmt.Sprintf(\"%cdb%c\", decimal, decimal+1)\n    }\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptlj2jbim_test.go:43: expected 'db0db', got '\0db\x01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptlj2jbim_test.go:43:\
    \ expected 'db100000db', got '\0db\x01'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmptlj2jbim_test.go:43: expected 'db1100111db', got '\x01db\x01\
    '\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptlj2jbim_test.go:43:\
    \ expected 'db1111db', got '\x01db\x01'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074446
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal>0\
    \ {\n        binary[i] = byte(decimal%2)\n        decimal /= 2\n        i++\n\
    \    }\n    binary[i] = 'b'\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpfajw1pb7_test.go:44: expected 'db0db', got 'b\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpfajw1pb7_test.go:44: expected 'db100000db', got '\0\0\0\0\
    \0\x01b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpfajw1pb7_test.go:44: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpfajw1pb7_test.go:44: expected\
    \ 'db1111db', got '\x01\x01\x01\x01b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    decimal /= 2\n    for i := 0; i <\
    \ decimal; i++ {\n        result += \"1\"\n    }\n    result += \"db\"\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpqk3uut43_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpqk3uut43_test.go:46:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpqk3uut43_test.go:46: expected 'db1100111db', got '0db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpqk3uut43_test.go:46:\
    \ expected 'db1111db', got '0db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    i := 0\n    for ; decimal > 0; decimal\
    \ = decimal / 2 {\n        if decimal % 2 == 0 {\n            result += fmt.Sprintf(\"\
    %c\", decimal)\n        } else {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \        }\n        i++\n    }\n    result += \"db\"\n    for ; decimal > 0; decimal\
    \ = decimal / 2 {\n        if decimal % 2 == 0 {\n            result += fmt.Sprintf(\"\
    %c\", decimal)\n        } else {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \        }\n        i++\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpnmaafb1e_test.go:55: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnmaafb1e_test.go:55:\
    \ expected 'db100000db', got ' \x10\b\x04\x02\x01db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpnmaafb1e_test.go:55: expected 'db1100111db', got '\x01\x01\
    \x01\f\x06\x01\x01db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n\
    \        tmpnmaafb1e_test.go:55: expected 'db1111db', got '\x01\x01\x01\x01db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074447
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpiic4hp0r_test.go:42: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpiic4hp0r_test.go:42:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpiic4hp0r_test.go:42: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpiic4hp0r_test.go:42:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n   \
    \ if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n  \
    \  decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx9zxfvop_test.go:115:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 1 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 2 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 3 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 4 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 5 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 6 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 7 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 8 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 9 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 10 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 11 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 12 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 13 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 14 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 15 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 16 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 17 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 18 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 19 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 20 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 21 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 22 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 23 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 24 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 25 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 26 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 27 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 28 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 29 {\n\
    \        result += decimal_to_binary(decimal/2)\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpztc8bxab_test.go:108:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074439
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal_to_binary_test);\
    \ i++ {\n        if decimal >= decimal_to_binary_test[i].decimal {\n         \
    \   result += decimal_to_binary_test[i].binary\n            decimal -= decimal_to_binary_test[i].decimal\n\
    \        } else {\n            result += decimal_to_binary_test[i].binary\n  \
    \      }\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_5uenn9_test.go:19:25: undefined: decimal_to_binary_test

    /tmp/tmpj_5uenn9_test.go:20:23: undefined: decimal_to_binary_test

    /tmp/tmpj_5uenn9_test.go:21:23: undefined: decimal_to_binary_test

    /tmp/tmpj_5uenn9_test.go:22:24: undefined: decimal_to_binary_test

    /tmp/tmpj_5uenn9_test.go:24:23: undefined: decimal_to_binary_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074446
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpiic4hp0r_test.go:42: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpiic4hp0r_test.go:42:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpiic4hp0r_test.go:42: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpiic4hp0r_test.go:42:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for ; i < 32;\
    \ i++ {\n        binary[i] = byte(decimal % 2)\n        decimal /= 2\n    }\n\
    \    binary[0] = 'b'\n    binary[32] = 'b'\n    return string(binary)\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmprso0_fbc_test.go:24\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmprso0_fbc_test.go:35\
    \ +0x28\ntesting.tRunner(0xc0000cc4e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Your code here\n    result := \"\"\n    decimal %= 2\n\
    \    for i := 0; i < decimal; i++ {\n        result += \"1\"\n    }\n    for i\
    \ := decimal; i < 32; i++ {\n        result += \"0\"\n    }\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpoyrzv3wk_test.go:46: expected 'db0db', got '00000000000000000000000000000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoyrzv3wk_test.go:46:\
    \ expected 'db100000db', got '00000000000000000000000000000000db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoyrzv3wk_test.go:46: expected\
    \ 'db1100111db', got '10000000000000000000000000000000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpoyrzv3wk_test.go:46: expected 'db1111db', got '10000000000000000000000000000000db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074442
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(fmt.Sprintf(\"\
    %d\", decimal)); i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"\
    %d\", decimal%2)\n            decimal /= 2\n        } else {\n            result\
    \ += fmt.Sprintf(\"%d\", decimal%2)\n            decimal *= 2\n        }\n   \
    \ }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpnhl7nfy9_test.go:47: expected 'db100000db', got 'db0db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnhl7nfy9_test.go:47:\
    \ expected 'db1100111db', got 'db1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpnhl7nfy9_test.go:47: expected 'db1111db', got 'db1db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074447
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"1\"\n    }\n    for i := decimal; i > 0; i-- {\n\
    \        result += \"0\"\n    }\n    return \"db\" + result + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp95h21jlo_test.go:44: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp95h21jlo_test.go:44:\
    \ expected 'db100000db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp95h21jlo_test.go:44: expected 'db1100111db', got 'db10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp95h21jlo_test.go:44:\
    \ expected 'db1111db', got 'db10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074444
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result = fmt.Sprintf(\"%cdb\", decimal)\n    }\n    decimal /= 2\n  \
    \  if decimal > 0 {\n        result = fmt.Sprintf(\"%cdb\", decimal) + result\n\
    \    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n \
    \ candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkceo46pf_test.go:45: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkceo46pf_test.go:45: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpkceo46pf_test.go:45: expected 'db1100111db', got '\x01db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpkceo46pf_test.go:45:\
    \ expected 'db1111db', got '\x01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074447
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    switch decimal {\n    case 0:\n     \
    \   result = \"0\"\n    case 1:\n        result = \"1\"\n    default:\n      \
    \  result += \"0\"\n    }\n    result += \"db\"\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpab41qgxt_test.go:49: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpab41qgxt_test.go:49:\
    \ expected 'db100000db', got '0db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpab41qgxt_test.go:49: expected\
    \ 'db1100111db', got '0db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpab41qgxt_test.go:49:\
    \ expected 'db1111db', got '0db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074446
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n   \
    \ if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n  \
    \  decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx9zxfvop_test.go:115:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \            decimal /= 2\n        } else {\n            result += fmt.Sprintf(\"\
    %c\", 1)\n        }\n    }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpahfzquuk_test.go:19:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n   \
    \ if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n  \
    \  decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx9zxfvop_test.go:115:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpiic4hp0r_test.go:42: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpiic4hp0r_test.go:42:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpiic4hp0r_test.go:42: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpiic4hp0r_test.go:42:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal % 2 ==\
    \ 0 {\n        result += \"1\"\n    } else {\n        result += \"0\"\n    }\n\
    \    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmphw6aabww_test.go:46: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmphw6aabww_test.go:46:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmphw6aabww_test.go:46: expected 'db1100111db', got '10'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmphw6aabww_test.go:46:\
    \ expected 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074446
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    switch decimal {\n    case 0:\n     \
    \   result = \"0\"\n    case 1:\n        result = \"1\"\n    default:\n      \
    \  result += \"0\"\n    }\n    result += \"db\"\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpab41qgxt_test.go:49: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpab41qgxt_test.go:49:\
    \ expected 'db100000db', got '0db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpab41qgxt_test.go:49: expected\
    \ 'db1100111db', got '0db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpab41qgxt_test.go:49:\
    \ expected 'db1111db', got '0db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074446
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Your code here\n    result := \"\"\n    temp := decimal\
    \ / 2\n    for i := 0; i < temp; i++ {\n        result += fmt.Sprintf(\"%c\",\
    \ decimal%2)\n        decimal /= 2\n    }\n    result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkan8t_nr_test.go:44: expected 'db0db', got '\0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkan8t_nr_test.go:44:\
    \ expected 'db100000db', got '\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpkan8t_nr_test.go:44: expected\
    \ 'db1100111db', got '\x01\x01\x01\0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpkan8t_nr_test.go:44: expected 'db1111db', got '\x01\x01\x01\
    \x01\0\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074447
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal_to_binary_test);\
    \ i++ {\n        if decimal > 0 {\n            result += decimal_to_binary_test[i]\n\
    \            decimal -= 2\n        } else {\n            result += decimal_to_binary_test[i]\n\
    \        }\n    }\n    return result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb1w2axjv_test.go:19:25: undefined: decimal_to_binary_test

    /tmp/tmpb1w2axjv_test.go:21:23: undefined: decimal_to_binary_test

    /tmp/tmpb1w2axjv_test.go:24:23: undefined: decimal_to_binary_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 1 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 2 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 3 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 4 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 5 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 6 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 7 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 8 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 9 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 10 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 11 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 12 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 13 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 14 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 15 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 16 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 17 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 18 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 19 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 20 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 21 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 22 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 23 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 24 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 25 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 26 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 27 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 28 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 29 {\n\
    \        result += decimal_to_binary(decimal/2)\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpztc8bxab_test.go:108:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074439
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := \"\"\n    decimalToBinary := func(decimal int)\
    \ string {\n        if decimal < 2 {\n            return fmt.Sprintf(\"0%d\",\
    \ decimal)\n        }\n        decimalToBinary := func(decimal int) string {\n\
    \            if decimal < 2 {\n                return fmt.Sprintf(\"0%d\", decimal)\n\
    \            }\n            decimalToBinary(decimal/2)\n            binary +=\
    \ fmt.Sprintf(\"%d\", decimal%2)\n        }\n        decimalToBinary(decimal)\n\
    \        return binary\n    }\n    return decimalToBinary(decimal)\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp48y6573t_test.go:26:13: undefined: decimalToBinary

    /tmp/tmp48y6573t_test.go:28:9: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    // Your code here\n    result := \"\"\n    temp := decimal\n\
    \    for temp > 0 {\n        result += \"0\"\n        temp = temp / 2\n    }\n\
    \    result += \"db\"\n    for temp > 0 {\n        result += \"1\"\n        temp\
    \ = temp / 2\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp4c_v3von_test.go:48: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp4c_v3von_test.go:48:\
    \ expected 'db100000db', got '000000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp4c_v3von_test.go:48: expected 'db1100111db', got '0000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp4c_v3von_test.go:48:\
    \ expected 'db1111db', got '0000db'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074447
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpvbty_9e2_test.go:44: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpvbty_9e2_test.go:44: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpvbty_9e2_test.go:44: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpvbty_9e2_test.go:44: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal>0\
    \ {\n        binary[i] = byte(decimal%2)\n        decimal /= 2\n        i++\n\
    \    }\n    return string(binary[:i+1])\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpfcc97vgv_test.go:43: expected 'db0db', got '\0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpfcc97vgv_test.go:43:\
    \ expected 'db100000db', got '\0\0\0\0\0\x01\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpfcc97vgv_test.go:43: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n\
    \        tmpfcc97vgv_test.go:43: expected 'db1111db', got '\x01\x01\x01\x01\0\
    '\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074447
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n//\
    \ decimal_to_binary(32)   # returns \"db100000db\"\nfunc decimal_to_binary(decimal\
    \ int) string {\n    result := \"\"\n    binary := make([]byte, 32)\n    for i\
    \ := 0; i < len(binary); i++ {\n        binary[i] = byte(decimal % 2)\n      \
    \  decimal /= 2\n    }\n    result += \"db\" + string(binary)\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp3ogs9ay4_test.go:43: expected 'db0db', got 'db\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp3ogs9ay4_test.go:43: expected 'db100000db', got 'db\0\0\0\
    \0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp3ogs9ay4_test.go:43: expected 'db1100111db', got 'db\x01\
    \x01\x01\0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp3ogs9ay4_test.go:43:\
    \ expected 'db1111db', got 'db\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074447
