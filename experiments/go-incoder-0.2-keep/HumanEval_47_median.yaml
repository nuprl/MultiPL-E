name: HumanEval_47_median
language: go_test.go
prompt: "package median_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
  \ median of elements in the list l.\n// >>> median([3, 1, 2, 4, 5])\n// 3\n// >>>\
  \ median([-10, 4, 6, 1000, 10, 20])\n// 15.0\nfunc median(l []int) float64 {\n"
tests: "func TestMedian(t *testing.T) {\n  candidate := median\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: 3 },\n     { actual:\
  \ candidate([]int{-10, 4, 6, 1000, 10, 20}), expected: 8.0 },\n     { actual: candidate([]int{5}),\
  \ expected: 5 },\n     { actual: candidate([]int{6, 5}), expected: 5.5 },\n    \
  \ { actual: candidate([]int{8, 1, 3, 9, 9, 2, 7}), expected: 7 },\n   }\n\n\tfor\
  \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
  \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
  \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\
  \t}\n\t\t})\n\t}\n}\n"
completions: ["    length := len(l)\n    if length%2 == 0 {\n        return l[(length-1)/2]\n\
    \    } else {\n        return (l[(length-1)/2] + l[length/2]) / 2\n    }\n}\n",
  "    if len(l) == 0 {\n        return float64(0)\n    }\n    sort.Sort(l)\n    n\
    \ := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return float64(l[n/2]\
    \ + l[n/2-1]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n  \
    \  sort.Ints(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n \
    \   }\n    return (l[n/2] + l[n/2]) / 2\n}\n", "    length := len(l)\n    if length%2\
    \ == 0 {\n        return l[(length-1)/2]\n    }\n    middle := length/2\n    left\
    \ := l[0:middle]\n    right := l[middle:]\n    median := (left + right) / 2\n\
    \    return median\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n \
    \   sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n/2] + l[n/2]) / 2\n}\n", "    length := len(l)\n    if\
    \ length%2 == 0 {\n        return l[(length-1)/2]\n    }\n    middle := length/2\n\
    \    left := l[0:middle]\n    right := l[middle:]\n    median := (left + right)\
    \ / 2\n    return median\n}\n", "    if len(l) == 0 {\n        return math.NaN()\n\
    \    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    middle := (n+1)/2\n    return float64(l[middle-1] + l[middle])/2\n\
    }\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n   \
    \ n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n/2]\
    \ + l[n/2 - 1]) / 2\n}\n", "    length := len(l)\n    if length%2 == 0 {\n   \
    \     return l[(length-1)/2]\n    }\n    middle := length/2\n    return median(l,\
    \ middle)\n}\n", "    length := len(l)\n    if length%2 == 0 {\n        return\
    \ l[(length-1)/2]\n    }\n    middle := length/2\n    return l[middle]\n}\n",
  "    if len(l) == 0 {\n        return math.NaN()\n    }\n    sort.Sort(l)\n    n\
    \ := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n/2]\
    \ + l[n/2-1]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n  \
    \  sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n \
    \   }\n    return (l[n/2] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n       \
    \ return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n  \
    \      return l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l)\
    \ == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if\
    \ n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n\
    }\n", "    if len(l) == 0 {\n        return float64(0)\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ ((l[n-1] + l[n/2]) / 2)\n}\n", "    if len(l) == 0 {\n        return 0.0\n \
    \   }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n      \
    \  return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n \
    \       return l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    if\
    \ len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n\
    \    if n%2 == 0 {\n        return l[n/2]\n    }\n    return ((l[n/2] + l[n/2])\
    \ / 2)\n}\n", "    length := len(l)\n    if length%2 == 0 {\n        return l[(length-1)/2]\n\
    \    }\n    middle := length/2\n    return l[middle]\n}\n", "    if len(l) ==\
    \ 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n\
    \ % 2 == 0 {\n        return l[n/2]\n    }\n    return (l[n/2] + l[n/2-1]) / 2\n\
    }\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n   \
    \ n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n-1]\
    \ + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(sort.IntSlice(l))\n\
    \    length := len(l)\n    if length % 2 == 0 {\n        return l[(length-1)/2]\n\
    \    }\n    return (l[length-1] + l[length/2]) / 2\n}\n", "    if len(l) == 0\
    \ {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2\
    \ == 0 {\n        return l[n/2]\n    }\n    return (l[n/2] + l[n/2-1]) / 2\n}\n",
  "    if len(l) == 0 {\n        return math.NaN()\n    }\n    sort.Sort(l)\n    n\
    \ := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    middle := n\
    \ / 2\n    return float64(l[middle-1] + l[middle])/2\n}\n", "    if len(l) ==\
    \ 0 {\n        return 0.0\n    }\n    sort.Ints(l)\n    return l[len(l)/2]\n}\n",
  "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(sort.IntSlice(l))\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n/2] + l[n/2-1]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n \
    \   }\n    sort.Sort(l)\n    length := len(l)\n    if length % 2 == 0 {\n    \
    \    return l[(length-1)/2]\n    }\n    return (l[(length-1)/2] + l[(length-1)/2])\
    \ / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n/2] + l[n/2 - 1]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n\
    \    }\n    sort.Sort(l)\n    n := len(l)\n    middle := n / 2\n    if n % 2 ==\
    \ 0 {\n        return l[middle]\n    }\n    return (l[middle-1] + l[middle]) /\
    \ 2\n}\n", "    if len(l) == 0 {\n        return math.NaN()\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n/2] + l[n/2 - 1]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n\
    \    }\n    sort.Ints(l)\n    n := len(l)\n    middle := n / 2\n    if n % 2 ==\
    \ 0 {\n        return l[middle]\n    }\n    return (l[middle-1] + l[middle]) /\
    \ 2\n}\n", "    length := len(l)\n    if length%2 == 0 {\n        return l[(length-1)/2]\n\
    \    }\n    middle := length/2\n    return l[middle]\n}\n", "    if len(l) ==\
    \ 0 {\n        return 0.0\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n\
    \    length := len(l)\n    middle := length / 2\n    if length%2 == 0 {\n    \
    \    return l[middle]\n    }\n    return (l[middle-1] + l[middle]) / 2\n}\n",
  "    if len(l) == 0 {\n        return float64(0)\n    }\n    sort.Sort(l)\n    n\
    \ := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n-1]\
    \ + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n        return float64(0)\n    }\n\
    \    sort.Sort(l)\n    length := len(l)\n    if length%2 == 0 {\n        return\
    \ l[(length-1)/2]\n    }\n    return (l[length/2] + l[length/2-1]) / 2\n}\n",
  "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n\
    \    if n % 2 == 0 {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2])\
    \ / 2\n}\n", "    if len(l) == 0 {\n        return math.NaN()\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n   \
    \ }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n/2] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n      \
    \  return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n % 2 == 0 {\n\
    \        return l[n/2]\n    }\n    return (l[n/2] + l[n/2 - 1]) / 2\n}\n", " \
    \   if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n\
    \    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2])\
    \ / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    middle := n / 2\n    if n % 2 == 0 {\n        return l[middle]\n\
    \    } else {\n        return (l[middle-1] + l[middle]) / 2\n    }\n}\n", "  \
    \  if len(l) == 0 {\n        return 0.0\n    }\n    sort.Ints(l)\n    n := len(l)\n\
    \    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2])\
    \ / 2\n}\n", "    sort.Sort(IntSlice(l))\n    if len(l) == 0 {\n        return\
    \ math.NaN()\n    }\n    length := len(l)\n    middle := length/2\n    if length%2\
    \ == 0 {\n        return l[middle]\n    }\n    return (l[middle-1] + l[middle])/2\n\
    }\n", "    length := len(l)\n    if length%2 == 0 {\n        return l[(length-1)/2]\n\
    \    }\n    middle := length/2\n    if length%2 == 1 {\n        return l[middle]\n\
    \    }\n    return median(l, middle)\n}\n", "    if len(l) == 0 {\n        return\
    \ math.NaN()\n    }\n    sort.Ints(l)\n    return l[len(l)/2]\n}\n", "    if len(l)\
    \ == 0 {\n        return math.NaN()\n    }\n    sort.Ints(l)\n    n := len(l)\n\
    \    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2])\
    \ / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n-1] + l[n/2]) / 2\n}\n", "    length := len(l)\n    if length%2 == 0 {\n\
    \        return l[(length-1)/2]\n    }\n    middle := length/2\n    left := l[:middle]\n\
    \    right := l[middle:]\n    medianLeft := median(left)\n    medianRight := median(right)\n\
    \    if medianLeft < medianRight {\n        return medianLeft\n    } else {\n\
    \        return medianRight\n    }\n}\n", "    if len(l) == 0 {\n        return\
    \ math.NaN()\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n  \
    \      return l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l)\
    \ == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if\
    \ n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n\
    }\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Ints(l)\n   \
    \ return l[len(l)-1]\n}\n", "    length := len(l)\n    if length%2 == 0 {\n  \
    \      return l[(length-1)/2]\n    }\n    middle := length/2\n    if length%2\
    \ == 1 {\n        return l[middle]\n    }\n    middle -= 1\n    return l[middle]\
    \ + median(l[middle:length-1])\n}\n", "    length := len(l)\n    if length%2 ==\
    \ 0 {\n        return l[(length-1)/2]\n    }\n    middle := length/2\n    return\
    \ l[middle]\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n/2] + l[n/2]) / 2.0\n}\n", "    if len(l) == 0 {\n        return 0.0\n \
    \   }\n    sort.Sort(l)\n    length := len(l)\n    if length%2 == 0 {\n      \
    \  return l[(length-1)/2]\n    }\n    middle := length/2\n    return float64(l[middle-1])\
    \ + float64(l[middle])/2\n}\n", "    if len(l) == 0 {\n        return 0.0\n  \
    \  }\n    sort.Sort(l)\n    length := len(l)\n    middle := length/2\n    if length%2\
    \ == 0 {\n        return l[middle]\n    }\n    return (l[middle-1] + l[middle])/2\n\
    }\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n   \
    \ n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n-1]\
    \ + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n        return math.NaN()\n    }\n\
    \    sort.Ints(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n      \
    \  return float64(0)\n    }\n    sort.Sort(l)\n    length := len(l)\n    if length%2\
    \ == 0 {\n        return l[(length-1)/2]\n    }\n    return (l[length-1] + l[length/2])\
    \ / 2\n}\n", "    length := len(l)\n    if length%2 == 0 {\n        return l[(length-1)/2]\n\
    \    }\n    middle := length/2\n    left := l[0:middle]\n    right := l[middle:]\n\
    \    leftMedian := median(left)\n    rightMedian := median(right)\n    if leftMedian\
    \ > rightMedian {\n        return left\n    } else {\n        return right\n \
    \   }\n}\n", "    if len(l) == 0 {\n        return float64(0)\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    middle\
    \ := (n+1)/2\n    return float64(l[middle-1] + l[middle])/2\n}\n", "    if len(l)\
    \ == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if\
    \ n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n/2] + l[n/2]) / 2\n\
    }\n", "    if len(l) == 0 {\n        return float64(0)\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n   \
    \ }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n      \
    \  return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n \
    \       return l[n/2]\n    }\n    return (l[n/2] + l[n/2 - 1]) / 2\n}\n", "  \
    \  if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n\
    \    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2])\
    \ / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n\
    \    length := len(l)\n    middle := length/2\n    if length%2 == 0 {\n      \
    \  return l[middle]\n    }\n    return (l[middle-1] + l[middle])/2\n}\n", "  \
    \  if len(l) == 0 {\n        return math.NaN()\n    }\n    sort.Sort(l)\n    n\
    \ := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n/2]\
    \ + l[n/2 - 1]) / 2\n}\n", "    if len(l) == 0 {\n        return math.NaN()\n\
    \    }\n    sort.Sort(sort.IntSlice(l))\n    length := len(l)\n    middle := length\
    \ / 2\n    if length%2 == 0 {\n        return l[middle]\n    } else {\n      \
    \  return (l[middle-1] + l[middle]) / 2\n    }\n}\n", "    if len(l) == 0 {\n\
    \        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    half := n /\
    \ 2\n    if n%2 == 0 {\n        return l[half]\n    }\n    return (l[half-1] +\
    \ l[half]) / 2\n}\n", "    sort.Sort(sort.IntSlice(l))\n    if len(l) == 0 {\n\
    \        return 0.0\n    }\n    length := len(l)\n    middle := length / 2\n \
    \   if length%2 == 0 {\n        return l[middle]\n    } else {\n        return\
    \ (l[middle-1] + l[middle]) / 2\n    }\n}\n", "    if len(l) == 0 {\n        return\
    \ 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return\
    \ l[n/2]\n    }\n    return (l[n/2] + l[n/2 - 1]) / 2\n}\n", "    if len(l) ==\
    \ 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2\
    \ == 0 {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n}\n",
  "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    length :=\
    \ len(l)\n    if length%2 == 0 {\n        return l[(length-1)/2]\n    }\n    return\
    \ (l[length-1] + l[length/2]) / 2\n}\n", "    if len(l) == 0 {\n        return\
    \ math.NaN()\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n  \
    \      return l[n/2]\n    }\n    middle := (n+1)/2\n    return float64(l[middle-1])\
    \ + float64(l[middle])/2\n}\n", "    if len(l) == 0 {\n        return 0.0\n  \
    \  }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n      \
    \  return math.NaN()\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 ==\
    \ 0 {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", " \
    \   if len(l) == 0 {\n        return float64(0)\n    }\n    sort.Sort(l)\n   \
    \ n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n-1]\
    \ + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n\
    \    length := len(l)\n    if length%2 == 0 {\n        return l[(length-1)/2]\n\
    \    }\n    return (l[(length-1)/2] + l[(length-1)/2]) / 2\n}\n", "    if len(l)\
    \ == 0 {\n        return float64(0)\n    }\n    sort.Sort(l)\n    n := len(l)\n\
    \    middle := n / 2\n    if n % 2 == 0 {\n        return l[middle]\n    }\n \
    \   return (l[middle-1] + l[middle]) / 2\n}\n", "    if len(l) == 0 {\n      \
    \  return float64(0)\n    }\n    sort.Ints(l)\n    n := len(l)\n    if n%2 ==\
    \ 0 {\n        return l[n/2]\n    }\n    return ((l[n/2] + l[n/2-1]) / 2)\n}\n",
  "    sort.Sort(sort.IntSlice(l))\n    if len(l) == 0 {\n        return 0.0\n   \
    \ }\n    length := len(l)\n    middle := length / 2\n    if length%2 == 0 {\n\
    \        return l[middle]\n    }\n    return float64(l[middle-1] + l[middle])\
    \ / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n/2] + l[n/2]) / 2.0\n}\n", "    if len(l) == 0 {\n        return 0.0\n \
    \   }\n    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n    n := len(l)\n    if\
    \ n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n\
    }\n", "    if len(l) == 0 {\n        return math.NaN()\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    middle\
    \ := n / 2\n    return float64(l[middle-1] + l[middle])/2\n}\n", "    length :=\
    \ len(l)\n    if length%2 == 0 {\n        return l[(length-1)/2]\n    }\n    middle\
    \ := length/2\n    left := l[0:middle]\n    right := l[middle:]\n    medianLeft\
    \ := median(left)\n    medianRight := median(right)\n    return median([]int{medianLeft,\
    \ medianRight})\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    middle := n / 2\n    if n % 2 == 0 {\n        return l[middle]\n\
    \    } else {\n        return (l[middle-1] + l[middle]) / 2\n    }\n}\n", "  \
    \  length := len(l)\n    if length%2 == 0 {\n        return l[(length-1)/2]\n\
    \    }\n    middle := length/2\n    return l[middle]\n}\n", "    if len(l) ==\
    \ 0 {\n        return float64(0)\n    }\n    sort.Sort(l)\n    n := len(l)\n \
    \   if n%2 == 0 {\n        return l[n/2]\n    }\n    return l[n/2] + median(l[0\
    \ : n/2-1])\n}\n", "    length := len(l)\n    if length%2 == 0 {\n        return\
    \ l[(length-1)/2]\n    }\n    middle := length/2\n    left := l[0:middle]\n  \
    \  right := l[middle:]\n    median := (left + right) / 2\n    return median\n\
    }\n", "    length := len(l)\n    if length%2 == 0 {\n        return l[(length-1)/2]\n\
    \    }\n    middle := length/2\n    left := []int{}\n    right := []int{}\n  \
    \  for i := 0; i < middle; i++ {\n        left = append(left, l[i])\n    }\n \
    \   for i := middle + 1; i < length; i++ {\n        right = append(right, l[i])\n\
    \    }\n    left := append(left, l[middle])\n    right := append(right, l[middle])\n\
    \    return float64(median(left))+float64(median(right))\n}\n", "    if len(l)\
    \ == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    middle\
    \ := n / 2\n    if n % 2 == 0 {\n        return l[middle]\n    }\n    return (l[middle-1]\
    \ + l[middle]) / 2\n}\n", "    length := len(l)\n    if length%2 == 0 {\n    \
    \    return l[(length-1)/2]\n    }\n    middle := length/2\n    left := l[0:middle]\n\
    \    right := l[middle:]\n    left := median(left)\n    right := median(right)\n\
    \    return float64(left+right)/float64(length)\n}\n", "    if len(l) == 0 {\n\
    \        return math.NaN()\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2\
    \ == 0 {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n}\n",
  "    length := len(l)\n    if length <= 1 {\n        return l[0]\n    }\n    middle\
    \ := length / 2\n    left := make([]int, middle)\n    right := make([]int, middle)\n\
    \    for i := 0; i < middle; i++ {\n        left[i] = l[i]\n    }\n    for i :=\
    \ middle + 1; i < length; i++ {\n        right[i-1] = l[i]\n    }\n    result\
    \ := 0.0\n    for i := 0; i < middle; i++ {\n        result += left[i] + right[i]\n\
    \    }\n    return result / 2.0\n}\n", "    length := len(l)\n    if length%2\
    \ == 0 {\n        return l[(length-1)/2]\n    } else {\n        return (l[(length-1)/2]\
    \ + l[length/2]) / 2\n    }\n}\n", "    if len(l) == 0 {\n        return math.NaN()\n\
    \    }\n    sort.Sort(l)\n    length := len(l)\n    if length%2 == 0 {\n     \
    \   return l[(length-1)/2]\n    }\n    middle := length/2\n    return l[middle]\n\
    }\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n   \
    \ n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n/2]\
    \ + l[n/2-1]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n  \
    \  sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n \
    \   }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n       \
    \ return 0.0\n    }\n    sort.Sort(sort.IntSlice(l))\n    n := len(l)\n    middle\
    \ := n / 2\n    if n % 2 == 0 {\n        return l[middle]\n    }\n    return (l[middle-1]\
    \ + l[middle]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n \
    \   sort.Ints(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n      \
    \  return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n \
    \       return l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    if\
    \ len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n\
    \    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2])\
    \ / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Ints(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n        return math.NaN()\n\
    \    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n/2] + l[n/2]) / 2\n}\n", "    length := len(l)\n    if\
    \ length%2 == 0 {\n        return l[(length-1)/2]\n    }\n    middle := length/2\n\
    \    left := l[0:middle]\n    right := l[middle:]\n    return median(left) + median(right)\n\
    }\n", "    length := len(l)\n    if length%2 == 0 {\n        return l[(length-1)/2]\n\
    \    }\n    middle := length/2\n    left := l[0:middle]\n    right := l[middle:]\n\
    \    return median(left) + median(right)\n}\n", "    if len(l) == 0 {\n      \
    \  return float64(0)\n    }\n    sort.Sort(l)\n    length := len(l)\n    middle\
    \ := length / 2\n    if length%2 == 0 {\n        return l[middle]\n    }\n   \
    \ return (l[middle-1] + l[middle]) / 2\n}\n", "    length := len(l)\n    if length%2\
    \ == 0 {\n        return l[(length-1)/2]\n    }\n    middle := length/2\n    left\
    \ := l[0:middle]\n    right := l[middle:]\n    median := (left + right) / 2\n\
    \    return median\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n \
    \   sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n      \
    \  return 0.0\n    }\n    sort.Sort(sort.IntSlice(l))\n    n := len(l)\n    if\
    \ n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n\
    }\n", "    if len(l) == 0 {\n        return float64(0)\n    }\n    sort.Sort(sort.IntSlice(l))\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n/2] + l[n/2-1]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n \
    \   }\n    sort.Sort(sort.IntSlice(l))\n    n := len(l)\n    if n%2 == 0 {\n \
    \       return l[n/2]\n    }\n    return (l[n/2] + l[n/2 - 1]) / 2\n}\n", "  \
    \  if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n\
    \    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n/2] + l[n/2-1])\
    \ / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n/2] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n        return math.NaN()\n\
    \    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n/2] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n      \
    \  return 0.0\n    }\n    sort.Sort(l)\n    length := len(l)\n    if length%2\
    \ == 0 {\n        return l[(length-1)/2]\n    }\n    return l[(length-1)/2] +\
    \ l[length/2-1]\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    middle := n / 2\n    if n % 2 == 0 {\n        return l[middle]\n\
    \    }\n    return (l[middle-1] + l[middle]) / 2\n}\n", "    if len(l) == 0 {\n\
    \        return math.NaN()\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2\
    \ == 0 {\n        return l[n/2]\n    }\n    return (l[n/2] + l[n/2-1]) / 2\n}\n",
  "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n\
    \    length := len(l)\n    if length%2 == 0 {\n        return l[(length-1)/2]\n\
    \    }\n    return l[(length-1)/2] + l[length/2]/2\n}\n", "    if len(l) == 0\
    \ {\n        return float64(0)\n    }\n    sort.Sort(l)\n    n := len(l)\n   \
    \ if n%2 == 0 {\n        return l[n/2]\n    }\n    return l[n/2] + l[n/2-1]\n\
    }\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n   \
    \ length := len(l)\n    if length % 2 == 0 {\n        return l[(length-1)/2]\n\
    \    }\n    return ((l[(length-1)/2] + l[(length-1)/2]) / 2)\n}\n", "    if len(l)\
    \ == 0 {\n        return math.NaN()\n    }\n    sort.Sort(l)\n    n := len(l)\n\
    \    if n % 2 == 0 {\n        return l[n/2]\n    }\n    return (l[n/2] + l[n/2\
    \ - 1]) / 2\n}\n", "    if len(l) == 0 {\n        return math.NaN()\n    }\n \
    \   sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n/2] + l[n/2]) / 2\n}\n", "    length := len(l)\n    if\
    \ length%2 == 0 {\n        return l[(length-1)/2]\n    }\n    middle := length/2\n\
    \    if length%2 == 1 {\n        return l[middle]\n    }\n    median := l[middle]\n\
    \    left := make([]int, middle)\n    right := make([]int, middle)\n    for i\
    \ := 0; i < middle; i++ {\n        left[i] = l[i]\n    }\n    for i := middle\
    \ + 1; i < length; i++ {\n        right[i-1] = l[i]\n    }\n    return medianOfTwoSortedArrays(left,\
    \ right)\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n/2] + l[n/2]) / 2\n}\n", "    sort.Sort(sort.IntSlice(l))\n    if len(l)\
    \ == 0 {\n        return math.NaN()\n    }\n    middle := len(l) / 2\n    if middle\
    \ == 0 {\n        return l[0]\n    }\n    if middle == 1 {\n        return l[1]\n\
    \    }\n    if middle == len(l) {\n        return l[len(l)-1]\n    }\n    switch\
    \ {\n    case l[middle] > l[middle-1]:\n        return median(append(l[:middle],\
    \ l[middle+1:]...))\n    case l[middle] < l[middle-1]:\n        return median(append(l[middle:],\
    \ l[:middle-1]...))\n    }\n}\n", "    if len(l) == 0 {\n        return 0.0\n\
    \    }\n    sort.Sort(l)\n    n := len(l)\n    middle := n / 2\n    if n % 2 ==\
    \ 0 {\n        return l[middle]\n    }\n    return (l[middle-1] + l[middle]) /\
    \ 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    m := n / 2\n    if n % 2 == 0 {\n        return l[m]\n \
    \   }\n    return (l[m] + l[m+1]) / 2\n}\n", "    if len(l) == 0 {\n        return\
    \ 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return\
    \ l[n/2]\n    }\n    return (l[n/2] + l[n/2 - 1]) / 2\n}\n", "    length := len(l)\n\
    \    if length%2 == 0 {\n        return l[(length-1)/2]\n    }\n    return ((l[length/2]\
    \ + l[length/2-1])/2)\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n\
    \    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n/2] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n      \
    \  return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n \
    \       return l[n/2]\n    }\n    return (l[n/2] + l[n/2]) / 2\n}\n", "    if\
    \ len(l) == 0 {\n        return math.NaN()\n    }\n    sort.Sort(l)\n    n :=\
    \ len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n/2]\
    \ + l[n/2-1]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n  \
    \  sort.Sort(l)\n    length := len(l)\n    if length%2 == 0 {\n        return\
    \ l[(length-1)/2]\n    }\n    return (l[(length-1)/2] + l[length/2]) / 2.0\n}\n",
  "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n\
    \    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n/2] + l[n/2 -\
    \ 1]) / 2\n}\n", "    if len(l) == 0 {\n        return float64(0)\n    }\n   \
    \ sort.Ints(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n  \
    \  }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n        return\
    \ 0.0\n    }\n    sort.Sort(sort.IntSlice(l))\n    length := len(l)\n    if length%2\
    \ == 0 {\n        return l[(length-1)/2]\n    }\n    return (l[(length-1)/2] +\
    \ l[(length-1)/2]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n\
    \    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n/2] + l[n/2-1]) / 2\n}\n", "    if len(l) == 0 {\n    \
    \    return math.NaN()\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 ==\
    \ 0 {\n        return l[n/2]\n    }\n    return ((l[n/2] + l[n/2-1]) / 2)\n}\n",
  "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n\
    \    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n/2] + l[n/2 -\
    \ 1]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n\
    \    length := len(l)\n    if length%2 == 0 {\n        return l[(length-1)/2]\n\
    \    }\n    return (l[(length-1)/2] + l[length/2]) / 2.0\n}\n", "    if len(l)\
    \ == 0 {\n        return float64(0)\n    }\n    sort.Sort(l)\n    n := len(l)\n\
    \    if n % 2 == 0 {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2])\
    \ / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n   \
    \ }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n/2] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n      \
    \  return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n \
    \       return l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    if\
    \ len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    length := len(l)\n\
    \    if length%2 == 0 {\n        return l[(length-1)/2]\n    }\n    return (l[length/2]\
    \ + l[length/2-1]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n\
    \    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n/2] + l[n/2-1]) / 2\n}\n", "    if len(l) == 0 {\n    \
    \    return math.NaN()\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 ==\
    \ 0 {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", " \
    \   if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n\
    \    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n/2] + l[n/2])\
    \ / 2\n}\n", "    if len(l) == 0 {\n        return math.NaN()\n    }\n    sort.Sort(sort.IntSlice(l))\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n/2] + l[n/2 - 1]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n\
    \    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    length := len(l)\n    if\
    \ length%2 == 0 {\n        return l[(length-1)/2]\n    }\n    middle := length/2\n\
    \    left := l[0:middle]\n    right := l[middle:]\n    median := (left + right)\
    \ / 2\n    return median\n}\n", "    length := len(l)\n    if length%2 == 0 {\n\
    \        return l[(length-1)/2]\n    }\n    middle := length/2\n    left := make([]int,\
    \ middle)\n    right := make([]int, middle)\n    for i := 0; i < middle; i++ {\n\
    \        left[i] = l[i]\n    }\n    for i := middle + 1; i < length; i++ {\n \
    \       right[i-1] = l[i]\n    }\n    leftLength := len(left)\n    rightLength\
    \ := len(right)\n    if leftLength > rightLength {\n        return median(left)\n\
    \    }\n    return median(right)\n}\n", "    length := len(l)\n    if length%2\
    \ == 0 {\n        return l[(length-1)/2]\n    }\n    middle := length/2\n    left\
    \ := l[:middle]\n    right := l[middle:]\n    leftMedian := median(left)\n   \
    \ rightMedian := median(right)\n    if leftMedian > rightMedian {\n        return\
    \ left\n    } else {\n        return right\n    }\n}\n", "    if len(l) == 0 {\n\
    \        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n % 2 ==\
    \ 0 {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", " \
    \   if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n\
    \    n := len(l)\n    if n % 2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n/2] + l[n/2 - 1]) / 2\n}\n", "    length := len(l)\n    if length%2 == 0\
    \ {\n        return l[(length-1)/2]\n    }\n    middle := length/2\n    left :=\
    \ []int{}\n    right := []int{}\n    for i := 0; i < middle; i++ {\n        left\
    \ = append(left, l[i])\n    }\n    for i := middle + 1; i < length; i++ {\n  \
    \      right = append(right, l[i])\n    }\n    return median(left) + median(right)\n\
    }\n", "    if len(l) == 0 {\n        return math.NaN()\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n/2] + l[n/2 - 1]) / 2\n}\n", "    length := len(l)\n    if length%2 == 0\
    \ {\n        return l[(length-1)/2]\n    } else {\n        return (l[length/2]\
    \ + l[length/2-1]) / 2\n    }\n}\n", "    if len(l) == 0 {\n        return 0.0\n\
    \    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n/2] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n      \
    \  return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n \
    \       return l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    if\
    \ len(l) == 0 {\n        return math.NaN()\n    }\n    sort.Sort(l)\n    length\
    \ := len(l)\n    middle := length / 2\n    if length%2 == 0 {\n        return\
    \ l[middle]\n    }\n    return (l[middle-1] + l[middle]) / 2\n}\n", "    if len(l)\
    \ == 0 {\n        return 0.0\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n\
    \    n := len(l)\n    middle := n / 2\n    if n % 2 == 0 {\n        return l[middle]\n\
    \    } else {\n        return (l[middle-1] + l[middle]) / 2\n    }\n}\n", "  \
    \  if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n\
    \    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2])\
    \ / 2\n}\n", "    if len(l) == 0 {\n        return math.NaN()\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n-1] + l[n/2]) / 2\n}\n", "    length := len(l)\n    if length%2 == 0 {\n\
    \        return l[(length-1)/2]\n    }\n    middle := length/2\n    return l[middle]\n\
    }\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n   \
    \ n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n-1]\
    \ + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n % 2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n   \
    \ }\n    sort.Sort(l)\n    n := len(l)\n    if n % 2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n/2] + l[n/2 - 1]) / 2\n}\n", "    length := len(l)\n  \
    \  if length%2 == 0 {\n        return l[(length-1)/2]\n    }\n    return ((l[length-1]\
    \ + l[length/2]) / 2)\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n    length := len(l)\n    if length%2\
    \ == 0 {\n        return l[(length-1)/2]\n    }\n    return (l[(length-1)/2] +\
    \ l[length/2]) / 2.0\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n\
    \    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n/2] + l[n/2 - 1]) / 2\n}\n", "    if len(l) == 0 {\n  \
    \      return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n % 2 == 0\
    \ {\n        return l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", " \
    \   if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n\
    \    if n%2 == 0 {\n        return l[n/2]\n    }\n    return (l[n/2] + l[n/2])\
    \ / 2.0\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n/2] + l[n/2 - 1]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n\
    \    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n      \
    \  return math.NaN()\n    }\n    sort.Ints(l)\n    length := len(l)\n    if length%2\
    \ == 0 {\n        return l[(length-1)/2]\n    }\n    return (l[length/2] + l[length/2-1])\
    \ / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(sort.IntSlice(l))\n\
    \    n := len(l)\n    if n % 2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n        return math.NaN()\n\
    \    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n/2] + l[n/2-1]) / 2\n}\n", "    if len(l) == 0 {\n    \
    \    return math.NaN()\n    }\n    sort.Sort(l)\n    return l[len(l)/2]\n}\n",
  "    if len(l) == 0 {\n        return math.NaN()\n    }\n    sort.Ints(l)\n    n\
    \ := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    middle := n/2\n\
    \    return float64(l[middle-1] + l[middle])/2\n}\n", "    if len(l) == 0 {\n\
    \        return math.NaN()\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2\
    \ == 0 {\n        return l[n/2]\n    }\n    middle := n / 2\n    return l[middle]\n\
    }\n", "    length := len(l)\n    if length%2 == 0 {\n        return l[(length-1)/2]\n\
    \    }\n    middle := length/2\n    return l[middle]\n}\n", "    if len(l) ==\
    \ 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    middle\
    \ := n / 2\n    if n % 2 == 0 {\n        return l[middle]\n    }\n    return (l[middle-1]\
    \ + l[middle]) / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n \
    \   sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n/2] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n      \
    \  return float64(0)\n    }\n    sort.Ints(l)\n    n := len(l)\n    middle :=\
    \ n / 2\n    if n % 2 == 0 {\n        return l[middle]\n    }\n    return (l[middle-1]\
    \ + l[middle]) / 2\n}\n", "    length := len(l)\n    if length%2 == 0 {\n    \
    \    return l[(length-1)/2]\n    }\n    middle := length/2\n    left := l[0:middle]\n\
    \    right := l[middle:]\n    leftMedian := median(left)\n    rightMedian := median(right)\n\
    \    if leftMedian > rightMedian {\n        return left\n    } else {\n      \
    \  return right\n    }\n}\n", "    if len(l) == 0 {\n        return float64(0)\n\
    \    }\n    sort.Sort(l)\n    n := len(l)\n    if n % 2 == 0 {\n        return\
    \ l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n\
    \        return math.NaN()\n    }\n    sort.Sort(l)\n    return l[len(l)/2]\n\
    }\n", "    if len(l) == 0 {\n        return float64(0)\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n/2] + l[n/2 - 1]) / 2\n}\n", "    if len(l) == 0 {\n        return float64(0)\n\
    \    }\n    sort.Sort(l)\n    length := len(l)\n    if length%2 == 0 {\n     \
    \   return l[(length-1)/2]\n    }\n    return (l[(length-1)/2] + l[(length-1)/2])\
    \ / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n\
    \    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n    }\n    return\
    \ (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n        return math.NaN()\n\
    \    }\n    sort.Sort(l)\n    n := len(l)\n    if n % 2 == 0 {\n        return\
    \ l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n}\n", "    if len(l) == 0 {\n\
    \        return 0.0\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n  \
    \  return l[len(l)/2]\n}\n", "    length := len(l)\n    if length%2 == 0 {\n \
    \       return l[(length-1)/2]\n    }\n    middle := length/2\n    return l[middle]\n\
    }\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n   \
    \ length := len(l)\n    if length%2 == 0 {\n        return l[(length-1)/2]\n \
    \   }\n    return (l[length-1] + l[length/2]) / 2\n}\n", "    if len(l) == 0 {\n\
    \        return 0.0\n    }\n    sort.Sort(l)\n    length := len(l)\n    if length%2\
    \ == 0 {\n        return l[(length-1)/2]\n    }\n    middle := length/2\n    return\
    \ (l[middle-1] + l[middle])/2\n}\n", "    if len(l) == 0 {\n        return math.NaN()\n\
    \    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n        return l[n/2]\n\
    \    }\n    return (l[n/2] + l[n/2 - 1]) / 2\n}\n", "    if len(l) == 0 {\n  \
    \      return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n    if n%2 == 0 {\n\
    \        return l[n/2]\n    }\n    return (l[n-1] + l[n/2]) / 2\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
