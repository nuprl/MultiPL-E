language: go_test.go
name: HumanEval_109_move_one_ball
results:
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return len(arr) == 0 && len(arr)\
    \ == shift\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpym8egg3l_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpym8egg3l_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return len(arr) == shift\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpmmi6gy82_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpmmi6gy82_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0]\
    \ = arr[shift]\n    \n    return move_one_ball(arr[1:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpo2zl_13p_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpo2zl_13p_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return len(arr) == shift\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpmmi6gy82_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpmmi6gy82_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\
    \ == true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpbw4rcl0l_test.go:27 +0x72 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbw4rcl0l_test.go:38 +0x54 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbw4rcl0l_test.go:38 +0x54 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbw4rcl0l_test.go:38 +0x54 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbw4rcl0l_test.go:38 +0x54 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbw4rcl0l_test.go:38 +0x54 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbw4rcl0l_test.go:38 +0x54 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbw4rcl0l_test.go:38 +0x54 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbw4rcl0l_test.go:38 +0x54 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbw4rcl0l_test.go:38 +0x54 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074340
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpshjb8p2d_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpshjb8p2d_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := append(arr, 0)\n    \n    for i := 0; i < len(arr); i++ {\n        for\
    \ j := 0; j < len(arr); j++ {\n            if arr[i] > arr[j] {\n            \
    \    arr[i], arr[j] = arr[j], arr[i]\n            }\n        }\n    }\n    \n\
    \    return arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3en4o_3q_test.go:32:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return arr[0] == 0\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpbo9ijc1g_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpbo9ijc1g_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)-1]\n    \n    for i := 0; i < len(arr); i++ {\n      \
    \  if arr[i] > arr[i+1] {\n            return false\n        }\n    }\n    \n\
    \    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6h8wbcqu_test.go:32:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpcjuikt6j_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpcjuikt6j_test.go:60\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  sorted, _ := sortArray(arr)\n    \n    return sorted == arr\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk56kstnc_test.go:32:18: undefined: sortArray

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    shift\
    \ += 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    return arr[0] != arr[shift]\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpfizc3itj_test.go:68: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpfizc3itj_test.go:68:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpcjuikt6j_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpcjuikt6j_test.go:60\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)-1]\n    \n    for i := 0; i < len(arr); i++ {\n      \
    \  for j := 0; j < len(arr)-i-1; j++ {\n            arr[j], arr[j+1] = arr[j+1],\
    \ arr[j]\n        }\n    }\n    \n    return arr == arr[:len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1sn0rhwg_test.go:32:9: no new variables on left side of :=

    /tmp/tmp1sn0rhwg_test.go:40:12: invalid operation: arr == arr[:len(arr) - 1] (slice
    can only be compared to nil)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n    }\n    \n    for i := 0; i < shift; i++ {\n       \
    \ arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n    }\n    \n    return arr[0]\
    \ == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpci906efj_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpci906efj_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return arr[0] == 0\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpbo9ijc1g_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpbo9ijc1g_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n    }\n    \n    if arr[0] != 0 {\n        return false\n\
    \    }\n    \n    for i := 0; i < shift; i++ {\n        arr[i] = arr[i]>>1\n \
    \   }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0me1fzwi_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0me1fzwi_test.go:69:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp_q17a7ei_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp_q17a7ei_test.go:60\
    \ +0x532\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift := len(arr) - 1\n\
    \    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < arr[shift] {\n\
    \            shift += 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ false\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9ox4s8ug_test.go:44:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074338
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)]\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i],\
    \ arr[len(arr)-i-1] = arr[len(arr)-i-1], arr[i]\n    }\n    \n    return false\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2rsb09ux_test.go:32:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ i == len(arr) && j == 0 && arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpv_ob9lxi_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpv_ob9lxi_test.go:57\
    \ +0x4d2\ntesting.tRunner(0xc0001a01a0, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  sorted, _ := sort.Ints(arr)\n    \n    if sorted == arr {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[i+1] {\n            arr[i], arr[i+1] = arr[i+1],\
    \ arr[i]\n            shift -= 1\n        }\n    }\n    \n    arr[0], arr[shift]\
    \ = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpelgb8m8g_test.go:32:18: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpshjb8p2d_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpshjb8p2d_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpcjuikt6j_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpcjuikt6j_test.go:60\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift--\n        }\n    }\n    \n    return arr == move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi6jhp9jw_test.go:41:19: invalid operation: arr == move_one_ball(arr) (mismatched
    types []int and bool)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  n := len(arr)\n    \n    // We will keep track of the number of right shift\
    \ operations performed\n    // till now\n    shift := 0\n    \n    // We will\
    \ keep track of the number of elements in the array which we\n    // have already\
    \ visited\n    visited := make([]bool, n)\n    \n    // We will keep track of\
    \ the number of elements in the array which we\n    // have already visited\n\
    \    visited[0] := true\n    \n    // We will keep track of the number of elements\
    \ in the array which we\n    // have already visited\n    visited[n-1] := true\n\
    \    \n    // We will keep track of the number of elements in the array which\
    \ we\n    // have already visited\n    visited[0] := true\n    \n    // We will\
    \ keep track of the number of elements in the array which we\n    // have already\
    \ visited\n    visited[n-1] := true\n    \n    // We will keep track of the number\
    \ of elements in the array which we\n    // have already visited\n    visited[0]\
    \ := true\n    \n    // We will keep track of the number of elements in the array\
    \ which we\n    // have already visited\n    visited[n-1] := true\n    \n    //\
    \ We will keep track of the number of elements in the array which we\n    // have\
    \ already visited\n    visited[0] := true\n    \n    // We will keep track of\
    \ the number of elements in the array which we\n    // have already visited\n\
    \    visited[n-1] := true\n    \n    // We will keep track of the number of elements\
    \ in the array which we\n    // have already visited\n    visited[0] := true\n\
    \    \n    // We will keep track of the number of elements in the array which\
    \ we\n    // have already visited\n    visited[n-1] := true\n    \n    // We will\
    \ keep track of the number of elements in the array which we\n    // have already\
    \ visited\n    visited[0] := true\n    \n    // We will keep track of the number\
    \ of elements in the array which we\n    // have already visited\n    visited[n-1]\
    \ := true\n    \n    // We will keep track of the number of elements in the array\
    \ which we\n    // have already visited\n    visited[0] := true\n    \n    //\
    \ We will keep track of the number of elements in the array which we\n    // have\
    \ already visited\n    visited[n-1] := true\n    \n    // We will keep track of\
    \ the number of elements in the array which we\n    // have already visited\n\
    \    visited[0] := true\n    \n    // We \nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6qq58ppi_test.go:44:5: expected identifier on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074337
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)-1]\n    \n    for i := len(arr) - 1; i > 0; i-- {\n  \
    \      arr[i], arr[i-1] = arr[i-1], arr[i]\n    }\n    \n    return arr[0] ==\
    \ arr[len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5dpqvh_k_test.go:32:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i]\
    \ = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr)-1]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpa31x7v2m_test.go:27 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074341
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ i == len(arr) && j == 0 && arr[0] > arr[len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp7dz_hwqw_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp7dz_hwqw_test.go:57\
    \ +0x4d2\ntesting.tRunner(0xc0001924e0, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074341
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0]\
    \ = arr[shift]\n    \n    return move_one_ball(arr[1:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpo2zl_13p_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpo2zl_13p_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift := len(arr) - 1\n\
    \    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < arr[shift] {\n\
    \            shift += 1\n        }\n    }\n    \n    if shift < len(arr) {\n \
    \       return false\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpimy1t_4m_test.go:44:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift -= 1\n    \n    for\
    \ i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n            shift\
    \ -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return false\n   \
    \ }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr); i++ {\n       \
    \ if arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n \
    \   if shift > 0 {\n        return false\n    }\n    \n    shift -= 1\n    \n\
    \    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n     \
    \       shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift -=\
    \ 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8uht69nz_test.go:157:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i]\
    \ > arr[i-1] {\n            arr[i-1], arr[i] = arr[i], arr[i-1]\n        }\n \
    \   }\n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5j06irmp_test.go:32:5: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform N right shift operations.\n    // We will keep track\
    \ of the number of right shift operations performed.\n    // If we are performing\
    \ N right shift operations then we know that the\n    // array is non-decreasing.\n\
    \    var shiftCount int = 0\n    \n    // We will keep track of the last element\
    \ of the array.\n    // We will perform right shift operation on the last element\
    \ of the array\n    // and move it to the starting position in the array.\n  \
    \  // We will keep track of the starting position in the array.\n    var lastElement\
    \ int = 0\n    \n    // We will keep track of the starting position in the array.\n\
    \    var startingPosition int = 0\n    \n    // We will keep track of the number\
    \ of elements in the array.\n    var numberOfElements int = len(arr)\n    \n \
    \   // We will keep track of the number of elements in the array.\n    var numberOfElements2\
    \ int = len(arr)\n    \n    // We will keep track of the number of elements in\
    \ the array.\n    var numberOfElements3 int = len(arr)\n    \n    // We will keep\
    \ track of the number of elements in the array.\n    var numberOfElements4 int\
    \ = len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ array.\n    var numberOfElements5 int = len(arr)\n    \n    // We will keep\
    \ track of the number of elements in the array.\n    var numberOfElements6 int\
    \ = len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ array.\n    var numberOfElements7 int = len(arr)\n    \n    // We will keep\
    \ track of the number of elements in the array.\n    var numberOfElements8 int\
    \ = len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ array.\n    var numberOfElements9 int = len(arr)\n    \n    // We will keep\
    \ track of the number of elements in the array.\n    var numberOfElements10 int\
    \ = len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ array.\n    var numberOfElements11 int = len(arr)\n    \n    // We will keep\
    \ track of the number of elements in the array.\n    var numberOfElements12 int\
    \ = len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ array.\n    var numberOfElements13 int = len(arr)\n    \n    // We will keep\
    \ track of the number of elements in the array.\n    var numberOfElements14 int\
    \ = len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ array.\n    var numberOfElements15 int = len(arr)\n    \n    // We will keep\
    \ track of the number of elements in the array.\n    var numberOfElements16 int\
    \ = len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ array.\n    var numberOfElements17 int = len(arr)\n    \n    // \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbten6mxu_test.go:99:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift := len(arr) - 1\n\
    \    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < arr[shift] {\n\
    \            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ false\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyivikk05_test.go:44:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform N right shift operations.\n    // We will perform\
    \ N right shift operations until we reach the end of the array.\n    // We will\
    \ perform N right shift operations until we reach the end of the array.\n    //\
    \ We will perform N right shift operations until we reach the end of the array.\n\
    \    // We will perform N right shift operations until we reach the end of the\
    \ array.\n    // We will perform N right shift operations until we reach the end\
    \ of the array.\n    // We will perform N right shift operations until we reach\
    \ the end of the array.\n    // We will perform N right shift operations until\
    \ we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until we reach the end of the array.\n    // We will perform N right shift operations\
    \ until \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps571zozn_test.go:66:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed \n\
    \    // to achieve non-decreasing order\n    var rightShiftCount int = 0\n   \
    \ \n    // We will keep track of the number of elements in the array \n    //\
    \ that have been moved to the starting position\n    var movedElements int = 0\n\
    \    \n    // We will keep track of the number of elements in the array that have\
    \ \n    // been moved to the starting position\n    var movedElements2 int = 0\n\
    \    \n    // We will keep track of the number of elements in the array that have\
    \ \n    // been moved to the starting position\n    var movedElements3 int = 0\n\
    \    \n    // We will keep track of the number of elements in the array that have\
    \ \n    // been moved to the starting position\n    var movedElements4 int = 0\n\
    \    \n    // We will keep track of the number of elements in the array that have\
    \ \n    // been moved to the starting position\n    var movedElements5 int = 0\n\
    \    \n    // We will keep track of the number of elements in the array that have\
    \ \n    // been moved to the starting position\n    var movedElements6 int = 0\n\
    \    \n    // We will keep track of the number of elements in the array that have\
    \ \n    // been moved to the starting position\n    var movedElements7 int = 0\n\
    \    \n    // We will keep track of the number of elements in the array that have\
    \ \n    // been moved to the starting position\n    var movedElements8 int = 0\n\
    \    \n    // We will keep track of the number of elements in the array that have\
    \ \n    // been moved to the starting position\n    var movedElements9 int = 0\n\
    \    \n    // We will keep track of the number of elements in the array that have\
    \ \n    // been moved to the starting position\n    var movedElements10 int =\
    \ 0\n    \n    // We will keep track of the number of elements in the array that\
    \ have \n    // been moved to the starting position\n    var movedElements11 int\
    \ = 0\n    \n    // We will keep track of the number of elements in the array\
    \ that have \n    // been moved to the starting position\n    var movedElements12\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ that have \n    // been moved to the starting position\n    var movedElements13\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ that have \n    // been moved to the starting position\n    var movedElements14\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ that have \n    // been moved to the starting position\n    var movedElements15\
    \ int = 0\n    \n    // We will keep track of the number of element\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl3iwq5q4_test.go:97:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ i == len(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpuju555dl_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpuju555dl_test.go:57\
    \ +0x505\ntesting.tRunner(0xc000103380, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074341
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed\n \
    \   // and will keep track of the current position in the array i.e. the \n  \
    \  // last element of the array will be moved to the starting position in the\
    \ array\n    // i.e. 0th index\n    shift := 0\n    \n    // We will keep track\
    \ of the number of elements in the array and will \n    // keep track of the current\
    \ position in the array i.e. the 0th index\n    index := 0\n    \n    // We will\
    \ keep track of the number of elements in the array and will \n    // keep track\
    \ of the current position in the array i.e. the 0th index\n    size := len(arr)\n\
    \    \n    // We will keep track of the number of elements in the array and will\
    \ \n    // keep track of the current position in the array i.e. the 0th index\n\
    \    index := 0\n    \n    // We will keep track of the number of elements in\
    \ the array and will \n    // keep track of the current position in the array\
    \ i.e. the 0th index\n    size := len(arr)\n    \n    // We will keep track of\
    \ the number of elements in the array and will \n    // keep track of the current\
    \ position in the array i.e. the 0th index\n    index := 0\n    \n    // We will\
    \ keep track of the number of elements in the array and will \n    // keep track\
    \ of the current position in the array i.e. the 0th index\n    size := len(arr)\n\
    \    \n    // We will keep track of the number of elements in the array and will\
    \ \n    // keep track of the current position in the array i.e. the 0th index\n\
    \    index := 0\n    \n    // We will keep track of the number of elements in\
    \ the array and will \n    // keep track of the current position in the array\
    \ i.e. the 0th index\n    size := len(arr)\n    \n    // We will keep track of\
    \ the number of elements in the array and will \n    // keep track of the current\
    \ position in the array i.e. the 0th index\n    index := 0\n    \n    // We will\
    \ keep track of the number of elements in the array and will \n    // keep track\
    \ of the current position in the array i.e. the 0th index\n    size := len(arr)\n\
    \    \n    // We will keep track of the number of elements in the array and will\
    \ \n    // keep track of the current position in the array i.e. the 0th index\n\
    \    index := 0\n    \n    // We will keep track of the number of elements in\
    \ the array and will \n    // keep track of the current position in the array\
    \ i.e. the 0th index\n    size := len(arr)\n    \n    // We will keep track of\
    \ the number of elements in the array and will \n    // keep track of the current\
    \ position in the array i.e. the 0th index\n    index := 0\n    \n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy_y7kgjx_test.go:91:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ arr[0] == arr[j]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc0001c4000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc0001c4000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpu8iy7r_2_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpu8iy7r_2_test.go:57\
    \ +0x53f\ntesting.tRunner(0xc0001851e0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074341
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpshjb8p2d_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpshjb8p2d_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  n := len(arr)\n    \n    // We have already performed right shift operation\
    \ on the first element\n    // of the array i.e. arr[0]. Now we perform right\
    \ shift operation on the\n    // remaining elements of the array i.e. arr[1],\
    \ arr[2], ..., arr[n-1].\n    // We perform right shift operation on the remaining\
    \ elements of the array\n    // i.e. arr[1], arr[2], ..., arr[n-1]. \n    // We\
    \ perform right shift operation on the remaining elements of the array\n    //\
    \ i.e. arr[1], arr[2], ..., arr[n-1]. \n    // We perform right shift operation\
    \ on the remaining elements of the array\n    // i.e. arr[1], arr[2], ..., arr[n-1].\
    \ \n    // We perform right shift operation on the remaining elements of the array\n\
    \    // i.e. arr[1], arr[2], ..., arr[n-1]. \n    // We perform right shift operation\
    \ on the remaining elements of the array\n    // i.e. arr[1], arr[2], ..., arr[n-1].\
    \ \n    // We perform right shift operation on the remaining elements of the array\n\
    \    // i.e. arr[1], arr[2], ..., arr[n-1]. \n    // We perform right shift operation\
    \ on the remaining elements of the array\n    // i.e. arr[1], arr[2], ..., arr[n-1].\
    \ \n    // We perform right shift operation on the remaining elements of the array\n\
    \    // i.e. arr[1], arr[2], ..., arr[n-1]. \n    // We perform right shift operation\
    \ on the remaining elements of the array\n    // i.e. arr[1], arr[2], ..., arr[n-1].\
    \ \n    // We perform right shift operation on the remaining elements of the array\n\
    \    // i.e. arr[1], arr[2], ..., arr[n-1]. \n    // We perform right shift operation\
    \ on the remaining elements of the array\n    // i.e. arr[1], arr[2], ..., arr[n-1].\
    \ \n    // We perform right shift operation on the remaining elements of the array\n\
    \    // i.e. arr[1], arr[2], ..., arr[n-1]. \n    // We perform right shift operation\
    \ on the remaining elements of the array\n    // i.e. arr[1], arr[2], ..., arr[n-1].\
    \ \n    // We perform right shift operation on the remaining elements of the array\n\
    \    // i.e. arr[1], arr[2], ..., arr[n-1]. \n    // We perform right shift operation\
    \ on the remaining elements of the array\n    // i.e. arr[1], arr[2], ..., arr[n-1].\
    \ \n    // We perform right shift operation on the remaining elements of the array\n\
    \    // i.e. arr[1], arr[2], ..., arr[n-1]. \n    // We perform right shift operation\
    \ on the remaining elements of the array\n    // i.e. arr[1], arr[2], ..., arr[n-1].\
    \ \n    // We perform right shift operation on the remaining elements of the array\n\
    \    // i.e. arr[1], arr[2], ..., arr[n-1]. \n    // We perform right shift operation\
    \ on the remaining elements of the array\n    // i.e. arr[1], \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb1oded9x_test.go:75:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // The first element will be moved to 0th position\n    arr[0] = arr[len(arr)-1]\n\
    \    \n    // The last element will be moved to 1st position\n    arr[len(arr)-1]\
    \ = 0\n    \n    // The first element will be moved to last position\n    arr[len(arr)-1]\
    \ = arr[0]\n    \n    // The last element will be moved to 1st position\n    arr[0]\
    \ = arr[len(arr)-1]\n    \n    // The first element will be moved to last position\n\
    \    arr[len(arr)-1] = arr[0]\n    \n    // The last element will be moved to\
    \ 0th position\n    arr[0] = arr[len(arr)-1]\n    \n    // The first element will\
    \ be moved to last position\n    arr[len(arr)-1] = arr[0]\n    \n    // The last\
    \ element will be moved to 1st position\n    arr[0] = arr[len(arr)-1]\n    \n\
    \    // The first element will be moved to last position\n    arr[len(arr)-1]\
    \ = arr[0]\n    \n    // The last element will be moved to 0th position\n    arr[0]\
    \ = arr[len(arr)-1]\n    \n    // The first element will be moved to last position\n\
    \    arr[len(arr)-1] = arr[0]\n    \n    // The last element will be moved to\
    \ 1st position\n    arr[0] = arr[len(arr)-1]\n    \n    // The first element will\
    \ be moved to last position\n    arr[len(arr)-1] = arr[0]\n    \n    // The last\
    \ element will be moved to 0th position\n    arr[0] = arr[len(arr)-1]\n    \n\
    \    // The first element will be moved to last position\n    arr[len(arr)-1]\
    \ = arr[0]\n    \n    // The last element will be moved to 1st position\n    arr[0]\
    \ = arr[len(arr)-1]\n    \n    // The first element will be moved to last position\n\
    \    arr[len(arr)-1] = arr[0]\n    \n    // The last element will be moved to\
    \ 0th position\n    arr[0] = arr[len(arr)-1]\n    \n    // The first element will\
    \ be moved to last position\n    arr[len(arr)-1] = arr[0]\n    \n    // The last\
    \ element will be moved to 1st position\n    arr[0] = arr[len(arr)-1]\n    \n\
    \    // The first element will be moved to last position\n    arr[len(arr)-1]\
    \ = arr[0]\n    \n    // The last element will be moved to 1st position\n    arr[0]\
    \ = arr[len(arr)-1]\n    \n    // The first element will be moved to last position\n\
    \    arr[len(arr)-1] = arr[0]\n    \n    // The last element will be moved to\
    \ 0th position\n    arr[0] = arr[len(arr)-1]\n    \n    // The first element \n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphq75fpps_test.go:105:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift--\n        }\n    }\n    \n    return arr[0] == 0\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp79sf9sg__test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp79sf9sg__test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074341
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed.\n\
    \    // We will start by performing the right shift operation on the first element.\n\
    \    // We will keep track of the number of right shift operations performed.\n\
    \    // We will start by performing the right shift operation on the first element.\n\
    \    var right_shift_count = 0\n    \n    // We will keep track of the number\
    \ of right shift operations performed.\n    // We will start by performing the\
    \ right shift operation on the first element.\n    // We will keep track of the\
    \ number of right shift operations performed.\n    // We will start by performing\
    \ the right shift operation on the first element.\n    var right_shift_count =\
    \ 0\n    \n    // We will keep track of the number of right shift operations performed.\n\
    \    // We will start by performing the right shift operation on the first element.\n\
    \    // We will keep track of the number of right shift operations performed.\n\
    \    // We will start by performing the right shift operation on the first element.\n\
    \    var right_shift_count = 0\n    \n    // We will keep track of the number\
    \ of right shift operations performed.\n    // We will start by performing the\
    \ right shift operation on the first element.\n    // We will keep track of the\
    \ number of right shift operations performed.\n    // We will start by performing\
    \ the right shift operation on the first element.\n    var right_shift_count =\
    \ 0\n    \n    // We will keep track of the number of right shift operations performed.\n\
    \    // We will start by performing the right shift operation on the first element.\n\
    \    // We will keep track of the number of right shift operations performed.\n\
    \    // We will start by performing the right shift operation on the first element.\n\
    \    var right_shift_count = 0\n    \n    // We will keep track of the number\
    \ of right shift operations performed.\n    // We will start by performing the\
    \ right shift operation on the first element.\n    // We will keep track of the\
    \ number of right shift operations performed.\n    // We will start by performing\
    \ the right shift operation on the first element.\n    var right_shift_count =\
    \ 0\n    \n    // We will keep track of the number of right shift operations performed.\n\
    \    // We will start by performing the right shift operation on the first element.\n\
    \    // We will keep track of the number of right shift operations performed.\n\
    \    // We will start by performing the right shift operation on the first element.\n\
    \    var right_shift_count = 0\n    \n    // We will keep track of the number\
    \ of right shift operations performed.\n    // We will start by performing the\
    \ right shift operation on the first element.\n    // We will keep track of the\
    \ number of right shift operations performed.\n    // We will start by performing\
    \ the right shift operation on the first element.\n    var right_shift_count =\
    \ 0\n    \n    // We will keep track of the number of right shift operations performed.\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp_djzcr8_test.go:81:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpshjb8p2d_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpshjb8p2d_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ i == len(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpuju555dl_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpuju555dl_test.go:57\
    \ +0x505\ntesting.tRunner(0xc000103380, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074341
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift := len(arr) - 1\n\
    \    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < arr[shift] {\n\
    \            shift += 1\n        }\n    }\n    \n    if shift < len(arr) {\n \
    \       return false\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpimy1t_4m_test.go:44:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)-1]\n    \n    for i := len(arr) - 1; i > 0; i-- {\n  \
    \      if arr[i] > arr[i-1] {\n            arr[i], arr[i-1] = arr[i-1], arr[i]\n\
    \        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp95ne_0fo_test.go:32:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074341
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  n := len(arr)\n    \n    // We are going to perform n right shift operations\
    \ on the given array\n    // and check if we can achieve non-decreasing order\
    \ or not.\n    for i := n - 1; i > 0; i-- {\n        // We are going to perform\
    \ right shift operation on the given array\n        // and check if we can achieve\
    \ non-decreasing order or not.\n        if arr[i] > arr[i-1] {\n            //\
    \ If we can achieve non-decreasing order then return true.\n            return\
    \ true\n        }\n    }\n    // If we can not achieve non-decreasing order then\
    \ return false.\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp4iqx9a_a_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp4iqx9a_a_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074341
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return len(arr) == shift\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpmmi6gy82_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpmmi6gy82_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpn6_z5jxw_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpn6_z5jxw_test.go:57\
    \ +0x4d2\ntesting.tRunner(0xc0001924e0, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074341
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[i+1] {\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n     \
    \   }\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuawf4mex_test.go:32:5: shift declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074341
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ arr[0] == arr[j]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc0001c4000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc0001c4000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpu8iy7r_2_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpu8iy7r_2_test.go:57\
    \ +0x53f\ntesting.tRunner(0xc0001851e0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074341
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift := len(arr) - 1\n\
    \    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < arr[shift] {\n\
    \            shift += 1\n        }\n    }\n    \n    if shift < len(arr) {\n \
    \       return false\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpimy1t_4m_test.go:44:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else if i == j {\n            return true\n        }\n    }\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpoq3y96lq_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpoq3y96lq_test.go:55\
    \ +0x4e5\ntesting.tRunner(0xc0001a0340, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074341
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmp0v3xhvxc_test.go:27 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmp0v3xhvxc_test.go:38 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmp0v3xhvxc_test.go:38\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmp0v3xhvxc_test.go:38 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmp0v3xhvxc_test.go:38 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmp0v3xhvxc_test.go:38\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmp0v3xhvxc_test.go:38 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmp0v3xhvxc_test.go:38 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmp0v3xhvxc_test.go:38\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmp0v3xhvxc_test.go:38 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmp0v3xhvxc_test.go:38 +0xb7 fp="
  timestamp: 1660074342
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation on arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    arr[0] = arr[1]\n    \n    // We are going to perform\
    \ right shift operation on arr[1]\n    // arr[1] will be moved to arr[2]\n   \
    \ arr[1] = arr[2]\n    \n    // We are going to perform right shift operation\
    \ on arr[2]\n    // arr[2] will be moved to arr[3]\n    arr[2] = arr[3]\n    \n\
    \    // We are going to perform right shift operation on arr[3]\n    // arr[3]\
    \ will be moved to arr[0]\n    arr[3] = arr[0]\n    \n    // We are going to perform\
    \ right shift operation on arr[0]\n    // arr[0] will be moved to arr[1]\n   \
    \ arr[0] = arr[1]\n    \n    // We are going to perform right shift operation\
    \ on arr[1]\n    // arr[1] will be moved to arr[2]\n    arr[1] = arr[2]\n    \n\
    \    // We are going to perform right shift operation on arr[2]\n    // arr[2]\
    \ will be moved to arr[3]\n    arr[2] = arr[3]\n    \n    // We are going to perform\
    \ right shift operation on arr[3]\n    // arr[3] will be moved to arr[0]\n   \
    \ arr[3] = arr[0]\n    \n    // We are going to perform right shift operation\
    \ on arr[0]\n    // arr[0] will be moved to arr[1]\n    arr[0] = arr[1]\n    \n\
    \    // We are going to perform right shift operation on arr[1]\n    // arr[1]\
    \ will be moved to arr[2]\n    arr[1] = arr[2]\n    \n    // We are going to perform\
    \ right shift operation on arr[2]\n    // arr[2] will be moved to arr[3]\n   \
    \ arr[2] = arr[3]\n    \n    // We are going to perform right shift operation\
    \ on arr[3]\n    // arr[3] will be moved to arr[0]\n    arr[3] = arr[0]\n    \n\
    \    // We are going to perform right shift operation on arr[0]\n    // arr[0]\
    \ will be moved to arr[1]\n    arr[0] = arr[1]\n    \n    // We are going to perform\
    \ right shift operation on arr[1]\n    // arr[1] will be moved to arr[2]\n   \
    \ arr[1] = arr[2]\n    \n    // We are going to perform right shift operation\
    \ on arr[2]\n    // arr[2] will be moved to arr[3]\n    arr[2] = arr[3]\n    \n\
    \    // We are going to perform right shift operation on arr[3]\n    // arr[3]\
    \ will be moved to arr[0]\n    arr[3] = arr[0]\n    \n    // We are going to perform\
    \ right shift operation on arr[0]\n    // arr[0] will be moved to arr[1]\n   \
    \ arr[0] = arr[1]\n    \n    // We are going to perform right shift \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_z2iytp4_test.go:101:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074341
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpshjb8p2d_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpshjb8p2d_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i]\
    \ = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr) - 1]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpuiy2zs6n_test.go:27 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074343
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpshjb8p2d_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpshjb8p2d_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp_q17a7ei_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp_q17a7ei_test.go:60\
    \ +0x532\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n    }\n\
    \    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpbbjzhj89_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpbbjzhj89_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074342
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  sorted, _ := sort_arr(arr)\n    \n    return is_sorted(sorted)\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7t_6ore6_test.go:32:18: undefined: sort_arr

    /tmp/tmp7t_6ore6_test.go:34:12: undefined: is_sorted

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return len(arr) == shift\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpmmi6gy82_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpmmi6gy82_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpshjb8p2d_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpshjb8p2d_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpshjb8p2d_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpshjb8p2d_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpwde0_um__test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpwde0_um__test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        shift -= 1\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp763sptmf_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp763sptmf_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074343
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := make([]int, len(arr))\n    \n    for i := 0; i < len(arr); i++ {\n \
    \       arr[i] = arr[i]\n    }\n    \n    arr[len(arr)-1] = arr[0]\n    \n   \
    \ for i := len(arr) - 2; i >= 0; i-- {\n        arr[i] = arr[i+1]\n    }\n   \
    \ \n    for i := 0; i < len(arr); i++ {\n        arr[i] = arr[i]\n    }\n    \n\
    \    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4ah70yj0_test.go:32:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpcjuikt6j_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpcjuikt6j_test.go:60\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[i+1] {\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n     \
    \       shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ move_one_ball(arr[:shift])\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball({0xc0000c4640?, 0xc0000f8f88?,\
    \ 0x4b3193?})\n\t/tmp/tmpd1e0xion_test.go:35 +0xa8\ncommand-line-arguments_test.TestMove_One_Ball(0x0?)\n\
    \t/tmp/tmpd1e0xion_test.go:55 +0xa8\ntesting.tRunner(0xc0001a01a0, 0x527f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074343
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  sorted, err := sortNonDecreasing(arr)\n    if err != nil {\n        return\
    \ false\n    }\n    \n    return sorted == arr\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzegnn4t7_test.go:32:20: undefined: sortNonDecreasing

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>(shift-1)\n        shift -= 1\n    }\n\
    \    \n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: negative shift\
    \ amount [recovered]\n\tpanic: runtime error: negative shift amount\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x5028a0, 0x5f1990})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5028a0, 0x5f1990})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpyeku6557_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpyeku6557_test.go:50\
    \ +0x4db\ntesting.tRunner(0xc000192680, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074343
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := make([]int, len(arr))\n    \n    for i := 0; i < len(arr); i++ {\n \
    \       arr[i] = arr[i]\n    }\n    \n    for i := 0; i < len(arr); i++ {\n  \
    \      arr[i] = arr[i]>>1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n\
    \        arr[i] = arr[i]<<1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n\
    \        arr[i] = arr[i]+1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n\
    \        arr[i] = arr[i]-1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n\
    \        if arr[i] != 0 {\n            return false\n        }\n    }\n    \n\
    \    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmiugb7al_test.go:32:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // Initialize a variable 'count' to store the number of right shift operations\n\
    \    // performed on the given array. Initialize it to zero.\n    var count int\
    \ = 0\n    \n    // Perform a right shift operation on the given array 'arr' by\
    \ one position\n    // and increment the count variable by 1.\n    arr = append(arr,\
    \ 0)\n    count++\n    \n    // Perform a right shift operation on the given array\
    \ 'arr' by one position\n    // and increment the count variable by 1.\n    arr\
    \ = append(arr, 0)\n    count++\n    \n    // Perform a right shift operation\
    \ on the given array 'arr' by one position\n    // and increment the count variable\
    \ by 1.\n    arr = append(arr, 0)\n    count++\n    \n    // Perform a right shift\
    \ operation on the given array 'arr' by one position\n    // and increment the\
    \ count variable by 1.\n    arr = append(arr, 0)\n    count++\n    \n    // Perform\
    \ a right shift operation on the given array 'arr' by one position\n    // and\
    \ increment the count variable by 1.\n    arr = append(arr, 0)\n    count++\n\
    \    \n    // Perform a right shift operation on the given array 'arr' by one\
    \ position\n    // and increment the count variable by 1.\n    arr = append(arr,\
    \ 0)\n    count++\n    \n    // Perform a right shift operation on the given array\
    \ 'arr' by one position\n    // and increment the count variable by 1.\n    arr\
    \ = append(arr, 0)\n    count++\n    \n    // Perform a right shift operation\
    \ on the given array 'arr' by one position\n    // and increment the count variable\
    \ by 1.\n    arr = append(arr, 0)\n    count++\n    \n    // Perform a right shift\
    \ operation on the given array 'arr' by one position\n    // and increment the\
    \ count variable by 1.\n    arr = append(arr, 0)\n    count++\n    \n    // Perform\
    \ a right shift operation on the given array 'arr' by one position\n    // and\
    \ increment the count variable by 1.\n    arr = append(arr, 0)\n    count++\n\
    \    \n    // Perform a right shift operation on the given array 'arr' by one\
    \ position\n    // and increment the count variable by 1.\n    arr = append(arr,\
    \ 0)\n    count++\n    \n    // Perform a right shift operation on the given array\
    \ 'arr' by one position\n    // and increment the count variable by 1.\n    arr\
    \ = append(arr, 0)\n    count++\n    \n    // Perform a right shift operation\
    \ on the given array 'arr' by one position\n    // and increment the count variable\
    \ by 1.\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp69pdzqm8_test.go:99:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed.\n\
    \    var shiftCount int = 0\n    \n    // We will keep track of the number of\
    \ elements in the array which are\n    // greater than the previous element.\n\
    \    var greaterCount int = 0\n    \n    // We will keep track of the number of\
    \ elements in the array which are\n    // less than the previous element.\n  \
    \  var lessCount int = 0\n    \n    // We will keep track of the number of elements\
    \ in the array which are\n    // equal to the previous element.\n    var equalCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // greater than or equal to the previous element.\n    var greaterEqualCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // less than or equal to the previous element.\n    var lessEqualCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // greater than or equal to the previous element.\n    var greaterEqualLessCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // less than or equal to the previous element.\n    var lessEqualGreaterCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // greater than or equal to the previous element.\n    var greaterEqualLessEqualCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // less than or equal to the previous element.\n    var lessEqualGreaterEqualCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // greater than or equal to the previous element.\n    var greaterEqualLessEqualGreaterCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // less than or equal to the previous element.\n    var lessEqualGreaterEqualGreaterCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // greater than or equal to the previous element.\n    var greaterEqualLessEqualGreaterEqualCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // less than or equal to the previous element.\n    var lessEqualGreaterEqualGreaterEqualCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // greater than or equal to the previous element.\n    var greaterEqualLessEqualGreaterEqualGreaterCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // less than or equal to the previous element.\n    var lessEqualGreaterEqualGreaterEqualGreaterCount\
    \ int = 0\n    \n    // We will keep track of the number of element\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprnlasrr3_test.go:96:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0]\
    \ = arr[shift]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpukqhucfq_test.go:27 +0xa6 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef706\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpukqhucfq_test.go:42 +0x71 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d1\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpukqhucfq_test.go:42 +0x71 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d1\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpukqhucfq_test.go:42 +0x71 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d1\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpukqhucfq_test.go:42 +0x71 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d1\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpukqhucfq_test.go:42 +0x71 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d1\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpukqhucfq_test.go:42 +0x71 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d1\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpukqhucfq_test.go:42 +0x71 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d1\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpukqhucfq_test.go:42 +0x71 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d1\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpukqhucfq_test.go:42 +0x71 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d1\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074344
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We have two pointers i and j which point to the first and last element\n\
    \    // of the given array. Initially i and j are pointing to arr[0] and arr[N-1].\n\
    \    // Initially i and j are pointing to arr[0] and arr[N-1].\n    i := 0\n \
    \   j := len(arr) - 1\n    \n    // We have two variables left and right which\
    \ keep track of the number\n    // of left shift operations and right shift operations.\n\
    \    left := 0\n    right := 0\n    \n    // We have two variables left and right\
    \ which keep track of the number\n    // of left shift operations and right shift\
    \ operations.\n    left := 0\n    right := 0\n    \n    // We keep track of the\
    \ number of left shift operations and right shift\n    // operations.\n    left\
    \ := 0\n    right := 0\n    \n    // We keep track of the number of left shift\
    \ operations and right shift\n    // operations.\n    left := 0\n    right :=\
    \ 0\n    \n    // We keep track of the number of left shift operations and right\
    \ shift\n    // operations.\n    left := 0\n    right := 0\n    \n    // We keep\
    \ track of the number of left shift operations and right shift\n    // operations.\n\
    \    left := 0\n    right := 0\n    \n    // We keep track of the number of left\
    \ shift operations and right shift\n    // operations.\n    left := 0\n    right\
    \ := 0\n    \n    // We keep track of the number of left shift operations and\
    \ right shift\n    // operations.\n    left := 0\n    right := 0\n    \n    //\
    \ We keep track of the number of left shift operations and right shift\n    //\
    \ operations.\n    left := 0\n    right := 0\n    \n    // We keep track of the\
    \ number of left shift operations and right shift\n    // operations.\n    left\
    \ := 0\n    right := 0\n    \n    // We keep track of the number of left shift\
    \ operations and right shift\n    // operations.\n    left := 0\n    right :=\
    \ 0\n    \n    // We keep track of the number of left shift operations and right\
    \ shift\n    // operations.\n    left := 0\n    right := 0\n    \n    // We keep\
    \ track of the number of left shift operations and right shift\n    // operations.\n\
    \    left := 0\n    right := 0\n    \n    // We keep track of the number of left\
    \ shift operations and right shift\n    // operations.\n    left := 0\n    right\
    \ := 0\n    \n    // We keep track of the number of left shift operations and\
    \ right shift\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoz3iddow_test.go:109:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    shift\
    \ += 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if arr[0] != arr[shift]\
    \ {\n        return false\n    }\n    \n    return move_one_ball(arr[1:])\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp9n5yhy0e_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp9n5yhy0e_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074343
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpcjuikt6j_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpcjuikt6j_test.go:60\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := append(arr, 0)\n    \n    i := 0\n    for i < len(arr) {\n        arr[i]\
    \ = arr[i] + 1\n        \n        if arr[i] > len(arr) {\n            arr[i] =\
    \ 0\n            arr[i-1] = arr[i-1] + 1\n        }\n        \n        i++\n \
    \   }\n    \n    return arr[0] == len(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiqt8ry09_test.go:32:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074343
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n        \n       \
    \ if i == shift {\n            arr[i] = 0\n            shift -= 1\n        }\n\
    \    }\n    \n    return len(arr) == shift\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpwha04vc5_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpwha04vc5_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074343
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of how many times we perform right shift operation\n\
    \    // to determine if we can get non-decreasing order or not.\n    var count\
    \ int = 0\n    \n    // We will keep track of the last element of the array and\
    \ will perform\n    // right shift operation on it every time we perform right\
    \ shift operation.\n    var lastElement int = 0\n    \n    // We will keep track\
    \ of how many times we perform right shift operation\n    // to determine if we\
    \ can get non-decreasing order or not.\n    var count2 int = 0\n    \n    // We\
    \ will keep track of the last element of the array and will perform\n    // right\
    \ shift operation on it every time we perform right shift operation.\n    var\
    \ lastElement2 int = 0\n    \n    // We will keep track of how many times we perform\
    \ right shift operation\n    // to determine if we can get non-decreasing order\
    \ or not.\n    var count3 int = 0\n    \n    // We will keep track of the last\
    \ element of the array and will perform\n    // right shift operation on it every\
    \ time we perform right shift operation.\n    var lastElement3 int = 0\n    \n\
    \    // We will keep track of how many times we perform right shift operation\n\
    \    // to determine if we can get non-decreasing order or not.\n    var count4\
    \ int = 0\n    \n    // We will keep track of the last element of the array and\
    \ will perform\n    // right shift operation on it every time we perform right\
    \ shift operation.\n    var lastElement4 int = 0\n    \n    // We will keep track\
    \ of how many times we perform right shift operation\n    // to determine if we\
    \ can get non-decreasing order or not.\n    var count5 int = 0\n    \n    // We\
    \ will keep track of the last element of the array and will perform\n    // right\
    \ shift operation on it every time we perform right shift operation.\n    var\
    \ lastElement5 int = 0\n    \n    // We will keep track of how many times we perform\
    \ right shift operation\n    // to determine if we can get non-decreasing order\
    \ or not.\n    var count6 int = 0\n    \n    // We will keep track of the last\
    \ element of the array and will perform\n    // right shift operation on it every\
    \ time we perform right shift operation.\n    var lastElement6 int = 0\n    \n\
    \    // We will keep track of how many times we perform right shift operation\n\
    \    // to determine if we can get non-decreasing order or not.\n    var count7\
    \ int = 0\n    \n    // We will keep track of the last element of the array and\
    \ will perform\n    // right shift operation on it every time we perform right\
    \ shift operation.\n    var lastElement7 int = 0\n    \n    // We will keep track\
    \ of how many times we perform right shift operation\n    // to determine if we\
    \ can get \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptfkw767h_test.go:90:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074343
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := append(arr, 0)\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[i+1] {\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n     \
    \   }\n    }\n    \n    return arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd8i888x9_test.go:32:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074343
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0]\
    \ = arr[shift]\n    \n    return move_one_ball(arr[1:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpo2zl_13p_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpo2zl_13p_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpcjuikt6j_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpcjuikt6j_test.go:60\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpshjb8p2d_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpshjb8p2d_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0]\
    \ = arr[shift]\n    \n    return move_one_ball(arr[1:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpo2zl_13p_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpo2zl_13p_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift -= 1\n    \n    for\
    \ i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n            shift\
    \ -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return false\n   \
    \ }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr); i++ {\n       \
    \ if arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n \
    \   if shift > 0 {\n        return false\n    }\n    \n    shift -= 1\n    \n\
    \    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n     \
    \       shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift -=\
    \ 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8uht69nz_test.go:157:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpcjuikt6j_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpcjuikt6j_test.go:60\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ i == len(arr) && j == -1\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpc36qamto_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpc36qamto_test.go:57\
    \ +0x4d2\ntesting.tRunner(0xc0001a0340, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074344
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i] >> 1\n        arr[i] = arr[i] << 1\n        arr[i] = arr[i] >> 1\n\
    \    }\n    \n    for i := 0; i < shift; i++ {\n        arr[i] = arr[i] >> 1\n\
    \    }\n    \n    return arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__3\
    \ (0.00s)\n        tmpc_mpx07a_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074344
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return arr == move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph8p2425q_test.go:41:19: invalid operation: arr == move_one_ball(arr) (mismatched
    types []int and bool)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074343
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  n := len(arr)\n    \n    // We have already performed right shift operation\n\
    \    // So we only need to check whether we can perform left shift operation or\
    \ not\n    // If we can perform left shift operation then we can perform right\
    \ shift operation\n    // and hence we can get non-decreasing order\n    if n\
    \ == 1 {\n        return true\n    }\n    \n    // We have already performed left\
    \ shift operation\n    // So we only need to check whether we can perform right\
    \ shift operation or not\n    // If we can perform right shift operation then\
    \ we can perform left shift operation\n    // and hence we can get non-decreasing\
    \ order\n    if n == 2 {\n        return true\n    }\n    \n    // We have already\
    \ performed right shift operation\n    // So we only need to check whether we\
    \ can perform left shift operation or not\n    // If we can perform left shift\
    \ operation then we can perform right shift operation\n    // and hence we can\
    \ get non-decreasing order\n    if n == 3 {\n        return true\n    }\n    \n\
    \    // We have already performed left shift operation\n    // So we only need\
    \ to check whether we can perform right shift operation or not\n    // If we can\
    \ perform right shift operation then we can perform left shift operation\n   \
    \ // and hence we can get non-decreasing order\n    if n == 4 {\n        return\
    \ true\n    }\n    \n    // We have already performed right shift operation\n\
    \    // So we only need to check whether we can perform left shift operation or\
    \ not\n    // If we can perform left shift operation then we can perform right\
    \ shift operation\n    // and hence we can get non-decreasing order\n    if n\
    \ == 5 {\n        return true\n    }\n    \n    // We have already performed left\
    \ shift operation\n    // So we only need to check whether we can perform right\
    \ shift operation or not\n    // If we can perform right shift operation then\
    \ we can perform left shift operation\n    // and hence we can get non-decreasing\
    \ order\n    if n == 6 {\n        return true\n    }\n    \n    // We have already\
    \ performed right shift operation\n    // So we only need to check whether we\
    \ can perform left shift operation or not\n    // If we can perform left shift\
    \ operation then we can perform right shift operation\n    // and hence we can\
    \ get non-decreasing order\n    if n == 7 {\n        return true\n    }\n    \n\
    \    // We have already performed left shift operation\n    // So we only need\
    \ to check whether we can perform right shift operation or not\n    // If we can\
    \ perform right shift operation then we can perform left shift operation\n   \
    \ // and hence we can get non-decreasing order\n    if n == 8 {\n        return\
    \ true\n    }\n    \n    // We have already performed right shift operation\n\
    \    // So we only need to check whether \nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpot6m9ej4_test.go:100:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074343
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwn_ifilc_test.go:96:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074343
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpshjb8p2d_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpshjb8p2d_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  n := len(arr)\n    \n    // We will keep track of the number of right shift\
    \ operations performed.\n    // We will perform right shift operations until we\
    \ reach the end of the\n    // array and we perform one more right shift operation.\n\
    \    shiftCount := 0\n    \n    // We will keep track of the number of elements\
    \ in the array that we\n    // are going to move.\n    moveCount := 0\n    \n\
    \    // We will keep track of the index of the element that we are going to move.\n\
    \    index := 0\n    \n    // We will keep track of the element that we are going\
    \ to move to the \n    // starting position.\n    element := arr[0]\n    \n  \
    \  // We will keep track of the number of elements in the array that we\n    //\
    \ are going to move.\n    moveCount := 0\n    \n    // We will keep track of the\
    \ index of the element that we are going to move.\n    index := 0\n    \n    //\
    \ We will keep track of the element that we are going to move to the \n    //\
    \ starting position.\n    element := arr[0]\n    \n    // We will keep track of\
    \ the number of elements in the array that we\n    // are going to move.\n   \
    \ moveCount := 0\n    \n    // We will keep track of the index of the element\
    \ that we are going to move.\n    index := 0\n    \n    // We will keep track\
    \ of the element that we are going to move to the \n    // starting position.\n\
    \    element := arr[0]\n    \n    // We will keep track of the number of elements\
    \ in the array that we\n    // are going to move.\n    moveCount := 0\n    \n\
    \    // We will keep track of the index of the element that we are going to move.\n\
    \    index := 0\n    \n    // We will keep track of the element that we are going\
    \ to move to the \n    // starting position.\n    element := arr[0]\n    \n  \
    \  // We will keep track of the number of elements in the array that we\n    //\
    \ are going to move.\n    moveCount := 0\n    \n    // We will keep track of the\
    \ index of the element that we are going to move.\n    index := 0\n    \n    //\
    \ We will keep track of the element that we are going to move to the \n    //\
    \ starting position.\n    element := arr[0]\n    \n    // We will keep track of\
    \ the number of elements in the array that we\n    // are going to move.\n   \
    \ moveCount := 0\n    \n    // We will keep track of the index of the element\
    \ that we are going to move.\n    index := 0\n    \n    // We will keep track\
    \ of the element that we are going to move to the \n    // starting position.\n\
    \    element := arr[0]\n    \n    // We will keep track of the number of element\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp90h1jclk_test.go:106:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074343
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift := len(arr) - 1\n\
    \    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < arr[shift] {\n\
    \            shift += 1\n        }\n    }\n    \n    if shift < len(arr) {\n \
    \       return false\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpimy1t_4m_test.go:44:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n    }\n\
    \    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpbbjzhj89_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpbbjzhj89_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpcjuikt6j_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpcjuikt6j_test.go:60\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We have N elements in the array. \n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-decreasing order.\n    // We need to perform N right shift\
    \ operations to get non-\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvcsvmyl9_test.go:66:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074343
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp6n_cn42a_test.go:27 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        shift -= 1\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpmi9tdf2b_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpmi9tdf2b_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074345
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  n := len(arr)\n    \n    // Initialize a boolean array 'b' of size 'n' with\
    \ value 'false'\n    b := make([]bool, n, n)\n    \n    // Initialize a boolean\
    \ array 'b' of size 'n' with value 'true'\n    b := make([]bool, n, n)\n    \n\
    \    // Initialize a boolean array 'b' of size 'n' with value 'false'\n    b :=\
    \ make([]bool, n, n)\n    \n    // Initialize a boolean array 'b' of size 'n'\
    \ with value 'true'\n    b := make([]bool, n, n)\n    \n    // Initialize a boolean\
    \ array 'b' of size 'n' with value 'false'\n    b := make([]bool, n, n)\n    \n\
    \    // Initialize a boolean array 'b' of size 'n' with value 'true'\n    b :=\
    \ make([]bool, n, n)\n    \n    // Initialize a boolean array 'b' of size 'n'\
    \ with value 'false'\n    b := make([]bool, n, n)\n    \n    // Initialize a boolean\
    \ array 'b' of size 'n' with value 'true'\n    b := make([]bool, n, n)\n    \n\
    \    // Initialize a boolean array 'b' of size 'n' with value 'false'\n    b :=\
    \ make([]bool, n, n)\n    \n    // Initialize a boolean array 'b' of size 'n'\
    \ with value 'true'\n    b := make([]bool, n, n)\n    \n    // Initialize a boolean\
    \ array 'b' of size 'n' with value 'false'\n    b := make([]bool, n, n)\n    \n\
    \    // Initialize a boolean array 'b' of size 'n' with value 'true'\n    b :=\
    \ make([]bool, n, n)\n    \n    // Initialize a boolean array 'b' of size 'n'\
    \ with value 'false'\n    b := make([]bool, n, n)\n    \n    // Initialize a boolean\
    \ array 'b' of size 'n' with value 'true'\n    b := make([]bool, n, n)\n    \n\
    \    // Initialize a boolean array 'b' of size 'n' with value 'false'\n    b :=\
    \ make([]bool, n, n)\n    \n    // Initialize a boolean array 'b' of size 'n'\
    \ with value 'true'\n    b := make([]bool, n, \nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi_m72p2h_test.go:81:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074344
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpshjb8p2d_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpshjb8p2d_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpcjuikt6j_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpcjuikt6j_test.go:60\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    return\
    \ arr[0] != arr[shift]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpvl0769gf_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpvl0769gf_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074345
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n    }\n    \n    for i := 0; i < shift; i++ {\n       \
    \ arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n    }\n    \n    for i := 0;\
    \ i < len(arr); i++ {\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \    }\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n    }\n    \n    for\
    \ i := 0; i < len(arr); i++ {\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \    }\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n    }\n    \n    for\
    \ i := 0; i < len(arr); i++ {\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \    }\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n    }\n    \n    for\
    \ i := 0; i < len(arr); i++ {\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \    }\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n    }\n    \n    for\
    \ i := 0; i < len(arr); i++ {\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \    }\n    \n    for i := 0; i < len(arr); i++ {\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqf2gpz7i_test.go:113:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074344
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpcjuikt6j_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpcjuikt6j_test.go:60\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We have already checked the length of the array\n    // So we know that\
    \ arr[0] <= arr[1] <= ... <= arr[N-1]\n    // So we know that arr[0] is always\
    \ greater than arr[1] and so on\n    // So we know that arr[0] is always greater\
    \ than arr[1] and so on\n    // So we know that arr[0] is always greater than\
    \ arr[1] and so on\n    // So we know that arr[0] is always greater than arr[1]\
    \ and so on\n    // So we know that arr[0] is always greater than arr[1] and so\
    \ on\n    // So we know that arr[0] is always greater than arr[1] and so on\n\
    \    // So we know that arr[0] is always greater than arr[1] and so on\n    //\
    \ So we know that arr[0] is always greater than arr[1] and so on\n    // So we\
    \ know that arr[0] is always greater than arr[1] and so on\n    // So we know\
    \ that arr[0] is always greater than arr[1] and so on\n    // So we know that\
    \ arr[0] is always greater than arr[1] and so on\n    // So we know that arr[0]\
    \ is always greater than arr[1] and so on\n    // So we know that arr[0] is always\
    \ greater than arr[1] and so on\n    // So we know that arr[0] is always greater\
    \ than arr[1] and so on\n    // So we know that arr[0] is always greater than\
    \ arr[1] and so on\n    // So we know that arr[0] is always greater than arr[1]\
    \ and so on\n    // So we know that arr[0] is always greater than arr[1] and so\
    \ on\n    // So we know that arr[0] is always greater than arr[1] and so on\n\
    \    // So we know that arr[0] is always greater than arr[1] and so on\n    //\
    \ So we know that arr[0] is always greater than arr[1] and so on\n    // So we\
    \ know that arr[0] is always greater than arr[1] and so on\n    // So we know\
    \ that arr[0] is always greater than arr[1] and so on\n    // So we know that\
    \ arr[0] is always greater than arr[1] and so on\n    // So we know that arr[0]\
    \ is always greater than arr[1] and so on\n    // So we know that arr[0] is always\
    \ greater than arr[1] and so on\n    // So we know that arr[0] is always greater\
    \ than arr[1] and so on\n    // So we know that arr[0] is always greater than\
    \ arr[1] and so on\n    // So we know that arr[0] is always greater than arr[1]\
    \ and so on\n    // So we know that arr[0] is always greater than arr[1] and so\
    \ on\n    // So we know that arr[0] is always greater than \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0eml13me_test.go:64:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074344
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpcjuikt6j_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpcjuikt6j_test.go:60\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        shift -= 1\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp763sptmf_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp763sptmf_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074343
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwn_ifilc_test.go:96:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074343
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i]\
    \ = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr) - 1]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpuiy2zs6n_test.go:27 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074343
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpet0c3ix__test.go:27 +0x85 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpet0c3ix__test.go:40 +0x65 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpet0c3ix__test.go:40 +0x65 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpet0c3ix__test.go:40 +0x65 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpet0c3ix__test.go:40 +0x65 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpet0c3ix__test.go:40 +0x65 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpet0c3ix__test.go:40 +0x65 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpet0c3ix__test.go:40 +0x65 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpet0c3ix__test.go:40 +0x65 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpet0c3ix__test.go:40 +0x65 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else if i == j {\n            break\n        } else {\n    \
    \        i++\n            j--\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpxxis8br4_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpxxis8br4_test.go:59\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074345
- exit_code: null
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    j := len(arr) - 1\n    \n    for {\n        if i ==\
    \ 0 {\n            break\n        }\n        \n        if arr[i] > arr[j] {\n\
    \            arr[i], arr[j] = arr[j], arr[i]\n            i, j = j, i\n      \
    \  } else {\n            i, j = j, i\n        }\n    }\n    \n    return true\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074358
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[i+1] {\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n     \
    \   }\n    }\n    \n    return move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball({0xc0000be640?, 0xc000124f88?,\
    \ 0x4b3193?})\n\t/tmp/tmpstap838w_test.go:35 +0xea\ncommand-line-arguments_test.TestMove_One_Ball(0x0?)\n\
    \t/tmp/tmpstap838w_test.go:50 +0xa8\ntesting.tRunner(0xc0001031e0, 0x528f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074345
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)-1]\n    \n    for i := 0; i < len(arr); i++ {\n      \
    \  arr[i] = arr[i] + 1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n   \
    \     if arr[i] > arr[i+1] {\n            return false\n        }\n    }\n   \
    \ \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp30orv4gi_test.go:32:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074345
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp_q17a7ei_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp_q17a7ei_test.go:60\
    \ +0x532\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift--\n        }\n    }\n    \n    return arr == move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi6jhp9jw_test.go:41:19: invalid operation: arr == move_one_ball(arr) (mismatched
    types []int and bool)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            i++\n        } else {\n            j--\n        }\n        if\
    \ i == j {\n            break\n        }\n    }\n    \n    arr[i], arr[j] = arr[j],\
    \ arr[i]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpr9zc6zyw_test.go:27 +0xbf fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef71f\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074346
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift := len(arr) - 1\n\
    \    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < arr[shift] {\n\
    \            shift += 1\n        }\n    }\n    \n    if shift < len(arr) {\n \
    \       return false\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpimy1t_4m_test.go:44:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed \n\
    \    // to check if we can achieve non-decreasing order\n    var rightShiftCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ \n    // which can be moved to their starting position\n    var movedElements\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which can\n    // be moved to their starting position\n    var movedElements2\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which can\n    // be moved to their starting position\n    var movedElements3\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which can\n    // be moved to their starting position\n    var movedElements4\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which can\n    // be moved to their starting position\n    var movedElements5\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which can\n    // be moved to their starting position\n    var movedElements6\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which can\n    // be moved to their starting position\n    var movedElements7\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which can\n    // be moved to their starting position\n    var movedElements8\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which can\n    // be moved to their starting position\n    var movedElements9\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which can\n    // be moved to their starting position\n    var movedElements10\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which can\n    // be moved to their starting position\n    var movedElements11\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which can\n    // be moved to their starting position\n    var movedElements12\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which can\n    // be moved to their starting position\n    var movedElements13\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which can\n    // be moved to their starting position\n    var movedElements14\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which can\n    // be moved to their starting position\n    var move\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7s9bd9up_test.go:94:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074344
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ i == len(arr) - 1\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpvm9we4sd_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpvm9we4sd_test.go:57\
    \ +0x505\ntesting.tRunner(0xc0001924e0, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074346
- exit_code: 0
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ arr[0] > arr[shift] {\n        return false\n    }\n    \n    arr[0] = arr[shift]\n\
    \    \n    return move_one_ball(arr[1:])\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[i+1] {\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n     \
    \       shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ move_one_ball(arr[0:shift])\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball({0xc0000c4640?, 0xc0000f8d18?,\
    \ 0x4b3193?})\n\t/tmp/tmpitp28prs_test.go:35 +0xa8\ncommand-line-arguments_test.TestMove_One_Ball(0x0?)\n\
    \t/tmp/tmpitp28prs_test.go:55 +0xa8\ntesting.tRunner(0xc0001a01a0, 0x527f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We have two pointers i and j which point to the first and last element\n\
    \    // of the given array. Initially i and j are pointing to the first and last\n\
    \    // element of the given array. \n    i := 0\n    j := len(arr) - 1\n    \n\
    \    // We will keep track of the number of right shift operations performed.\n\
    \    // Initially the number of right shift operations is 0.\n    shiftCount :=\
    \ 0\n    \n    // We will keep track of the number of elements in the array which\
    \ are\n    // greater than the element at position i.\n    greaterCount := 0\n\
    \    \n    // We will keep track of the number of elements in the array which\
    \ are\n    // less than the element at position i.\n    lessCount := 0\n    \n\
    \    // We will keep track of the number of elements in the array which are\n\
    \    // equal to the element at position i.\n    equalCount := 0\n    \n    //\
    \ We will keep track of the number of elements in the array which are\n    //\
    \ greater than the element at position j.\n    greaterThanCount := 0\n    \n \
    \   // We will keep track of the number of elements in the array which are\n \
    \   // less than the element at position j.\n    lessThanCount := 0\n    \n  \
    \  // We will keep track of the number of elements in the array which are\n  \
    \  // equal to the element at position j.\n    equalThanCount := 0\n    \n   \
    \ // We will keep track of the number of elements in the array which are\n   \
    \ // greater than the element at position i.\n    greaterThanEqualCount := 0\n\
    \    \n    // We will keep track of the number of elements in the array which\
    \ are\n    // less than the element at position i.\n    lessThanEqualCount :=\
    \ 0\n    \n    // We will keep track of the number of elements in the array which\
    \ are\n    // equal to the element at position i.\n    equalThanEqualCount :=\
    \ 0\n    \n    // We will keep track of the number of elements in the array which\
    \ are\n    // greater than the element at position j.\n    greaterThanEqualThanCount\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // less than the element at position j.\n    lessThanEqualThanCount\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // equal to the element at position j.\n    equalThanEqualThanCount\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // greater than the element at position i.\n    greaterThanEqualThanEqualCount\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // less than the element at position i.\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm168l8d7_test.go:97:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074345
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpcjuikt6j_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpcjuikt6j_test.go:60\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    shift\
    \ += 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    shift -= 1\n    \n  \
    \  for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n       \
    \     shift -= 1\n        }\n    }\n    \n    return arr[0] != arr[shift]\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball({0xc0000c4668?, 0xc0000f8f88?,\
    \ 0x4b3193?})\n\t/tmp/tmpeqzsxeuj_test.go:51 +0xd5\ncommand-line-arguments_test.TestMove_One_Ball(0x0?)\n\
    \t/tmp/tmpeqzsxeuj_test.go:69 +0x1d7\ntesting.tRunner(0xc000192680, 0x528f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i, j =\
    \ j, i\n        } else {\n            return false\n        }\n    }\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpxvfh43tf_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpxvfh43tf_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n    }\n    \n    for i := 0; i < shift; i++ {\n       \
    \ arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n    }\n    \n    for i := 0;\
    \ i < len(arr); i++ {\n        if arr[i] > arr[i+1] {\n            return false\n\
    \        }\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpoiepxhpl_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpoiepxhpl_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation on arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // arr[2] will\
    \ be moved to arr[3]\n    // arr[3] will be moved to arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // arr[2] will\
    \ be moved to arr[3]\n    // arr[3] will be moved to arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // arr[2] will\
    \ be moved to arr[3]\n    // arr[3] will be moved to arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // arr[2] will\
    \ be moved to arr[3]\n    // arr[3] will be moved to arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // arr[2] will\
    \ be moved to arr[3]\n    // arr[3] will be moved to arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // arr[2] will\
    \ be moved to arr[3]\n    // arr[3] will be moved to arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // arr[2] will\
    \ be moved to arr[3]\n    // arr[3] will be moved to arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // arr[2] will\
    \ be moved to arr[3]\n    // arr[3] will be moved to arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // arr[2] will\
    \ be moved to arr[3]\n    // arr[3] will be moved to arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // arr[2] will\
    \ be moved to arr[3]\n    // arr[3] will be moved to arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // arr[2] will\
    \ be moved to arr[3]\n    // arr[3] will be moved to arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // arr[2] will\
    \ be moved to arr[3]\n    // arr[3] will be moved to arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // arr[2] will\
    \ be moved to arr[3]\n    // arr[3] will be moved to arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // arr\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjaf47emi_test.go:88:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074345
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i]\
    \ = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr)-1]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpa31x7v2m_test.go:27 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa31x7v2m_test.go:40 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074341
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    \n    return true\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpzyh2glrh_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpzyh2glrh_test.go:61\
    \ +0x525\ntesting.tRunner(0xc0001a01a0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of shifts performed so far.\n    var shifts\
    \ int = 0\n    \n    // We will keep track of the last element in the array.\n\
    \    var lastElem int = 0\n    \n    // We will keep track of the first element\
    \ in the array.\n    var firstElem int = 0\n    \n    // We will keep track of\
    \ the number of elements in the array.\n    var numElems int = len(arr)\n    \n\
    \    // We will keep track of the number of elements in the array that are\n \
    \   // smaller than the lastElem in the array.\n    var numSmallerElems int =\
    \ 0\n    \n    // We will keep track of the number of elements in the array that\
    \ are \n    // greater than the firstElem in the array.\n    var numGreaterElems\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ that are \n    // equal to the lastElem in the array.\n    var numEqualElems\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ that are \n    // greater than the firstElem in the array.\n    var numGreaterElems\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ that are \n    // smaller than the lastElem in the array.\n    var numSmallerElems\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ that are \n    // equal to the lastElem in the array.\n    var numEqualElems\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ that are \n    // greater than the firstElem in the array.\n    var numGreaterElems\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ that are \n    // smaller than the lastElem in the array.\n    var numSmallerElems\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ that are \n    // equal to the lastElem in the array.\n    var numEqualElems\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ that are \n    // greater than the firstElem in the array.\n    var numGreaterElems\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ that are \n    // smaller than the lastElem in the array.\n    var numSmallerElems\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ that are \n    // equal to the lastElem in the array.\n    var numEqualElems\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ that are \n    // greater than the firstElem in the array.\n    var numGreaterElems\
    \ int = 0\n    \n    // We will keep track of the number of elements in the \n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnjaqgwgt_test.go:97:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074345
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ len(arr) == i\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpriv5l8bd_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpriv5l8bd_test.go:57\
    \ +0x505\ntesting.tRunner(0xc0001a61a0, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else if i == j {\n            break\n        } else {\n    \
    \        i++\n            j--\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpxxis8br4_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpxxis8br4_test.go:59\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074345
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i >= j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp_mqe3ipq_test.go:68: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp_mqe3ipq_test.go:68:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwn_ifilc_test.go:96:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074343
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed\n \
    \   // so far.\n    var shiftCount int = 0\n    \n    // We will keep track of\
    \ the last element of the array which will be\n    // moved to the starting position\
    \ in the array i.e. 0th index.\n    var lastElement int = 0\n    \n    // We will\
    \ keep track of the number of elements in the array which are\n    // smaller\
    \ than the lastElement.\n    var smallerCount int = 0\n    \n    // We will keep\
    \ track of the number of elements in the array which are\n    // greater than\
    \ the lastElement.\n    var greaterCount int = 0\n    \n    // We will keep track\
    \ of the number of elements in the array which are\n    // equal to the lastElement.\n\
    \    var equalCount int = 0\n    \n    // We will keep track of the number of\
    \ elements in the array which are\n    // greater than the lastElement.\n    var\
    \ greaterEqualCount int = 0\n    \n    // We will keep track of the number of\
    \ elements in the array which are\n    // smaller than the lastElement.\n    var\
    \ smallerEqualCount int = 0\n    \n    // We will keep track of the number of\
    \ elements in the array which are\n    // equal to the lastElement.\n    var equalEqualCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // greater than the lastElement.\n    var greaterEqualEqualCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // smaller than the lastElement.\n    var smallerEqualEqualCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // equal to the lastElement.\n    var equalEqualEqualCount int\
    \ = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // greater than the lastElement.\n    var greaterEqualEqualEqualCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // smaller than the lastElement.\n    var smallerEqualEqualEqualCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // equal to the lastElement.\n    var equalEqualEqualEqualCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // greater than the lastElement.\n    var greaterEqualEqualEqualEqualCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // smaller than the lastElement.\n    var smallerEqualEqualEqualEqualCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which are\n    // equal to the lastElement.\n    var equalEqualEqualEqualEqualCount\
    \ int = 0\n    \n    // We will keep track of the number of \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzx3_ya5c_test.go:101:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074345
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpcjuikt6j_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpcjuikt6j_test.go:60\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift := len(arr) - 1\n\
    \    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < arr[shift] {\n\
    \            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ false\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyivikk05_test.go:44:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := make([]int, len(arr))\n    \n    for i := 0; i < len(arr); i++ {\n \
    \       arr[i] = arr[i]\n    }\n    \n    for i := 0; i < len(arr); i++ {\n  \
    \      arr[i] = arr[i] >> 1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n\
    \        arr[i] = arr[i] << 1\n    }\n    \n    return arr == arr\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpocendaz7_test.go:32:9: no new variables on left side of :=

    /tmp/tmpocendaz7_test.go:46:12: invalid operation: arr == arr (slice can only
    be compared to nil)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i]\
    \ = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr) - 1]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpuiy2zs6n_test.go:27 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpuiy2zs6n_test.go:40 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074343
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpshjb8p2d_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpshjb8p2d_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n        \n       \
    \ if i == shift {\n            arr[i] = 0\n            shift += 1\n        }\n\
    \    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n \
    \ candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpethmaik3_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpethmaik3_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074347
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation on the given array\n    //\
    \ and we will keep track of the number of right shift operations performed.\n\
    \    // We will keep track of the number of right shift operations performed by\n\
    \    // keeping a variable 'shiftCount' which will keep track of the number of\
    \ \n    // right shift operations performed.\n    var shiftCount int = 0\n   \
    \ \n    // We will keep track of the number of elements in the given array by\n\
    \    // keeping a variable 'arrSize' which will keep track of the number of \n\
    \    // elements in the given array.\n    var arrSize int = len(arr)\n    \n \
    \   // We will keep track of the number of elements in the given array by\n  \
    \  // keeping a variable 'arrSize' which will keep track of the number of \n \
    \   // elements in the given array.\n    var arrSize int = len(arr)\n    \n  \
    \  // We will keep track of the number of elements in the given array by\n   \
    \ // keeping a variable 'arrSize' which will keep track of the number of \n  \
    \  // elements in the given array.\n    var arrSize int = len(arr)\n    \n   \
    \ // We will keep track of the number of elements in the given array by\n    //\
    \ keeping a variable 'arrSize' which will keep track of the number of \n    //\
    \ elements in the given array.\n    var arrSize int = len(arr)\n    \n    // We\
    \ will keep track of the number of elements in the given array by\n    // keeping\
    \ a variable 'arrSize' which will keep track of the number of \n    // elements\
    \ in the given array.\n    var arrSize int = len(arr)\n    \n    // We will keep\
    \ track of the number of elements in the given array by\n    // keeping a variable\
    \ 'arrSize' which will keep track of the number of \n    // elements in the given\
    \ array.\n    var arrSize int = len(arr)\n    \n    // We will keep track of the\
    \ number of elements in the given array by\n    // keeping a variable 'arrSize'\
    \ which will keep track of the number of \n    // elements in the given array.\n\
    \    var arrSize int = len(arr)\n    \n    // We will keep track of the number\
    \ of elements in the given array by\n    // keeping a variable 'arrSize' which\
    \ will keep track of the number of \n    // elements in the given array.\n   \
    \ var arrSize int = len(arr)\n    \n    // We will keep track of the number of\
    \ elements in the given array by\n    // keeping a variable 'arrSize' which will\
    \ keep track of the number of \n    // elements in the given array.\n    var arrSize\
    \ int = len(arr)\n    \n    // We will keep track of the number of elements in\
    \ the given array by\n    // keeping a variable 'arrSize' which will keep track\
    \ of the number of \n    // elements in the given array.\n    var arrSize int\
    \ = len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ given array by\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmzbmed63_test.go:91:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074345
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift := len(arr) - 1\n\
    \    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < arr[shift] {\n\
    \            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ false\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyivikk05_test.go:44:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp6n_cn42a_test.go:27 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp6n_cn42a_test.go:42 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpshjb8p2d_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpshjb8p2d_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpn6_z5jxw_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpn6_z5jxw_test.go:57\
    \ +0x4d2\ntesting.tRunner(0xc0001924e0, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074341
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return arr[0] == 0\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpbo9ijc1g_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpbo9ijc1g_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We have two pointers left and right which point to each element of arr\n\
    \    // and one pointer temp which points to the last element of arr\n    left\
    \ := 0\n    right := len(arr) - 1\n    temp := arr[len(arr) - 1]\n    \n    //\
    \ We will keep track of the number of right shift operations performed\n    //\
    \ and keep track of whether we have found a non-decreasing order\n    count :=\
    \ 0\n    \n    // We will keep track of the number of right shift operations performed\n\
    \    // and keep track of whether we have found a non-decreasing order\n    count\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed\n    // and keep track of whether we have found a non-decreasing order\n\
    \    count := 0\n    \n    // We will keep track of the number of right shift\
    \ operations performed\n    // and keep track of whether we have found a non-decreasing\
    \ order\n    count := 0\n    \n    // We will keep track of the number of right\
    \ shift operations performed\n    // and keep track of whether we have found a\
    \ non-decreasing order\n    count := 0\n    \n    // We will keep track of the\
    \ number of right shift operations performed\n    // and keep track of whether\
    \ we have found a non-decreasing order\n    count := 0\n    \n    // We will keep\
    \ track of the number of right shift operations performed\n    // and keep track\
    \ of whether we have found a non-decreasing order\n    count := 0\n    \n    //\
    \ We will keep track of the number of right shift operations performed\n    //\
    \ and keep track of whether we have found a non-decreasing order\n    count :=\
    \ 0\n    \n    // We will keep track of the number of right shift operations performed\n\
    \    // and keep track of whether we have found a non-decreasing order\n    count\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed\n    // and keep track of whether we have found a non-decreasing order\n\
    \    count := 0\n    \n    // We will keep track of the number of right shift\
    \ operations performed\n    // and keep track of whether we have found a non-decreasing\
    \ order\n    count := 0\n    \n    // We will keep track of the number of right\
    \ shift operations performed\n    // and keep track of whether we have found a\
    \ non-decreasing order\n    count := 0\n    \n    // We will keep track of the\
    \ number of right shift operations performed\n    // and keep track of whether\
    \ we have found a non-decreasing order\n    count := 0\n    \n    // We will keep\
    \ track of the number of right shift operations performed\n    // and keep track\
    \ of whether \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn59y6f23_test.go:92:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074345
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift := len(arr) - 1\n\
    \    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < arr[shift] {\n\
    \            shift += 1\n        }\n    }\n    \n    if shift < len(arr) {\n \
    \       return false\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpimy1t_4m_test.go:44:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0]\
    \ = arr[shift]\n    \n    return move_one_ball(arr[1:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpo2zl_13p_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpo2zl_13p_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[i+1] {\n            shift -= 1\n            arr[i], arr[shift]\
    \ = arr[shift], arr[i]\n        }\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc00014e000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc00014e000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp7u7vl0np_test.go:35\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp7u7vl0np_test.go:51\
    \ +0x586\ntesting.tRunner(0xc000119040, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n"
  timestamp: 1660074347
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[i+1] {\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n     \
    \       shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ move_one_ball(arr[:shift])\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball({0xc0000c4640?, 0xc0000f8f88?,\
    \ 0x4b3193?})\n\t/tmp/tmpd1e0xion_test.go:35 +0xa8\ncommand-line-arguments_test.TestMove_One_Ball(0x0?)\n\
    \t/tmp/tmpd1e0xion_test.go:55 +0xa8\ntesting.tRunner(0xc0001a01a0, 0x527f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074343
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  n := len(arr)\n    \n    i := 0\n    j := n - 1\n    \n    for {\n        if\
    \ arr[i] > arr[j] {\n            i++\n        } else {\n            j--\n    \
    \    }\n        if i >= j {\n            break\n        }\n    }\n    \n    arr[i],\
    \ arr[j] = arr[j], arr[i]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 34 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpi9yuxj9y_test.go:27 +0xd0 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef730\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpi9yuxj9y_test.go:50 +0x85 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpi9yuxj9y_test.go:50 +0x85 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpi9yuxj9y_test.go:50 +0x85 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpi9yuxj9y_test.go:50 +0x85 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpi9yuxj9y_test.go:50 +0x85 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpi9yuxj9y_test.go:50 +0x85 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpi9yuxj9y_test.go:50 +0x85 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpi9yuxj9y_test.go:50 +0x85 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpi9yuxj9y_test.go:50 +0x85 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074348
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  n := len(arr)\n    \n    // The first element of the array is moved to 0th\
    \ position\n    arr[0] = arr[n-1]\n    \n    // The last element of the array\
    \ is moved to 1st position\n    arr[n-1] = 0\n    \n    // The remaining elements\
    \ are shifted one position to the right\n    for i := 1; i < n; i++ {\n      \
    \  arr[i] = arr[i-1]\n    }\n    \n    // The array is sorted in non-decreasing\
    \ order\n    for i := 1; i < n; i++ {\n        if arr[i] > arr[i-1] {\n      \
    \      return false\n        }\n    }\n    \n    return true\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis solution does not work if the array is empty or has only\
    \ one element. Also, it does not work for negative numbers. Please check my answer\
    \ for a correct solution.\n<|/ c |>\n<| a tags=algorithm,arrays,sorting,go |>\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"time\"\
    \n)\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcn676rv4_test.go:54:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074345
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpwde0_um__test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpwde0_um__test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    shift\
    \ += 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    return arr[0] == arr[shift]\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpea__u5sq_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpea__u5sq_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074347
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)-1]\n    \n    for i := len(arr) - 1; i > 0; i-- {\n  \
    \      arr[i] = arr[i-1]\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvxp18lfa_test.go:32:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return arr[0] == 0\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpbo9ijc1g_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpbo9ijc1g_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        shift -= 1\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp763sptmf_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp763sptmf_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074343
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed so\
    \ far\n    // and will keep track of the last element of the array that has been\
    \ moved\n    // to the starting position in the array i.e. 0th index.\n    shiftCount\
    \ := 0\n    lastElement := arr[0]\n    \n    // We will keep track of the number\
    \ of right shift operations performed so far\n    // and will keep track of the\
    \ last element of the array that has been moved\n    // to the starting position\
    \ in the array i.e. 0th index.\n    shiftCount := 0\n    lastElement := arr[0]\n\
    \    \n    // We will keep track of the number of right shift operations performed\
    \ so far\n    // and will keep track of the last element of the array that has\
    \ been moved\n    // to the starting position in the array i.e. 0th index.\n \
    \   shiftCount := 0\n    lastElement := arr[0]\n    \n    // We will keep track\
    \ of the number of right shift operations performed so far\n    // and will keep\
    \ track of the last element of the array that has been moved\n    // to the starting\
    \ position in the array i.e. 0th index.\n    shiftCount := 0\n    lastElement\
    \ := arr[0]\n    \n    // We will keep track of the number of right shift operations\
    \ performed so far\n    // and will keep track of the last element of the array\
    \ that has been moved\n    // to the starting position in the array i.e. 0th index.\n\
    \    shiftCount := 0\n    lastElement := arr[0]\n    \n    // We will keep track\
    \ of the number of right shift operations performed so far\n    // and will keep\
    \ track of the last element of the array that has been moved\n    // to the starting\
    \ position in the array i.e. 0th index.\n    shiftCount := 0\n    lastElement\
    \ := arr[0]\n    \n    // We will keep track of the number of right shift operations\
    \ performed so far\n    // and will keep track of the last element of the array\
    \ that has been moved\n    // to the starting position in the array i.e. 0th index.\n\
    \    shiftCount := 0\n    lastElement := arr[0]\n    \n    // We will keep track\
    \ of the number of right shift operations performed so far\n    // and will keep\
    \ track of the last element of the array that has been moved\n    // to the starting\
    \ position in the array i.e. 0th index.\n    shiftCount := 0\n    lastElement\
    \ := arr[0]\n    \n    // We will keep track of the number of right shift operations\
    \ performed so far\n    // and will keep track of the last element of the array\
    \ that has been moved\n    // to the starting position in the array i.e. 0th index.\n\
    \    shiftCount := 0\n    lastElement := arr[0]\n    \n    // We will keep track\
    \ of the number of right shift operations performed so far\n    // \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3c_ofos1_test.go:88:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation N times to get non-decreasing\
    \ order.\n    // We will keep track of the number of right shift operations performed.\n\
    \    var shiftCount int = 0\n    \n    // We will keep track of the last element\
    \ of the array i.e. arr[N-1].\n    var lastElement int = 0\n    \n    // We will\
    \ keep track of the last element of the array i.e. arr[0].\n    var firstElement\
    \ int = 0\n    \n    // We will keep track of the number of elements we already\
    \ have in the array.\n    var numElements int = len(arr)\n    \n    // We will\
    \ keep track of the number of elements we already have in the array.\n    var\
    \ numElements2 int = len(arr)\n    \n    // We will keep track of the number of\
    \ elements we already have in the array.\n    var numElements3 int = len(arr)\n\
    \    \n    // We will keep track of the number of elements we already have in\
    \ the array.\n    var numElements4 int = len(arr)\n    \n    // We will keep track\
    \ of the number of elements we already have in the array.\n    var numElements5\
    \ int = len(arr)\n    \n    // We will keep track of the number of elements we\
    \ already have in the array.\n    var numElements6 int = len(arr)\n    \n    //\
    \ We will keep track of the number of elements we already have in the array.\n\
    \    var numElements7 int = len(arr)\n    \n    // We will keep track of the number\
    \ of elements we already have in the array.\n    var numElements8 int = len(arr)\n\
    \    \n    // We will keep track of the number of elements we already have in\
    \ the array.\n    var numElements9 int = len(arr)\n    \n    // We will keep track\
    \ of the number of elements we already have in the array.\n    var numElements10\
    \ int = len(arr)\n    \n    // We will keep track of the number of elements we\
    \ already have in the array.\n    var numElements11 int = len(arr)\n    \n   \
    \ // We will keep track of the number of elements we already have in the array.\n\
    \    var numElements12 int = len(arr)\n    \n    // We will keep track of the\
    \ number of elements we already have in the array.\n    var numElements13 int\
    \ = len(arr)\n    \n    // We will keep track of the number of elements we already\
    \ have in the array.\n    var numElements14 int = len(arr)\n    \n    // We will\
    \ keep track of the number of elements we already have in the array.\n    var\
    \ numElements15 int = len(arr)\n    \n    // We will keep track of the number\
    \ of elements we already have in the array.\n    var numElements16 int = len(arr)\n\
    \    \n    // We will keep track of the number of elements we already have in\
    \ the array.\n    var numElement\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph_kudey__test.go:91:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074346
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift := len(arr) - 1\n\
    \    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < arr[shift] {\n\
    \            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ false\n    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i]\
    \ < arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if shift\
    \ > 0 {\n        return false\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyuom_9c1_test.go:44:11: no new variables on left side of :=

    /tmp/tmpyuom_9c1_test.go:56:11: no new variables on left side of :=

    /tmp/tmpyuom_9c1_test.go:68:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpcjuikt6j_test.go:36\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpcjuikt6j_test.go:60\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return arr[0] == 0\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpbo9ijc1g_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpbo9ijc1g_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)-1]\n    \n    for i := 0; i < len(arr); i++ {\n      \
    \  if arr[i] > arr[i+1] {\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n \
    \       }\n    }\n    \n    return arr == arr[:len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkqi_ukld_test.go:32:9: no new variables on left side of :=

    /tmp/tmpkqi_ukld_test.go:40:12: invalid operation: arr == arr[:len(arr) - 1] (slice
    can only be compared to nil)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation on the given array\n    //\
    \ arr[1], arr[2], ..., arr[N]\n    \n    // We are going to perform right shift\
    \ operation on the given array\n    // arr[1], arr[2], ..., arr[N]\n    \n   \
    \ // We are going to perform right shift operation on the given array\n    //\
    \ arr[1], arr[2], ..., arr[N]\n    \n    // We are going to perform right shift\
    \ operation on the given array\n    // arr[1], arr[2], ..., arr[N]\n    \n   \
    \ // We are going to perform right shift operation on the given array\n    //\
    \ arr[1], arr[2], ..., arr[N]\n    \n    // We are going to perform right shift\
    \ operation on the given array\n    // arr[1], arr[2], ..., arr[N]\n    \n   \
    \ // We are going to perform right shift operation on the given array\n    //\
    \ arr[1], arr[2], ..., arr[N]\n    \n    // We are going to perform right shift\
    \ operation on the given array\n    // arr[1], arr[2], ..., arr[N]\n    \n   \
    \ // We are going to perform right shift operation on the given array\n    //\
    \ arr[1], arr[2], ..., arr[N]\n    \n    // We are going to perform right shift\
    \ operation on the given array\n    // arr[1], arr[2], ..., arr[N]\n    \n   \
    \ // We are going to perform right shift operation on the given array\n    //\
    \ arr[1], arr[2], ..., arr[N]\n    \n    // We are going to perform right shift\
    \ operation on the given array\n    // arr[1], arr[2], ..., arr[N]\n    \n   \
    \ // We are going to perform right shift operation on the given array\n    //\
    \ arr[1], arr[2], ..., arr[N]\n    \n    // We are going to perform right shift\
    \ operation on the given array\n    // arr[1], arr[2], ..., arr[N]\n    \n   \
    \ // We are going to perform right shift operation on the given array\n    //\
    \ arr[1], arr[2], ..., arr[N]\n    \n    // We are going to perform right shift\
    \ operation on the given array\n    // arr[1], arr[2], ..., arr[N]\n    \n   \
    \ // We are going to perform right shift operation on the given array\n    //\
    \ arr[1], arr[2], ..., arr[N]\n    \n    // We are going to perform right shift\
    \ operation on the given array\n    // arr[1], arr[2], ..., arr[N]\n    \n   \
    \ // We are going to perform right shift operation on the given array\n    //\
    \ arr[1], arr[2], ..., arr[N]\n    \n    // We are going to perform right shift\
    \ operation on the given array\n    // arr[1], arr[2], ..., arr[N]\n    \n   \
    \ // We are going to perform right shift operation on the given array\n    //\
    \ arr[1], arr[2], ..., arr[N\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3uufhw4y_test.go:94:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074346
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)-1]\n    \n    for i := 0; i < len(arr); i++ {\n      \
    \  arr[i], arr[i+1] = arr[i+1], arr[i]\n    }\n    \n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpasvzre7w_test.go:32:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074347
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n        \n       \
    \ if shift < 0 {\n            return false\n        }\n        \n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmphd5r9z62_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmphd5r9z62_test.go:66:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074348
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            i++\n        } else {\n            j--\n        }\n        if\
    \ i == j {\n            break\n        }\n    }\n    \n    arr[i], arr[j] = arr[j],\
    \ arr[i]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpr9zc6zyw_test.go:27 +0xbf fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef71f\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpr9zc6zyw_test.go:48 +0x7f fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n        }\n        i++\n   \
    \     j--\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpde965mjn_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpde965mjn_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074348
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed\n \
    \   // to achieve non-decreasing order.\n    var shiftCount int = 0\n    \n  \
    \  // We will keep track of the number of elements in the array which we\n   \
    \ // have already visited.\n    var visited []int\n    \n    // We will keep track\
    \ of the number of elements in the array which we\n    // have already visited.\n\
    \    var visitedCount int = 0\n    \n    // We will keep track of the number of\
    \ elements in the array which we\n    // have already visited.\n    var visitedCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which we\n    // have already visited.\n    var visitedCount int = 0\n    \n\
    \    // We will keep track of the number of elements in the array which we\n \
    \   // have already visited.\n    var visitedCount int = 0\n    \n    // We will\
    \ keep track of the number of elements in the array which we\n    // have already\
    \ visited.\n    var visitedCount int = 0\n    \n    // We will keep track of the\
    \ number of elements in the array which we\n    // have already visited.\n   \
    \ var visitedCount int = 0\n    \n    // We will keep track of the number of elements\
    \ in the array which we\n    // have already visited.\n    var visitedCount int\
    \ = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which we\n    // have already visited.\n    var visitedCount int = 0\n    \n\
    \    // We will keep track of the number of elements in the array which we\n \
    \   // have already visited.\n    var visitedCount int = 0\n    \n    // We will\
    \ keep track of the number of elements in the array which we\n    // have already\
    \ visited.\n    var visitedCount int = 0\n    \n    // We will keep track of the\
    \ number of elements in the array which we\n    // have already visited.\n   \
    \ var visitedCount int = 0\n    \n    // We will keep track of the number of elements\
    \ in the array which we\n    // have already visited.\n    var visitedCount int\
    \ = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which we\n    // have already visited.\n    var visitedCount int = 0\n    \n\
    \    // We will keep track of the number of elements in the array which we\n \
    \   // have already visited.\n    var visitedCount int = 0\n    \n    // We will\
    \ keep track of the number of elements in the array which we\n    // have already\
    \ visited.\n    var visitedCount int = 0\n    \n    // We will keep track of the\
    \ number of elements in the array which we\n    // have already visited.\n   \
    \ var visitedCount int\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbt3zbw6r_test.go:103:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074346
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg6ptkpba_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg6ptkpba_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074339
