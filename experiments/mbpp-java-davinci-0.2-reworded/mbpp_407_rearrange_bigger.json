{
  "name": "mbpp_407_rearrange_bigger",
  "language": "java",
  "prompt": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // Write a function to create the next bigger number by rearranging the digits of a given number.\n    public static Object rearrangeBigger(long n) {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    public static void main(String[] args) {\n    assert(rearrangeBigger((12l)).equals((Object(21l))));\n    assert(rearrangeBigger((10l)).equals((Object(false))));\n    assert(rearrangeBigger((102l)).equals((Object(120l))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        // If the number has only one digit, it is the biggest number possible.\n        if (n < 10) {\n            return -1;\n        }\n        // Convert the number to a string.\n        String s = Long.toString(n);\n        // Create a list of the digits.\n        List<Integer> digits = new ArrayList<Integer>();\n        for (int i = 0; i < s.length(); i++) {\n            digits.add(Character.getNumericValue(s.charAt(i)));\n        }\n        // Find the first digit that is less than the digit to its right.\n        int i = 0;\n        while (i < digits.size() - 1 && digits.get(i) >= digits.get(i + 1)) {\n            i++;\n        }\n        // If no such digit exists, the number is the biggest possible.\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the digit found in the previous step that is greater than the digit found in the previous step.\n        int j = i + 1;\n        while (j < digits.size() - 1 && digits.get(j) <= digits.get(i)) {\n            j++;\n        }\n        // Swap the digits found in the previous two steps.\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // Sort the digits to the right of the digit found in the first step in ascending order.\n        List<Integer> sublist = digits.subList(i + 1, digits.size());\n        Collections.sort(sublist);\n        // Convert the list of digits back to a number.\n        StringBuilder sb = new StringBuilder();\n        for (int k = 0; k < digits.size(); k++) {\n            sb.append(digits.get(k));\n        }\n        return Long.parseLong(sb.toString());",
    "        // Given a number, return the next bigger number that can be formed by rearranging the digits.\n        // If the given number is the biggest possible number with its digits, return -1.\n        // For example:\n        // 12 ==> 21\n        // 513 ==> 531\n        // 2017 ==> 2071\n        // 9 ==> -1\n        // 111 ==> -1\n        // 531 ==> -1\n        // 123456789 ==> 123456798\n        // 123456798 ==> 123456879\n        // 123456879 ==> 123456897\n        // 123456897 ==> 123456978\n        // 123456978 ==> 123457689\n        // 123457689 ==> 123457869\n        // 123457869 ==> 123457896\n        // 123457896 ==> 123457968\n        // 123457968 ==> 123457986\n        // 123457986 ==> 123458679\n        // 123458679 ==> 123458697\n        // 123458697 ==> 123458769\n        // 123458769 ==> 123458796\n        // 123458796 ==> 123458867\n        // 123458867 ==> 123458876\n        // 123458876 ==> 123458897\n        // 123458897 ==> 123458967\n        // 123458967 ==> 123458976\n        // 123458976 ==> 123458987\n        // 123458987 ==> 123459768\n        // 123459768 ==> 123459786\n        // 123459786 ==> 123459867\n        // 123459867 ==> 123459876\n        // 123459876 ==> 123459887\n        // 123459887 ==> 123459967\n        // 123459967 ==> 123459976\n        // 123459976 ==> 123459987\n        // 123459987 ==> 123465789\n        // 123465789 ==> 123465879\n        // 123465879 ==> 123465897\n        // 123465897 ==> 123465978\n        // 123465978 ==> 123465987\n        // 123465987 ==>",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first index from the right that is smaller than the one to its right\n        int i = c.length - 2;\n        while (i >= 0 && c[i] >= c[i + 1]) {\n            i--;\n        }\n        // If no such index exists, the number is already the largest possible\n        if (i < 0) {\n            return -1;\n        }\n        // Find the smallest number to the right of i that is larger than c[i]\n        int j = c.length - 1;\n        while (j >= 0 && c[j] <= c[i]) {\n            j--;\n        }\n        // Swap c[i] and c[j]\n        char temp = c[i];\n        c[i] = c[j];\n        c[j] = temp;\n        // Reverse the string to the right of i\n        int left = i + 1;\n        int right = c.length - 1;\n        while (left < right) {\n            temp = c[left];\n            c[left] = c[right];\n            c[right] = temp;\n            left++;\n            right--;\n        }\n        // Convert back to string and return\n        return Long.parseLong(new String(c));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If there is no decreasing digit, then the number is already the biggest\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the first decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the first decreasing digit with the smallest digit to the right of it\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits to the right of the first decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert back to long\n        return Long.parseLong(new String(c));",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If no decreasing digit, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the first decreasing digit\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap the first decreasing digit with the smallest digit to the right\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse the digits to the right of the first decreasing digit\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert to long\n        return Long.parseLong(new String(c));",
    "        // 1. Find the largest index i such that array[i \u2212 1] < array[i].\n        // If no such index exists, the permutation is the last permutation.\n        // 2. Find the largest index j greater than i such that array[j] > array[i \u2212 1].\n        // 3. Swap array[j] and array[i \u2212 1].\n        // 4. Reverse the suffix starting at array[i].\n        //\n        // Example:\n        // Input:  [1,2,3]\n        // Output: [1,3,2]\n        //\n        // Input:  [3,2,1]\n        // Output: [1,2,3]\n        //\n        // Input:  [1,1,5]\n        // Output: [1,5,1]\n        //\n        // Input:  [1,3,2]\n        // Output: [2,1,3]\n        //\n        // Input:  [2,3,1]\n        // Output: [3,1,2]\n        //\n        // Input:  [5,4,7,5,3,2]\n        // Output: [5,5,2,3,4,7]\n        //\n        // Input:  [2,2,7,5,4,3,2,2,1]\n        // Output: [2,3,1,2,2,2,4,5,7]\n        //\n        // Input:  [2,1,3]\n        // Output: [3,1,2]\n        //\n        // Input:  [1,1,1]\n        // Output: [1,1,1]\n        //\n        // Input:  [1,2]\n        // Output: [2,1]\n        //\n        // Input:  [2,1]\n        // Output: [1,2]\n        //\n        // Input:  [1]\n        // Output: [1]\n        //\n        // Input:  [1,2,3,4]\n        // Output: [1,2,4,3]\n        //\n        // Input:  [1,2,4,3]\n        //",
    "        // convert to array of digits\n        ArrayList<Integer> digits = new ArrayList<Integer>();\n        while (n > 0) {\n            digits.add((int)n % 10);\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // find the first digit that is smaller than the one to the right\n        int i = 0;\n        for (i = 0; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // if no such digit exists, return -1\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // find the smallest digit to the right of the first digit that is larger than the first digit\n        int j = i + 1;\n        for (int k = i + 2; k < digits.size(); k++) {\n            if (digits.get(k) < digits.get(j) && digits.get(k) > digits.get(i)) {\n                j = k;\n            }\n        }\n        // swap the first digit and the smallest digit to the right of it\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // sort the digits to the right of the first digit\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // convert the array of digits back to a number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] chars = s.toCharArray();\n        // Create a list of chars\n        List<Character> list = new ArrayList<Character>();\n        for (char c : chars) {\n            list.add(c);\n        }\n        // Create a list of indices\n        List<Integer> indices = new ArrayList<Integer>();\n        for (int i = 0; i < list.size(); i++) {\n            indices.add(i);\n        }\n        // Create a list of pairs\n        List<Pair<Character, Integer>> pairs = new ArrayList<Pair<Character, Integer>>();\n        for (int i = 0; i < list.size(); i++) {\n            pairs.add(new Pair<Character, Integer>(list.get(i), indices.get(i)));\n        }\n        // Sort the pairs\n        Collections.sort(pairs, new Comparator<Pair<Character, Integer>>() {\n            @Override\n            public int compare(Pair<Character, Integer> p1, Pair<Character, Integer> p2) {\n                return p1.getValue0().compareTo(p2.getValue0());\n            }\n        });\n        // Find the first pair that is greater than the previous pair\n        int i = 0;\n        while (i < pairs.size() - 1) {\n            if (pairs.get(i).getValue0() < pairs.get(i + 1).getValue0()) {\n                break;\n            }\n            i++;\n        }\n        // If no such pair exists, return -1\n        if (i == pairs.size() - 1) {\n            return -1;\n        }\n        // Swap the two pairs\n        Pair<Character, Integer> temp = pairs.get(i);\n        pairs.set(i, pairs.get(i + 1));\n        pairs.set(i + 1, temp);\n        // Sort the pairs from i + 1 to the end\n        Collections.sort(pairs.subList(i + 1, pairs.size()), new Comparator<Pair<Character, Integer>>() {\n            @",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] chars = s.toCharArray();\n        // Find the first index from the right that is smaller than the next\n        int i = chars.length - 1;\n        while (i > 0 && chars[i] <= chars[i - 1]) {\n            i--;\n        }\n        // If i is 0, then the number is already the largest possible\n        if (i == 0) {\n            return -1;\n        }\n        // Find the smallest number to the right of i that is larger than the number at i\n        int j = chars.length - 1;\n        while (j > i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // Swap the numbers\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // Sort the numbers to the right of i\n        Arrays.sort(chars, i, chars.length);\n        // Convert back to string\n        String result = new String(chars);\n        // Convert to long\n        return Long.parseLong(result);",
    "        // convert to string\n        String s = Long.toString(n);\n        // convert to char array\n        char[] chars = s.toCharArray();\n        // find first decreasing digit\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        // if no decreasing digit, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // find the first digit greater than the decreasing digit\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // swap the decreasing digit and the greater digit\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // reverse the digits after the decreasing digit\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        // convert to long and return\n        return Long.parseLong(new String(chars));",
    "        // get the digits\n        List<Integer> digits = new ArrayList<>();\n        while (n > 0) {\n            digits.add((int) (n % 10));\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // find the first digit that is smaller than the next digit\n        int i = 0;\n        for (; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // if no such digit, return -1\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // find the smallest digit that is larger than the current digit\n        int j = i + 1;\n        for (; j < digits.size(); j++) {\n            if (digits.get(j) > digits.get(i)) {\n                break;\n            }\n        }\n        // swap the digits\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // sort the digits after the current digit\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // return the number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        // Find the first digit that is smaller than the digit to its right.\n        // Find the smallest digit to the right of the digit found in the previous step.\n        // Swap the two digits found in the previous two steps.\n        // Sort the digits to the right of the digit found in step 1 in ascending order.\n        // If no digit found in step 1, return -1.\n        String s = Long.toString(n);\n        for (int i = s.length() - 2; i >= 0; i--) {\n            if (s.charAt(i) < s.charAt(i + 1)) {\n                char c = s.charAt(i);\n                int min = i + 1;\n                for (int j = i + 1; j < s.length(); j++) {\n                    if (s.charAt(j) < s.charAt(min) && s.charAt(j) > c) {\n                        min = j;\n                    }\n                }\n                s = s.substring(0, i) + s.charAt(min) + s.substring(i + 1, min) + c + s.substring(min + 1);\n                char[] chars = s.substring(i + 1).toCharArray();\n                Arrays.sort(chars);\n                s = s.substring(0, i + 1) + new String(chars);\n                return Long.parseLong(s);\n            }\n        }\n        return -1;",
    "        // Create a list of digits\n        List<Long> digits = new ArrayList<>();\n        while (n > 0) {\n            digits.add(n % 10);\n            n /= 10;\n        }\n        // Find the first digit that is less than the digit to its right\n        int i = 0;\n        for (i = digits.size() - 1; i > 0; i--) {\n            if (digits.get(i - 1) < digits.get(i)) {\n                break;\n            }\n        }\n        // If no such digit exists, return -1\n        if (i == 0) {\n            return -1;\n        }\n        // Find the smallest digit to the right of the pivot that is greater than the pivot\n        int j = i;\n        for (j = i; j < digits.size(); j++) {\n            if (digits.get(j) > digits.get(i - 1)) {\n                break;\n            }\n        }\n        // Swap the pivot with the smallest digit to its right\n        long temp = digits.get(i - 1);\n        digits.set(i - 1, digits.get(j));\n        digits.set(j, temp);\n        // Sort the digits to the right of the pivot\n        Collections.sort(digits.subList(i, digits.size()));\n        // Return the new number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] c = s.toCharArray();\n        // Find the first decreasing digit\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        // If there is no decreasing digit, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit greater than c[i - 1]\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        // Swap c[i - 1] and c[j]\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        // Reverse c[i, c.length - 1]\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        // Convert to long\n        return Long.parseLong(new String(c));",
    "        String s = String.valueOf(n);\n        int[] a = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            a[i] = Integer.parseInt(String.valueOf(s.charAt(i)));\n        }\n        int i = a.length - 1;\n        while (i > 0 && a[i - 1] >= a[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = a.length - 1;\n        while (a[j] <= a[i - 1]) {\n            j--;\n        }\n        int temp = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = temp;\n        j = a.length - 1;\n        while (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n            i++;\n            j--;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int k = 0; k < a.length; k++) {\n            sb.append(a[k]);\n        }\n        return Long.parseLong(sb.toString());",
    "        String s = Long.toString(n);\n        char[] c = s.toCharArray();\n        int i = c.length - 1;\n        while (i > 0 && c[i - 1] >= c[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = c.length - 1;\n        while (c[j] <= c[i - 1]) {\n            j--;\n        }\n        char temp = c[i - 1];\n        c[i - 1] = c[j];\n        c[j] = temp;\n        j = c.length - 1;\n        while (i < j) {\n            temp = c[i];\n            c[i] = c[j];\n            c[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(c));",
    "        // Get the digits of the number\n        List<Integer> digits = new ArrayList<>();\n        while (n > 0) {\n            digits.add((int) (n % 10));\n            n /= 10;\n        }\n        Collections.reverse(digits);\n        // Find the first digit that is smaller than the digit after it\n        int i = 0;\n        for (i = 0; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                break;\n            }\n        }\n        // If there is no such digit, then the number is already the biggest\n        if (i == digits.size() - 1) {\n            return -1;\n        }\n        // Find the smallest digit that is bigger than the digit at i\n        int j = i + 1;\n        for (int k = i + 1; k < digits.size(); k++) {\n            if (digits.get(k) > digits.get(i) && digits.get(k) < digits.get(j)) {\n                j = k;\n            }\n        }\n        // Swap the digits at i and j\n        int temp = digits.get(i);\n        digits.set(i, digits.get(j));\n        digits.set(j, temp);\n        // Sort the digits after i\n        Collections.sort(digits.subList(i + 1, digits.size()));\n        // Return the new number\n        long result = 0;\n        for (int k = 0; k < digits.size(); k++) {\n            result = result * 10 + digits.get(k);\n        }\n        return result;",
    "        // Convert to string\n        String s = Long.toString(n);\n        // Convert to char array\n        char[] chars = s.toCharArray();\n        // Find the first decreasing digit\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        // If no decreasing digit found, return -1\n        if (i <= 0) {\n            return -1;\n        }\n        // Find the smallest digit larger than the decreasing digit\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        // Swap the digits\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        // Reverse the digits after the decreasing digit\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        // Return the new number\n        return Long.parseLong(new String(chars));",
    "        String s = Long.toString(n);\n        char[] chars = s.toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i - 1] >= chars[i]) {\n            i--;\n        }\n        if (i <= 0) {\n            return -1;\n        }\n        int j = chars.length - 1;\n        while (j >= i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        char temp = chars[i - 1];\n        chars[i - 1] = chars[j];\n        chars[j] = temp;\n        j = chars.length - 1;\n        while (i < j) {\n            temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            i++;\n            j--;\n        }\n        return Long.parseLong(new String(chars));",
    "        // Convert the number to a string.\n        String number = Long.toString(n);\n        // Create a list of digits.\n        List<Integer> digits = new ArrayList<Integer>();\n        for (int i = 0; i < number.length(); i++) {\n            digits.add(Character.getNumericValue(number.charAt(i)));\n        }\n        // Find the first digit that is smaller than the digit after it.\n        int index = -1;\n        for (int i = 0; i < digits.size() - 1; i++) {\n            if (digits.get(i) < digits.get(i + 1)) {\n                index = i;\n            }\n        }\n        // If no such digit exists, return -1.\n        if (index == -1) {\n            return -1;\n        }\n        // Find the smallest digit that is larger than the digit at the index.\n        int min = digits.get(index + 1);\n        int minIndex = index + 1;\n        for (int i = index + 1; i < digits.size(); i++) {\n            if (digits.get(i) > digits.get(index) && digits.get(i) < min) {\n                min = digits.get(i);\n                minIndex = i;\n            }\n        }\n        // Swap the digits at the index and the minIndex.\n        int temp = digits.get(index);\n        digits.set(index, digits.get(minIndex));\n        digits.set(minIndex, temp);\n        // Sort the digits after the index.\n        List<Integer> sublist = digits.subList(index + 1, digits.size());\n        Collections.sort(sublist);\n        // Convert the list of digits to a string.\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < digits.size(); i++) {\n            sb.append(digits.get(i));\n        }\n        // Convert the string to a long.\n        return Long.parseLong(sb.toString());"
  ]
}