name: HumanEval_12_longest
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Out of list of strings, return the longest one. Return the first one in\
  \ case of multiple\n    // strings of the same length. Return None in case the input\
  \ list is empty.\n    // >>> longest((List[String]()))\n    // None\n    // >>>\
  \ longest((List[String](\"a\", \"b\", \"c\")))\n    // \"a\"\n    // >>> longest((List[String](\"\
  a\", \"bb\", \"ccc\")))\n    // \"ccc\"\n    def longest(strings : List[String])\
  \ : Option[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(longest((List[String]())).equals(None));\n\
  \    assert(longest((List[String](\"x\", \"y\", \"z\"))).equals(\"x\"));\n    assert(longest((List[String](\"\
  x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"))).equals(\"zzzz\"));\n    }\n\
  \n}\n"
completions: ["        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc\
    \ else s)\n            Some(longest)\n        }", "        if (strings.isEmpty)\
    \ None\n        else strings.sortWith(_ < _).lastOption", "        strings.foldLeft(List[String]())((list,\
    \ s) => {\n            if (list.length < s.length) list :+ s\n            else\
    \ list\n        })\n            .maxBy(_.length)", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => {\n                if (acc.length < s.length) acc else s\n           \
    \ })\n            Some(longest)\n        }", "        strings.foldLeft(List[String]())(\
    \ (acc, s) => acc match {\n            case Nil => Some(s)\n            case x\
    \ :: xs => if (x.length > s.length) x :: acc else acc match {\n              \
    \  case Nil => Some(x)\n                case x :: xs => if (x.length > s.length)\
    \ x :: xs else x\n            }\n        })", "        strings.length match {\n\
    \            case 0 => None\n            case 1 => strings.headOption\n      \
    \      case _ => {\n                val longest = strings.foldLeft(List[String]())((acc,\
    \ s) => {\n                    if (acc.length < s.length) acc :+ s\n         \
    \           else s\n                })\n                longest.headOption\n \
    \           }\n        }", "        strings.foldLeft(List[String]())((list, string)\
    \ => {\n            if (list.length < string.length) list :+ string\n        \
    \    else string\n        })", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.length >= str.length) list :+ str\n        \
    \    else str\n        })", "        strings.foldLeft(List[String]())( (acc, s)\
    \ => acc match {\n            case Nil => Some(s)\n            case x :: xs =>\
    \ if (x.length > s.length) x :: acc else acc match {\n                case Nil\
    \ => Some(s)\n                case x :: xs => if (x.length > s.length) x :: acc\
    \ else acc match {\n                    case Nil => Some(s)\n                \
    \    case x :: xs => x :: longest(xs)\n                }\n            }\n    \
    \    })", "        strings.foldLeft(None)( (max, str) => {\n            val len\
    \ = str.length\n            if (len > max.getOrElse(len)) {\n                Some(str)\n\
    \            } else {\n                max\n            }\n        })", "    \
    \    if (strings.length == 0) None\n        else {\n            val longest =\
    \ strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc else s)\n\
    \            Some(longest)\n        }", "        if (strings.length == 0) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (a,b) => if\
    \ (a.length < b.length) a else b )\n            strings.find(s => s == longest).getOrElse(longest)\n\
    \        }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc\
    \ else s)\n            longest.length match {\n                case 1 => Some(longest)\n\
    \                case _ => longest\n            }\n        }", "        strings.foldLeft(List[String]())((acc,\
    \ s) => {\n            if (acc.length < s.length) acc :+ s\n            else Some(s)\n\
    \        })", "        if (strings.length == 0) None\n        else {\n       \
    \     val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length)\
    \ acc else s)\n            Some(longest)\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")(_ + _.length).max\n\
    \            strings.find(_.length == longest)\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n  \
    \      }", "        strings.length match {\n            case 0 => None\n     \
    \       case _ => {\n                val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n                Some(longest)\n\
    \            }\n        }", "        strings.foldLeft(List[String]())((acc, s)\
    \ => {\n            if (acc.length < s.length) acc :+ s\n            else Some(acc)\n\
    \        })", "        if (strings.isEmpty) None\n        else {\n           \
    \ val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length)\
    \ acc else s)\n            Some(longest)\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n  \
    \      }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.maxBy(_.length)\n            if (longest.length == strings.length)\
    \ Some(longest)\n            else longest.headOption\n        }", "        if\
    \ (strings.isEmpty) None\n        else strings.foldLeft(\"\") { (longest, s) =>\n\
    \            if (longest.length < s.length) longest\n            else s\n    \
    \    }", '        strings.foldLeft(List[String]())((acc, s) => if (acc.length
    < s.length) acc else s)', "        if (strings.length == 0) None\n        else\
    \ {\n            val longest = strings.foldLeft(\"\")( (a,b) => if (a.length <\
    \ b.length) a else b )\n            strings.find( s => s == longest).map( s =>\
    \ s ).getOrElse(longest)\n        }", "        if (strings.isEmpty) None\n   \
    \     else {\n            val longest = strings.foldLeft(\"\")( (acc, s) => {\n\
    \                if (acc.length < s.length) acc else s\n            })\n     \
    \       Some(longest)\n        }", "        strings.foldLeft(List[String]())((list,\
    \ s) => {\n            if (list.length >= s.length) list :+ s\n            else\
    \ list\n        })\n            .maxBy(_.length)", '        strings.foldLeft(List[String]())(
    (acc, s) => if (acc.length < s.length) acc else s)', "        strings.foldLeft(None)\
    \ {\n            case (Some(longest), s) =>\n                if (longest.length\
    \ < s.length) Some(s) else None\n            case (None, _) => None\n        }",
  "        if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.foldLeft(List[String]())(\n            list => if\
    \ (list.length >= strings.length) list else (strings.head :: list)\n        )",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (acc, s) => {\n                if (acc.length < s.length)\
    \ acc else s\n            })\n            Some(longest)\n        }", "       \
    \ if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.foldLeft(List[String]()){ (list, s) =>\n       \
    \     if (list.length < s.length) list :+ s\n            else s\n        }.maxBy(_.length)",
  "        if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (acc, s) => {\n                if (acc.length\
    \ < s.length) acc else s\n            })\n            Some(longest)\n        }",
  "        strings.length match {\n            case 0 => None\n            case 1\
    \ => strings.headOption\n            case _ =>\n                val longest =\
    \ strings.foldLeft(List[String]())((acc, s) => {\n                    if (acc.length\
    \ < s.length) acc :+ s\n                    else s\n                })\n     \
    \           longest.headOption\n        }", "        if (strings.isEmpty) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (a,b) => if\
    \ (a.length < b.length) a else b )\n            strings.find(s => s == longest).getOrElse(longest)\n\
    \        }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc\
    \ else s)\n            Some(longest)\n        }", "        if (strings.isEmpty)\
    \ None\n        else strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length)\
    \ acc else s)", "        strings.foldLeft(List[String]())(\n            list =>\
    \ list.foldLeft(List[String]())(\n                list => list.foldLeft(List[String]())(\n\
    \                    list => list.foldLeft(List[String]())(\n                \
    \        list => list.foldLeft(List[String]())(\n                            list\
    \ => list.foldLeft(List[String]())(\n                                list => list.foldLeft(List[String]())(\n\
    \                                    list => list.foldLeft(List[String]())(\n\
    \                                        list => list.foldLeft(List[String]())(\n\
    \                                            list => list.foldLeft(List[String]())(\n\
    \                                                list => list.foldLeft(List[String]())(\n\
    \                                                    list => list.foldLeft(List[String]())(\n\
    \                                                        list => list.foldLeft(List[String]())(\n\
    \                                                            list => list.foldLeft(List[String]())(\n\
    \                                                                list => list.foldLeft(List[String]())(\n\
    \                                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                        list\
    \ => list.foldLeft(List[String]())(\n                                        \
    \                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \    list => list.foldLeft(List[String]())(\n                                \
    \                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \            list => list.foldLeft(List[String]())(\n                        \
    \                                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                    list => list.foldLeft(List[String]())(\n                \
    \                                                                            \
    \        list => list.foldLeft(List[String]())(\n                            \
    \                                                                            list\
    \ => list.foldLeft(List[String]())(\n                                        \
    \                                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                        list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                            list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                        list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                            list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                                list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                                    list => list.foldLeft(List[String]())(\n",
  "        if (strings.isEmpty) None\n        else strings.foldLeft(\"\")( (max: String,\
    \ current: String) => if (current.length() > max.length) max else current)", " \
    \       strings.foldLeft(None)( (acc, s) => acc match {\n            case None\
    \ => Some(s)\n            case Some(acc) => if (acc.length < s.length) Some(s)\
    \ else acc\n        })", "        if (strings.isEmpty) None\n        else {\n\
    \            val longest = strings.foldLeft(\"\")(_ + _.length).max\n        \
    \    strings.find(_.length == longest)\n        }", "        strings.foldLeft(List[String]())((list,\
    \ s) => {\n            if (list.length < s.length) list :+ s\n            else\
    \ list\n        })\n            .maxBy(_.length)", "        if (strings.isEmpty)\
    \ None\n        else strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length)\
    \ acc else s)", '        strings.foldLeft(List[String]())((acc, s) => if (acc.length
    < s.length) acc else s)', "        if (strings.isEmpty) None\n        else strings.foldLeft(strings.head)\
    \ {\n            case (longest, string) =>\n                if (string.length\
    \ == longest.length) string\n                else if (string.length == longest.length\
    \ + 1) string\n                else longest\n        }", "        strings.foldLeft(List[String]())((list,\
    \ string) => {\n            if (list.length < string.length) list :+ string\n\
    \            else string\n        })", "        if (strings.length == 0) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)\n            Some(longest)\n        }",
  "        strings.foldLeft(List[String]()){\n            case (acc, str) => if (acc.length\
    \ < str.length) acc :+ str else str\n        }.maxBy(_.length)", "        strings.foldLeft(List[String]()){\
    \ (list, s) =>\n            if (list.length < s.length) list :+ s\n          \
    \  else s\n        }.maxBy(_.length)", "        if (strings.isEmpty) None\n  \
    \      else strings.foldLeft(\"\")( (a,b) => if (a.length < b.length) a else b\
    \ )", "        if (strings.length == 0) None\n        else {\n            val\
    \ longest = strings.sortWith(_ < _).last\n            if (longest.length == strings.length)\
    \ Some(longest)\n            else longest.headOption\n        }", "        strings.foldLeft(List[String]())((list,\
    \ s) => {\n            if (list.isEmpty || s.length == list.last.length) list\
    \ :+ s\n            else list :+ s\n        })", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => {\n                if (acc.length < s.length) acc else s\n           \
    \ })\n            Some(longest)\n        }", "        if (strings.isEmpty) None\n\
    \        else strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc\
    \ else s)", "        strings.foldLeft(List[String]())((list, str) => {\n     \
    \       val len = str.length\n            if (len > list.last.length) list :+\
    \ str\n            else list\n        })\n            .maxBy(_.length)", "   \
    \     if (strings.length == 0) None\n        else {\n            val longest =\
    \ strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc else s)\n\
    \            Some(longest)\n        }", '        strings.foldLeft(List[String]())((acc,
    s) => if (acc.length < s.length) acc else s)', "        if (strings.isEmpty) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (a,b) => if\
    \ (a.length < b.length) a else b )\n            strings.find(s => s == longest).getOrElse(longest)\n\
    \        }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc\
    \ else s)\n            Some(longest)\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (a,b)\
    \ => if (a.length < b.length) a else b )\n            strings.find(s => s == longest).getOrElse(longest)\n\
    \        }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc\
    \ else s)\n            Some(longest)\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (a,\
    \ b) => if (a.length < b.length) a else b )\n            strings.find(s => s ==\
    \ longest).getOrElse(longest)\n        }", '        strings.foldLeft(List[String]())((list,
    s) => if (list.size < s.length) list :+ s else list)', "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n  \
    \      }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc\
    \ else s)\n            Some(longest)\n        }", "        strings.foldLeft(List[String]())(\n\
    \            (acc, s) => acc match {\n                case Nil => Some(s)\n  \
    \              case x :: xs => if (x.length > s.length) x :: xs else s :: xs\n\
    \            }\n        )", "        if (strings.isEmpty) None\n        else {\n\
    \            val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n            Some(longest)\n        }", "        strings.foldLeft(List[String]())((list,\
    \ s) => {\n            if (list.length < s.length) list :+ s\n            else\
    \ list\n        })\n            .maxBy(_.length)", "        if (strings.isEmpty)\
    \ None\n        else strings.foldLeft(strings.head)((max, str) => if (str.length\
    \ >= max.length) str else max)", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.length < str.length) list :+ str\n         \
    \   else str\n        })", "        if (strings.isEmpty) None\n        else {\n\
    \            val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n            Some(longest)\n        }", "        if\
    \ (strings.length == 0) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.foldLeft(List[String]())((list, str) => {\n    \
    \        if (list.length < str.length) list :+ str\n            else str\n   \
    \     })", "        strings.foldLeft(List[String]())(\n            (acc, s) =>\
    \ if (acc.length < s.length) acc else s\n        )", "        if (strings.isEmpty)\
    \ None\n        else strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length)\
    \ acc else s)", "        strings.length match {\n            case 0 => None\n\
    \            case _ => {\n                val longest = strings.foldLeft(\"\"\
    )( (acc, s) => {\n                    if (acc.length < s.length) acc else s\n\
    \                })\n                Some(longest)\n            }\n        }",
  "        strings.foldLeft(List[String]())((list, s) => {\n            if (list.length\
    \ < s.length) list :+ s\n            else list\n        })\n            .maxBy(_.length)",
  "        if (strings.isEmpty) None\n        else strings.foldLeft(strings.headOption)((max:\
    \ Option[String], s: String) => if (max.isEmpty || s.length >= max.length) Some(s)\
    \ else max)", "        strings.foldLeft(List[String]())((list, str) => list match\
    \ {\n            case Nil => Some(str)\n            case head :: tail => if (head.length\
    \ == str.length) head :: list else str\n        })", "        strings.foldLeft(List[String]())((list,\
    \ string) => {\n            val length = string.length\n            if (list.length\
    \ < length) list :+ string\n            else if (list.length == length) list :+\
    \ string\n            else None\n        })", "        if (strings.isEmpty) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ {\n                if (acc.length < s.length) acc else s\n            })\n \
    \           Some(longest)\n        }", "        strings.length match {\n     \
    \       case 0 => None\n            case _ => {\n                val longest =\
    \ strings.foldLeft(\"\")( (acc, s) => {\n                    if (acc.length <\
    \ s.length) acc else s\n                })\n                Some(longest)\n  \
    \          }\n        }", "        strings.foldLeft(List[String]())((list, str)\
    \ => {\n            if (list.length < str.length) list :+ str\n            else\
    \ str\n        })", "        if (strings.isEmpty) None\n        else strings.foldLeft(\"\
    \") { (longest, s) =>\n            if (longest.length < s.length) longest\n  \
    \          else s\n        }", "        strings.foldLeft(List[String]()){ (list,\
    \ s) =>\n            val length = s.length\n            if (list.length < length)\
    \ list :+ s\n            else if (list.length == length) Some(list.last)\n   \
    \         else None\n        }", "        strings.foldLeft(List[String]())((list,\
    \ s) => {\n            if (list.length < s.length) list :+ s\n            else\
    \ list\n        })\n            .maxBy(_.length)", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (a,\
    \ b) => if (a.length < b.length) a else b )\n            strings.find(s => s ==\
    \ longest) match {\n                case Some(longest) => Some(longest)\n    \
    \            case None => None\n            }\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n  \
    \      }", "        if (strings.length == 0) None\n        else {\n          \
    \  val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length)\
    \ acc else s)\n            Some(longest)\n        }", "        if (strings.isEmpty)\
    \ None\n        else strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length)\
    \ acc else s)", "        if (strings.isEmpty) None\n        else strings.foldLeft(strings.headOption)((max,\
    \ s) => if (s.length >= max.length) max else Some(s))", "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.foldLeft(\"\"\
    )( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        if (strings.length == 0) None\n        else {\n        \
    \    val longest = strings.sortWith(_ < _).last\n            if (longest.length\
    \ == strings.length) Some(longest)\n            else longest.headOption\n    \
    \    }", "        if (strings.isEmpty) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc else s)\n\
    \            Some(longest)\n        }", "        if (strings.isEmpty) None\n \
    \       else {\n            val longest = strings.foldLeft(\"\")( (a, b) => if\
    \ (a.length < b.length) a else b )\n            strings.find(s => s == longest).getOrElse(longest)\n\
    \        }", "        strings.foldLeft((\"\", List[String]()))((acc, elem) =>\
    \ {\n            val length = elem.length\n            val newLength = acc._1.length\
    \ + length\n            if (newLength > acc._2.length) {\n                (elem,\
    \ acc._2)\n            } else {\n                (elem.substring(0, newLength),\
    \ acc._2 :+ elem)\n            }\n        })", '        strings.foldLeft(List[String]())((acc,
    s) => if (acc.length < s.length) acc else s)', "        strings.foldLeft(List[String]())((list,\
    \ str) => list match {\n            case Nil => Some(str)\n            case _\
    \ => if (str.length >= list.length) str else list\n        })", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.length >= str.length) {\n                list\
    \ :+ str\n            } else {\n                list\n            }\n        }).maxBy(_.length)",
  "        strings.length match {\n            case 0 => None\n            case _\
    \ => {\n                val longest = strings.foldLeft(\"\")( (acc, s) => {\n\
    \                    if (acc.length < s.length) acc else s\n                })\n\
    \                Some(longest)\n            }\n        }", "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.foldLeft(List[String]())((acc,\
    \ s) => {\n                if (acc.length < s.length) acc :+ s\n             \
    \   else acc\n            })\n            if (longest.length == strings.length)\
    \ longest.headOption\n            else longest.headOption\n        }", "     \
    \   strings.foldLeft(List[String]())( (list, string) => {\n            if (list.length\
    \ < string.length) list :+ string\n            else string\n        })", '        strings.foldLeft(List[String]())((acc,
    s) => if (acc.length < s.length) acc else s)', "        strings.length match {\n\
    \            case 0 => None\n            case 1 => strings.headOption\n      \
    \      case _ => {\n                val maxLength = strings.foldLeft(Int.MaxValue)(_\
    \ + _.length)\n                strings.find(_.length == maxLength)\n         \
    \   }\n        }", "        strings.foldLeft(None: Option[String]){\n        \
    \    case (Some(longest), string) =>\n                string.size match {\n  \
    \                  case 1 => Some(longest)\n                    case _ => Some(longest\
    \ + string)\n                }\n            case (None, string) => Some(string)\n\
    \        }", "        strings.foldLeft(List[String]())((list, s) => {\n      \
    \      if (list.length < s.length) list :+ s\n            else Some(s)\n     \
    \   })", "        strings.foldLeft(List[String]())(\n            list => list\
    \ match {\n                case Nil => None\n                case head :: tail\
    \ => if (head.length == list.length) head else longest(tail)\n            }\n\
    \        )", "        strings.foldLeft(List[String]())((list, str) => {\n    \
    \        if (list.length < str.length) list :+ str\n            else str\n   \
    \     })", "        strings.foldLeft(List[String]())((list, str) => {\n      \
    \      if (list.length < str.length) list :+ str\n            else str\n     \
    \   })", "        strings.foldLeft(List[String]())((list, str) => {\n        \
    \    if (list.length < str.length) list :+ str\n            else str\n       \
    \ })", "        strings.foldLeft(List[String]()){\n            (acc, s) =>\n \
    \               if (acc.length < s.length) acc :+ s\n                else s\n\
    \        }.maxBy(_.length)", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            val len = str.length\n            if (len > list.size)\
    \ {\n                list :+ str\n            } else {\n                list\n\
    \            }\n        })\n            .maxBy(_.length)", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n  \
    \      }", "        strings.foldLeft(List[String]())((list, str) => {\n      \
    \      if (list.length == 0) list :+ str\n            else {\n               \
    \ if (list.length < str.length) list :+ str\n                else list\n     \
    \       }\n        }).maxBy(_.length)", "        if (strings.isEmpty) None\n \
    \       else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)\n            Some(longest)\n        }",
  "        if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        if (strings.isEmpty) None\n        else strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n  \
    \      }", "        strings.foldLeft(None)( (acc, str) => acc match {\n      \
    \      case None => Some(str)\n            case Some(acc) => if (acc.length <\
    \ str.length) Some(str) else acc\n        })", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.length >= str.length) list :+ str\n        \
    \    else str\n        })", "        if (strings.isEmpty) None\n        else strings.foldLeft(List[String]())((list,\
    \ string) => {\n            if (list.length == string.length) list :+ string\n\
    \            else list\n        })", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.length < str.length) {\n                list\
    \ :+ str\n            } else {\n                list\n            }\n        }).maxBy(_.length)",
  "        if (strings.isEmpty) None\n        else strings.maxBy(_.length)", "   \
    \     strings.foldLeft(List[String]())((acc, s) => {\n            if (acc.length\
    \ < s.length) acc :+ s\n            else acc\n        })", "        strings.length\
    \ match {\n            case 0 => None\n            case 1 => strings.headOption\n\
    \            case _ => {\n                val longest = strings.foldLeft(\"\"\
    )( (acc, s) => {\n                    if (acc.length < s.length) acc else s\n\
    \                })\n                Some(longest)\n            }\n        }",
  "        if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.foldLeft(List[String]())((acc, s) => {\n       \
    \     if (acc.length < s.length) acc :+ s\n            else Some(acc)\n      \
    \  })", "        if (strings.length == 0) None\n        else strings.foldLeft(strings(0))((max,\
    \ str) => if (str.length >= max.length) max else str)", "        strings.foldLeft(List[String]())((list,\
    \ s) => {\n            val l = list.size\n            if (l > 0 && s.length ==\
    \ l(list.last)) {\n                list.last :: s\n            } else {\n    \
    \            list :+ s\n            }\n        })\n            .maxBy(_.length)",
  '        strings.foldLeft(List[String]())((acc, s) => if (acc.length < s.length)
    acc else s)', "        if (strings.isEmpty) None\n        else strings.foldLeft(\"\
    \")( (a,b) => if (a.length < b.length) a else b)", "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.foldLeft(\"\"\
    )( (a,b) => if (a.length < b.length) a else b )\n            strings.find(s =>\
    \ s == longest).getOrElse(longest)\n        }", "        if (strings.length ==\
    \ 0) None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n  \
    \      }", "        strings.foldLeft(List[String]())((acc, s) => acc match {\n\
    \            case Nil => Some(s)\n            case x :: xs => if (s.length() >\
    \ x.length()) Some(s) else x\n        })", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            val len = str.length\n            if (list.exists(_.length\
    \ == len)) {\n                list.find(_.length == len).getOrElse(str)\n    \
    \        } else {\n                list :+ str\n            }\n        })", " \
    \       strings.foldLeft(List[String]())((list, str) => {\n            if (list.length\
    \ == 0 || list.length == str.length) {\n                list :+ str\n        \
    \    } else {\n                if (list.length < str.length) {\n             \
    \       list :+ str\n                } else {\n                    list\n    \
    \            }\n            }\n        })", "        strings.foldLeft(List[String]())((acc,\
    \ s) => {\n            if (acc.length < s.length) acc :+ s\n            else acc\n\
    \        })\n            .maxBy(_.length)", "        strings.foldLeft(List[String]())((acc,\
    \ s) => {\n            if (acc.length < s.length) acc :+ s\n            else Some(s.substring(acc.length))\n\
    \        })", "        if (strings.isEmpty) None\n        else {\n           \
    \ val longest = strings.foldLeft(\"\")( (acc, s) => {\n                if (acc.length\
    \ < s.length) acc else s\n            })\n            Some(longest)\n        }",
  "        strings.foldLeft(List[String]()){\n            case (acc, s) => if (acc.length\
    \ < s.length) acc :+ s else acc\n        }.maxBy(_.length)", "        if (strings.isEmpty)\
    \ None\n        else strings.foldLeft(\"\") {\n            case (acc, s) => if\
    \ (acc.length < s.length) acc else s}", "        strings.foldLeft(List[String]())((acc,\
    \ s) => acc match {\n            case Nil => Some(s)\n            case x :: xs\
    \ => if (s.length() > acc.length()) Some(s) else acc\n        })", "        if\
    \ (strings.isEmpty) None\n        else strings.foldLeft(\"\") {\n            case\
    \ (acc, s) => if (acc.length < s.length) acc else s}", "        strings.foldLeft(List[String]())((list,\
    \ s) => {\n            if (list.length < s.length) list :+ s\n            else\
    \ list\n        })\n            .maxBy(_.length)", '        strings.foldLeft(List[String]())((acc,
    s) => if (acc.length < s.length) acc else s)', "        if (strings.isEmpty) None\n\
    \        else strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc\
    \ else s)", "        strings.foldLeft(List[String]())((list, s) => {\n       \
    \     if (list.length < s.length) list :+ s\n            else s\n        })",
  "        if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.foldLeft(List[String]())((list, str) => {\n    \
    \        if (list.length >= str.length) list :+ str\n            else str\n  \
    \      })", "        strings.foldLeft(List[String]())((list, string) => {\n  \
    \          if (list.length < string.length) list :+ string\n            else list\n\
    \        })", "        if (strings.length == 0) None\n        else {\n       \
    \     val longest = strings.sortWith(_ < _).last\n            if (longest.length\
    \ == strings.length) Some(longest)\n            else longest.headOption\n    \
    \    }", "        if (strings.isEmpty) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc else s)\n\
    \            Some(longest)\n        }", "        if (strings.length == 0) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)\n            Some(longest)\n        }",
  '        strings.foldLeft(List[String]())( (acc, s) => if (acc.length < s.length)
    acc else s)', "        strings.length match {\n            case 0 => None\n  \
    \          case _ => {\n                val longest = strings.foldLeft(\"\")(_\
    \ + _.length).max\n                strings.find(_.length == longest)\n       \
    \     }\n        }", "        if (strings.isEmpty) None\n        else {\n    \
    \        val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length)\
    \ acc else s)\n            Some(longest)\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n  \
    \      }", "        strings.foldLeft(List[String]())((list, str) => {\n      \
    \      if (list.length < str.length) {\n                list :+ str\n        \
    \    } else {\n                list\n            }\n        }).maxBy(_.length)",
  "        if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        if (strings.isEmpty) None\n        else strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (a,b)\
    \ => if (a.length < b.length) a else b )\n            strings.find(s => s == longest).getOrElse(longest)\n\
    \        }", "        if (strings.length == 0) None\n        else {\n        \
    \    val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length)\
    \ acc else s)\n            Some(longest)\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n  \
    \      }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc\
    \ else s)\n            Some(longest)\n        }", '        strings.foldLeft(List[String]())((acc,
    s) => if (acc.length < s.length) acc else s)']
stop_tokens:
- "\n    }\n"
