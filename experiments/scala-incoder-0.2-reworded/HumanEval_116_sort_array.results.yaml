language: scala
name: HumanEval_116_sort_array
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimal = onesCount / arr.length\n        val zerosDecimal\
    \ = zerosCount / arr.length\n        val onesDecimalDecimal = onesDecimal / zerosDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal / onesDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal / onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zeros\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg_wil_yj.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg_wil_yj.scala:31:68\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m                                                                    ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg_wil_yj.scala:34:76\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg_wil_yj.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659795002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => 1l).sum\n        val zerosCount = zeros.map(x => 1l).sum\n        val onesDecimal\
    \ = ones.map(x => x.toString.toLong).sum\n        val zerosDecimal = zeros.map(x\
    \ => x.toString.toLong).sum\n        val onesDecimalDecimal = onesDecimal.toString.toLong\n\
    \        val zerosDecimalDecimal = zerosDecimal.toString.toLong\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal.toString.toLong\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal.toString.toLong\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal.toString.toLong\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal.toString.toLong\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal.toString.toLong\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal.toString.toLong\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal.toString.toLong\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal.toString.toLong\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal.toString.toLong\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toString.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal.toString.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toString.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toString.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toString.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpic78nxz_.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimal.toString.toLong\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpic78nxz_.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal.toString.toLong\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpic78nxz_.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimal.toString.toLong\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Nam"
  stdout: ''
  timestamp: 1659795002
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesCount = onesArr.size\n        val zerosCount = zerosArr.size\n        if\
    \ (onesCount > zerosCount) {\n            onesArr\n        } else if (zerosCount\
    \ > onesCount) {\n            zerosArr\n        } else {\n            onesArr.zip(zerosArr).sortBy(_._1).map(_._2)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpelooj4yq.scala:30)\n\tat Problem.main(tmpelooj4yq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795004
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = arr.count(_ == 1).map(_.toString.toInt)\n\
    \        val zerosDecimal = arr.count(_ == 0).map(_.toString.toInt)\n        val\
    \ onesDecimalCount = arr.count(_ == 1).map(_.toString.toInt)\n        val zerosDecimalCount\
    \ = arr.count(_ == 0).map(_.toString.toInt)\n        val onesDecimalCount = arr.count(_\
    \ == 1).map(_.toString.toInt)\n        val zerosDecimalCount = arr.count(_ ==\
    \ 0).map(_.toString.toInt)\n        val onesDecimalCount = arr.count(_ == 1).map(_.toString.toInt)\n\
    \        val zerosDecimalCount = arr.count(_ == 0).map(_.toString.toInt)\n   \
    \     val onesDecimalCount = arr.count(_ == 1).map(_.toString.toInt)\n       \
    \ val zerosDecimalCount = arr.count(_ == 0).map(_.toString.toInt)\n        val\
    \ onesDecimalCount = arr.count(_ == 1).map(_.toString.toInt)\n        val zerosDecimalCount\
    \ = arr.count(_ == 0).map(_.toString.toInt)\n        val onesDecimalCount = arr.count(_\
    \ == 1).map(_.toString.toInt)\n        val zerosDecimalCount = arr.count(_ ==\
    \ 0).map(_.toString.toInt)\n        val onesDecimalCount = arr.count(_ == 1).map(_.toString.toInt)\n\
    \        val zerosDecimalCount = arr.count(_ == 0).map(_.toString.toInt)\n   \
    \     val onesDecimalCount = arr.count(_ == 1).map(_.toString.toInt)\n       \
    \ val zerosDecimalCount = arr.count(_ == 0).map(_.toString.toInt)\n        val\
    \ onesDecimalCount = arr.count(_ == 1).map(_.toString.toInt)\n        val zerosDecimalCount\
    \ = arr.count(_ == 0).map(_.toString.toInt)\n        val onesDecimalCount = arr.count(_\
    \ == 1).map(_.toString.toInt)\n        val zerosDecimalCount = arr.count(_ ==\
    \ 0).map(_.toString.toInt)\n        val onesDecimalCount = arr.count(_ == 1).map(_.toString.toInt)\n\
    \        val zerosDecimalCount = arr.count(_ == 0).map(_.toString.toInt)\n   \
    \     val onesDecimalCount = arr.count(_ == 1).map(_.toString.toInt)\n       \
    \ val zerosDecimalCount = arr.count(_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxjej6n48.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxjej6n48.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalCount\e[0m = arr.count(_ == \e[31m1\e[0m).map(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxjej6n48.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ arr.count(_ == \e[31m0\e[0m).map(_.toString.toInt)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxjej6n48.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = arr.count(_\
    \ == \e[31m1\e[0m).map(_.toString.toInt)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxjej6n48.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ arr.count(_ == \e[31m0\e[0m).map(_.toString.toInt)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m "
  stdout: ''
  timestamp: 1659795003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpn70zza00.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpn70zza00.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpn70zza00.scala:33:75 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                   ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659795003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZerosList\
    \ = onesZeros :: arr.filter(_ != 0).toList\n        val onesZerosListSorted =\
    \ onesZerosList.toList.sortBy(_ / onesZeros)\n        val onesZerosListSortedReversed\
    \ = onesZerosListSorted.reverse\n        val onesZerosListSortedReversedSorted\
    \ = onesZerosListSortedReversed.sortBy(_ / onesZeros)\n        val onesZerosListSortedReversedSortedReversed\
    \ = onesZerosListSortedReversedSorted.reverse\n        val onesZerosListSortedReversedSortedReversedSorted\
    \ = onesZerosListSortedReversedSortedReversed.sortBy(_ / onesZeros)\n        val\
    \ onesZerosListSortedReversedSortedReversedSortedReversed = onesZerosListSortedReversedSortedReversedSorted.reverse\n\
    \        val onesZerosListSortedReversedSortedReversedSortedReversedSorted = onesZerosListSortedReversedSortedReversedSortedReversedSorted.sortBy(_\
    \ / onesZeros)\n        val onesZerosListSortedReversedSortedReversedSortedReversedSortedReversed\
    \ = onesZerosListSortedReversedSortedReversedSortedReversedSorted.reverse\n  \
    \      val onesZerosListSortedReversedSortedReversedSortedReversedSortedReversedSorted\
    \ = onesZerosListSortedReversedSortedReversedSortedReversedSortedReversed.sortBy(_\
    \ / onesZeros)\n        val onesZerosListSortedReversedSortedReversedSortedReversedSortedReversedSortedReversed\
    \ = onesZerosListSortedReversedSortedReversedSortedReversedSortedReversedSortedReversedSorted.reverse\n\
    \        val onesZerosListSortedReversedSortedReversedSortedReversedSortedReversedSortedReversedSorted\
    \ = onesZerosListSortedReversedSortedReversedSortedReversedSortedReversedSortedReversedSortedReversed.sortBy(_\
    \ / onesZeros)\n        val onesZerosListSortedReversedSortedReversedSortedReversedSortedReversedSortedReversedSorted\
    \ = onesZerosListSortedReversedSortedReversedSortedReversedSortedReversedSortedReversedSortedReversed.sortBy(_\
    \ / onesZeros)\n        val onesZerosListSortedReversedSortedReversedSortedReversedSortedReversedSortedReversedSortedReversedSorted\
    \ = onesZerosListSortedReversedSortedReversedSorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxp_8f_fy.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36monesZerosListSortedReversedSortedReversedSortedReversedSortedReversedSortedReversedSorted\e\
    [0m = onesZerosListSortedReversedSortedReversedSortedReversedSortedReversedSortedReversedSortedReversed.sortBy(_\
    \ / onesZeros)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZerosListSortedReversedSortedReversedSortedReversedSortedReversedSortedReversedSorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZerosListSortedReversedSortedReversedSortedReversedSortedReversedSortedReversedSorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpxp_8f_fy.scala:19:64 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesZerosListSorted\e[0m\
    \ = onesZerosList.toList.sortBy(_ / onesZeros)\n\e[31m\e[31m   |\e[0m        \
    \                                                      ^^^\e[0m\n\e[31m   |\e\
    [0mvalue / is not a member of AnyVal, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpxp_8f_fy.scala:19:76 -----------------------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesZerosListSorted\e[0m = onesZerosList.toList.sortBy(_\
    \ / onesZeros)\n\e[31m\e[31m   |\e[0m                                        \
    \                                    ^\e[0m\n\e[31m   |\e[0mambiguous given instances:\
    \ both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35"
  stdout: ''
  timestamp: 1659795003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal.toDouble\
    \ / Math.pow(10, onesDecimalDecimal)\n        val zerosDecimalDecimalDecimal =\
    \ zerosDecimalDecimal.toDouble / Math.pow(10, zerosDecimalDecimal)\n        val\
    \ onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, onesDecimalDecimalDecimal)\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal.toDouble / Math.pow(10, zerosDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, onesDecimalDecimalDecimalDecimal)\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal.toDouble / Math.pow(10, zerosDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, onesDecimalDecimalDecimalDecimalDecimal)\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal.toDouble / Math.pow(10, zerosDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, onesDecimalDecimalDecimalDecimalDecimalDecimal)\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimalDecimalDecimalDecimalDecimal)\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, onesDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwdvmdp4o.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwdvmdp4o.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(\e[31m10\e[0m, zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpwdvmdp4o.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(\e[31m10\e[0m, onesDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpwdvmdp4o.scala:25:47 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mone"
  stdout: ''
  timestamp: 1659795002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo01fl7_i.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo01fl7_i.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpo01fl7_i.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659795002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(_.toLong).count(_\
    \ == 1)\n        val zerosCount = zeros.map(_.toLong).count(_ == 0)\n        val\
    \ onesDecimal = ones.map(_.toLong).map(_.toString.toDouble).sum\n        val zerosDecimal\
    \ = zeros.map(_.toLong).map(_.toString.toDouble).sum\n        val onesDecimalCount\
    \ = ones.map(_.toLong).map(_.toString.toDouble).count(_ == 1)\n        val zerosDecimalCount\
    \ = zeros.map(_.toLong).map(_.toString.toDouble).count(_ == 0)\n        val onesDecimalCount\
    \ = ones.map(_.toLong).map(_.toString.toDouble).count(_ == 1)\n        val zerosDecimalCount\
    \ = zeros.map(_.toLong).map(_.toString.toDouble).count(_ == 0)\n        val onesDecimalCount\
    \ = ones.map(_.toLong).map(_.toString.toDouble).count(_ == 1)\n        val zerosDecimalCount\
    \ = zeros.map(_.toLong).map(_.toString.toDouble).count(_ == 0)\n        val onesDecimalCount\
    \ = ones.map(_.toLong).map(_.toString.toDouble).count(_ == 1)\n        val zerosDecimalCount\
    \ = zeros.map(_.toLong).map(_.toString.toDouble).count(_ == 0)\n        val onesDecimalCount\
    \ = ones.map(_.toLong).map(_.toString.toDouble).count(_ == 1)\n        val zerosDecimalCount\
    \ = zeros.map(_.toLong).map(_.toString.toDouble).count(_ == 0)\n        val onesDecimalCount\
    \ = ones.map(_.toLong).map(_.toString.toDouble).count(_ == 1)\n        val zerosDecimalCount\
    \ = zeros.map(_.toLong).map(_.toString.toDouble).count(_ == 0)\n        val onesDecimalCount\
    \ = ones.map(_.toLong).map(_.toString.toDouble).count(_ == 1)\n        val zerosDecimalCount\
    \ = zeros.map(_.toLong).map(_.toString.toDouble).count(_ == 0)\n        val onesDecimalCount\
    \ = ones.map(_.toLong).map(_.toString.toDouble).count(_ == 1)\n        val zerosDecimalCount\
    \ = zeros.map(_.toLong).map(_.toString.toDouble).count(_ == 0)\n        val onesDecimalCount\
    \ = ones.map(_.toLong).map(_.toString.toDouble).count(_ == 1)\n        val zerosDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3rxuey8p.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3rxuey8p.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalCount\e[0m = ones.map(_.toLong).map(_.toString.toDouble).count(_\
    \ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3rxuey8p.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zeros.map(_.toLong).map(_.toString.toDouble).count(_ == \e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35mzerosDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3rxuey8p.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ ones.map(_.toLong).map(_.toString.toDouble).count(_ == \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3rxuey8p.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zeros.map(_.toLong).map(_.toString.toDo"
  stdout: ''
  timestamp: 1659795003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArray = arr.map(x => if (x == 1) 1 else 0)\n\
    \        val zerosArray = arr.map(x => if (x == 0) 0 else 1)\n        val onesArraySorted\
    \ = onesArray.sortWith(_ < _)\n        val zerosArraySorted = zerosArray.sortWith(_\
    \ < _)\n        val sortedArray = onesArraySorted.zip(zerosArraySorted).sortWith(_._1\
    \ < _._1)\n        sortedArray.map(x => x._2).reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxupoivdc.scala:22:35\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        sortedArray.map(\e[36mx\e\
    [0m => x._2).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => 1l).sum\n        val zerosCount = zeros.map(x => 0l).sum\n        val onesDecimal\
    \ = onesCount / 2\n        val zerosDecimal = zerosCount / 2\n        val onesDecimalDecimal\
    \ = onesDecimal / 2\n        val zerosDecimalDecimal = zerosDecimal / 2\n    \
    \    val onesDecimalDecimalDecimal = onesDecimalDecimal / 2\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal / 2\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 2\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 2\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmplh2x9c6x.scala:39:88 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \                          expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmplh2x9c6x.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / \e[31m2\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplh2x9c6x.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmplh2x9"
  stdout: ''
  timestamp: 1659795002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong).length\n\
    \        val zeros = arr.filter(x => x == 0l.toLong).length\n        val onesZeros\
    \ = ones + zeros\n        val onesZeroArray = Array.ofDim[Long](onesZeros)\n \
    \       val onesZeroArrayCopy = onesZeroArray.clone()\n        val onesZeroArrayCopySorted\
    \ = onesZeroArrayCopy.sortWith(_ < _)\n        val onesZeroArraySortedCopy = onesZeroArrayCopySorted.clone()\n\
    \        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySortedCopy = onesZeroArraySortedCopySorted.clone()\n\
    \        val onesZeroArraySortedCopySortedCopy = onesZeroArraySortedCopySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySortedCopySorted = onesZeroArraySortedCopySortedCopySorted.clone()\n\
    \        val onesZeroArraySortedCopySortedCopySorted = onesZeroArraySortedCopySortedCopySorted.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySortedCopySorted = onesZeroArraySortedCopySortedCopySorted.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySortedCopySorted = onesZeroArraySortedCopySortedCopySorted.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySortedCopySorted = onesZeroArraySortedCopySortedCopySorted.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySortedCopySorted = onesZeroArraySortedCopySortedCopySorted.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySortedCopySorted = onesZeroArraySortedCopySortedCopySorted.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySortedCopySorted = onesZeroArraySortedCopySortedCopySorted.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySortedCopySorted = onesZeroArraySortedCopySortedCopySorted.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySortedCopySorted = onesZeroArraySortedCopySortedCopySorted.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySortedCopySorted = onesZeroArraySortedCopySortedCopySorted.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySortedCopySorted = \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfmjwdud_.scala:36:53 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36monesZeroArraySortedCopySortedCopySorted\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \     ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpfmjwdud_.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeroArraySortedCopySortedCopy\e[0m =\
    \ onesZeroArraySortedCopySortedCopy.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroArraySortedCopySortedCopy is already defined as \e\
    [33mvalue\e[0m \e[35monesZeroArraySortedCopySortedCopy\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfmjwdud_.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroArraySortedCopySortedCopySorted\e[0m = onesZeroArraySortedCopySortedCopySorted.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroArraySortedCopySortedCopySorted is already defined\
    \ as \e[33mvalue\e[0m \e[35monesZeroArraySortedCopySortedCopySorted\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpfmjwdud_.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeroArraySortedCopySortedCopySorted\e\
    [0m = onesZeroArraySortedCopySortedCopySorted.sortWith(_ < _)\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |"
  stdout: ''
  timestamp: 1659795002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesZeros = ones + zeros\n        val onesZeroArr = onesZeros.map(x => x ->\
    \ 1).toMap\n        val zerosArr = zerosArr.map(x => x -> 0).toMap\n        val\
    \ onesZeroArr = onesZeros.map(x => x -> 1).toMap\n        val onesZeroArr = onesZeros.map(x\
    \ => x -> 1).toMap\n        val onesZeroArr = onesZeros.map(x => x -> 1).toMap\n\
    \        val onesZeroArr = onesZeros.map(x => x -> 1).toMap\n        val onesZeroArr\
    \ = onesZeros.map(x => x -> 1).toMap\n        val onesZeroArr = onesZeros.map(x\
    \ => x -> 1).toMap\n        val onesZeroArr = onesZeros.map(x => x -> 1).toMap\n\
    \        val onesZeroArr = onesZeros.map(x => x -> 1).toMap\n        val onesZeroArr\
    \ = onesZeros.map(x => x -> 1).toMap\n        val onesZeroArr = onesZeros.map(x\
    \ => x -> 1).toMap\n        val onesZeroArr = onesZeros.map(x => x -> 1).toMap\n\
    \        val onesZeroArr = onesZeros.map(x => x -> 1).toMap\n        val onesZeroArr\
    \ = onesZeros.map(x => x -> 1).toMap\n        val onesZeroArr = onesZeros.map(x\
    \ => x -> 1).toMap\n        val onesZeroArr = onesZeros.map(x => x -> 1).toMap\n\
    \        val onesZeroArr = onesZeros.map(x => x -> 1).toMap\n        val onesZeroArr\
    \ = onesZeros.map(x => x -> 1).toMap\n        val onesZeroArr = onesZeros.map(x\
    \ => x -> 1).toMap\n        val onesZeroArr = onesZeros.map(x => x -> 1).toMap\n\
    \        val onesZeroAr\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvk2st80o.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvk2st80o.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosArr\e[0m = zerosArr.map(\e[36mx\e[0m => x -> \e[31m0\e[0m).toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArr is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvk2st80o.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr\e[0m = onesZeros.map(\e\
    [36mx\e[0m => x -> \e[31m1\e[0m).toMap\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroArr is already defined as \e[33mvalue\e[0m \e[35monesZeroArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvk2st80o.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr\e[0m = onesZeros.map(\e\
    [36mx\e[0m => x -> \e[31m1\e[0m).toMap\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroArr is already defined as \e[33mvalue\e[0m \e[35monesZeroArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvk2st80o.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr\e[0m = onesZeros.map(\e\
    [36mx\e[0m => x -> \e[31m1\e[0m).toMap\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroArr is already defined as \e[33mvalue\e[0m \e[35monesZeroArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote t"
  stdout: ''
  timestamp: 1659795003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l.toLong)\n        val\
    \ zeros = arr.filter(_ == 0l.toLong)\n        val onesCount = ones.count()\n \
    \       val zerosCount = zeros.count()\n        val onesDecimal = onesCount.toDouble\
    \ / arr.size\n        val zerosDecimal = zerosCount.toDouble / arr.size\n    \
    \    val onesDecimalInt = onesDecimal.toInt\n        val zerosDecimalInt = zerosDecimal.toInt\n\
    \        val onesDecimalInt = onesDecimalInt.toLong\n        val zerosDecimalInt\
    \ = zerosDecimalInt.toLong\n        val onesDecimalInt = onesDecimalInt.toLong\n\
    \        val zerosDecimalInt = zerosDecimalInt.toLong\n        val onesDecimalInt\
    \ = onesDecimalInt.toLong\n        val zerosDecimalInt = zerosDecimalInt.toLong\n\
    \        val onesDecimalInt = onesDecimalInt.toLong\n        val zerosDecimalInt\
    \ = zerosDecimalInt.toLong\n        val onesDecimalInt = onesDecimalInt.toLong\n\
    \        val zerosDecimalInt = zerosDecimalInt.toLong\n        val onesDecimalInt\
    \ = onesDecimalInt.toLong\n        val zerosDecimalInt = zerosDecimalInt.toLong\n\
    \        val onesDecimalInt = onesDecimalInt.toLong\n        val zerosDecimalInt\
    \ = zerosDecimalInt.toLong\n        val onesDecimalInt = onesDecimalInt.toLong\n\
    \        val zerosDecimalInt = zerosDecimalInt.toLong\n        val onesDecimalInt\
    \ = onesDecimalInt.toLong\n        val zerosDecimalInt = zerosDecimalInt.toLong\n\
    \        val onesDecimalInt = onesDecimalInt.toLong\n        val zerosDecimalInt\
    \ = zerosDecimalInt.toLong\n        val onesDecimalInt = onesDecimalInt.toLong\n\
    \        val zerosDecimalInt = zerosDecimalInt.toLong\n        val onesDecimalInt\
    \ = onesDecimalInt.toLong\n        val zerosDecimalInt = zerosDecimalInt.toLong\n\
    \        val onesDecimalInt = onesDecimalInt.toLong\n        val zerosDecimalInt\
    \ = zerosDecimalInt.toLong\n        val onesDecimalInt = onesDecimalInt.toLong\n\
    \        val zerosDecimalInt = zerosDecimalInt.toLong\n        val onesDecimalInt\
    \ = onesDecimalInt.toLong\n        val zerosDecimalInt = \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp9d89kcgl.scala:52:29 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalInt\e[0m = \n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9d89kcgl.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesDecimalInt\e[0m = onesDecimalInt.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesDecimalInt is already defined as \e[33mvalue\e[0m \e[35monesDecimalInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9d89kcgl.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalInt\e[0m = zerosDecimalInt.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mzerosDecimalInt is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9d89kcgl.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalInt\e[0m = onesDecimalInt.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesDecimalInt is already defined as \e[33mvalue\e[0m \e[35monesDecimalInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9d89kcgl.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalInt\e[0m = zerosDecimalInt.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mz"
  stdout: ''
  timestamp: 1659795003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.count(_\
    \ == 1l.toLong)\n        val zerosCount = zeros.count(_ == 0l.toLong)\n      \
    \  val onesDecimal = onesCount / arr.length\n        val zerosDecimal = zerosCount\
    \ / arr.length\n        val onesDecimalDecimal = onesDecimal / onesCount\n   \
    \     val zerosDecimalDecimal = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = one\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4wqpsypv.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimal / zerosCount\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp4wqpsypv.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp4wqpsypv.scala:39:89 ------------------------\e[0m\e[0m\n\
    \e[31m39 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = one\n\e[31m\e[31m   |\e[0m                                             \
    \                                            ^^^\e[0m\n\e[31m   |\e[0m       \
    \                                                   Not found: one\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4wqpsypv.scala:40:5 ---------------------\e\
    [0m\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659795002
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros_sorted\
    \ = arr.sortBy(x => (onesZeros - x))\n        val onesZeros_sorted2 = onesZeros_sorted.sortBy(x\
    \ => (ones - x))\n        val onesZeros_sorted3 = onesZeros_sorted2.sortBy(x =>\
    \ (zeros - x))\n        val onesZeros_sorted4 = onesZeros_sorted3.sortBy(x =>\
    \ (ones - x))\n        onesZeros_sorted4\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxslxn7x0.scala:25)\n\tat Problem.main(tmpxslxn7x0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795004
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.map(x => 1l).sum\n\
    \        val zerosCount = zeros.map(x => 0l).sum\n        val onesZeros = ones.zip(zeros)\n\
    \        val onesZeroCount = onesZeros.map(x => 1l).sum\n        val onesZeroZeros\
    \ = onesZeros.zip(zeros)\n        val onesZeroZeroCount = onesZeroZeros.map(x\
    \ => 1l).sum\n        val onesZeroZeroZeros = onesZeroZeros.zip(zeros)\n     \
    \   val onesZeroZeroZeroCount = onesZeroZeroZeros.map(x => 1l).sum\n        val\
    \ onesZeroZeroZeroZeros = onesZeroZeroZeros.zip(zeros)\n        val onesZeroZeroZeroZeroCount\
    \ = onesZeroZeroZeroZeros.map(x => 1l).sum\n        val onesZeroZeroZeroZeroZeros\
    \ = onesZeroZeroZeroZeros.zip(zeros)\n        val onesZeroZeroZeroZeroZeroCount\
    \ = onesZeroZeroZeroZeroZeros.map(x => 1l).sum\n        val onesZeroZeroZeroZeroZeros\
    \ = onesZeroZeroZeroZeroZeros.zip(zeros)\n        val onesZeroZeroZeroZeroZeroCount\
    \ = onesZeroZeroZeroZeroZeros.map(x => 1l).sum\n        val onesZeroZeroZeroZeroZeros\
    \ = onesZeroZeroZeroZeroZeros.zip(zeros)\n        val onesZeroZeroZeroZeroZeroCount\
    \ = onesZeroZeroZeroZeroZeros.map(x => 1l).sum\n        val onesZeroZeroZeroZeroZeroZeros\
    \ = onesZeroZeroZeroZeroZeros.zip(zeros)\n        val onesZeroZeroZeroZeroZeroCount\
    \ = onesZeroZeroZeroZeroZeros.map(x => 1l).sum\n        val onesZeroZeroZeroZeroZeroZeros\
    \ = onesZeroZeroZeroZeroZeros.zip(zeros)\n        val onesZeroZeroZeroZeroZeroZeroCount\
    \ = onesZeroZeroZeroZeroZeros.map(x => 1l).sum\n        val onesZeroZeroZeroZeroZeroZeros\
    \ = onesZeroZeroZeroZeroZeros.zip(zeros)\n        val onesZeroZeroZeroZeroZeroZeroCount\
    \ = onesZeroZeroZeroZeroZeros.map(x => 1l).sum\n        val ones\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphl2gzwzs.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphl2gzwzs.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroZeroZeroZeroZeros\e[0m = onesZeroZeroZeroZeroZeros.zip(zeros)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroZeros is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphl2gzwzs.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroZeroCount\e\
    [0m = onesZeroZeroZeroZeroZeros.map(\e[36mx\e[0m => \e[31m1l\e[0m).sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroZeroCount is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroZeroCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphl2gzwzs.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroZeros\e\
    [0m = onesZeroZeroZeroZeroZeros.zip(zeros)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroZeros is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphl2gzwzs.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroZeroCount\e\
    [0m = onesZeroZeroZeroZeroZeros.map(\e["
  stdout: ''
  timestamp: 1659795003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros\
    \ = onesZeros % 2\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        val onesZeros = onesZeros >> 1\n        val onesZeros\
    \ = onesZeros >> 1\n        \n    }\n    def main(args: Array[String]) = {\n \
    \   assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphyunvw4o.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros\
    \ % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphyunvw4o.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros >> \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphyunvw4o.scala:20:12 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros >> \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphyunvw4o.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros >> \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphyunvw4o.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros >> \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0monesZeros is already defined as \e[33mvalue\e[0m \e[35mon"
  stdout: ''
  timestamp: 1659795002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.count\n    \
    \    val zerosCount = zeros.count\n        val onesDecimal = ones.map(_.toString.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(_.toString.toDouble).sum\n        val onesDecimalDiff\
    \ = onesDecimal - zerosDecimal\n        val zerosDecimalDiff = zerosDecimal -\
    \ onesDecimal\n        val onesDecimalDiffInt = onesDecimalDiff.toInt\n      \
    \  val zerosDecimalDiffInt = zerosDecimalDiff.toInt\n        val onesDecimalDiffInt\
    \ = onesDecimalDiffInt\n        val zerosDecimalDiffInt = zerosDecimalDiffInt\n\
    \        val onesDecimalDiffInt = onesDecimalDiffInt\n        val zerosDecimalDiffInt\
    \ = zerosDecimalDiffInt\n        val onesDecimalDiffInt = onesDecimalDiffInt\n\
    \        val zerosDecimalDiffInt = zerosDecimalDiffInt\n        val onesDecimalDiffInt\
    \ = onesDecimalDiffInt\n        val zerosDecimalDiffInt = zerosDecimalDiffInt\n\
    \        val onesDecimalDiffInt = onesDecimalDiffInt\n        val zerosDecimalDiffInt\
    \ = zerosDecimalDiffInt\n        val onesDecimalDiffInt = onesDecimalDiffInt\n\
    \        val zerosDecimalDiffInt = zerosDecimalDiffInt\n        val onesDecimalDiffInt\
    \ = onesDecimalDiffInt\n        val zerosDecimalDiffInt = zerosDecimalDiffInt\n\
    \        val onesDecimalDiffInt = onesDecimalDiffInt\n        val zerosDecimalDiffInt\
    \ = zerosDecimalDiffInt\n        val onesDecimalDiffInt = onesDecimalDiffInt\n\
    \        val zerosDecimalDiffInt = zerosDecimalDiffInt\n        val onesDecimalDiffInt\
    \ = onesDecimalDiffInt\n        val zerosDecimalDiffInt = zerosDecimalDiffInt\n\
    \        val onesDecimalDiffInt = onesDecimalDiffInt\n        val zerosDecimalDiffInt\
    \ = zerosDecimalDiffInt\n        val onesDecimalDiffInt = onesDecimalDiffInt\n\
    \        val zerosDecimalDiffInt = zerosDecimalDiffInt\n        val onesDecimalDiffInt\
    \ = onesDecimalDiffInt\n        val zerosDecimalDiffInt = zerosDecimalDiffInt\n\
    \        val onesDecimalDiffInt = onesDecimalDiffInt\n        val zerosDecimalDiffInt\
    \ = zerosDecimalDiffInt\n        val onesDecimalDiffInt = onesDecimalDiffInt\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpn0dawjkc.scala:54:11 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpn0dawjkc.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDiffInt\e[0m\
    \ = onesDecimalDiffInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDiffInt is already defined as \e[33mvalue\e[0m\
    \ \e[35monesDecimalDiffInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpn0dawjkc.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDiffInt\e[0m\
    \ = zerosDecimalDiffInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDiffInt is already defined as \e[33mvalue\e[0m\
    \ \e[35mzerosDecimalDiffInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpn0dawjkc.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDiffInt\e[0m\
    \ = onesDecimalDiffInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDiffInt is already defined as \e[33mvalue\e[0m\
    \ \e[35monesDecimalDiffInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpn0dawjkc.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDiffInt\e[0m\
    \ = zerosDecimalDiffInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDiffInt is already defined as \e[33mvalue\e[0m\
    \ \e"
  stdout: ''
  timestamp: 1659795003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpku3h5p8o.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpku3h5p8o.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpku3h5p8o.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \ ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E"
  stdout: ''
  timestamp: 1659795002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(x => x == 1l)\n        val zeros\
    \ = arr.count(x => x == 0l)\n        val onesZeros = ones + zeros\n        val\
    \ onesZeros_sorted = arr.sortBy(x => (onesZeros - x).toInt)\n        val onesZeros_sorted_reversed\
    \ = onesZeros_sorted.reverse\n        val onesZeros_sorted_reversed_sorted = onesZeros_sorted_reversed.sortBy(x\
    \ => (onesZeros - x).toInt)\n        val onesZeros_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted.reverse\n        val onesZeros_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed.sortBy(x => (onesZeros - x).toInt)\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed = onesZeros_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x => (onesZeros\
    \ - x).toInt)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => (onesZeros - x).toInt)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => (onesZeros - x).toInt)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sor\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpet_cnyrb.scala:30:127 -----------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\e\
    [0m = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sor\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sor\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpet_cnyrb.scala:31:5\
    \ ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjpjpx_t7.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros_sorted\
    \ = arr.sortBy(x => (onesZeros - x))\n        val onesZeros_sorted2 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted3 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted4 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted5 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted6 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted7 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted8 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted9 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted10 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted11 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted12 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted13 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted14 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted15 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted16 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted17 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted18 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted19 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted20 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp73y9n64o.scala:38:5\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong).length\n\
    \        val zeros = arr.filter(x => x == 0l.toLong).length\n        val onesZeros\
    \ = ones + zeros\n        val onesZerosList = onesZeros :: arr.filterNot(x =>\
    \ x == 0l.toLong)\n        val onesZerosListLength = onesZerosList.length\n  \
    \      val onesZerosListLength = onesZerosListLength - 1\n        val onesZerosListLength\
    \ = onesZerosListLength - 1\n        val onesZerosListLength = onesZerosListLength\
    \ - 1\n        val onesZerosListLength = onesZerosListLength - 1\n        val\
    \ onesZerosListLength = onesZerosListLength - 1\n        val onesZerosListLength\
    \ = onesZerosListLength - 1\n        val onesZerosListLength = onesZerosListLength\
    \ - 1\n        val onesZerosListLength = onesZerosListLength - 1\n        val\
    \ onesZerosListLength = onesZerosListLength - 1\n        val onesZerosListLength\
    \ = onesZerosListLength - 1\n        val onesZerosListLength = onesZerosListLength\
    \ - 1\n        val onesZerosListLength = onesZerosListLength - 1\n        val\
    \ onesZerosListLength = onesZerosListLength - 1\n        val onesZerosListLength\
    \ = onesZerosListLength - 1\n        val onesZerosListLength = onesZerosListLength\
    \ - 1\n        val onesZerosListLength = onesZerosListLength - 1\n        val\
    \ onesZerosListLength = onesZerosListLength - 1\n        val onesZerosListLength\
    \ = onesZerosListLength - 1\n        val onesZerosListLength = onesZerosListLength\
    \ - 1\n        val onesZerosListLength = onesZerosListLength - 1\n        val\
    \ onesZerosListLength = onesZerosListLength - 1\n        val onesZerosListLength\
    \ = onesZerosListLength - 1\n        val onesZerosListLength = onesZerosListLength\
    \ - 1\n        val onesZerosListLength = onesZerosListLength - 1\n        val\
    \ onesZerosListLength = onesZerosListLength - 1\n        val onesZerosListLength\
    \ = onesZerosListLength - 1\n        val onesZerosListLength = onesZerosListLength\
    \ - 1\n        val onesZerosListLength = onesZerosListLength - 1\n        val\
    \ onesZerosListLength = onesZerosListLength - 1\n        val onesZerosListLength\
    \ = onesZerosListLength - 1\n        val onesZerosListLength = onesZerosListLength\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvwhvibdx.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36monesZerosListLength\e[0m\
    \ = onesZerosListLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZerosListLength is already defined as \e[33mvalue\e[0m\
    \ \e[35monesZerosListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpvwhvibdx.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesZerosListLength\e[0m\
    \ = onesZerosListLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZerosListLength is already defined as \e[33mvalue\e[0m\
    \ \e[35monesZerosListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpvwhvibdx.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36monesZerosListLength\e[0m\
    \ = onesZerosListLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZerosListLength is already defined as \e[33mvalue\e[0m\
    \ \e[35monesZerosListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpvwhvibdx.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesZerosListLength\e[0m\
    \ = onesZerosListLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZerosListLength is already defined as \e[33mvalue\e[0m\
    \ \e[35monesZerosListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpvwhvibdx.scala:24:12 ---------"
  stdout: ''
  timestamp: 1659795010
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesArr = arr.filter(_\
    \ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr = arr.filter(_ % 2 ==\
    \ 1).sortBy(_ % 2).reverse\n        val onesArr2 = onesArr.filter(_ % 2 == 0).sortBy(_\
    \ % 2).reverse\n        val zerosArr2 = zerosArr.filter(_ % 2 == 1).sortBy(_ %\
    \ 2).reverse\n        val onesArr3 = onesArr2.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n\
    \        val zerosArr3 = zerosArr2.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n\
    \        val onesArr4 = onesArr3.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n  \
    \      val zerosArr4 = zerosArr3.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n  \
    \      val onesArr5 = onesArr4.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n    \
    \    val zerosArr5 = zerosArr4.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n    \
    \    val onesArr6 = onesArr5.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n      \
    \  val zerosArr6 = zerosArr5.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n      \
    \  val onesArr7 = onesArr6.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n        val\
    \ zerosArr7 = zerosArr6.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n        val\
    \ onesArr8 = onesArr7.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr8\
    \ = zerosArr7.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n        val onesArr9 =\
    \ onesArr8.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr9 = zerosArr8.filter(_\
    \ % 2 == 1).sortBy(_ % 2).reverse\n        val onesArr10 = onesArr9.filter(_ %\
    \ 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr10 = zerosArr9.filter(_ %\
    \ 2 == 1).sortBy(_ % 2).reverse\n        val onesArr11 = onesArr10.filter(_ %\
    \ 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr11 = zerosArr10.filter(_\
    \ % 2 == 1).sortBy(_ % 2).reverse\n        val onesArr12 = onesArr11.filter(_\
    \ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr12 = zerosArr11.filter\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsqxgi1ca.scala:41:5\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795014
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesZeros = ones + zeros\n        val onesZeroArr = onesZeros.toList.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr2 = onesZeros.toList.sortBy(_.toString.toInt).reverse\n\
    \        val onesZeroArr3 = onesZeros.toList.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr4 = onesZeros.toList.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse\n\
    \        val onesZeroArr5 = onesZeros.toList.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr6 = onesZeros.toList.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse\n\
    \        val onesZeroArr7 = onesZeros.toList.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr8 = onesZeros.toList.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr9 = onesZeros.toList.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr10 = onesZeros.toList.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3iy4o9at.scala:20:36 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr\e[0m = onesZeros.toList.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m     value toList is not a member of Int - did you mean onesZeros.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3iy4o9at.scala:21:37 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr2\e[0m = onesZeros.toList.sortBy(_.toString.toInt).reverse\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m     value toList is not a member of Int - did you mean onesZeros.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3iy4o9at.scala:22:37 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr3\e[0m = onesZeros.toList.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m     value toList is not a member of Int - did you mean onesZeros.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3iy4o9at.scala:23:37 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr4\e[0m = onesZeros.toList.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m     value toList is not a member of Int - did you mean onesZeros.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3iy4o9at.scala:24:37 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr5\e[0m = onesZeros.toList.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m     value toList is not a member of Int - did you mean onesZeros.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3iy4o9at.scala:25:37 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesZeroA"
  stdout: ''
  timestamp: 1659795015
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesArr = arr.filter(_\
    \ % 2 == 0).sortBy(_.toString.toInt)\n        val zerosArr = arr.filter(_ % 2\
    \ == 1).sortBy(_.toString.toInt)\n        val onesArr2 = onesArr.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val zerosArr2 = zerosArr.zipWithIndex.sortBy(_._1).map(_._2)\n      \
    \  val onesArr3 = onesArr2.zip(zerosArr2).sortBy(_._1).map(_._2)\n        val\
    \ zerosArr3 = zerosArr2.zip(onesArr2).sortBy(_._1).map(_._2)\n        onesArr3.zip(zerosArr3).sortBy(_._1).map(_._2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7nv9_f9l.scala:26)\n\tat Problem.main(tmp7nv9_f9l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795017
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.size\n      \
    \  val zerosDecimal = zerosCount / arr.size\n        val onesDecimalDecimal =\
    \ onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n    \
    \    val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n     \
    \   val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppv5i04en.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppv5i04en.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppv5i04en.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795012
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArray = arr.map(x => if (x == 1) 1 else 0)\n\
    \        val zerosArray = arr.map(x => if (x == 0) 0 else 1)\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArrayLength / 2\n        val zerosArrayLength =\
    \ zerosArrayLength / 2\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val zerosArrayLength = zerosArrayLength + onesArrayLength\n        val\
    \ onesArrayLength = onesArrayLength / 2\n        val zerosArrayLength = zerosArrayLength\
    \ / 2\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n    \
    \    val zerosArrayLength = zerosArrayLength + onesArrayLength\n        val onesArrayLength\
    \ = onesArrayLength / 2\n        val zerosArrayLength = zerosArrayLength / 2\n\
    \        val onesArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ zerosArrayLength = zerosArrayLength + onesArrayLength\n        val onesArrayLength\
    \ = onesArrayLength / 2\n        val zerosArrayLength = zerosArrayLength / 2\n\
    \        val onesArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ zerosArrayLength = zerosArrayLength + onesArrayLength\n        val onesArrayLength\
    \ = onesArrayLength / 2\n        val zerosArrayLength = zerosArrayLength / 2\n\
    \        val onesArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ zerosArrayLength = zerosArrayLength + onesArrayLength\n        val onesArrayLength\
    \ = onesArrayLength / 2\n        val zerosArrayLength = zerosArrayLength / 2\n\
    \        val onesArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ zerosArrayLength = zerosArrayLength + onesArrayLength\n        val onesArrayLength\
    \ = onesArrayLength / 2\n        val zerosArrayLength = zerosArrayLength / 2\n\
    \        val onesArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ zerosArrayLength = zerosArrayLength + onesArrayLength\n        val onesArrayLength\
    \ = onesArrayLength / 2\n        val zerosArrayLength = zerosArrayLength / 2\n\
    \        val onesArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ zerosArrayLength = zerosArrayLength + onesArrayLength\n        val onesArrayLength\
    \ = onesArrayLength / 2\n        val zerosArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg34tib5n.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg34tib5n.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesArrayLength\e[0m = onesArrayLength / \e[31m2\e[0m\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesArrayLength\
    \ is already defined as \e[33mvalue\e[0m \e[35monesArrayLength\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg34tib5n.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosArrayLength\e[0m = zerosArrayLength / \e[31m2\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e[35mzerosArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpg34tib5n.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArrayLength\
    \ + zerosArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35monesArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpg34tib5n.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m =\
    \ zerosArrayLength + onesArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35mzerosArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overlo"
  stdout: ''
  timestamp: 1659795014
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.size\n      \
    \  val zerosDecimal = zerosCount / arr.size\n        val onesDecimalDecimal =\
    \ onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n    \
    \    val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n     \
    \   val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppv5i04en.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppv5i04en.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppv5i04en.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795012
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros % 2\n        val onesZeros = onesZeros\n        val onesZero = onesZero\n\
    \        val onesZeros = onesZeros\n        val onesZero = onesZero\n        val\
    \ onesZeros = onesZeros\n        val onesZero = onesZero\n        val onesZeros\
    \ = onesZeros\n        val onesZero = onesZero\n        val onesZeros = onesZeros\n\
    \        val onesZero = onesZero\n        val onesZeros = onesZeros\n        val\
    \ onesZero = onesZero\n        val onesZeros = onesZeros\n        val onesZero\
    \ = onesZero\n        val onesZeros = onesZeros\n        val onesZero = onesZero\n\
    \        val onesZeros = onesZeros\n        val onesZero = onesZero\n        val\
    \ onesZeros = onesZeros\n        val onesZero = onesZero\n        val onesZeros\
    \ = onesZeros\n        val onesZero = onesZero\n        val onesZeros = onesZeros\n\
    \        val onesZero = onesZero\n        val onesZeros = onesZeros\n        val\
    \ onesZero = onesZero\n        val onesZeros = onesZeros\n        val onesZero\
    \ = onesZero\n        val onesZeros = onesZeros\n        val onesZero = onesZero\n\
    \        val onesZeros = onesZeros\n        val onesZero = onesZero\n        val\
    \ onesZeros = onesZeros\n        val onesZero = onesZero\n        val onesZeros\
    \ = onesZeros\n        val onesZero = onesZero\n        val onesZeros = onesZeros\n\
    \        val onesZero = onesZero\n        val onesZeros = onesZeros\n        val\
    \ onesZero = onesZero\n        val one\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9wipqhps.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9wipqhps.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeros\e[0m = onesZero % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesZeros is already defined\
    \ as \e[33mvalue\e[0m \e[35monesZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9wipqhps.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36monesZero\e[0m = onesZeros\
    \ % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZero is already defined as \e[33mvalue\e[0m \e[35monesZero\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9wipqhps.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesZeros\
    \ is already defined as \e[33mvalue\e[0m \e[35monesZeros\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9wipqhps.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZero\e[0m = onesZero\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZero is already defined as \e[33mvalue\e[0m \e[35monesZero\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9wipqhps.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros\n\e[3"
  stdout: ''
  timestamp: 1659795013
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesZeros = ones.zip(zeros)\n        val onesZeroCount\
    \ = onesZeros.map(x => onesZeros.count(_ == x)).sum\n        val onesZeroZeros\
    \ = onesZeros.zip(zeros)\n        val onesZeroZeroCount = onesZeroZeros.map(x\
    \ => onesZeroZeros.count(_ == x)).sum\n        val onesZeroZeroZeros = onesZeroZeros.zip(zeros)\n\
    \        val onesZeroZeroZeroCount = onesZeroZeroZeros.map(x => onesZeroZeroZeros.count(_\
    \ == x)).sum\n        val onesZeroZeroZeroZeros = onesZeroZeroZeros.zip(zeros)\n\
    \        val onesZeroZeroZeroZeroCount = onesZeroZeroZeroZeros.map(x => onesZeroZeroZeroZeros.count(_\
    \ == x)).sum\n        val onesZeroZeroZeroZeros = onesZeroZeroZeroZeros.zip(zeros)\n\
    \        val onesZeroZeroZeroZeroCount = onesZeroZeroZeroZeros.map(x => onesZeroZeroZeroZeros.count(_\
    \ == x)).sum\n        val onesZeroZeroZeroZeros = onesZeroZeroZeroZeros.zip(zeros)\n\
    \        val onesZeroZeroZeroZeroCount = onesZeroZeroZeroZeros.map(x => onesZeroZeroZeroZeros.count(_\
    \ == x)).sum\n        val onesZeroZeroZeroZeros = onesZeroZeroZeroZeros.zip(zeros)\n\
    \        val onesZeroZeroZeroZeroCount = onesZeroZeroZeroZeros.map(x => onesZeroZeroZeroZeros.count(_\
    \ == x)).sum\n        val onesZeroZeroZeroZeros = onesZeroZeroZeroZeros.zip(zeros)\n\
    \        val onesZeroZeroZeroZeroCount = onesZeroZeroZeroZeros.map(x => onesZeroZeroZeroZeros.count(_\
    \ == x)).sum\n        val onesZeroZeroZeroZeros = onesZeroZeroZeroZeros.zip(zeros)\n\
    \        val onesZeroZeroZeroZeroCount = onesZeroZeroZeroZeros.map(x \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph6x8gc56.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph6x8gc56.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroZeroZeroZeros\e[0m = onesZeroZeroZeroZeros.zip(zeros)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeros is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmph6x8gc56.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroCount\e\
    [0m = onesZeroZeroZeroZeros.map(\e[36mx\e[0m => onesZeroZeroZeroZeros.count(_\
    \ == x)).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroCount is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmph6x8gc56.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeros\e\
    [0m = onesZeroZeroZeroZeros.zip(zeros)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeros is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmph6x8gc56.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroCount\e\
    [0m = onesZeroZeroZeroZeros.map(\e[36mx\e[0m => onesZeroZer"
  stdout: ''
  timestamp: 1659795014
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val maxOnes = arr.filter(_ == 1).max\n\
    \        val maxZeros = arr.filter(_ == 0).max\n        val maxOnesZeros = maxOnes\
    \ - maxZeros\n        val maxOnesZeros_ = maxOnesZeros - 1\n        val maxOnesZeros_1\
    \ = maxOnesZeros - 2\n        val maxOnesZeros_2 = maxOnesZeros - 3\n        val\
    \ maxOnesZeros_3 = maxOnesZeros - 4\n        val maxOnesZeros_4 = maxOnesZeros\
    \ - 5\n        val maxOnesZeros_5 = maxOnesZeros - 6\n        val maxOnesZeros_6\
    \ = maxOnesZeros - 7\n        val maxOnesZeros_7 = maxOnesZeros - 8\n        val\
    \ maxOnesZeros_8 = maxOnesZeros - 9\n        val maxOnesZeros_9 = maxOnesZeros\
    \ - 10\n        val maxOnesZeros_10 = maxOnesZeros - 11\n        val maxOnesZeros_11\
    \ = maxOnesZeros - 12\n        val maxOnesZeros_12 = maxOnesZeros - 13\n     \
    \   val maxOnesZeros_13 = maxOnesZeros - 14\n        val maxOnesZeros_14 = maxOnesZeros\
    \ - 15\n        val maxOnesZeros_15 = maxOnesZeros - 16\n        val maxOnesZeros_16\
    \ = maxOnesZeros - 17\n        val maxOnesZeros_17 = maxOnesZeros - 18\n     \
    \   val maxOnesZeros_18 = maxOnesZeros - 19\n        val maxOnesZeros_19 = maxOnesZeros\
    \ - 20\n        val maxOnesZeros_20 = maxOnesZeros - 21\n        val maxOnesZeros_21\
    \ = maxOnesZeros - 22\n        val maxOnesZeros_22 = maxOnesZeros - 23\n     \
    \   val maxOnesZeros_23 = maxOnesZeros - 24\n        val maxOnesZeros_24 = maxOnesZeros\
    \ - 25\n        val maxOnesZeros_25 = maxOnesZeros - 26\n        val maxOnesZeros_26\
    \ = maxOnesZeros - 27\n        val maxOnesZeros_27 = maxOnesZeros - 28\n     \
    \   val maxOnesZeros_28 = maxOnesZeros - 29\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt8r7d7ys.scala:50:5\
    \ ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795013
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(x => x == 1).toList\n  \
    \      val zerosArr = arr.filter(x => x == 0).toList\n        val onesCount =\
    \ onesArr.size\n        val zerosCount = zerosArr.size\n        val onesSum =\
    \ onesArr.sum\n        val zerosSum = zerosArr.sum\n        val onesMax = onesArr.max\n\
    \        val zerosMax = zerosArr.max\n        val onesMin = onesArr.min\n    \
    \    val zerosMin = zerosArr.min\n        val onesAvg = onesArr.sum / onesCount\n\
    \        val zerosAvg = zerosArr.sum / zerosCount\n        val onesDev = onesArr.sum\
    \ / onesSum\n        val zerosDev = zerosArr.sum / zerosSum\n        val onesDeviation\
    \ = onesArr.reduce((x, y) => x - y)\n        val zerosDeviation = zerosArr.reduce((x,\
    \ y) => x - y)\n        val onesVariance = onesArr.reduce((x, y) => x - y) / onesCount\n\
    \        val zerosVariance = zerosArr.reduce((x, y) => x - y) / zerosCount\n \
    \       val onesStandardDeviation = math.sqrt(onesVariance)\n        val zerosStandardDeviation\
    \ = math.sqrt(zerosVariance)\n        val onesStandardError = math.sqrt((onesDev\
    \ / onesSum) * (onesCount - onesCount))\n        val zerosStandardError = math.sqrt((zerosDev\
    \ / zerosSum) * (zerosCount - zerosCount))\n        val onesVarianceDeviation\
    \ = math.sqrt(onesVariance)\n        val zerosVarianceDeviation = math.sqrt(zerosVariance)\n\
    \        val onesVarianceError = math.sqrt((onesDev / onesSum) * (onesCount -\
    \ onesCount))\n        val zerosVarianceError = math.sqrt((zerosDev / zerosSum)\
    \ * (zerosCount - zerosCount))\n        val onesVarianceDeviationDeviation = math.sqrt(onesVarianceDeviation)\n\
    \        val zerosVarianceDeviationDeviation = math.sqrt(zerosVarianceDeviation)\n\
    \        val onesVarianceDeviationError = math.sqrt((onesDeviationDev / onesSum)\
    \ * (onesCount - onesCount))\n        val zerosVarianceDeviationDeviation = math.sqrt(zerosVarianceDeviation)\n\
    \        val one\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7ugkt617.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7ugkt617.scala:46:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosVarianceDeviationDeviation\e[0m = math.sqrt(zerosVarianceDeviation)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosVarianceDeviationDeviation is already defined as \e[33mvalue\e\
    [0m \e[35mzerosVarianceDeviationDeviation\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7ugkt617.scala:45:52\
    \ ------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e\
    [36monesVarianceDeviationError\e[0m = math.sqrt((onesDeviationDev / onesSum) *\
    \ (onesCount - onesCount))\n\e[31m\e[31m   |\e[0m                            \
    \                        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                               Not found: onesDeviationDev\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7ugkt617.scala:48:5 ---------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659795013
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.count(_\
    \ == 1)\n        val zerosCount = zeros.count(_ == 0)\n        val onesZeros =\
    \ ones.zip(zeros)\n        val onesZeroCount = onesZeros.count(_._1 == _._2)\n\
    \        val onesZeroZeros = onesZeros.filter(_._1 == _._2)\n        val onesZeroZeroCount\
    \ = onesZeroZeros.count(_._1 == _._2)\n        val onesZeroZeroZeros = onesZeroZeros.filter(_._1\
    \ == _._2)\n        val onesZeroZeroZeroCount = onesZeroZeroZeros.count(_._1 ==\
    \ _._2)\n        val onesZeroZeroZeroZeros = onesZeroZeroZeros.filter(_._1 ==\
    \ _._2)\n        val onesZeroZeroZeroZeroCount = onesZeroZeroZeroZeros.count(_._1\
    \ == _._2)\n        val onesZeroZeroZeroZeroZeros = onesZeroZeroZeroZeros.filter(_._1\
    \ == _._2)\n        val onesZeroZeroZeroZeroZeroCount = onesZeroZeroZeroZeroZeros.count(_._1\
    \ == _._2)\n        val onesZeroZeroZeroZeroZeroZeros = onesZeroZeroZeroZeroZeros.filter(_._1\
    \ == _._2)\n        val onesZeroZeroZeroZeroZeroCount = onesZeroZeroZeroZeroZeros.count(_._1\
    \ == _._2)\n        val onesZeroZeroZeroZeroZeroZeros = onesZeroZeroZeroZeroZeroZeros.filter(_._1\
    \ == _._2)\n        val onesZeroZeroZeroZeroZeroZeroCount = onesZeroZeroZeroZeroZeroZeros.count(_._1\
    \ == _._2)\n        val onesZeroZeroZeroZeroZeroZeroZeros = onesZeroZeroZeroZeroZeroZeroZeros.filter(_._1\
    \ == _._2)\n        val onesZeroZeroZeroZeroZeroZeroCount = onesZeroZeroZeroZeroZeroZeroZeros.count(_._1\
    \ == _._2)\n        val onesZeroZeroZeroZeroZeroZeroZeros = onesZeroZeroZeroZeroZeroZeroZeroZeros.filter(_._1\
    \ == _._2)\n        val onesZeroZeroZeroZeroZeroZeroZeroCount = onesZeroZeroZeroZeroZeroZeroZeroZeros.count(_._1\
    \ == _._2)\n        val onesZeroZeroZeroZero\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7n_ye4w4.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7n_ye4w4.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroZeroZeroZeroZeroCount\e[0m = onesZeroZeroZeroZeroZeros.count(_._1\
    \ == _._2)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroZeroCount is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroZeroCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7n_ye4w4.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroZeroZeros\e\
    [0m = onesZeroZeroZeroZeroZeroZeros.filter(_._1 == _._2)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroZeroZeros is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroZeroZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7n_ye4w4.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroZeroZeroCount\e\
    [0m = onesZeroZeroZeroZeroZeroZeroZeros.count(_._1 == _._2)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroZeroZeroCount is already defined as \e\
    [33mvalue\e[0m \e[35monesZeroZeroZeroZeroZeroZeroCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7n_ye4w4.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |"
  stdout: ''
  timestamp: 1659795017
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l)\n        val zeros\
    \ = arr.filter(_ == 0l)\n        val onesCount = ones.count()\n        val zerosCount\
    \ = zeros.count()\n        val onesDecimal = onesCount.toDouble / arr.length\n\
    \        val zerosDecimal = zerosCount.toDouble / arr.length\n        val onesDecimalInt\
    \ = onesDecimal.toInt\n        val zerosDecimalInt = zerosDecimal.toInt\n    \
    \    val onesDecimalDecimal = onesDecimalInt.toDouble / onesDecimal\n        val\
    \ zerosDecimalDecimal = zerosDecimalInt.toDouble / zerosDecimal\n        val onesDecimalDecimalInt\
    \ = onesDecimalDecimal.toInt\n        val zerosDecimalDecimalInt = zerosDecimalDecimal.toInt\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimalInt.toDouble / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimalInt.toDouble / zerosDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalInt = onesDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalInt = zerosDecimalDecimalDecimal.toInt\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalInt.toDouble\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal =\
    \ zerosDecimalDecimalDecimalInt.toDouble / zerosDecimalDecimalDecimal\n      \
    \  val onesDecimalDecimalDecimalDecimalInt = onesDecimalDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalDecimalInt = zerosDecimalDecimalDecimalDecimalInt.toInt\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalInt.toDouble\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalInt.toDouble / zerosDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalInt = onesDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalInt = zerosDecimalDecimalDecimalDecimalDecimalInt.toInt\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalInt.toDouble\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalInt.toDouble / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalInt = onesDecimalDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg3_c2f3w.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpg3_c2f3w.scala:17:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m       \
    \ \e[33mval\e[0m \e[36monesCount\e[0m = ones.count()\n\e[31m\e[31m   |\e[0m  \
    \                      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument for\
    \ parameter p of \e[33mmethod\e[0m \e[35mcount\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m: (p: Long => Boolean): Int\n\e[31m\e[31m-- Error: /tmp/tmpg3_c2f3w.scala:18:36\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m18 |\e[0m       \
    \ \e[33mval\e[0m \e[36mzerosCount\e[0m = zeros.count()\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument\
    \ for parameter p of \e[33mmethod\e[0m \e[35mcount\e[0m in \e[33mtrait\e[0m \e\
    [35mIterableOnceOps\e[0m: (p: Long => Boolean): Int\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpg3_c2f3w.scala:34:51 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalInt\e\
    [0m = zerosDecimalDecimalDecimalDecimalInt.toInt\n\e[31m\e[31m   |\e[0m      \
    \                                             ^\e[0m\n\e[31m   |\e[0m        \
    \ Recursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalInt\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg3_c2f3w.scala:38:58\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalInt\e[0m = zerosDecimalDecimalDecimalDecimalDecimalInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^\e[0m\n\e[31m   |\e[0m  Recursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg3_c2f3w.scala:43:5\
    \ ---------------------\e[0m\e[0m"
  stdout: ''
  timestamp: 1659795014
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjpjpx_t7.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x))\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x))\n        val onesZeros = ones.zip(zeros)\n        val onesZerosCount\
    \ = onesZeros.map(x => (x._1, x._2))\n        val onesZerosCountSorted = onesZerosCount.sortBy(x\
    \ => x._1)\n        val zerosZerosCount = zerosZeros.map(x => (x._1, x._2))\n\
    \        val zerosZerosCountSorted = zerosZerosCount.sortBy(x => x._1)\n     \
    \   val onesZerosCountSortedSorted: Seq[(Long, Long)] = onesZerosCountSorted.sortBy(x\
    \ => x._2)\n        val zerosZerosCountSortedSorted: Seq[(Long, Long)] = zerosZerosCountSorted.sortBy(x\
    \ => x._2)\n        val onesZerosCountSortedSortedSorted: Seq[(Long, Long)] =\
    \ onesZerosCountSortedSorted.sortBy(x => x._1)\n        val zerosZerosCountSortedSortedSorted:\
    \ Seq[(Long, Long)] = zerosZerosCountSortedSorted.sortBy(x => x._1)\n        val\
    \ onesZerosCountSortedSortedSortedSorted: Seq[(Long, Long)] = onesZerosCountSortedSortedSorted.sortBy(x\
    \ => x._2)\n        val zerosZerosCountSortedSortedSortedSorted: Seq[(Long, Long)]\
    \ = zerosZerosCountSortedSortedSorted.sortBy(x => x._2)\n        val onesZerosCountSortedSortedSortedSortedSorted:\
    \ Seq[(Long, Long)] = onesZerosCountSortedSortedSortedSorted.sortBy(x => x._1)\n\
    \        val zerosZerosCountSortedSortedSortedSortedSorted: Seq[(Long, Long)]\
    \ = zerosZerosCountSortedSortedSortedSorted.sortBy(x => x._1)\n        val onesZerosCountSortedSortedSortedSortedSortedSorted:\
    \ Seq[(Long, Long)] = onesZerosCountSortedSortedSortedSortedSorted.sortBy(x =>\
    \ x._2)\n        val zerosZerosCountSortedSortedSortedSortedSortedSorted: Seq[(Long,\
    \ Long)] = zerosZerosCountSortedSortedSortedSortedSorted.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnrqftw19.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpnrqftw19.scala:22:30 ------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosZerosCount\e[0m = zerosZeros.map(\e\
    [36mx\e[0m => (x._1, x._2))\n\e[31m\e[31m   |\e[0m                           \
    \   ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found: zerosZeros\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnrqftw19.scala:24:60\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36monesZerosCountSortedSorted\e\
    [0m: \e[35mSeq\e[0m[(\e[35mLong\e[0m, \e[35mLong\e[0m)] = onesZerosCountSorted.sortBy(\e\
    [36mx\e[0m => x._2)\n\e[31m\e[31m   |\e[0m                                   \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                          Found:    \e[1m\e[31mList\e[0m[(Long, Long)]\n\
    \e[31m   |\e[0m                          Required: \e[1m\e[32mcollection\e[0m\e\
    [1m\e[32m.\e[0m\e[1m\e[32mmutable\e[0m\e[1m\e[32m.\e[0m\e[1m\e[32mSeq\e[0m[(Long,\
    \ Long)]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnrqftw19.scala:34:5\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795014
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(_.toInt).sum\n\
    \        val zerosCount = zeros.map(_.toInt).sum\n        val onesDecimal = onesCount\
    \ / 2\n        val zerosDecimal = zerosCount / 2\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal.toLong\n       \
    \ val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpxk73i7b9.scala:43:11 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpxk73i7b9.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimal is already defined\
    \ as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimal\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpxk73i7b9.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxk73i7b9.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimal is already defined\
    \ as \e[33"
  stdout: ''
  timestamp: 1659795015
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.map(_.toInt).sum\n\
    \        val zerosCount = zeros.map(_.toInt).sum\n        val onesDecimal = ones.map(_.toInt).map(math.pow(2,\
    \ _)).sum\n        val zerosDecimal = zeros.map(_.toInt).map(math.pow(2, _)).sum\n\
    \        val onesDecimalDecimal = ones.map(_.toInt).map(math.pow(2, _)).map(math.pow(2,\
    \ _)).sum\n        val zerosDecimalDecimal = zeros.map(_.toInt).map(math.pow(2,\
    \ _)).map(math.pow(2, _)).sum\n        val onesDecimalDecimalDecimal = ones.map(_.toInt).map(math.pow(2,\
    \ _)).map(math.pow(2, _)).map(math.pow(2, _)).sum\n        val zerosDecimalDecimalDecimal\
    \ = zeros.map(_.toInt).map(math.pow(2, _)).map(math.pow(2, _)).map(math.pow(2,\
    \ _)).sum\n        val onesDecimalDecimalDecimalDecimal = ones.map(_.toInt).map(math.pow(2,\
    \ _)).map(math.pow(2, _)).map(math.pow(2, _)).map(math.pow(2, _)).sum\n      \
    \  val zerosDecimalDecimalDecimalDecimal = zeros.map(_.toInt).map(math.pow(2,\
    \ _)).map(math.pow(2, _)).map(math.pow(2, _)).map(math.pow(2, _)).sum\n      \
    \  val onesDecimalDecimalDecimalDecimalDecimal = ones.map(_.toInt).map(math.pow(2,\
    \ _)).map(math.pow(2, _)).map(math.pow(2, _)).map(math.pow(2, _)).map(math.pow(2,\
    \ _)).sum\n        val zerosDecimalDecimalDecimalDecimalDecimal = zeros.map(_.toInt).map(math.pow(2,\
    \ _)).map(math.pow(2, _)).map(math.pow(2, _)).map(math.pow(2, _)).map(math.pow(2,\
    \ _)).sum\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = ones.map(_.toInt).map(math.pow(2,\
    \ _)).map(math.pow(2, _)).map(math.pow(2, _)).map(math.pow(2, _)).map(math.pow(2,\
    \ _)).map(math.pow(2, _)).sum\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zeros.map(_.toInt).map(math.pow(2, _)).map(math.pow(2, _)).map(math.pow(2,\
    \ _)).map(math.pow(2, _)).map(math.pow(2, _)).map(math.pow(2, _)).map(math.pow(2,\
    \ _)).sum\n        val onesDecimalDecimalDecimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8zj4w2mk.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp8zj4w2mk.scala:32:5 ---------------------\e[0m\e[0m\n\e[31m32 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795015
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l)\n        val zeros\
    \ = arr.filter(_ == 0l)\n        val onesCount = ones.count\n        val zerosCount\
    \ = zeros.count\n        val onesDecimal = onesCount / 2\n        val zerosDecimal\
    \ = zerosCount / 2\n        val onesDecimalDecimal = onesDecimal / 2\n       \
    \ val zerosDecimalDecimal = zerosDecimal / 2\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / 2\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / 2\n        val zerosDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph03gbdfg.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph03gbdfg.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimal\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimal is already defined\
    \ as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimal\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmph03gbdfg.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimal / \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmph03gbdfg.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimal / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group"
  stdout: ''
  timestamp: 1659795015
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.size\n      \
    \  val zerosDecimal = zerosCount / arr.size\n        val onesDecimalDecimal =\
    \ onesDecimal / zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal /\
    \ onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / zerosDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / onesDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ onesDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp45rrkl_q.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp45rrkl_q.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp45rrkl_q.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longe"
  stdout: ''
  timestamp: 1659795014
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l)\n        val zeros\
    \ = arr.filter(x => x == 0l)\n        val onesCount = ones.count\n        val\
    \ zerosCount = zeros.count\n        val onesDecimal = onesCount * 10\n       \
    \ val zerosDecimal = zerosCount * 10\n        val onesDecimalString = onesDecimal.toString\n\
    \        val zerosDecimalString = zerosDecimal.toString\n        val onesDecimalString\
    \ = onesDecimalString.toUpperCase\n        val zerosDecimalString = zerosDecimalString.toUpperCase\n\
    \        val onesDecimalString = onesDecimalString.substring(0, onesDecimalString.length\
    \ - 1)\n        val zerosDecimalString = zerosDecimalString.substring(0, zerosDecimalString.length\
    \ - 1)\n        val onesDecimalString = onesDecimalString.substring(0, onesDecimalString.length\
    \ - 1)\n        val zerosDecimalString = zerosDecimalString.substring(0, zerosDecimalString.length\
    \ - 1)\n        val onesDecimalString = onesDecimalString.substring(0, onesDecimalString.length\
    \ - 1)\n        val zerosDecimalString = zerosDecimalString.substring(0, zerosDecimalString.length\
    \ - 1)\n        val onesDecimalString = onesDecimalString.substring(0, onesDecimalString.length\
    \ - 1)\n        val zerosDecimalString = zerosDecimalString.substring(0, zerosDecimalString.length\
    \ - 1)\n        val onesDecimalString = onesDecimalString.substring(0, onesDecimalString.length\
    \ - 1)\n        val zerosDecimalString = zerosDecimalString.substring(0, zerosDecimalString.length\
    \ - 1)\n        val onesDecimalString = onesDecimalString.substring(0, onesDecimalString.length\
    \ - 1)\n        val zerosDecimalString = zerosDecimalString.substring(0, zerosDecimalString.length\
    \ - 1)\n        val onesDecimalString = onesDecimalString.substring(0, onesDecimalString.length\
    \ - 1)\n        val zerosDecimalString = zerosDecimalString.substring(0, zerosDecimalString.length\
    \ - 1)\n        val onesDecimalString = onesDecimalString.substring(0, onesDecimalString.length\
    \ - 1)\n        val zerosDecimalString = zerosDecimalString.substring(0, zerosDecimalString.length\
    \ - 1)\n        val onesDecimalString = onesDecimalString.substring(0, onesDecimalString.length\
    \ - 1)\n        val zerosDecimalString = zerosDecimalString.substring(0, zerosDecimalString.length\
    \ - 1)\n        val onesDecimalString = onesDecimalString.substring(0, onesDecimalString.length\
    \ - 1)\n        val zerosDecimalString = zerosDecimalString.substring(0, zerosDecimalString.length\
    \ - 1)\n        val onesDecimalString = onesDecimalString.substring(0, onesDecimalString.length\
    \ - 1)\n        val zerosDecimalString = zerosDecimalString.substring(0, zerosDecimalString.length\
    \ - 1)\n        val onesDecimalString = onesDecimalString.substring(0, onesDecimalString.length\
    \ - 1)\n        val zerosDecimalString = zerosDecimalString.substring(0, zerosDecimalString.length\
    \ - 1)\n        val onesDecimalString = onesDecimalString.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprk328h30.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmprk328h30.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalString\e[0m = onesDecimalString.toUpperCase\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalString is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmprk328h30.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalString\e[0m\
    \ = zerosDecimalString.toUpperCase\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalString is already defined as \e[33mvalue\e[0m\
    \ \e[35mzerosDecimalString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmprk328h30.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalString\e[0m =\
    \ onesDecimalString.substring(\e[31m0\e[0m, onesDecimalString.length - \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalString is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmprk328h30.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalString\e[0m\
    \ = zerosDecimalString.substring(\e[31m0\e[0m, zerosDecimalString.length - \e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795017
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val onesZeros = ones + zeros\n  \
    \      val onesZeros_sorted = arr.sortBy(_ - onesZeros)\n        val onesZeros_sorted_reversed\
    \ = onesZeros_sorted.reverse\n        val onesZeros_sorted_reversed_sorted = onesZeros_sorted_reversed.sortBy(_\
    \ - ones)\n        val onesZeros_sorted_reversed_sorted_reversed = onesZeros_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted = onesZeros_sorted_reversed_sorted_reversed.sortBy(_\
    \ - zeros)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted.reverse\n        onesZeros_sorted_reversed_sorted_reversed_sorted_reversed\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_66zhhfz.scala:27)\n\tat Problem.main(tmp_66zhhfz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795017
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjpjpx_t7.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x % 2l.toLong == 0)\n \
    \       val zeros = arr.filter(x => x % 2l.toLong != 0)\n        val onesCount\
    \ = ones.map(x => x.toLong).distinct\n        val zerosCount = zeros.map(x =>\
    \ x.toLong).distinct\n        val onesCountMap = onesCount.foldLeft(Map[Long,\
    \ Long]())((m, x) => m + (x -> m.getOrElse(x, 0l)))\n        val zerosCountMap\
    \ = zerosCount.foldLeft(Map[Long, Long]())((m, x) => m + (x -> m.getOrElse(x,\
    \ 0l)))\n        val onesCountMapSorted = onesCountMap.sortBy(_._1)\n        val\
    \ zerosCountMapSorted = zerosCountMap.sortBy(_._1)\n        val onesCountMapSortedWithZeros\
    \ = onesCountMapSorted.map(x => (x, 0l))\n        val zerosCountMapSortedWithZeros\
    \ = zerosCountMapSorted.map(x => (x, 0l))\n        val onesCountMapSortedWithZerosAndOnes\
    \ = onesCountMapSortedWithZeros.union(zerosCountMapSortedWithZeros)\n        val\
    \ zerosCountMapSortedWithZerosAndOnes = zerosCountMapSortedWithZeros.union(onesCountMapSortedWithZeros)\n\
    \        val onesCountMapSortedWithZerosAndOnesAndZeros = onesCountMapSortedWithZeros.union(zerosCountMapSortedWithZeros)\n\
    \        val zerosCountMapSortedWithZerosAndOnesAndZeros = zerosCountMapSortedWithZeros.union(onesCountMapSortedWithZeros)\n\
    \        val onesCountMapSortedWithZerosAndOnesAndZerosAndOnes = onesCountMapSortedWithZeros.union(zerosCountMapSortedWithZeros)\n\
    \        val zerosCountMapSortedWithZerosAndOnesAndOnesAndZeros = zerosCountMapSortedWithZeros.union(onesCountMapSortedWithZeros)\n\
    \        val onesCountMapSortedWithZerosAndOnesAndOnesAndZeros = onesCountMapSortedWithZeros.union(zerosCountMapSortedWithZeros)\n\
    \        val zerosCountMapSortedWithZerosAndOnesAndOnesAndZeros = zerosCountMapSortedWithZeros.union(onesCountMapSortedWithZeros)\n\
    \        val onesCountMapSortedWithZerosAndOnesAndOnesAndZerosAndOnes = onesCountMapSortedWithZeros.union(zerosCountMapSortedWithZeros)\n\
    \        val zerosCount\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpunuywiw9.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpunuywiw9.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosCountMapSortedWithZerosAndOnesAndOnesAndZeros\e[0m = zerosCountMapSortedWithZeros.union(onesCountMapSortedWithZeros)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosCountMapSortedWithZerosAndOnesAndOnesAndZeros is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosCountMapSortedWithZerosAndOnesAndOnesAndZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpunuywiw9.scala:21:46 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesCountMapSorted\e[0m = onesCountMap.sortBy(_._1)\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue sortBy is not a member of scala.collection.mutable.Map[Long,\
    \ Long]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpunuywiw9.scala:22:48 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosCountMapSorted\e[0m\
    \ = zerosCountMap.sortBy(_._1)\n\e[31m\e[31m   |\e[0m                        \
    \          ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue sortBy is not a member\
    \ of scala.collection.mutable.Map[Long, Long]\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpunuywiw9.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659795016
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n  \
    \      val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpla7d0s9h.scala:31:68 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpla7d0s9h.scala:32:119\
    \ --------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                             ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpla7d0s9h.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpla7d0s9h.scala:36:83\
    \ ------------------------\e"
  stdout: ''
  timestamp: 1659795015
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesArr = arr.filter(_\
    \ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr = arr.filter(_ % 2 ==\
    \ 1).sortBy(_ % 2).reverse\n        val onesArr2 = onesArr.filter(_ > 0)\n   \
    \     val zerosArr2 = zerosArr.filter(_ > 0)\n        val onesArr3 = onesArr2.filter(_\
    \ > 0)\n        val zerosArr3 = zerosArr2.filter(_ > 0)\n        val onesArr4\
    \ = onesArr3.filter(_ > 0)\n        val zerosArr4 = zerosArr3.filter(_ > 0)\n\
    \        val onesArr5 = onesArr4.filter(_ > 0)\n        val zerosArr5 = zerosArr4.filter(_\
    \ > 0)\n        val onesArr6 = onesArr5.filter(_ > 0)\n        val zerosArr6 =\
    \ zerosArr5.filter(_ > 0)\n        val onesArr7 = onesArr6.filter(_ > 0)\n   \
    \     val zerosArr7 = zerosArr6.filter(_ > 0)\n        val onesArr8 = onesArr7.filter(_\
    \ > 0)\n        val zerosArr8 = zerosArr7.filter(_ > 0)\n        val onesArr9\
    \ = onesArr8.filter(_ > 0)\n        val zerosArr9 = zerosArr8.filter(_ > 0)\n\
    \        val onesArr10 = onesArr9.filter(_ > 0)\n        val zerosArr10 = zerosArr9.filter(_\
    \ > 0)\n        val onesArr11 = onesArr10.filter(_ > 0)\n        val zerosArr11\
    \ = zerosArr10.filter(_ > 0)\n        val onesArr12 = onesArr11.filter(_ > 0)\n\
    \        val zerosArr12 = zerosArr11.filter(_ > 0)\n        val onesArr13 = onesArr12.filter(_\
    \ > 0)\n        val zerosArr13 = zerosArr12.filter(_ > 0)\n        val onesArr14\
    \ = onesArr13.filter(_ > 0)\n        val zerosArr14 = zerosArr13.filter(_ > 0)\n\
    \        val onesArr15 = onesArr14.filter(_ > 0)\n        val zerosArr15 = zerosArr14.filter(_\
    \ > 0)\n        val onesArr16 = onesArr15.filter(_ > 0)\n        val zerosArr16\
    \ = zerosArr15.filter(_ > 0)\n        val onesArr17 = onesArr16.filter(_ > 0)\n\
    \        val zerosArr17 = zeros\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxw3ebjj2.scala:51:5\
    \ ---------------------\e[0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795017
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesZeros = ones + zeros\n\
    \        val onesZerosSorted = onesZeros.sortBy(x => x.toString.toInt)\n     \
    \   val zerosSorted = zeros.sortBy(x => x.toString.toInt)\n        val onesZerosSortedWithZeros\
    \ = onesZerosSorted.zip(zerosSorted).sortBy(x => x._1 - x._2)\n        val zerosSortedWithOnes\
    \ = zerosSorted.zip(onesSorted).sortBy(x => x._1 - x._2)\n        val onesZerosSortedWithOnes\
    \ = onesZerosSortedWithZeros.zip(zerosSortedWithOnes).sortBy(x => x._1 - x._2)\n\
    \        val zerosSortedWithZeros = zerosSortedWithOnes.zip(onesSorted).sortBy(x\
    \ => x._1 - x._2)\n        val onesSortedWithZeros = onesZerosSortedWithZeros.zip(zerosSortedWithZeros).sortBy(x\
    \ => x._1 - x._2)\n        val zerosSortedWithOnes = zerosSortedWithZeros.zip(onesSortedWithOnes).sortBy(x\
    \ => x._1 - x._2)\n        val onesSortedWithOnes = onesZerosSortedWithZeros.zip(zerosSortedWithOnes).sortBy(x\
    \ => x._1 - x._2)\n        val zerosSortedWithZeros = zerosSortedWithOnes.zip(onesSortedWithZeros).sortBy(x\
    \ => x._1 - x._2)\n        val onesSortedWithZeros = onesZerosSortedWithZeros.zip(zerosSortedWithZeros).sortBy(x\
    \ => x._1 - x._2)\n        val zerosSortedWithOnes = zerosSortedWithZeros.zip(onesSortedWithOnes).sortBy(x\
    \ => x._1 - x._2)\n        val onesSortedWithOnes = onesZerosSortedWithZeros.zip(zerosSortedWithOnes).sortBy(x\
    \ => x._1 - x._2)\n        val zerosSortedWithZeros = zerosSortedWithOnes.zip(onesSortedWithZeros).sortBy(x\
    \ => x._1 - x._2)\n        val onesSortedWithZeros = onesZerosSortedWithZeros.zip(zerosSortedWithZeros).sortBy(x\
    \ => x._1 - x._2)\n        val zerosSortedWithOnes = zerosSortedWithZ\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8a4suv1v.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mzerosSortedWithOnes\e[0m\
    \ = zerosSortedWithZeros.zip(onesSortedWithOnes).sortBy(\e[36mx\e[0m => x._1 -\
    \ x._2)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosSortedWithOnes is already defined as \e[33mvalue\e[0m\
    \ \e[35mzerosSortedWithOnes\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp8a4suv1v.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mzerosSortedWithZeros\e[0m\
    \ = zerosSortedWithOnes.zip(onesSortedWithZeros).sortBy(\e[36mx\e[0m => x._1 -\
    \ x._2)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosSortedWithZeros is already defined as \e[33mvalue\e[0m\
    \ \e[35mzerosSortedWithZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp8a4suv1v.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36monesSortedWithZeros\e[0m\
    \ = onesZerosSortedWithZeros.zip(zerosSortedWithZeros).sortBy(\e[36mx\e[0m =>\
    \ x._1 - x._2)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesSortedWithZeros is already defined as \e[33mvalue\e[0m\
    \ \e[35monesSortedWithZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp8a4suv1v.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mzerosSortedWithOnes\e[0m\
    \ = zerosSortedWithZeros.zip(onesSortedWithOnes).sortBy(\e[36mx\e[0m => x._1 -\
    \ x._2)\n\e[31m\e[31m   |\e[0m        ^^^^^"
  stdout: ''
  timestamp: 1659795018
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((x, y) => x.toLong == y.toLong ? x.toLong\
    \ - y.toLong : x.toLong - y.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8ur91pc5.scala:15:85 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) =>\
    \ x.toLong == y.toLong ? x.toLong - y.toLong : x.toLong \e[35m-\e[0m y.toLong)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \                               Not found: type -\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp8ur91pc5.scala:15:52 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) =>\
    \ x.toLong == y.toLong ? x.toLong - y.toLong : x.toLong \e[35m-\e[0m y.toLong)\n\
    \e[31m\e[31m   |\e[0m                                           ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                         value ? is not a member\
    \ of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1659795021
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).max\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).max\n        val onesDecimal = ones.map(x => x.toString.toDouble).max\n\
    \        val zerosDecimal = zeros.map(x => x.toString.toDouble).max\n        val\
    \ onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n        val zerosDecimalCount\
    \ = zeros.map(x => zeros.count(_ == x)).max\n        val onesDecimalCount = ones.map(x\
    \ => ones.count(_ == x)).max\n        val zerosDecimalCount = zeros.map(x => zeros.count(_\
    \ == x)).max\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).max\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).max\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).max\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).max\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).max\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).max\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).max\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).max\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).max\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).max\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).max\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).max\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).max\n   \
    \     val onesDecimalCount = ones.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1ul1_bws.scala:43:40 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ ones.map(\n\e[31m\e[31m   |\e[0m                                        ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp1ul1_bws.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e[36mx\e\
    [0m => ones.count(_ == x)).max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1ul1_bws.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zeros.map(\e[36mx\e[0m => zeros.count(_ == x)).max\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1ul1_bws.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e\
    [36mx\e[0m => ones.count(_ == x)).max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1ul1_bws.scala:26:12 ---------------------------\e\
    ["
  stdout: ''
  timestamp: 1659795026
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjpjpx_t7.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo01fl7_i.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo01fl7_i.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpo01fl7_i.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659795002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecim\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkk8ax7yc.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpkk8ax7yc.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpkk8ax7yc.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659795025
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesZeros = ones.zip(zeros)\n\
    \        val onesZerosSorted = onesZeros.sortBy(_._1).sortBy(_._2)\n        val\
    \ onesZerosSortedList = onesZerosSorted.map(x => x._1)\n        val zerosSorted\
    \ = zeros.sortBy(_ % 2 == 1).sortBy(_ % 2 == 0)\n        val zerosSortedList =\
    \ zeros.map(x => x.toLong)\n        val zerosSortedList2 = zerosSorted.map(x =>\
    \ x.toLong)\n        val zerosSortedList3 = zerosSorted.map(x => x.toLong)\n \
    \       val zerosSortedList4 = zerosSorted.map(x => x.toLong)\n        val zerosSortedList5\
    \ = zerosSorted.map(x => x.toLong)\n        val zerosSortedList6 = zerosSorted.map(x\
    \ => x.toLong)\n        val zerosSortedList7 = zerosSorted.map(x => x.toLong)\n\
    \        val zerosSortedList8 = zerosSorted.map(x => x.toLong)\n        val zerosSortedList9\
    \ = zerosSorted.map(x => x.toLong)\n        val zerosSortedList10 = zerosSorted.map(x\
    \ => x.toLong)\n        val zerosSortedList11 = zerosSorted.map(x => x.toLong)\n\
    \        val zerosSortedList12 = zerosSorted.map(x => x.toLong)\n        val zerosSortedList13\
    \ = zerosSorted.map(x => x.toLong)\n        val zerosSortedList14 = zerosSorted.map(x\
    \ => x.toLong)\n        val zerosSortedList15 = zerosSorted.map(x => x.toLong)\n\
    \        val zerosSortedList16 = zerosSorted.map(x => x.toLong)\n        val zerosSortedList17\
    \ = zerosSorted.map(x => x.toLong)\n        val zerosSortedList18 = zerosSorted.map(x\
    \ => x.toLong)\n        val zerosSortedList19 = zerosSorted.map(x => x.toLong)\n\
    \        val zerosSortedList20 = zerosSorted.map(x => x.toLong)\n        val zerosSortedList21\
    \ = zerosSorted.map(x => x.toLong)\n        val zerosSortedList22 = zerosSorted.map(x\
    \ => x.toLong)\n        val zerosSortedList23 = zerosSorted.map(x => x.toLong)\n\
    \        val zerosSortedList24 = \n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0sijwlsy.scala:44:31 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mzerosSortedList24\e[0m =\
    \ \n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m\
    \                               expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0sijwlsy.scala:45:5\
    \ ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795026
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesArr = arr.filter(_\
    \ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr = arr.filter(_ % 2 ==\
    \ 1).sortBy(_ % 2).reverse\n        val onesArr2 = onesArr.filter(_ % 2 == 0).sortBy(_\
    \ % 2).reverse\n        val zerosArr2 = zerosArr.filter(_ % 2 == 1).sortBy(_ %\
    \ 2).reverse\n        val onesArr3 = onesArr2.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n\
    \        val zerosArr3 = zerosArr2.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n\
    \        val onesArr4 = onesArr3.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n  \
    \      val zerosArr4 = zerosArr3.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n  \
    \      val onesArr5 = onesArr4.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n    \
    \    val zerosArr5 = zerosArr4.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n    \
    \    val onesArr6 = onesArr5.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n      \
    \  val zerosArr6 = zerosArr5.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n      \
    \  val onesArr7 = onesArr6.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n        val\
    \ zerosArr7 = zerosArr6.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n        val\
    \ onesArr8 = onesArr7.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr8\
    \ = zerosArr7.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n        val onesArr9 =\
    \ onesArr8.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr9 = zerosArr8.filter(_\
    \ % 2 == 1).sortBy(_ % 2).reverse\n        val onesArr10 = onesArr9.filter(_ %\
    \ 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr10 = zerosArr9.filter(_ %\
    \ 2 == 1).sortBy(_ % 2).reverse\n        val onesArr11 = onesArr10.filter(_ %\
    \ 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr11 = zerosArr10.filter(_\
    \ % 2 == 1).sortBy(_ % 2).reverse\n        val onesArr12 = onesArr11.filter(_\
    \ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr12 = zerosArr11.filter\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsqxgi1ca.scala:41:5\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795014
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesZeros = arr.filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).length\n        val onesOnes = arr.filter(_ % 2\
    \ == 1).filter(_ % 2 == 1).length\n        val onesZeroOnes = arr.filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 1).length\n        val onesOnesOnes\
    \ = arr.filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).length\n    \
    \    val onesZeroOnesOnes = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 1).filter(_ % 2 == 1).length\n        val onesOnesOnesOnes = arr.filter(_\
    \ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).length\n\
    \        val onesZeroOnesOnesOnes = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).length\n        val onesOnesOnesOnesOnes\
    \ = arr.filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2\
    \ == 1).filter(_ % 2 == 1).length\n        val onesZeroOnesOnesOnesOnes = arr.filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_\
    \ % 2 == 1).filter(_ % 2 == 1).length\n        val onesOnesOnesOnesOnesOnes =\
    \ arr.filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 ==\
    \ 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).length\n       \
    \ val onesZeroOnesOnesOnesOnesOnes = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_\
    \ % 2 == 1).filter(_ % 2 == 1).length\n        val onesOnesOnesOnesOnesOnesOnes\
    \ = arr.filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2\
    \ == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2\
    \ == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).length\n        val onesZeroOnesOnesOnesOnesOnesOnes\
    \ = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6004haf5.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp6004haf5.scala:30:5 ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795026
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l)\n        val zeros\
    \ = arr.filter(_ == 0l)\n        val onesCount = ones.count\n        val zerosCount\
    \ = zeros.count\n        if (onesCount > zerosCount) {\n            val onesSorted\
    \ = ones.sortWith(compareByOnesCount)\n            val zerosSorted = zeros.sortWith(compareByZeroCount)\n\
    \            onesSorted ++ zerosSorted\n        } else if (zerosCount > onesCount)\
    \ {\n            val zerosSorted = zeros.sortWith(compareByZeroCount)\n      \
    \      val onesSorted = ones.sortWith(compareByOnesCount)\n            zerosSorted\
    \ ++ onesSorted\n        } else {\n            arr\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjhdq9vyp.scala:19:22 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (onesCount > zerosCount) {\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue > is not\
    \ a member of (Long => Boolean) => Int, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjhdq9vyp.scala:20:43\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m\
    \ \e[36monesSorted\e[0m = ones.sortWith(compareByOnesCount)\n\e[31m\e[31m   |\e\
    [0m                                           ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                           Not found: compareByOnesCount\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjhdq9vyp.scala:21:45\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m\
    \ \e[36mzerosSorted\e[0m = zeros.sortWith(compareByZeroCount)\n\e[31m\e[31m  \
    \ |\e[0m                                             ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                           Not found: compareByZeroCount\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjhdq9vyp.scala:23:30\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        } \e[33melse\e[0m\
    \ \e[33mif\e[0m (zerosCount > onesCount) {\n\e[31m\e[31m   |\e[0m            \
    \       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue > is not a member of (Long =>\
    \ Boolean) => Int, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOr"
  stdout: ''
  timestamp: 1659795027
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong).length\n\
    \        val zeros = arr.filter(x => x == 0l.toLong).length\n        val onesZeros\
    \ = ones + zeros\n        val onesZeroArray = Array.ofDim[Long](onesZeros)\n \
    \       val onesZeroArrayCopy = onesZeroArray.clone()\n        val onesZeroArrayCopySorted\
    \ = onesZeroArrayCopy.sortWith(_ < _)\n        val onesZeroArraySortedCopy = onesZeroArrayCopySorted.clone()\n\
    \        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArray\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpex3rh5ih.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesZeroArraySortedCopySorted\e\
    [0m = onesZeroArraySortedCopy.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroArraySortedCopySorted is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroArraySortedCopySorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpex3rh5ih.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36monesZeroArraySortedCopySorted\e\
    [0m = onesZeroArraySortedCopy.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroArraySortedCopySorted is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroArraySortedCopySorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpex3rh5ih.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesZeroArraySortedCopySorted\e\
    [0m = onesZeroArraySortedCopy.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroArraySortedCopySorted is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroArraySortedCopySorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpex3rh5ih.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36monesZeroArraySortedCopySorted\e\
    [0m = onesZeroArraySortedCopy.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroArraySortedCopySorted is already def"
  stdout: ''
  timestamp: 1659795026
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimal = ones.map(x => x.toString.toInt).sum\n\
    \        val zerosDecimal = zeros.map(x => x.toString.toInt).sum\n        val\
    \ onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount\
    \ = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpey32w8te.scala:43:40 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ ones.map(\n\e[31m\e[31m   |\e[0m                                        ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpey32w8te.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e[36mx\e\
    [0m => ones.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpey32w8te.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zeros.map(\e[36mx\e[0m => zeros.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpey32w8te.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e\
    [36mx\e[0m => ones.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpey32w8te.scala:26:12 ---------------------------\e\
    ["
  stdout: ''
  timestamp: 1659795027
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.map(_.toString.toInt).sum\n\
    \        val zerosCount = zeros.map(_.toString.toInt).sum\n        val onesDecimal\
    \ = onesCount / arr.length\n        val zerosDecimal = zerosCount / arr.length\n\
    \        val onesDecimalDecimal = onesDecimal / onesCount\n        val zerosDecimalDecimal\
    \ = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw1geaf9i.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpw1geaf9i.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpw1geaf9i.scala:33:75 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                   ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659795026
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val twos = arr.filter(_ % 2 == 1).length\n        val threes = arr.filter(_\
    \ % 3 == 0).length\n        val fours = arr.filter(_ % 4 == 0).length\n      \
    \  val fives = arr.filter(_ % 5 == 0).length\n        val sixes = arr.filter(_\
    \ % 6 == 0).length\n        val sevens = arr.filter(_ % 7 == 0).length\n     \
    \   val eights = arr.filter(_ % 8 == 0).length\n        val nines = arr.filter(_\
    \ % 9 == 0).length\n        val tens = arr.filter(_ % 10 == 0).length\n      \
    \  val hundreds = arr.filter(_ % 100 == 0).length\n        val thousands = arr.filter(_\
    \ % 1000 == 0).length\n        val tenThousands = arr.filter(_ % 10000 == 0).length\n\
    \        val oneThousands = arr.filter(_ % 100000 == 0).length\n        val oneHundreds\
    \ = arr.filter(_ % 1000000 == 0).length\n        val oneThousandThousands = arr.filter(_\
    \ % 10000000 == 0).length\n        val oneThousandHundreds = arr.filter(_ % 100000000\
    \ == 0).length\n        val oneThousandThousandHundreds = arr.filter(_ % 1000000000\
    \ == 0).length\n        val oneThousandThousandThousandHundreds = arr.filter(_\
    \ % 10000000000 == 0).length\n        val oneThousandThousandThousandThousandHundreds\
    \ = arr.filter(_ % 100000000000 == 0).length\n        val oneThousandThousandThousandThousandHundreds\
    \ = arr.filter(_ % 1000000000000 == 0).length\n        val oneThousandThousandThousandThousandThousandHundreds\
    \ = arr.filter(_ % 10000000000000 == 0).length\n        val oneThousandThousandThousandThousandThousandHundreds\
    \ = arr.filter(_ % 100000000000000 == 0).length\n        val oneThousandThousandThousandThousandThousandThousandHundreds\
    \ = arr.filter(_ % 1000000000000000 == 0).length\n        val oneThousandThousandThousandThousandThousandThousandHundreds\
    \ = arr.filter(_ % 10000000000000000 == 0).length\n        val oneThousandThousandThousandThousandThousandTh\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0tbgej82.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0tbgej82.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36moneThousandThousandThousandThousandHundreds\e[0m = arr.filter(_ % \e[31m1000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moneThousandThousandThousandThousandHundreds is already defined\
    \ as \e[33mvalue\e[0m \e[35moneThousandThousandThousandThousandHundreds\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0tbgej82.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36moneThousandThousandThousandThousandThousandHundreds\e\
    [0m = arr.filter(_ % \e[31m100000000000000\e[0m == \e[31m0\e[0m).length\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moneThousandThousandThousandThousandThousandHundreds is already\
    \ defined as \e[33mvalue\e[0m \e[35moneThousandThousandThousandThousandThousandHundreds\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0tbgej82.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36moneThousandThousandThousandThousandThousandThousandHundreds\e\
    [0m = arr.filter(_ % \e[31m10000000000000000\e[0m == \e[31m0\e[0m).length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moneThousandThousandThousandThousandThousandThousandHundreds\
    \ is already defined as \e[33mvalue\e[0m \e[35moneThousandThousandThousan"
  stdout: ''
  timestamp: 1659795026
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ / onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal /\
    \ zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / one\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpftw4qoyb.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpftw4qoyb.scala:29:61 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpftw4qoyb.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e"
  stdout: ''
  timestamp: 1659795025
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros_sorted\
    \ = onesZeros.sortBy(_ / onesZeros)\n        val onesZeros_sorted2 = onesZeros.sortBy(_\
    \ / onesZeros)\n        val onesZeros_sorted3 = onesZeros.sortBy(_ / onesZeros)\n\
    \        val onesZeros_sorted4 = onesZeros.sortBy(_ / onesZeros)\n        val\
    \ onesZeros_sorted5 = onesZeros.sortBy(_ / onesZeros)\n        val onesZeros_sorted6\
    \ = onesZeros.sortBy(_ / onesZeros)\n        val onesZeros_sorted7 = onesZeros.sortBy(_\
    \ / onesZeros)\n        val onesZeros_sorted8 = onesZeros.sortBy(_ / onesZeros)\n\
    \        val onesZeros_sorted9 = onesZeros.sortBy(_ / onesZeros)\n        val\
    \ onesZeros_sorted10 = onesZeros.sortBy(_ / onesZeros)\n        val onesZeros_sorted11\
    \ = onesZeros.sortBy(_ / onesZeros)\n        val onesZeros_sorted12 = onesZeros.sortBy(_\
    \ / onesZeros)\n        val onesZeros_sorted13 = onesZeros.sortBy(_ / onesZeros)\n\
    \        val onesZeros_sorted14 = onesZeros.sortBy(_ / onesZeros)\n        val\
    \ onesZeros_sorted15 = onesZeros.sortBy(_ / onesZeros)\n        val onesZeros_sorted16\
    \ = onesZeros.sortBy(_ / onesZeros)\n        val onesZeros_sorted17 = onesZeros.sortBy(_\
    \ / onesZeros)\n        val onesZeros_sorted18 = onesZeros.sortBy(_ / onesZeros)\n\
    \        val onesZeros_sorted19 = onesZeros.sortBy(_ / onesZeros)\n        val\
    \ onesZeros_sorted20 = onesZeros.sortBy(_ / onesZeros)\n        val onesZeros_sorted21\
    \ = onesZeros.sortBy(_ / onesZeros)\n        val onesZeros_sorted22 = ones\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmica8mr1.scala:18:41 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted\e[0m =\
    \ onesZeros.sortBy(_ / onesZeros)\n\e[31m\e[31m   |\e[0m                     \
    \          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \   value sortBy is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpmica8mr1.scala:19:42 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m        \e[33mval\e[0m \e[36monesZeros_sorted2\e[0m = onesZeros.sortBy(_ /\
    \ onesZeros)\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                value sortBy is not a member\
    \ of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmica8mr1.scala:20:42\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeros_sorted3\e[0m = onesZeros.sortBy(_ / onesZeros)\n\e[31m\e[31m   |\e\
    [0m                                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                            value sortBy is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpmica8mr1.scala:21:42 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted4\e[0m =\
    \ onesZeros.sortBy(_ / onesZeros)\n\e[31m\e[31m   |\e[0m                     \
    \           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \     value sortBy is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpmica8mr1.scala:22:42 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mval\e[0m \e[36monesZeros_sorted5\e[0m = onesZeros.sortBy(_ /\
    \ onesZeros)\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                value sortBy is not a member\
    \ of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmica8mr1.scala:23:42\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeros_sorted6\e[0m = onesZeros.sortBy(_ / onesZeros)\n\e[31m\e[31m   |\e\
    [0m                                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                            value sortB"
  stdout: ''
  timestamp: 1659795030
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesArr = arr.filter(_\
    \ % 2 == 0).sortBy(_.toString.toInt)\n        val zerosArr = arr.filter(_ % 2\
    \ == 1).sortBy(_.toString.toInt)\n        val onesArr2 = onesArr.sortBy(_.toString.toInt)\n\
    \        val zerosArr2 = zerosArr.sortBy(_.toString.toInt)\n        val onesArr3\
    \ = onesArr2.sortBy(_.toString.toInt)\n        val zerosArr3 = zerosArr2.sortBy(_.toString.toInt)\n\
    \        val onesArr4 = onesArr3.sortBy(_.toString.toInt)\n        val zerosArr4\
    \ = zerosArr3.sortBy(_.toString.toInt)\n        val onesArr5 = onesArr4.sortBy(_.toString.toInt)\n\
    \        val zerosArr5 = zerosArr4.sortBy(_.toString.toInt)\n        val onesArr6\
    \ = onesArr5.sortBy(_.toString.toInt)\n        val zerosArr6 = zerosArr5.sortBy(_.toString.toInt)\n\
    \        val onesArr7 = onesArr6.sortBy(_.toString.toInt)\n        val zerosArr7\
    \ = zerosArr6.sortBy(_.toString.toInt)\n        val onesArr8 = onesArr7.sortBy(_.toString.toInt)\n\
    \        val zerosArr8 = zerosArr7.sortBy(_.toString.toInt)\n        val onesArr9\
    \ = onesArr8.sortBy(_.toString.toInt)\n        val zerosArr9 = zerosArr8.sortBy(_.toString.toInt)\n\
    \        val onesArr10 = onesArr9.sortBy(_.toString.toInt)\n        val zerosArr10\
    \ = zerosArr9.sortBy(_.toString.toInt)\n        val onesArr11 = onesArr10.sortBy(_.toString.toInt)\n\
    \        val zerosArr11 = zerosArr10.sortBy(_.toString.toInt)\n        val onesArr12\
    \ = onesArr11.sortBy(_.toString.toInt)\n        val zerosArr12 = zerosArr11.sortBy(_.toString.toInt)\n\
    \        val onesArr13 = onesArr12.sortBy(_.toString.toInt)\n        val zerosArr13\
    \ = zerosArr12.sortBy(_.toString.toInt)\n        val onesArr14 = onesArr13.sortBy(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp4r19fvsl.scala:43:41 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36monesArr14\e[0m = onesArr13.sortBy(\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp4r19fvsl.scala:44:4\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m44 |\e[0m    }\n\
    \e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both\
    \ \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and\
    \ \e[33mobject\e[0m \e[35mBigDecimal\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e\
    [0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp4r19fvsl.scala:44:5 ---------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795027
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArray = arr.map(x => if (x == 1) 1 else 0)\n\
    \        val zerosArray = arr.map(x => if (x == 0) 0 else 1)\n        val onesArraySorted\
    \ = onesArray.sortWith((x, y) => x < y)\n        val zerosArraySorted = zerosArray.sortWith((x,\
    \ y) => x < y)\n        val onesArraySortedWithZeros = onesArraySorted.zip(zerosArraySorted)\n\
    \        val zerosArraySortedWithOnes = zerosArraySorted.zip(onesArraySorted)\n\
    \        val onesArraySortedWithZerosAndOnes = onesArraySortedWithZeros.zip(zerosArraySortedWithOnes)\n\
    \        val zerosArraySortedWithOnesAndZeros = zerosArraySortedWithOnesAndZeros.map(x\
    \ => if (x._1 == 1) x._2 else x._1)\n        val zerosArraySortedWithOnesAndZerosAndOnes\
    \ = zerosArraySortedWithOnesAndZerosAndOnes.map(x => if (x._1 == 1) x._2 else\
    \ x._1)\n        val zerosArraySortedWithOnesAndZerosAndOnesAndZeros = zerosArraySortedWithOnesAndZerosAndOnesAndZeros.map(x\
    \ => if (x._1 == 1) x._2 else x._1)\n        val zerosArraySortedWithOnesAndZerosAndOnesAndZerosAndOnes\
    \ = zerosArraySortedWithOnesAndZerosAndOnesAndZerosAndOnes.map(x => if (x._1 ==\
    \ 1) x._2 else x._1)\n        val zerosArraySortedWithOnesAndZerosAndOnesAndZerosAndOnesAndZeros\
    \ = zerosArraySortedWithOnesAndZerosAndOnesAndZerosAndOnesAndZeros.map(x => if\
    \ (x._1 == 1) x._2 else x._1)\n        val zerosArraySortedWithOnesAndZerosAndOnesAndZerosAndOnesAndZerosAndOnes\
    \ = zerosArraySortedWithOnesAndZerosAndOnesAndZerosAndOnesAndZerosAndOnes.map(x\
    \ => if (x._1 == 1) x._2 else x._1)\n        val zerosArraySortedWithOnesAndZerosAndOnesAndZerosAndOnesAndZerosAndOnesAndZeros\
    \ = zerosArraySortedWithOnesAndZerosAndOnesAndZerosAndOnesAndZerosAndOnesAndZeros.map(x\
    \ => if (x._1 == \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpx6yqfxze.scala:30:190 --------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mzerosArraySortedWithOnesAndZerosAndOnesAndZerosAndOnesAndZerosAndOnesAndZeros\e\
    [0m = zerosArraySortedWithOnesAndZerosAndOnesAndZerosAndOnesAndZerosAndOnesAndZeros.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x._1 == \n\e[31m\e[31m   |\e[0m                 \
    \                                                                            \
    \                                                                            \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \       expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpx6yqfxze.scala:24:47 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosArraySortedWithOnesAndZeros\e\
    [0m = zerosArraySortedWithOnesAndZeros.map(\e[36mx\e[0m => \e[33mif\e[0m (x._1\
    \ == \e[31m1\e[0m) x._2 \e[33melse\e[0m x._1)\n\e[31m\e[31m   |\e[0m         \
    \                                      ^\e[0m\n\e[31m   |\e[0m             Recursive\
    \ \e[33mvalue\e[0m \e[35mzerosArraySortedWithOnesAndZeros\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx6yqfxze.scala:25:54\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosArraySortedWithOnesAndZerosAndOnes\e[0m = zerosArraySortedWithOnesAndZerosAndOnes.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x._1 == \e[31m1\e[0m) x._2 \e[33melse\e[0m x._1)\n\
    \e[31m\e[31m   |\e[0m                                                      ^\e\
    [0m\n\e[31m   |\e[0m      Recursive \e[33mvalue\e[0m \e[35mzerosArraySortedWithOnesAndZerosAndOnes\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx6yqfxze.scala:26:62\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosArraySortedWithOnesAndZerosAndOnesAndZeros\e[0m = "
  stdout: ''
  timestamp: 1659795028
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesArr = arr.filter(_\
    \ % 2 == 0).sortBy(x => math.abs(x))\n        val zerosArr = arr.filter(_ % 2\
    \ == 1).sortBy(x => math.abs(x))\n        val onesSortedArr = onesArr.take(ones)\n\
    \        val zerosSortedArr = zerosArr.take(zeros)\n        onesSortedArr.zip(zerosSortedArr).sortBy(_._1).map(_._2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkq6pxdht.scala:24)\n\tat Problem.main(tmpkq6pxdht.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795030
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(_.toString.toInt).sum\n\
    \        val zerosCount = zeros.map(_.toString.toInt).sum\n        val onesDecimal\
    \ = ones.map(_.toString.toInt).map(_.toString.toDouble).sum\n        val zerosDecimal\
    \ = zeros.map(_.toString.toInt).map(_.toString.toDouble).sum\n        val onesDecimalDecimal\
    \ = ones.map(_.toString.toInt).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val zerosDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val onesDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val zerosDecimalDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val onesDecimalDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val zerosDecimalDecimalDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = ones.map(_.toString.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwf8dgchs.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwf8dgchs.scala:30:5 ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795029
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZerosInv\
    \ = onesZeros / arr.length\n        val onesZerosInv2 = onesZerosInv * onesZerosInv\n\
    \        val onesZerosInv3 = onesZerosInv2 * onesZerosInv\n        val onesZerosInv4\
    \ = onesZerosInv3 * onesZerosInv\n        val onesZerosInv5 = onesZerosInv4 *\
    \ onesZerosInv\n        val onesZerosInv6 = onesZerosInv5 * onesZerosInv\n   \
    \     val onesZerosInv7 = onesZerosInv6 * onesZerosInv\n        val onesZerosInv8\
    \ = onesZerosInv7 * onesZerosInv\n        val onesZerosInv9 = onesZerosInv8 *\
    \ onesZerosInv\n        val onesZerosInv10 = onesZerosInv9 * onesZerosInv\n  \
    \      val onesZerosInv11 = onesZerosInv10 * onesZerosInv\n        val onesZerosInv12\
    \ = onesZerosInv11 * onesZerosInv\n        val onesZerosInv13 = onesZerosInv12\
    \ * onesZerosInv\n        val onesZerosInv14 = onesZerosInv13 * onesZerosInv\n\
    \        val onesZerosInv15 = onesZerosInv14 * onesZerosInv\n        val onesZerosInv16\
    \ = onesZerosInv15 * onesZerosInv\n        val onesZerosInv17 = onesZerosInv16\
    \ * onesZerosInv\n        val onesZerosInv18 = onesZerosInv17 * onesZerosInv\n\
    \        val onesZerosInv19 = onesZerosInv18 * onesZerosInv\n        val onesZerosInv20\
    \ = onesZerosInv19 * onesZerosInv\n        val onesZerosInv21 = onesZerosInv20\
    \ * onesZerosInv\n        val onesZerosInv22 = onesZerosInv21 * onesZerosInv\n\
    \        val onesZerosInv23 = onesZerosInv22 * onesZerosInv\n        val onesZerosIn\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf5bikck0.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpf5bikck0.scala:42:5 ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795028
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecim\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdvyo88tk.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpdvyo88tk.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdvyo88tk.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m                                         \
    \                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tm"
  stdout: ''
  timestamp: 1659795029
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjpjpx_t7.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x.toInt == 1)\n       \
    \ val zeros = arr.filter(x => x.toInt == 0)\n        val onesCount = ones.map(x\
    \ => x.toInt).sum\n        val zerosCount = zeros.map(x => x.toInt).sum\n    \
    \    val onesDecimal = onesCount / arr.length\n        val zerosDecimal = zerosCount\
    \ / arr.length\n        val onesDecimalDecimal = onesDecimal / onesCount\n   \
    \     val zerosDecimalDecimal = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = ones\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpen56ahn0.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimal / zerosCount\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpen56ahn0.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpen56ahn0.scala:40:5 ---------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795029
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArray = arr.map(x => if (x == 1) 1 else 0)\n\
    \        val zerosArray = arr.map(x => if (x == 0) 0 else 1)\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArray.length\n      \
    \  val zerosArrayLength = zerosArray.length\n        val onesArrayLength = onesArray.length\n\
    \        val zerosArrayLength = zerosArray.length\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArray.length\n      \
    \  val zerosArrayLength = zerosArray.length\n        val onesArrayLength = onesArray.length\n\
    \        val zerosArrayLength = zerosArray.length\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArray.length\n      \
    \  val zerosArrayLength = zerosArray.length\n        val onesArrayLength = onesArray.length\n\
    \        val zerosArrayLength = zerosArray.length\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArray.length\n      \
    \  val zerosArrayLength = zerosArray.length\n        val onesArrayLength = onesArray.length\n\
    \        val zerosArrayLength = zerosArray.length\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeup9cds4.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e[35monesArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpeup9cds4.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m = zerosArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e[35mzerosArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpeup9cds4.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e[35monesArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpeup9cds4.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m = zerosArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e[35mzerosArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpeup9cds4.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795028
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesZeros = arr.filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).length\n        val onesOnes = arr.filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 1).length\n        val onesTwos = arr.filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 2).length\n\
    \        val onesThrees = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ %\
    \ 2 == 1).filter(_ % 2 == 2).filter(_ % 2 == 3).length\n        val onesFours\
    \ = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2\
    \ == 2).filter(_ % 2 == 3).filter(_ % 2 == 4).length\n        val onesFives =\
    \ arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 ==\
    \ 2).filter(_ % 2 == 3).filter(_ % 2 == 4).filter(_ % 2 == 5).length\n       \
    \ val onesSixes = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_\
    \ % 2 == 2).filter(_ % 2 == 3).filter(_ % 2 == 4).filter(_ % 2 == 5).filter(_\
    \ % 2 == 6).length\n        val onesSevens = arr.filter(_ % 2 == 0).filter(_ %\
    \ 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 2).filter(_ % 2 == 3).filter(_ %\
    \ 2 == 4).filter(_ % 2 == 5).filter(_ % 2 == 6).filter(_ % 2 == 7).length\n  \
    \      val onesEights = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2\
    \ == 1).filter(_ % 2 == 2).filter(_ % 2 == 3).filter(_ % 2 == 4).filter(_ % 2\
    \ == 5).filter(_ % 2 == 6).filter(_ % 2 == 7).filter(_ % 2 == 8).length\n    \
    \    val onesNines = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 ==\
    \ 1).filter(_ % 2 == 2).filter(_ % 2 == 3).filter(_ % 2 == 4).filter(_ % 2 ==\
    \ 5).filter(_ % 2 == 6).filter(_ % 2 == 7).filter(_ % 2 == 8).filter(_ % 2 ==\
    \ 9).length\n        val onesTens = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 1).filter(_ % 2 == 2).filter(_ % 2 == 3).filter(_ % 2 == 4).filter(_\
    \ % 2 == 5).filter(_ % \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp2u1nv951.scala:27:170 --------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36monesTens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).filter(_ % \e[31m2\e[0m == \e[31m1\e[0m).filter(_\
    \ % \e[31m2\e[0m == \e[31m1\e[0m).filter(_ % \e[31m2\e[0m == \e[31m2\e[0m).filter(_\
    \ % \e[31m2\e[0m == \e[31m3\e[0m).filter(_ % \e[31m2\e[0m == \e[31m4\e[0m).filter(_\
    \ % \e[31m2\e[0m == \e[31m5\e[0m).filter(_ % \n\e[31m\e[31m   |\e[0m         \
    \                                                                            \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp2u1nv951.scala:28:5 ---------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795030
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val decimals = arr.filter(_\
    \ % 10 == 0).length\n        val decimalsDecimals = arr.filter(_ % 10 == 1).length\n\
    \        val decimalsDecimalsDecimals = arr.filter(_ % 10 == 2).length\n     \
    \   val decimalsDecimalsDecimalsDecimals = arr.filter(_ % 10 == 3).length\n  \
    \      val decimalsDecimalsDecimalsDecimalsDecimals = arr.filter(_ % 10 == 4).length\n\
    \        val decimalsDecimalsDecimalsDecimalsDecimalsDecimals = arr.filter(_ %\
    \ 10 == 5).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 6).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 7).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 8).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 9).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 10).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 11).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 12).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 13).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 14).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 15).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsnztm2_0.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpsnztm2_0.scala:34:5 ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795030
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l.toLong).length\n   \
    \     val zeros = arr.filter(_ == 0l.toLong).length\n        val onesZeros = ones\
    \ + zeros\n        val onesZeros_sorted = arr.sortBy(x => (onesZeros - x.toLong))\n\
    \        val onesZeros_sorted_reversed = onesZeros_sorted.reverse\n        val\
    \ onesZeros_sorted_reversed_sorted = onesZeros_sorted_reversed.sortBy(x => (onesZeros\
    \ - x.toLong))\n        val onesZeros_sorted_reversed_sorted_reversed = onesZeros_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted = onesZeros_sorted_reversed_sorted_reversed.sortBy(x\
    \ => (onesZeros - x.toLong))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted.reverse\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x => (onesZeros\
    \ - x.toLong))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => (onesZeros - x.toLong))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.sortBy(x\
    \ => (onesZeros - x.toLong))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3_kse43g.scala:28:111 --------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\e\
    [0m = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.sortBy(\e\
    [36mx\e[0m => (onesZeros - x.toLong))\n\e[31m\e[31m   |\e[0m                 \
    \                                                                            \
    \                  ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e\
    [31m   |\e[0m  onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp3_kse43g.scala:29:120 -----------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\e\
    [0m = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3_kse43g.scala:30:136\
    \ -----------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\e\
    [0m = onesZeros_sorted_reversed_sorted_reversed_sorted_reverse\n\e[31m\e[31m \
    \  |\e[0m                                                                 "
  stdout: ''
  timestamp: 1659795031
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesArr2 = onesArr.zip(zerosArr).sortBy(_._1).map(_._2)\n        val zerosArr2\
    \ = zerosArr.zip(onesArr).sortBy(_._1).map(_._2)\n        onesArr2.toList ++ zerosArr2.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsgcqwgtk.scala:24)\n\tat Problem.main(tmpsgcqwgtk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795036
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal *\
    \ 10\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal * 10\n    \
    \    val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal *\
    \ 10\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6_vvmvdp.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp6_vvmvdp.scala:25:47 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimal\e[0m\
    \ = onesDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m  \
    \                                             ^\e[0m\n\e[31m   |\e[0m        \
    \     Recursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimal\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6_vvmvdp.scala:26:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimal\
    \ * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m                                     \
    \           ^\e[0m\n\e[31m   |\e[0m            Recursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6_vvmvdp.scala:39:96\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDe"
  stdout: ''
  timestamp: 1659795037
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.count(_\
    \ == 1)\n        val zerosCount = zeros.count(_ == 0)\n        val onesDecimal\
    \ = onesCount.toDouble / arr.length\n        val zerosDecimal = zerosCount.toDouble\
    \ / arr.length\n        val onesDecimalInt = onesDecimal.toInt\n        val zerosDecimalInt\
    \ = zerosDecimal.toInt\n        val onesDecimalLong = onesDecimal.toLong\n   \
    \     val zerosDecimalLong = zerosDecimal.toLong\n        val onesDecimalLongInt\
    \ = onesDecimalLong.toInt\n        val zerosDecimalLongInt = zerosDecimalLong.toInt\n\
    \        val onesDecimalLongLong = onesDecimalLong.toLong\n        val zerosDecimalLongLong\
    \ = zerosDecimalLong.toLong\n        val onesDecimalLongLongInt = onesDecimalLongLong.toInt\n\
    \        val zerosDecimalLongLongInt = zerosDecimalLongLong.toInt\n        val\
    \ onesDecimalLongLongLong = onesDecimalLongLong.toLong\n        val zerosDecimalLongLongLong\
    \ = zerosDecimalLongLong.toLong\n        val onesDecimalLongLongLongInt = onesDecimalLongLongLong.toInt\n\
    \        val zerosDecimalLongLongLongInt = zerosDecimalLongLongLong.toInt\n  \
    \      val onesDecimalLongLongLongLong = onesDecimalLongLongLong.toLong\n    \
    \    val zerosDecimalLongLongLongLong = zerosDecimalLongLongLong.toLong\n    \
    \    val onesDecimalLongLongLongLongInt = onesDecimalLongLongLongLong.toInt\n\
    \        val zerosDecimalLongLongLongLongInt = zerosDecimalLongLongLongLong.toInt\n\
    \        val onesDecimalLongLongLongLongLong = onesDecimalLongLongLongLong.toLong\n\
    \        val zerosDecimalLongLongLongLongLong = zerosDecimalLongLongLongLong.toLong\n\
    \        val onesDecimalLongLongLongLongLongInt = onesDecimalLongLongLongLongLong.toInt\n\
    \        val zerosDecimalLongLongLongLongLongInt = zerosDecimalLongLongLongLongLong.toInt\n\
    \        val onesDecimalLongLongLongLongLongLong = onesDecimalLongLongLongLongLongLong.toLong\n\
    \        val zerosDecimalLongLongLongLongLongLong = zerosDecimalLongLongLongLongLongLong.toLong\n\
    \        val onesDecimalLongLongLongLongLongLongInt = onesDecimalLongLongLongLongLongLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpq5_rmk_6.scala:43:50 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36monesDecimalLongLongLongLongLongLong\e\
    [0m = onesDecimalLongLongLongLongLongLong.toLong\n\e[31m\e[31m   |\e[0m      \
    \                                            ^\e[0m\n\e[31m   |\e[0m         \
    \ Recursive \e[33mvalue\e[0m \e[35monesDecimalLongLongLongLongLongLong\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpq5_rmk_6.scala:44:51\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalLongLongLongLongLongLong\e[0m = zerosDecimalLongLongLongLongLongLong.toLong\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0m         Recursive \e[33mvalue\e[0m \e[35mzerosDecimalLongLongLongLongLongLong\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq5_rmk_6.scala:46:5\
    \ ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795037
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesCount = onesArr.length\n        val zerosCount = zerosArr.length\n     \
    \   val onesSum = onesArr.foldLeft(0L)(_ + _)\n        val zerosSum = zerosArr.foldLeft(0L)(_\
    \ + _)\n        val onesMax = onesSum / onesCount\n        val zerosMax = zerosSum\
    \ / zerosCount\n        val onesMin = onesSum / onesCount * -1\n        val zerosMin\
    \ = zerosSum / zerosCount * -1\n        val onesSumArr = onesArr.sortBy(_.toString.toInt)\n\
    \        val zerosSumArr = zerosArr.sortBy(_.toString.toInt)\n        val onesSumCount\
    \ = onesSumArr.length\n        val zerosSumCount = zerosSumArr.length\n      \
    \  val onesSumMax = onesSumArr.foldLeft(0L)(_ + _) / onesSumCount\n        val\
    \ zerosSumMax = zerosSumArr.foldLeft(0L)(_ + _) / zerosSumCount\n        val onesSumMin\
    \ = onesSumArr.foldLeft(0L)(_ + _) * -1 / onesSumCount\n        val zerosSumMin\
    \ = zerosSumArr.foldLeft(0L)(_ + _) * -1 / zerosSumCount\n        val onesSumSumArr\
    \ = onesSumArr.sortBy(_.toString.toInt)\n        val zerosSumSumArr = zerosSumArr.sortBy(_.toString.toInt)\n\
    \        val onesSumSumCount = onesSumSumArr.length\n        val zerosSumSumCount\
    \ = zerosSumSumArr.length\n        val onesSumMax = onesSumSumArr.foldLeft(0L)(_\
    \ + _) / onesSumSumCount\n        val zerosSumMax = zerosSumSumArr.foldLeft(0L)(_\
    \ + _) / zerosSumSumCount\n        val onesSumMin = onesSumSumArr.foldLeft(0L)(_\
    \ + _) * -1 / onesSumSumCount\n        val zerosSumMin = \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp39gck54j.scala:42:25 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mzerosSumMin\e[0m = \n\e\
    [31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m          \
    \               expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp39gck54j.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36monesSumMax\e[0m = onesSumSumArr.foldLeft(\e\
    [31m0L\e[0m)(_ + _) / onesSumSumCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesSumMax is already defined as \e[33mvalue\e[0m \e[35monesSumMax\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp39gck54j.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mzerosSumMax\e[0m = zerosSumSumArr.foldLeft(\e\
    [31m0L\e[0m)(_ + _) / zerosSumSumCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosSumMax is already defined as \e[33mvalue\e[0m \e[35mzerosSumMax\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp39gck54j.scala:41:12 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m        \e[33mval\e[0m \e[36monesSumMin\e[0m = onesSumSumArr.foldLeft(\e\
    [31m0L\e[0m)(_ + _) * -\e[31m1\e[0m / onesSumSumCount\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesSumMin is already defined as \e[33mvalue\e[0m \e[35monesSumMin\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp39gck54j.scala:43:5 ---------------------\e[0m\e[0m\n\
    \e[31m"
  stdout: ''
  timestamp: 1659795038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.count(_\
    \ == 1)\n        val zerosCount = zeros.count(_ == 0)\n        val onesDecimal\
    \ = onesCount / arr.size\n        val zerosDecimal = zerosCount / arr.size\n \
    \       val onesDecimalDecimal = onesDecimal / zerosDecimal\n        val zerosDecimalDecimal\
    \ = zerosDecimal / onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdfajecaw.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpdfajecaw.scala:29:61 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdfajecaw.scala:30:62\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m                                                              ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdfajecaw.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval"
  stdout: ''
  timestamp: 1659795038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(_.toString.toInt).sum\n\
    \        val zerosCount = zeros.map(_.toString.toInt).sum\n        val onesDecimal\
    \ = onesCount / 2\n        val zerosDecimal = zerosCount / 2\n        val onesDecimalDecimal\
    \ = onesDecimal / 2\n        val zerosDecimalDecimal = zerosDecimal / 2\n    \
    \    val onesDecimalDecimalDecimal = onesDecimalDecimal / 2\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal / 2\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDeci\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9_9amguu.scala:37:89 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9_9amguu.scala:32:69\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                               ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9_9amguu.scala:38:90\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDeci\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDeci\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explai"
  stdout: ''
  timestamp: 1659795037
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesArr = arr.filter(_\
    \ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr = arr.filter(_ % 2 ==\
    \ 1).sortBy(_ % 2).reverse\n        val onesArr2 = onesArr.filter(_ % 2 == 0).sortBy(_\
    \ % 2).reverse\n        val zerosArr2 = zerosArr.filter(_ % 2 == 1).sortBy(_ %\
    \ 2).reverse\n        val onesArr3 = onesArr2.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n\
    \        val zerosArr3 = zerosArr2.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n\
    \        val onesArr4 = onesArr3.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n  \
    \      val zerosArr4 = zerosArr3.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n  \
    \      val onesArr5 = onesArr4.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n    \
    \    val zerosArr5 = zerosArr4.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n    \
    \    val onesArr6 = onesArr5.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n      \
    \  val zerosArr6 = zerosArr5.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n      \
    \  val onesArr7 = onesArr6.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n        val\
    \ zerosArr7 = zerosArr6.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n        val\
    \ onesArr8 = onesArr7.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr8\
    \ = zerosArr7.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n        val onesArr9 =\
    \ onesArr8.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr9 = zerosArr8.filter(_\
    \ % 2 == 1).sortBy(_ % 2).reverse\n        val onesArr10 = onesArr9.filter(_ %\
    \ 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr10 = zerosArr9.filter(_ %\
    \ 2 == 1).sortBy(_ % 2).reverse\n        val onesArr11 = onesArr10.filter(_ %\
    \ 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr11 = zerosArr10.filter(_\
    \ % 2 == 1).sortBy(_ % 2).reverse\n        val onesArr12 = onesArr11.filter(_\
    \ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr12 = zerosArr11.filter\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsqxgi1ca.scala:41:5\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795014
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros_sorted\
    \ = arr.sortWith(x => onesZeros_sorted - x)\n        val onesZeros_sortedWithOnes\
    \ = onesZeros_sorted.take(ones)\n        val onesZeros_sortedWithOnesZeros = onesZeros_sortedWithOnes.take(zeros)\n\
    \        val onesZeros_sortedWithOnesZeros_sorted = onesZeros_sortedWithOnesZeros.sortWith(x\
    \ => x - onesZeros_sortedWithOnesZeros)\n        onesZeros_sortedWithOnesZeros_sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp4ds92fsd.scala:18:46 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted\e[0m =\
    \ arr.sortWith(\e[36mx\e[0m => onesZeros_sorted - x)\n\e[31m\e[31m   |\e[0m  \
    \                                          ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                 Wrong number of parameters, expected:\
    \ 2\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp4ds92fsd.scala:21:92 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sortedWithOnesZeros_sorted\e\
    [0m = onesZeros_sortedWithOnesZeros.sortWith(\e[36mx\e[0m => x - onesZeros_sortedWithOnesZeros)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                 Wrong number of parameters, expected:\
    \ 2\n2 errors found\n"
  stdout: ''
  timestamp: 1659795034
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimal = ones.map(x => x.toString.toInt).sum\n\
    \        val zerosDecimal = zeros.map(x => x.toString.toInt).sum\n        val\
    \ onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount\
    \ = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpey32w8te.scala:43:40 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ ones.map(\n\e[31m\e[31m   |\e[0m                                        ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpey32w8te.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e[36mx\e\
    [0m => ones.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpey32w8te.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zeros.map(\e[36mx\e[0m => zeros.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpey32w8te.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e\
    [36mx\e[0m => ones.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpey32w8te.scala:26:12 ---------------------------\e\
    ["
  stdout: ''
  timestamp: 1659795027
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimal = ones.map(x => x.toString.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(x => x.toString.toDouble).sum\n        val\
    \ onesDecimalDecimal = onesDecimal.toString.toDouble\n        val zerosDecimalDecimal\
    \ = zerosDecimal.toString.toDouble\n        val onesDecimalDecimalDecimal = onesDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp_hxjn313.scala:40:11 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp_hxjn313.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_hxjn313.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_hxjn313.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjpjpx_t7.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa_nvkjbq.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpa_nvkjbq.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa_nvkjbq.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m                                         \
    \                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tm"
  stdout: ''
  timestamp: 1659795038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesCount = onesArr.length\n        val zerosCount = zerosArr.length\n     \
    \   val onesSum = onesArr.foldLeft(0L)(_ + _)\n        val zerosSum = zerosArr.foldLeft(0L)(_\
    \ + _)\n        val onesMax = onesSum / onesCount\n        val zerosMax = zerosSum\
    \ / zerosCount\n        val onesMin = onesSum / onesCount\n        val zerosMin\
    \ = zerosSum / zerosCount\n        val onesAvg = onesSum / onesCount\n       \
    \ val zerosAvg = zerosSum / zerosCount\n        val onesDev = onesSum / onesCount\n\
    \        val zerosDev = zerosSum / zerosCount\n        val onesDeviation = onesSum\
    \ / onesCount - onesAvg\n        val zerosDeviation = zerosSum / zerosCount -\
    \ zerosAvg\n        val onesVariance = onesDev / onesCount\n        val zerosVariance\
    \ = zerosDev / zerosCount\n        val onesStandardDeviation = math.sqrt(onesVariance)\n\
    \        val zerosStandardDeviation = math.sqrt(zerosVariance)\n        val onesStandardError\
    \ = math.sqrt((onesVariance - onesStandardDeviation) * (onesVariance - onesStandardDeviation))\n\
    \        val zerosStandardError = math.sqrt((zerosVariance - zerosStandardDeviation)\
    \ * (zerosVariance - zerosStandardDeviation))\n        val onesVarianceDeviation\
    \ = onesStandardDeviation / onesCount\n        val zerosVarianceDeviation = zerosStandardDeviation\
    \ / zerosCount\n        val onesVarianceStandardError = math.sqrt((onesVarianceDeviation\
    \ - onesStandardError) * (onesVarianceDeviation - onesStandardError))\n      \
    \  val zerosVarianceStandardError = math.sqrt((zerosVarianceDeviation - zerosStandardError)\
    \ * (zerosVarianceDeviation - zerosStandardError))\n        val onesVarianceStandardDeviation\
    \ = onesStandardError / onesCount\n        val zerosVarianceStandardDeviation\
    \ = zerosStandardError / zerosCount\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaa7btzz3.scala:46:5\
    \ ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesArr = arr.filter(_\
    \ % 2 == 0).map(_.toLong)\n        val zerosArr = arr.filter(_ % 2 == 1).map(_.toLong)\n\
    \        val onesArr = onesArr.sortBy(_.toInt)\n        val zerosArr = zerosArr.sortBy(_.toInt)\n\
    \        val onesArr = onesArr.sortBy(_.toLong)\n        val zerosArr = zerosArr.sortBy(_.toLong)\n\
    \        val onesArr = onesArr.sortBy(_.toInt)\n        val zerosArr = zerosArr.sortBy(_.toInt)\n\
    \        val onesArr = onesArr.sortBy(_.toLong)\n        val zerosArr = zerosArr.sortBy(_.toLong)\n\
    \        val onesArr = onesArr.sortBy(_.toInt)\n        val zerosArr = zerosArr.sortBy(_.toInt)\n\
    \        val onesArr = onesArr.sortBy(_.toLong)\n        val zerosArr = zerosArr.sortBy(_.toLong)\n\
    \        val onesArr = onesArr.sortBy(_.toInt)\n        val zerosArr = zerosArr.sortBy(_.toInt)\n\
    \        val onesArr = onesArr.sortBy(_.toLong)\n        val zerosArr = zerosArr.sortBy(_.toLong)\n\
    \        val onesArr = onesArr.sortBy(_.toInt)\n        val zerosArr = zerosArr.sortBy(_.toInt)\n\
    \        val onesArr = onesArr.sortBy(_.toLong)\n        val zerosArr = zerosArr.sortBy(_.toLong)\n\
    \        val onesArr = onesArr.sortBy(_.toInt)\n        val zerosArr = zerosArr.sortBy(_.toInt)\n\
    \        val onesArr = onesArr.sortBy(_.toLong)\n        val zerosArr = zerosArr.sortBy(_.toLong)\n\
    \        val onesArr = onesArr.sortBy(_.toInt)\n        val zerosArr = zerosArr.sortBy(_.toInt)\n\
    \        val onesArr = onesArr.sortBy(_.toLong)\n        val zerosArr = zerosArr.sortBy(_.toLong)\n\
    \        val onesAr\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphaxjub61.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphaxjub61.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesArr\e[0m = onesArr.sortBy(_.toInt)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphaxjub61.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.sortBy(_.toInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosArr is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphaxjub61.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortBy(_.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphaxjub61.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.sortBy(_.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosArr is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphaxjub61.scala:23:12 ---------------------------\e[0"
  stdout: ''
  timestamp: 1659795038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val onesArr = arr.filter(_ == 1).map(_.toLong)\n\
    \        val zerosArr = arr.filter(_ == 0).map(_.toLong)\n        val onesArr\
    \ = onesArr.sortBy(_.toInt)\n        val zerosArr = zerosArr.sortBy(_.toInt)\n\
    \        val result = onesArr.zip(zerosArr).sortBy(_._1).map(x => x._2)\n    \
    \    result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsav4p1se.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortBy(_.toInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpsav4p1se.scala:20:12 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.sortBy(_.toInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosArr is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1659795036
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesZeros = ones + zeros\n\
    \        val onesZeroCount = onesZeros.map(_.toLong).sum\n        val zeroCount\
    \ = zeros.map(_.toLong).sum\n        val onesZeroCountAndZeroCount = onesZeroCount\
    \ + zeroCount\n        val onesZeroCountAndZeroCountAndOnesZeroCount = onesZeroCountAndZeroCount\
    \ + onesZeroCount\n        val onesZeroCountAndZeroCountAndOnesZeroCountAndOnesZeroCount\
    \ = onesZeroCountAndZeroCountAndOnesZeroCount + onesZeroCountAndOnesZeroCount\n\
    \        val onesZeroCountAndZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCount\
    \ = onesZeroCountAndZeroCountAndOnesZeroCountAndOnesZeroCount + onesZeroCountAndOnesZeroCountAndOnesZeroCount\n\
    \        val onesZeroCountAndZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCount\
    \ = onesZeroCountAndZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCount\
    \ + onesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCount\n\
    \        val onesZeroCountAndZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCount\
    \ = onesZeroCountAndZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCount\
    \ + onesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCount\n\
    \        val onesZeroCountAndZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCount\
    \ = onesZeroCountAndZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCount\
    \ + onesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOne\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7n8898x_.scala:17:29 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = ones +\
    \ zeros\n\e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue + is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7n8898x_.scala:25:120\
    \ --------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroCountAndZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCount\e\
    [0m = onesZeroCountAndZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCount\
    \ + onesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCount\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZeroCountAndZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCount\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp7n8898x_.scala:26:152 -----------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36monesZeroCountAndZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCount\e\
    [0m = onesZeroCountAndZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCount\
    \ + onesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZeroCountAndOnesZ"
  stdout: ''
  timestamp: 1659795041
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n  \
    \      val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmxo023po.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmxo023po.scala:31:68\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m    \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmxo023po.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmxo023po.scala:36:83\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimal)\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal.toDouble / Math.pow(10, onesDecimalDecimal)\n        val\
    \ onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimalDecimal)\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal.toDouble / Math.pow(10, onesDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimalDecimalDecimal)\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal.toDouble / Math.pow(10, onesDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimalDecimalDecimalDecimal)\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / Math.pow(10, onesDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimalDecimalDecimalDecimalDecimal)\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpskf6phim.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble /\
    \ Math.pow(\e[31m10\e[0m, onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpskf6phim.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpskf6phim.scala:25:47 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimal\e[0m\
    \ = onesDecimalDecimalDecimalDecimal.toDouble / Math.pow(\e[31m10\e[0m, zerosDecimalDecimalDecimal)\n\
    \e[31m\e[31m   |\e[0m                                               ^\e[0m\n\e\
    [31m   |\e[0m             Recursive \e[33mvalue\e[0m \e[35mone"
  stdout: ''
  timestamp: 1659795039
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x))\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x))\n        val onesZeros = ones.zip(zeros)\n        val onesZeroCount =\
    \ onesZeros.map(x => onesZeros.count(_ == x))\n        val onesZeroCountSorted\
    \ = onesZeroCount.sortBy(x => x._1)\n        val onesZeroCountSortedSortedList\
    \ = onesZeroCountSorted.toList\n        val onesZeroCountSortedSortedListSorted\
    \ = onesZeroCountSortedSortedList.sortBy(x => x._2)\n        val onesZeroCountSortedSortedListSortedSorted\
    \ = onesZeroCountSortedSortedListSorted.toList\n        val onesZeroCountSortedSortedListSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8hthz6gd.scala:26:4 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8hthz6gd.scala:21:62\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeroCountSorted\e[0m = onesZeroCount.sortBy(\e[36mx\e[0m => x._1)\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \  ^^^^\e[0m\n\e[31m   |\e[0m                                         value _1\
    \ is not a member of Int\n\e[31m\e[31m-- Error: /tmp/tmp8hthz6gd.scala:21:65 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeroCountSorted\e[0m\
    \ = onesZeroCount.sortBy(\e[36mx\e[0m => x._1)\n\e[31m\e[31m   |\e[0m        \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp8hthz6gd.scala:26:5 ---------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659795040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArray = arr.map(x => if (x == 1) 1 else 0)\n\
    \        val zerosArray = arr.map(x => if (x == 0) 0 else 1)\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArrayLength + zerosArrayLength\n        val onesArray\
    \ = onesArray.take(onesArrayLength)\n        val zerosArray = zerosArray.take(zerosArrayLength)\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArray = onesArray.take(onesArrayLength)\n\
    \        val zerosArray = zerosArray.take(zerosArrayLength)\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArray = onesArray.take(onesArrayLength)\n        val zerosArray =\
    \ zerosArray.take(zerosArrayLength)\n        val onesArrayLength = onesArray.length\n\
    \        val zerosArrayLength = zerosArray.length\n        val onesArray = onesArray.take(onesArrayLength)\n\
    \        val zerosArray = zerosArray.take(zerosArrayLength)\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArray = onesArray.take(onesArrayLength)\n        val zerosArray =\
    \ zerosArray.take(zerosArrayLength)\n        val onesArrayLength = onesArray.length\n\
    \        val zerosArrayLength = zerosArray.length\n        val onesArray = onesArray.take(onesArrayLength)\n\
    \        val zerosArray = zerosArray.take(zerosArrayLength)\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArray = onesArray.take(onesArrayLength)\n        val zerosArray =\
    \ zerosArray.take(zerosArrayLength)\n        val onesArrayLength = onesArray.length\n\
    \        val zerosArrayLength = zerosArray.length\n        val onesArray = onesArray.take(onesArrayLength)\n\
    \        val zerosArray = zerosArray.take(zerosArrayLength)\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArray = onesArray.take(onesArrayLength)\n        \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6102u3vm.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArrayLength\
    \ + zerosArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35monesArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6102u3vm.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36monesArray\e[0m = onesArray.take(onesArrayLength)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArray is already defined as \e[33mvalue\e[0m \e[35monesArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6102u3vm.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mzerosArray\e[0m = zerosArray.take(zerosArrayLength)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArray is already defined as \e[33mvalue\e[0m \e[35mzerosArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6102u3vm.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e[35monesArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6102u3vm.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m = zerosArray."
  stdout: ''
  timestamp: 1659795040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjpjpx_t7.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x % 2 == 0).toList\n  \
    \      val zeros = arr.filter(x => x % 2 == 1).toList\n        val onesCount =\
    \ ones.map(x => x.toInt).sum\n        val zerosCount = zeros.map(x => x.toInt).sum\n\
    \        val onesDecimal = ones.map(x => x.toLong).sum\n        val zerosDecimal\
    \ = zeros.map(x => x.toLong).sum\n        val onesDecimalDecimal = ones.map(x\
    \ => x.toLong).map(x => x.toLong).sum\n        val zerosDecimalDecimal = zeros.map(x\
    \ => x.toLong).map(x => x.toLong).sum\n        val onesDecimalDecimalDecimal =\
    \ ones.map(x => x.toLong).map(x => x.toLong).map(x => x.toLong).sum\n        val\
    \ zerosDecimalDecimalDecimal = zeros.map(x => x.toLong).map(x => x.toLong).map(x\
    \ => x.toLong).sum\n        val onesDecimalDecimalDecimalDecimal = ones.map(x\
    \ => x.toLong).map(x => x.toLong).map(x => x.toLong).map(x => x.toLong).sum\n\
    \        val zerosDecimalDecimalDecimalDecimal = zeros.map(x => x.toLong).map(x\
    \ => x.toLong).map(x => x.toLong).map(x => x.toLong).sum\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = ones.map(x => x.toLong).map(x => x.toLong).map(x => x.toLong).map(x => x.toLong).map(x\
    \ => x.toLong).sum\n        val zerosDecimalDecimalDecimalDecimalDecimal = zeros.map(x\
    \ => x.toLong).map(x => x.toLong).map(x => x.toLong).map(x => x.toLong).map(x\
    \ => x.toLong).sum\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = ones.map(x => x.toLong).map(x => x.toLong).map(x => x.toLong).map(x => x.toLong).map(x\
    \ => x.toLong).map(x => x.toLong).sum\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zeros.map(x => x.toLong).map(x => x.toLong).map(x => x.toLong).map(x => x.toLong).map(x\
    \ => x.toLong).map(x => x.toLong).sum\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = ones.map(x => x.toLong).\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq2ih8kg0.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpq2ih8kg0.scala:32:5 ---------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795041
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toInt).sum\n        val zerosCount = zeros.map(x => x.toInt).sum\n    \
    \    val onesDecimal = ones.map(x => x.toInt).map(x => x / onesCount).sortBy(x\
    \ => x)\n        val zerosDecimal = zeros.map(x => x.toInt).map(x => x / zerosCount).sortBy(x\
    \ => x)\n        val onesDecimalList = onesDecimal.toList\n        val zerosDecimalList\
    \ = zerosDecimal.toList\n        val onesDecimalListLength = onesDecimalList.length\n\
    \        val zerosDecimalListLength = zerosDecimalList.length\n        val onesDecimalListLength\
    \ = onesDecimalListLength > 0 ? onesDecimalListLength : 1\n        val zerosDecimalListLength\
    \ = zerosDecimalListLength > 0 ? zerosDecimalListLength : 1\n        val onesDecimalListLength\
    \ = onesDecimalListLength > 0 ? onesDecimalListLength : 1\n        val zerosDecimalListLength\
    \ = zerosDecimalListLength > 0 ? zerosDecimalListLength : 1\n        val onesDecimalListLength\
    \ = onesDecimalListLength > 0 ? onesDecimalListLength : 1\n        val zerosDecimalListLength\
    \ = zerosDecimalListLength > 0 ? zerosDecimalListLength : 1\n        val onesDecimalListLength\
    \ = onesDecimalListLength > 0 ? onesDecimalListLength : 1\n        val zerosDecimalListLength\
    \ = zerosDecimalListLength > 0 ? zerosDecimalListLength : 1\n        val onesDecimalListLength\
    \ = onesDecimalListLength > 0 ? onesDecimalListLength : 1\n        val zerosDecimalListLength\
    \ = zerosDecimalListLength > 0 ? zerosDecimalListLength : 1\n        val onesDecimalListLength\
    \ = onesDecimalListLength > 0 ? onesDecimalListLength : 1\n        val zerosDecimalListLength\
    \ = zerosDecimalListLength > 0 ? zerosDecimalListLength : 1\n        val onesDecimalListLength\
    \ = onesDecimalListLength > 0 ? onesDecimalListLength : 1\n        val zerosDecimalListLength\
    \ = zerosDecimalListLength > 0 ? zerosDecimalListLength : 1\n        val onesDecimalListLength\
    \ = onesDecimalListLength > 0 ? onesDecimalListLength : 1\n        val zerosDecimalListLength\
    \ = zerosDecimalListLength > 0 ? zerosDecimalListLength : 1\n        val onesDecimalListLength\
    \ = onesDecimalListLength > 0 ? onesDecimalListLength : 1\n        val zerosDecimalList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppowqrbz1.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppowqrbz1.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalListLength\e[0m = onesDecimalListLength > \e[31m0\e[0m ? onesDecimalListLength\
    \ : \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalListLength is already defined as \e[33mvalue\e\
    [0m \e[35monesDecimalListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppowqrbz1.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalListLength\e\
    [0m = zerosDecimalListLength > \e[31m0\e[0m ? zerosDecimalListLength : \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalListLength is already defined as \e[33mvalue\e\
    [0m \e[35mzerosDecimalListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppowqrbz1.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36monesDecimalListLength\e\
    [0m = onesDecimalListLength > \e[31m0\e[0m ? onesDecimalListLength : \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalListLength is already defined as \e[33mvalue\e\
    [0m \e[35monesDecimalListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppowqrbz1.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[3"
  stdout: ''
  timestamp: 1659795042
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ / onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal /\
    \ zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp60rpfola.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp60rpfola.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp60rpfola.scala:34:69\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mNot found: zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explai"
  stdout: ''
  timestamp: 1659795041
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArray = arr.map(x => (x % 2) == 1).sorted\n\
    \        val zerosArray = arr.map(x => (x % 2) == 0).sorted\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArrayLength + zerosArrayLength\n        val zeros\
    \ = ones - onesArrayLength\n        val onesArray = onesArray.take(onesArrayLength)\n\
    \        val zerosArray = zerosArray.take(zerosArrayLength)\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArrayLength + zerosArrayLength\n        val zeros\
    \ = ones - onesArrayLength\n        val onesArray = onesArray.take(onesArrayLength)\n\
    \        val zerosArray = zerosArray.take(zerosArrayLength)\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArrayLength + zerosArrayLength\n        val zeros\
    \ = ones - onesArrayLength\n        val onesArray = onesArray.take(onesArrayLength)\n\
    \        val zerosArray = zerosArray.take(zerosArrayLength)\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArrayLength + zerosArrayLength\n        val zeros\
    \ = ones - onesArrayLength\n        val onesArray = onesArray.take(onesArrayLength)\n\
    \        val zerosArray = zerosArray.take(zerosArrayLength)\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArrayLength + zerosArrayLength\n        val zeros\
    \ = ones - onesArrayLength\n        val onesArray = onesArray.take(onesArrayLength)\n\
    \        val zerosArray = zerosArray.take(zerosArrayLength)\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArrayLength + zerosArrayLength\n        val zeros\
    \ = ones - onesArrayLength\n        val onesArray = onesArray.take(onesArrayLength)\n\
    \        val zerosArray = zerosArray.take(zerosArray\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpth_qnqf_.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpth_qnqf_.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesArrayLength\e[0m = onesArrayLength + zerosArrayLength\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e[35monesArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpth_qnqf_.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mzeros\e[0m = ones - onesArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mzeros is already defined as \e[33mvalue\e[0m \e[35mzeros\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpth_qnqf_.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36monesArray\e[0m = onesArray.take(onesArrayLength)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArray is already defined as \e[33mvalue\e[0m \e[35monesArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpth_qnqf_.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosArray\e[0m = zerosArray.take(zerosArrayLength)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArray is already defined as \e[33mvalue\e[0m \e[35mzerosArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31"
  stdout: ''
  timestamp: 1659795042
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.size\n\
    \        val zerosCount = zeros.size\n        val onesDecimal = onesCount / 2\n\
    \        val zerosDecimal = zerosCount / 2\n        val onesDecimalDecimal = onesDecimal\
    \ / 2\n        val zerosDecimalDecimal = zerosDecimal / 2\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / 2\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 2\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 2\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0byhje0d.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / \e[31m2\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0byhje0d.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp0byhje0d.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / \e[31m2\e[0m\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \          ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m"
  stdout: ''
  timestamp: 1659795041
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDeci\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplyop0ly4.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmplyop0ly4.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplyop0ly4.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m                                         \
    \                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tm"
  stdout: ''
  timestamp: 1659795042
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesCount = onesArr.length\n        val zerosCount = zerosArr.length\n     \
    \   val onesMax = onesArr.max\n        val zerosMax = zerosArr.max\n        val\
    \ onesMin = onesArr.min\n        val zerosMin = zerosArr.min\n        val onesSum\
    \ = onesArr.sum\n        val zerosSum = zerosArr.sum\n        val onesAvg = onesSum\
    \ / onesCount\n        val zerosAvg = zerosSum / zerosCount\n        val onesDev\
    \ = onesCount * onesAvg - onesSum * onesAvg\n        val zerosDev = zerosCount\
    \ * zerosAvg - zerosSum * zerosAvg\n        val onesDeviation = onesDev / onesCount\n\
    \        val zerosDeviation = zerosDev / zerosCount\n        val onesVariance\
    \ = onesCount * onesDeviation\n        val zerosVariance = zerosCount * zerosDeviation\n\
    \        val onesStdDev = onesVariance / onesCount\n        val zerosStdDev =\
    \ zerosVariance / zerosCount\n        val onesStdDeviation = onesStdDev / onesCount\n\
    \        val zerosStdDeviation = zerosStdDev / zerosCount\n        val onesMinMax\
    \ = onesMin + onesMax\n        val zerosMinMax = zerosMin + zerosMax\n       \
    \ val onesMinMaxSum = onesMinMax.sum\n        val zerosMinMaxSum = zerosMinMax.sum\n\
    \        val onesMinMaxAvg = onesMinMaxSum / onesCount\n        val zerosMinMaxAvg\
    \ = zerosMinMaxSum / zerosCount\n        val onesMinMaxDev = onesMinMaxSum * onesAvg\
    \ - onesMinMaxSum * onesAvg\n        val zerosMinMaxDev = zerosMinMaxSum * zerosAvg\
    \ - zerosMinMaxSum * zerosAvg\n        val onesMinMaxVariance = onesMinMaxSum\
    \ * onesDeviation\n        val zerosMinMaxVariance = zerosMinMaxSum * zerosDeviation\n\
    \        val onesMinMaxStd\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg10dd3id.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg10dd3id.scala:41:39\
    \ ------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e\
    [36monesMinMaxSum\e[0m = onesMinMax.sum\n\e[31m\e[31m   |\e[0m               \
    \             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \ value sum is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg10dd3id.scala:42:41\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosMinMaxSum\e[0m = zerosMinMax.sum\n\e[31m\e[31m   |\e[0m             \
    \                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \      value sum is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpg10dd3id.scala:50:5 ---------------------\e[0m\e[0m\n\e[31m50\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795047
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros_sorted\
    \ = arr.sortBy(x => if (x == 1l.toLong) onesZeros else x.toString.toLong)\n  \
    \      val onesZeros_sorted2 = onesZeros_sorted.sortBy(x => if (x == 1l.toLong)\
    \ onesZeros else x.toString.toLong)\n        val onesZeros_sorted3 = onesZeros_sorted.sortBy(x\
    \ => if (x == 1l.toLong) onesZeros else x.toString.toLong)\n        val onesZeros_sorted4\
    \ = onesZeros_sorted.sortBy(x => if (x == 1l.toLong) onesZeros else x.toString.toLong)\n\
    \        val onesZeros_sorted5 = onesZeros_sorted.sortBy(x => if (x == 1l.toLong)\
    \ onesZeros else x.toString.toLong)\n        val onesZeros_sorted6 = onesZeros_sorted.sortBy(x\
    \ => if (x == 1l.toLong) onesZeros else x.toString.toLong)\n        val onesZeros_sorted7\
    \ = onesZeros_sorted.sortBy(x => if (x == 1l.toLong) onesZeros else x.toString.toLong)\n\
    \        val onesZeros_sorted8 = onesZeros_sorted.sortBy(x => if (x == 1l.toLong)\
    \ onesZeros else x.toString.toLong)\n        val onesZeros_sorted9 = onesZeros_sorted.sortBy(x\
    \ => if (x == 1l.toLong) onesZeros else x.toString.toLong)\n        val onesZeros_sorted10\
    \ = onesZeros_sorted.sortBy(x => if (x == 1l.toLong) onesZeros else x.toString.toLong)\n\
    \        val onesZeros_sorted11 = onesZeros_sorted.sortBy(x => if (x == 1l.toLong)\
    \ onesZeros else x.toString.toLong)\n        val onesZeros_sorted12 = onesZeros_sorted.sortBy(x\
    \ => if (x == 1l.toLong) onesZeros else x.toString.toLong)\n        val onesZeros_sorted13\
    \ = onesZeros_sorted.sortBy(x => if (x == 1l.toLong) onesZeros else x.toString.toLong)\n\
    \        val onesZeros_sorted14 = onesZeros_sorted.sortBy(x \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6d_9rve8.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp6d_9rve8.scala:18:100\
    \ ----------------------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e\
    [33mval\e[0m \e[36monesZeros_sorted\e[0m = arr.sortBy(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1l\e[0m.toLong) onesZeros \e[33melse\e[0m x.toString.toLong)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                            ^\e[0m\n\e[31m   |\e[0mNo implicit\
    \ Ordering defined for AnyVal..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e[35mAnyVal\e[0m](\n\
    \e[31m   |\e[0m      /* missing */summon[java.util.Comparator[AnyVal]]\n\e[31m\
    \   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found\
    \ that match type java.util.Comparator[AnyVal].\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp6d_9rve8.scala:32:5 ---------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795049
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = ones / onesCount\n        val\
    \ zerosDecimal = zeros / zerosCount\n        val onesDecimalDecimal = onesDecimal\
    \ / onesCount\n        val zerosDecimalDecimal = zerosDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n     \
    \   val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n      \
    \  val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcoufb805.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcoufb805.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpcoufb805.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659795048
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = arr.count(_ == 1 && _ == 0)\n   \
    \     val onesOnes = arr.count(_ == 1 && _ == 1)\n        val onesZeroOnes = arr.count(_\
    \ == 1 && _ == 0 && _ == 1)\n        val onesOnesOnes = arr.count(_ == 1 && _\
    \ == 1 && _ == 1)\n        val onesZeroOnesOnes = arr.count(_ == 1 && _ == 0 &&\
    \ _ == 1 && _ == 1)\n        val onesOnesZeroOnesOnes = arr.count(_ == 1 && _\
    \ == 1 && _ == 0 && _ == 1)\n        val onesZeroOnesOnesOnes = arr.count(_ ==\
    \ 1 && _ == 0 && _ == 1 && _ == 1)\n        val onesOnesZeroOnesZeroOnes = arr.count(_\
    \ == 1 && _ == 1 && _ == 0 && _ == 0)\n        val onesZeroOnesOnesZeroOnes =\
    \ arr.count(_ == 1 && _ == 0 && _ == 1 && _ == 0)\n        val onesOnesZeroOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 1 && _ == 0 && _ == 0)\n        val onesZeroOnesOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 0 && _ == 1 && _ == 0)\n        val onesOnesZeroOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 1 && _ == 0 && _ == 0)\n        val onesZeroOnesOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 0 && _ == 1 && _ == 0)\n        val onesOnesZeroOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 1 && _ == 0 && _ == 0)\n        val onesZeroOnesOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 0 && _ == 1 && _ == 0)\n        val onesOnesZeroOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 1 && _ == 0 && _ == 0)\n        val onesZeroOnesOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 0 && _ == 1 && _ == 0)\n        val onesOnesZeroOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 1 && _ == 0 && _ == 0)\n        val onesZeroOnesOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 0 && _ == 1 && _ == 0)\n        val onesOnesZeroOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 1 && _ == 0 && \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpjzikdwnr.scala:36:78 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36monesOnesZeroOnesZeroOnes\e\
    [0m = arr.count(_ == \e[31m1\e[0m && _ == \e[31m1\e[0m && _ == \e[31m0\e[0m &&\
    \ \n\e[31m\e[31m   |\e[0m                                                    \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \            expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpjzikdwnr.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36monesOnesZeroOnesZeroOnes\e\
    [0m = arr.count(_ == \e[31m1\e[0m && _ == \e[31m1\e[0m && _ == \e[31m0\e[0m &&\
    \ _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesOnesZeroOnesZeroOnes is already defined as \e[33mvalue\e\
    [0m \e[35monesOnesZeroOnesZeroOnes\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjzikdwnr.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36monesZeroOnesOnesZeroOnes\e\
    [0m = arr.count(_ == \e[31m1\e[0m && _ == \e[31m0\e[0m && _ == \e[31m1\e[0m &&\
    \ _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroOnesOnesZeroOnes is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroOnesOnesZeroOnes\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjzikdwnr.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36monesOnesZeroOnesZeroOnes\e\
    [0m = arr.count(_ == \e[31m1\e[0m && _ == \e[31m1\e[0m && _ == \e[31m0\e[0m &&\
    \ _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795049
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x % 2l.toLong == 0l.toLong)\n\
    \        val zeros = arr.filter(x => x % 2l.toLong != 0l.toLong)\n        val\
    \ onesCount = ones.map(x => x.toLong).count(x => x == 1l.toLong)\n        val\
    \ zerosCount = zeros.map(x => x.toLong).count(x => x == 0l.toLong)\n        val\
    \ onesDecimal = ones.map(x => x.toLong).map(x => x.toInt).sum\n        val zerosDecimal\
    \ = zeros.map(x => x.toLong).map(x => x.toInt).sum\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal +\
    \ zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ + onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ + zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal + onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal +\
    \ zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal + onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + zerosDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal + onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfgznc3oe.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal + onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpfgznc3oe.scala:29:61 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal + zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfgznc3oe.scala:30:62\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m                                                              ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfgznc3oe.scala:33:75\
    \ -------------"
  stdout: ''
  timestamp: 1659795048
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros_sorted\
    \ = arr.sortBy(_ - onesZeros)\n        val onesZeros_sorted_reversed = onesZeros_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted = onesZeros_sorted_reversed.sortBy(_\
    \ - onesZeros)\n        val onesZeros_sorted_reversed_sorted_reversed = onesZeros_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted = onesZeros_sorted_reversed_sorted_reversed.sortBy(_\
    \ - onesZeros)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted.reverse\n        onesZeros_sorted_reversed_sorted_reversed_sorted_reversed\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp09sxz7il.scala:27)\n\tat Problem.main(tmp09sxz7il.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795052
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeroArray\
    \ = arr.map(x => (x % onesZeros, x)).toArray\n        val onesZeroArraySorted\
    \ = onesZeroArray.sortBy(_._1).map(x => x._2)\n        val onesZeroArraySortedWithZeros\
    \ = onesZeroArraySorted.take(onesZeros)\n        val onesZeroArraySortedWithOnes\
    \ = onesZeroArraySorted.drop(onesZeros)\n        val onesZeroArraySortedWithOnesAndZeros\
    \ = onesZeroArraySortedWithOnes ++ onesZeroArraySortedWithZeros\n        val onesZeroArraySortedWithOnesAndZerosAndOnes\
    \ = onesZeroArraySortedWithOnesAndZeros ++ onesZeroArraySortedWithOnes\n     \
    \   val onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros = onesZeroArraySortedWithOnesAndZerosAndOnes\
    \ ++ onesZeroArraySortedWithOnesAndZeros\n        val onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\
    \ = onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\n        val onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\
    \ = onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\n        val onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\
    \ = onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\n        val onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\
    \ = onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\n        val onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\
    \ = onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\n        val onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\
    \ = onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\n        val onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\
    \ = onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\n        val onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\
    \ = onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\n        val onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\
    \ = onesZeroArraySortedWithOnesAndZerosAndOnesAndZ\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp26j91n20.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\e\
    [0m = onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroArraySortedWithOnesAndZerosAndOnesAndZeros is already\
    \ defined as \e[33mvalue\e[0m \e[35monesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp26j91n20.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\e\
    [0m = onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroArraySortedWithOnesAndZerosAndOnesAndZeros is already\
    \ defined as \e[33mvalue\e[0m \e[35monesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp26j91n20.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\e\
    [0m = onesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroArraySortedWithOnesAndZerosAndOnesAndZeros is already\
    \ defined as \e[33mvalue\e[0m \e[35monesZeroArraySortedWithOnesAndZerosAndOnesAndZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp26j91n20.scala:28"
  stdout: ''
  timestamp: 1659795051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimal)\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal.toDouble / Math.pow(10, onesDecimalDecimal)\n        val\
    \ onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimalDecimal)\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal.toDouble / Math.pow(10, onesDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimalDecimalDecimal)\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal.toDouble / Math.pow(10, onesDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimalDecimalDecimalDecimal)\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / Math.pow(10, onesDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimalDecimalDecimalDecimalDecimal)\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpskf6phim.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble /\
    \ Math.pow(\e[31m10\e[0m, onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpskf6phim.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpskf6phim.scala:25:47 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimal\e[0m\
    \ = onesDecimalDecimalDecimalDecimal.toDouble / Math.pow(\e[31m10\e[0m, zerosDecimalDecimalDecimal)\n\
    \e[31m\e[31m   |\e[0m                                               ^\e[0m\n\e\
    [31m   |\e[0m             Recursive \e[33mvalue\e[0m \e[35mone"
  stdout: ''
  timestamp: 1659795039
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesZeros = ones + zeros\n\
    \        val onesZeros_arr = arr.filter(_ % 2 == 0).sortBy(_ % onesZeros)\n  \
    \      val zerosOnes_arr = arr.filter(_ % 2 == 1).sortBy(_ % onesZeros)\n    \
    \    onesZeros_arr.toList ++ zerosOnes_arr.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4185cp3g.scala:23)\n\tat Problem.main(tmp4185cp3g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795052
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesArr = arr.filter(_\
    \ % 2 == 0).map(x => x.toLong)\n        val zerosArr = arr.filter(_ % 2 == 1).map(x\
    \ => x.toLong)\n        val onesArr = onesArr.sortWith((x, y) => x - y)\n    \
    \    val zerosArr = zerosArr.sortWith((x, y) => x - y)\n        val onesArr =\
    \ onesArr.sortWith((x, y) => x - y)\n        val zerosArr = zerosArr.sortWith((x,\
    \ y) => x - y)\n        val onesArr = onesArr.sortWith((x, y) => x - y)\n    \
    \    val zerosArr = zerosArr.sortWith((x, y) => x - y)\n        val onesArr =\
    \ onesArr.sortWith((x, y) => x - y)\n        val zerosArr = zerosArr.sortWith((x,\
    \ y) => x - y)\n        val onesArr = onesArr.sortWith((x, y) => x - y)\n    \
    \    val zerosArr = zerosArr.sortWith((x, y) => x - y)\n        val onesArr =\
    \ onesArr.sortWith((x, y) => x - y)\n        val zerosArr = zerosArr.sortWith((x,\
    \ y) => x - y)\n        val onesArr = onesArr.sortWith((x, y) => x - y)\n    \
    \    val zerosArr = zerosArr.sortWith((x, y) => x - y)\n        val onesArr =\
    \ onesArr.sortWith((x, y) => x - y)\n        val zerosArr = zerosArr.sortWith((x,\
    \ y) => x - y)\n        val onesArr = onesArr.sortWith((x, y) => x - y)\n    \
    \    val zerosArr = zerosArr.sortWith((x, y) => x - y)\n        val onesArr =\
    \ onesArr.sortWith((x, y) => x - y)\n        val zerosArr = zerosArr.sortWith((x,\
    \ y) => x - y)\n        val onesArr = onesArr.sortWith((x, y) => x - y)\n    \
    \    val zerosArr = zerosArr.sortWith((x, y) => x - y)\n        val onesArr =\
    \ onesArr.sortWith((x, y) => x - y)\n        val zerosArr = zerosArr.sortWith((x,\
    \ y) => x - y)\n        val onesArr = onesArr.sortWith((x, y) => x - y)\n    \
    \    val zerosArr = zerosArr.sortWith((x, y) => x - y)\n        val onesArr =\
    \ one\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3hqm4jav.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x - y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3hqm4jav.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x - y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArr is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3hqm4jav.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x - y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3hqm4jav.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x - y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArr is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3hqm4jav.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[3"
  stdout: ''
  timestamp: 1659795050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpm_f1p9im.scala:38:153 --------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \n\e[31m\e[31m   |\e[0m                                                  \
    \                                                                            \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpm_f1p9im.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpm_f1p9im.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0"
  stdout: ''
  timestamp: 1659795049
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l)\n        val zeros\
    \ = arr.filter(x => x == 0l)\n        val onesCount = ones.map(x => 1l).count(_\
    \ == 1)\n        val zerosCount = zeros.map(x => 0l).count(_ == 0)\n        val\
    \ onesDecimal = onesCount.toDouble / arr.length\n        val zerosDecimal = zerosCount.toDouble\
    \ / arr.length\n        val onesDecimalDecimal = onesDecimal / Math.pow(10, arr.length)\n\
    \        val zerosDecimalDecimal = zerosDecimal / Math.pow(10, arr.length)\n \
    \       val onesDecimalDecimalDecimal = onesDecimalDecimal / Math.pow(10, arr.length)\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / Math.pow(10, arr.length)\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / Math.pow(10,\
    \ arr.length)\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / Math.pow(10, arr.length)\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / Math.pow(10, arr.length)\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / Math.pow(10, arr.length)\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / Math.pow(10, arr.length)\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / Math.pow(10, arr.length)\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / Math.pow(10, arr.length)\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / Math.pow(10, arr.length)\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / Math.pow(10, arr.length)\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / Math.pow(10, arr.length)\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / Math.pow(10, arr.length)\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / Math.pow(10, arr.length)\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuzh6pazb.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimal / Math.pow(\e[31m10\e[0m, arr.length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuzh6pazb.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / Math.pow(\e[31m10\e\
    [0m, arr.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuzh6pazb.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimal / Math.pow(\e[31m10\e[0m, arr.length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote th"
  stdout: ''
  timestamp: 1659795050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.count\n    \
    \    val zerosCount = zeros.count\n        val onesDecimal = ones.map(_.toString.toInt).sum\
    \ / onesCount\n        val zerosDecimal = zeros.map(_.toString.toInt).sum / zerosCount\n\
    \        val onesDecimalDecimal = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal\
    \ = zerosDecimal + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ * onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal *\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ * onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ * zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ * onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal * onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal * onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * zerosCount\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp49r7tfcn.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal * zerosCount\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp49r7tfcn.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal * onesCount\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp49r7tfcn.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal * zerosCount\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e"
  stdout: ''
  timestamp: 1659795051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ / onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal /\
    \ zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpav53ivx7.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpav53ivx7.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpav53ivx7.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longe"
  stdout: ''
  timestamp: 1659795051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.size\n\
    \        val zerosCount = zeros.size\n        val onesDecimal = onesCount / 2\n\
    \        val zerosDecimal = zerosCount / 2\n        val onesDecimalDecimal = onesDecimal\
    \ + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal + onesDecimal\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal + zerosDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal + onesDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal + zerosDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal +\
    \ onesDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal + zerosDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ + onesDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal + zerosDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ + onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal + zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal + zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmctmhrtd.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal + onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpmctmhrtd.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal + zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmctmhrtd.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longe"
  stdout: ''
  timestamp: 1659795051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.count(_\
    \ == 1)\n        val zerosCount = zeros.count(_ == 0)\n        val onesZeros =\
    \ ones.zip(zeros)\n        val onesZerosCount = onesZeros.count(_._1 == 1)\n \
    \       val zerosOnes = zeros.zip(ones)\n        val zerosOnesCount = zerosOnes.count(_._1\
    \ == 0)\n        val onesOnes = ones.zip(ones)\n        val onesOnesCount = onesOnes.count(_._1\
    \ == 1)\n        val onesZeroAndOnes = onesOnes.zip(onesZeros)\n        val onesZeroAndOnesCount\
    \ = onesZeroAndOnes.count(_._1 == 1)\n        val onesZeroAndOnesZeroAndOnes =\
    \ onesZeroAndOnes.zip(onesZeroAndOnes)\n        val onesZeroAndOnesZeroAndOnesCount\
    \ = onesZeroAndOnesZeroAndOnes.count(_._1 == 1)\n        val onesZeroAndOnesZeroAndOnesZeroAndOnes\
    \ = onesZeroAndOnesZeroAndOnes.zip(onesZeroAndOnesZeroAndOnes)\n        val onesZeroAndOnesZeroAndOnesZeroAndOnesCount\
    \ = onesZeroAndOnesZeroAndOnesZeroAndOnes.count(_._1 == 1)\n        val onesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnes\
    \ = onesZeroAndOnesZeroAndOnesZeroAndOnes.zip(onesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnes)\n\
    \        val onesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnesCount = onesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnes.count(_._1\
    \ == 1)\n        val onesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnesCount\
    \ = onesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnesCount.toLong\n\
    \        val onesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnes\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpczefuctj.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpczefuctj.scala:26:57\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36monesZeroAndOnesCount\e[0m = onesZeroAndOnes.count(_._1\
    \ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                    \
    \                     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m   Values of types (Long,\
    \ Long) and Int cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpczefuctj.scala:28:79\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36monesZeroAndOnesZeroAndOnesCount\e[0m = onesZeroAndOnesZeroAndOnes.count(_._1\
    \ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                    \
    \                                           ^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues\
    \ of types ((Long, Long), (Long, Long)) and Int cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- Error: /tmp/tmpczefuctj.scala:30:101 ----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36monesZeroAndOnesZeroAndOnesZeroAndOnesCount\e\
    [0m = onesZeroAndOnesZeroAndOnesZeroAndOnes.count(_._1 == \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                     ^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues of\
    \ types (((Long, Long), (Long, Long)), ((Long, Long), (Long, Long))) and Int cannot\
    \ be compared with == or !=\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpczefuctj.scala:31:105\
    \ --------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnes\e[0m = onesZeroAndOnesZeroAndOnesZeroAndOnes.zip(onesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnes)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                 ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35monesZeroAndOnesZeroAndOnesZeroAndOnesZeroAndOnes\e[0m\
    \ needs type\n"
  stdout: ''
  timestamp: 1659795053
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjpjpx_t7.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesZeros = ones + zeros\n\
    \        val onesZeroCount = onesZeros.map(_.toLong).count(_ > 0).toLong\n   \
    \     val onesZeroCount2 = onesZeros.map(_.toLong).count(_ == 0).toLong\n    \
    \    val onesZeroCount3 = onesZeros.map(_.toLong).count(_ < 0).toLong\n      \
    \  val onesZeroCount4 = onesZeros.map(_.toLong).count(_ == -1).toLong\n      \
    \  val onesZeroCount5 = onesZeros.map(_.toLong).count(_ == -2).toLong\n      \
    \  val onesZeroCount6 = onesZeros.map(_.toLong).count(_ == -3).toLong\n      \
    \  val onesZeroCount7 = onesZeros.map(_.toLong).count(_ == -4).toLong\n      \
    \  val onesZeroCount8 = onesZeros.map(_.toLong).count(_ == -5).toLong\n      \
    \  val onesZeroCount9 = onesZeros.map(_.toLong).count(_ == -6).toLong\n      \
    \  val onesZeroCount10 = onesZeros.map(_.toLong).count(_ == -7).toLong\n     \
    \   val onesZeroCount11 = onesZeros.map(_.toLong).count(_ == -8).toLong\n    \
    \    val onesZeroCount12 = onesZeros.map(_.toLong).count(_ == 9).toLong\n    \
    \    val onesZeroCount13 = onesZeros.map(_.toLong).count(_ == 10).toLong\n   \
    \     val onesZeroCount14 = onesZeros.map(_.toLong).count(_ == 11).toLong\n  \
    \      val onesZeroCount15 = onesZeros.map(_.toLong).count(_ == 12).toLong\n \
    \       val onesZeroCount16 = onesZeros.map(_.toLong).count(_ == 13).toLong\n\
    \        val onesZeroCount17 = onesZeros.map(_.toLong).count(_ == 14).toLong\n\
    \        val onesZeroCount18 = onesZeros.map(_.toLong).count(_ == 15).toLong\n\
    \        val onesZeroCount19 = onesZeros.map(_.toLong).count(_ == 16).toLong\n\
    \        val onesZeroCount20 = onesZeros.map(_.toLong).\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp01jx8z0_.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp01jx8z0_.scala:17:29 ------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = ones + zeros\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a\
    \ member of List[Long], but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp01jx8z0_.scala:38:5 ---------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659795053
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = arr.count(_ == 1).asInstanceOf[Double]\
    \ / ones\n        val zerosDecimal = arr.count(_ == 0).asInstanceOf[Double] /\
    \ zeros\n        val onesDecimalDecimal = onesDecimal + zerosDecimal\n       \
    \ val zerosDecimalDecimal = zerosDecimal + onesDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal.toInt\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal.toInt\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal.toInt\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptadhhiu2.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toInt\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptadhhiu2.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptadhhiu2.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mva"
  stdout: ''
  timestamp: 1659795053
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).size\n        val zeros\
    \ = arr.filter(_ == 0).size\n        val onesZeros = ones + zeros\n        val\
    \ onesZeros_sorted = arr.sortBy(_ - onesZeros)\n        val onesZeros_sorted_reversed\
    \ = onesZeros_sorted.reverse\n        val onesZeros_sorted_reversed_sorted = onesZeros_sorted_reversed.sortBy(_\
    \ - onesZeros)\n        val onesZeros_sorted_reversed_sorted_reversed = onesZeros_sorted_reversed_sorted.reverse\n\
    \        onesZeros_sorted_reversed_sorted_reversed\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnofeuyn2.scala:25)\n\tat Problem.main(tmpnofeuyn2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros_sorted\
    \ = arr.sortBy(_ - onesZeros)\n        val onesZeros_sorted_reversed = onesZeros_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted = onesZeros_sorted_reversed.sortBy(_\
    \ - onesZeros)\n        val onesZeros_sorted_reversed_sorted_reversed = onesZeros_sorted_reversed_sorted.reverse\n\
    \        onesZeros_sorted_reversed_sorted_reversed\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpadaiduvl.scala:25)\n\tat Problem.main(tmpadaiduvl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n  \
    \      val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = one\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7_b6g2rd.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7_b6g2rd.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp7_b6g2rd.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimal"
  stdout: ''
  timestamp: 1659795052
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArray = arr.map(x => if (x == 1) 1 else 0)\n\
    \        val zerosArray = arr.map(x => if (x == 0) 0 else 1)\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArrayLength / 2\n        val zerosArrayLength =\
    \ zerosArrayLength / 2\n        val onesArrayLength = onesArrayLength * 2\n  \
    \      val zerosArrayLength = zerosArrayLength * 2\n        val onesArrayLength\
    \ = onesArrayLength * 2\n        val zerosArrayLength = zerosArrayLength * 2\n\
    \        val onesArrayLength = onesArrayLength * 2\n        val zerosArrayLength\
    \ = zerosArrayLength * 2\n        val onesArrayLength = onesArrayLength * 2\n\
    \        val zerosArrayLength = zerosArrayLength * 2\n        val onesArrayLength\
    \ = onesArrayLength * 2\n        val zerosArrayLength = zerosArrayLength * 2\n\
    \        val onesArrayLength = onesArrayLength * 2\n        val zerosArrayLength\
    \ = zerosArrayLength * 2\n        val onesArrayLength = onesArrayLength * 2\n\
    \        val zerosArrayLength = zerosArrayLength * 2\n        val onesArrayLength\
    \ = onesArrayLength * 2\n        val zerosArrayLength = zerosArrayLength * 2\n\
    \        val onesArrayLength = onesArrayLength * 2\n        val zerosArrayLength\
    \ = zerosArrayLength * 2\n        val onesArrayLength = onesArrayLength * 2\n\
    \        val zerosArrayLength = zerosArrayLength * 2\n        val onesArrayLength\
    \ = onesArrayLength * 2\n        val zerosArrayLength = zerosArrayLength * 2\n\
    \        val onesArrayLength = onesArrayLength * 2\n        val zerosArrayLength\
    \ = zerosArrayLength * 2\n        val onesArrayLength = onesArrayLength * 2\n\
    \        val zerosArrayLength = zerosArrayLength * 2\n        val onesArrayLength\
    \ = onesArrayLength * 2\n        val zerosArrayLength = zerosArrayLength * 2\n\
    \        val onesArrayLength = onesArrayLength * 2\n        val zerosArrayLength\
    \ = zerosArrayLength * 2\n        val onesArrayLength = onesArrayLength * 2\n\
    \        val zerosArrayLength = zerosArrayLength * 2\n        val onesArrayLength\
    \ = onesArrayLength * 2\n        val zerosArrayLength = zerosArrayLength * 2\n\
    \        val onesArrayLength = onesArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0v_tw7d0.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArrayLength\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35monesArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0v_tw7d0.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m =\
    \ zerosArrayLength / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35mzerosArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0v_tw7d0.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArrayLength\
    \ * \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35monesArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0v_tw7d0.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m =\
    \ zerosArrayLength * \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35mzerosArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0v_tw7d0.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0"
  stdout: ''
  timestamp: 1659795053
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesCount = onesArr.length\n        val zerosCount = zerosArr.length\n     \
    \   if (onesCount > zerosCount) {\n            onesArr\n        } else if (zerosCount\
    \ > onesCount) {\n            zerosArr\n        } else {\n            onesArr.zip(zerosArr).sortBy(_._1).map(_._2)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8tnqegb5.scala:30)\n\tat Problem.main(tmp8tnqegb5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795056
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros_sorted\
    \ = arr.sortBy(_ - onesZeros)\n        val onesZeros_sorted2 = onesZeros_sorted.sortBy(_\
    \ - onesZeros)\n        val onesZeros_sorted3 = onesZeros_sorted2.sortBy(_ - onesZeros)\n\
    \        val onesZeros_sorted4 = onesZeros_sorted3.sortBy(_ - onesZeros)\n   \
    \     val onesZeros_sorted5 = onesZeros_sorted4.sortBy(_ - onesZeros)\n      \
    \  val onesZeros_sorted6 = onesZeros_sorted5.sortBy(_ - onesZeros)\n        val\
    \ onesZeros_sorted7 = onesZeros_sorted6.sortBy(_ - onesZeros)\n        val onesZeros_sorted8\
    \ = onesZeros_sorted7.sortBy(_ - onesZeros)\n        val onesZeros_sorted9 = onesZeros_sorted8.sortBy(_\
    \ - onesZeros)\n        val onesZeros_sorted10 = onesZeros_sorted9.sortBy(_ -\
    \ onesZeros)\n        val onesZeros_sorted11 = onesZeros_sorted10.sortBy(_ - onesZeros)\n\
    \        val onesZeros_sorted12 = onesZeros_sorted11.sortBy(_ - onesZeros)\n \
    \       val onesZeros_sorted13 = onesZeros_sorted12.sortBy(_ - onesZeros)\n  \
    \      val onesZeros_sorted14 = onesZeros_sorted13.sortBy(_ - onesZeros)\n   \
    \     val onesZeros_sorted15 = onesZeros_sorted14.sortBy(_ - onesZeros)\n    \
    \    val onesZeros_sorted16 = onesZeros_sorted15.sortBy(_ - onesZeros)\n     \
    \   val onesZeros_sorted17 = onesZeros_sorted16.sortBy(_ - onesZeros)\n      \
    \  val onesZeros_sorted18 = onesZeros_sorted17.sortBy(_ - onesZeros)\n       \
    \ val onesZeros_sorted19 = onesZeros_sorted18.sortBy(_ - onesZeros)\n        val\
    \ onesZeros_sorted20 = onesZeros_sorted19.sortBy(_ - onesZeros)\n        val onesZeros_sorted21\
    \ = onesZeros_sorted20.sortBy(_ - \n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6ttqll8r.scala:38:62 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted21\e[0m\
    \ = onesZeros_sorted20.sortBy(_ - \n\e[31m\e[31m   |\e[0m                    \
    \                                          ^\e[0m\n\e[31m   |\e[0m           \
    \                            expression expected but \e[31m'}'\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp6ttqll8r.scala:39:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp6ttqll8r.scala:39:5 ---------------------\e[0m\e\
    [0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659795055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal.toDouble\
    \ + zerosDecimalDecimal.toDouble\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal.toDouble\
    \ + onesDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal.toDouble + zerosDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal.toDouble\
    \ + onesDecimalDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal.toDouble + zerosDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal.toDouble\
    \ + onesDecimalDecimalDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble + zerosDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ + onesDecimalDecimalDecimalDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble + zerosDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ + onesDecimalDecimalDecimalDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble + zerosDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ + onesDecimalDecimalDecimalDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble + zerosDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ + onesDecimalDecimalDecimalDecimalDecimal.toDouble\n        val onesDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp77t71op3.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp77t71op3.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ + onesDecimalDecimalDecimalDecimalDecimal.toDouble\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp77t71op3.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble + zerosDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp77t71op3.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble + onesDecimalDecimalDecimalDecimalDecimal.toDou"
  stdout: ''
  timestamp: 1659795060
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_2np9f1i.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_2np9f1i.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp_2np9f1i.scala:37:82 ------------------------\e[0m\e[0m\n\
    \e[31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m                                              \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e"
  stdout: ''
  timestamp: 1659795060
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = ones\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpox3xjlw7.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpox3xjlw7.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpox3xjlw7.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecim"
  stdout: ''
  timestamp: 1659795060
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros_sorted\
    \ = onesZeros.sortBy(_ / onesZeros)\n        val onesZeros_sorted_sorted = onesZeros_sorted.sortBy(_\
    \ % onesZeros)\n        val onesZeros_sorted_sorted_sorted = onesZeros_sorted_sorted.sortBy(_\
    \ / onesZeros)\n        val onesZeros_sorted_sorted_sorted_sorted = onesZeros_sorted_sorted_sorted.sortBy(_\
    \ % onesZeros)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted = onesZeros_sorted_sorted_sorted_sorted.sortBy(_\
    \ / onesZeros)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted.sortBy(_ % onesZeros)\n     \
    \   val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_\
    \ / onesZeros)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_\
    \ % onesZeros)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_\
    \ / onesZeros)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_\
    \ % onesZeros)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_\
    \ / onesZeros)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_\
    \ % onesZeros)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_\
    \ / onesZeros)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa11_ajgi.scala:18:41 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted\e[0m =\
    \ onesZeros.sortBy(_ / onesZeros)\n\e[31m\e[31m   |\e[0m                     \
    \          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \   value sortBy is not a member of Int\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa11_ajgi.scala:25:80\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e[0m\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_\
    \ % onesZeros)\n\e[31m\e[31m   |\e[0m                                        \
    \                                        ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35monesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa11_ajgi.scala:26:87\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_\
    \ / onesZeros)\n\e[31m\e[31m   |\e[0m                                        \
    \                                               ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35monesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa11_ajgi.scala:27:94\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_\
    \ % onesZeros)\n\e[31m\e[31m   |\e[0m                                        \
    \                                                      ^\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659795061
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjpjpx_t7.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArray = arr.map(x => (x % 2 == 0 ? 1 : 0)).toArray\n\
    \        val zerosArray = arr.map(x => (x % 2 == 0 ? 0 : 1)).toArray\n       \
    \ val onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArray.length\n      \
    \  val zerosArrayLength = zerosArray.length\n        val onesArrayLength = onesArray.length\n\
    \        val zerosArrayLength = zerosArray.length\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArray.length\n      \
    \  val zerosArrayLength = zerosArray.length\n        val onesArrayLength = onesArray.length\n\
    \        val zerosArrayLength = zerosArray.length\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArray.length\n      \
    \  val zerosArrayLength = zerosArray.length\n        val onesArrayLength = onesArray.length\n\
    \        val zerosArrayLength = zerosArray.length\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArray.length\n      \
    \  val zerosArrayLength = zerosArray.length\n        val onesArrayLength = onesArray.length\n\
    \        val zerosArrayLength = zerosArray.length\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArray.length\n      \
    \  val zerosArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpeunpub2y.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeunpub2y.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesArrayLength\e[0m = onesArray.length\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesArrayLength\
    \ is already defined as \e[33mvalue\e[0m \e[35monesArrayLength\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeunpub2y.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosArrayLength\e[0m = zerosArray.length\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mzerosArrayLength\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosArrayLength\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpeunpub2y.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e[35monesArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpeunpub2y.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m = zerosArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e[35mzerosArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Namin"
  stdout: ''
  timestamp: 1659795062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.map(_.toString.toInt).sum\n\
    \        val zerosCount = zeros.map(_.toString.toInt).sum\n        val onesDecimal\
    \ = onesCount / arr.length\n        val zerosDecimal = zerosCount / arr.length\n\
    \        val onesDecimalString = onesDecimal.toString\n        val zerosDecimalString\
    \ = zerosDecimal.toString\n        val onesDecimalInt = onesDecimalString.toInt\n\
    \        val zerosDecimalInt = zerosDecimalString.toInt\n        val onesDecimalLong\
    \ = onesDecimalInt * 1l\n        val zerosDecimalLong = zerosDecimalInt * 1l\n\
    \        val onesDecimalFloat = onesDecimalLong.toFloat\n        val zerosDecimalFloat\
    \ = zerosDecimalLong.toFloat\n        val onesDecimalDouble = onesDecimalFloat.toDouble\n\
    \        val zerosDecimalDouble = zerosDecimalFloat.toDouble\n        val onesDecimalLong\
    \ = onesDecimalDouble.toLong\n        val zerosDecimalLong = zerosDecimalDouble.toLong\n\
    \        val onesDecimalInt = onesDecimalLong.toInt\n        val zerosDecimalInt\
    \ = zerosDecimalLong.toInt\n        val onesDecimalLong = onesDecimalInt * 1l\n\
    \        val zerosDecimalLong = zerosDecimalInt * 1l\n        val onesDecimalFloat\
    \ = onesDecimalLong.toFloat\n        val zerosDecimalFloat = zerosDecimalLong.toFloat\n\
    \        val onesDecimalDouble = onesDecimalFloat.toDouble\n        val zerosDecimalDouble\
    \ = zerosDecimalFloat.toDouble\n        val onesDecimalLong = onesDecimalDouble.toLong\n\
    \        val zerosDecimalLong = zerosDecimalDouble.toLong\n        val onesDecimalInt\
    \ = onesDecimalLong.toInt\n        val zerosDecimalInt = zerosDecimalLong.toInt\n\
    \        val onesDecimalLong = onesDecimalInt * 1l\n        val zerosDecimalLong\
    \ = zerosDecimalInt * 1l\n        val onesDecimalFloat = onesDecimalLong.toFloat\n\
    \        val zerosDecimalFloat = zerosDecimalLong.toFloat\n        val onesDecimalDouble\
    \ = onesDecimalFloat.toDouble\n        val zerosDecimalDouble = zerosDecimalFloat.toDouble\n\
    \        val onesDecimalLong = onesDecimalDouble.toLong\n        val zerosDecimalLong\
    \ = zerosDecimalDouble.toLong\n        val onesDecimalInt = onesDecimalLong.toInt\n\
    \        val zerosDecimalIn\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzz7jnyam.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzz7jnyam.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalLong\e[0m = onesDecimalDouble.toLong\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesDecimalLong\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalLong\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzz7jnyam.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalLong\e[0m = zerosDecimalDouble.toLong\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mzerosDecimalLong is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalLong\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzz7jnyam.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalInt\e[0m = onesDecimalLong.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesDecimalInt is already defined as \e[33mvalue\e[0m \e[35monesDecimalInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzz7jnyam.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalInt\e[0m = zerosDecimalLong.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mzerosDecimalInt is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of to"
  stdout: ''
  timestamp: 1659795061
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesZeros = ones + zeros\n        val onesZeroArr = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr2 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr3 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr4 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr5 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr6 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr7 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr8 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr9 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr10 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr11 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr12 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr13 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr14 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr15 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr16 = onesZeros.map(_.toString.toInt).\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsp0fppo5.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpsp0fppo5.scala:20:36 ------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeroArr\e[0m = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value map is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpsp0fppo5.scala:21:37 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr2\e[0m = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           value map is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpsp0fppo5.scala:22:37 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr3\e[0m = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           value map is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpsp0fppo5.scala:23:37 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr4\e[0m = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           value map is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpsp0fppo5.scala:24:37 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr5\e[0m = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           value map is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpsp0fppo5.scala:25:37 ------------------------\e\
    [0m\e[0m\n\e"
  stdout: ''
  timestamp: 1659795065
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimal = ones.map(x => x.toString.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(x => x.toString.toDouble).sum\n        val\
    \ onesDecimalDecimal = onesDecimal.toString.toDouble\n        val zerosDecimalDecimal\
    \ = zerosDecimal.toString.toDouble\n        val onesDecimalDecimalDecimal = onesDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8rftbi41.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8rftbi41.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8rftbi41.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-"
  stdout: ''
  timestamp: 1659795062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n  \
    \      val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = one\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7_b6g2rd.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7_b6g2rd.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp7_b6g2rd.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimal"
  stdout: ''
  timestamp: 1659795052
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuq1oif82.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuq1oif82.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuq1oif82.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArray = arr.filter(_ == 1).map(_.toLong).toArray\n\
    \        val zerosArray = arr.filter(_ == 0).map(_.toLong).toArray\n        val\
    \ onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArray.length\n      \
    \  val zerosArrayLength = zerosArray.length\n        val onesArrayLength = onesArray.length\n\
    \        val zerosArrayLength = zerosArray.length\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArray.length\n      \
    \  val zerosArrayLength = zerosArray.length\n        val onesArrayLength = onesArray.length\n\
    \        val zerosArrayLength = zerosArray.length\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArray.length\n      \
    \  val zerosArrayLength = zerosArray.length\n        val onesArrayLength = onesArray.length\n\
    \        val zerosArrayLength = zerosArray.length\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArray.length\n      \
    \  val zerosArrayLength = zerosArray.length\n        val onesArrayLength = onesArray.length\n\
    \        val zerosArrayLength = zerosArray.length\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArray.length\n      \
    \  val zerosArrayLength = zeros\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphg31we85.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e[35monesArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphg31we85.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m = zerosArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e[35mzerosArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphg31we85.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e[35monesArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphg31we85.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m = zerosArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e[35mzerosArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphg31we85.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l).toList\n     \
    \   val zeros = arr.filter(x => x == 0l).toList\n        val onesCount = ones.map(x\
    \ => 1l).sum\n        val zerosCount = zeros.map(x => 0l).sum\n        val onesDecimal\
    \ = ones.map(x => x.toString.toDouble).sum\n        val zerosDecimal = zeros.map(x\
    \ => x.toString.toDouble).sum\n        val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n\
    \        val zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n \
    \       val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n    \
    \    val zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n     \
    \   val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n        val\
    \ zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n        val onesDecimalCount\
    \ = ones.map(x => x.toString.toDouble).count\n        val zerosDecimalCount =\
    \ zeros.map(x => x.toString.toDouble).count\n        val onesDecimalCount = ones.map(x\
    \ => x.toString.toDouble).count\n        val zerosDecimalCount = zeros.map(x =>\
    \ x.toString.toDouble).count\n        val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n\
    \        val zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n \
    \       val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n    \
    \    val zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n     \
    \   val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n        val\
    \ zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n        val onesDecimalCount\
    \ = ones.map(x => x.toString.toDouble).count\n        val zerosDecimalCount =\
    \ zeros.map(x => x.toString.toDouble).count\n        val onesDecimalCount = ones.map(x\
    \ => x.toString.toDouble).count\n        val zerosDecimalCount = zeros.map(x =>\
    \ x.toString.toDouble).count\n        val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n\
    \        val zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n \
    \       val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n    \
    \    val zerosDecimalCount = zer\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp45q4_8wt.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ ones.map(\e[36mx\e[0m => x.toString.toDouble).count\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e[35monesDecimalCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp45q4_8wt.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m = zeros.map(\e\
    [36mx\e[0m => x.toString.toDouble).count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35mzerosDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp45q4_8wt.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ ones.map(\e[36mx\e[0m => x.toString.toDouble).count\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e[35monesDecimalCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp45q4_8wt.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m = zeros.map(\e\
    [36mx\e[0m => x.toString.toDouble).count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35mzerosDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same gr"
  stdout: ''
  timestamp: 1659795063
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.map(x => 1l).sum\n\
    \        val zerosCount = zeros.map(x => 0l).sum\n        val onesDecimal = ones.map(x\
    \ => x.toString.toDouble).sum\n        val zerosDecimal = zeros.map(x => x.toString.toDouble).sum\n\
    \        val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n   \
    \     val zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n    \
    \    val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n       \
    \ val zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n        val\
    \ onesDecimalCount = ones.map(x => x.toString.toDouble).count\n        val zerosDecimalCount\
    \ = zeros.map(x => x.toString.toDouble).count\n        val onesDecimalCount =\
    \ ones.map(x => x.toString.toDouble).count\n        val zerosDecimalCount = zeros.map(x\
    \ => x.toString.toDouble).count\n        val onesDecimalCount = ones.map(x =>\
    \ x.toString.toDouble).count\n        val zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n\
    \        val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n   \
    \     val zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n    \
    \    val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n       \
    \ val zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n        val\
    \ onesDecimalCount = ones.map(x => x.toString.toDouble).count\n        val zerosDecimalCount\
    \ = zeros.map(x => x.toString.toDouble).count\n        val onesDecimalCount =\
    \ ones.map(x => x.toString.toDouble).count\n        val zerosDecimalCount = zeros.map(x\
    \ => x.toString.toDouble).count\n        val onesDecimalCount = ones.map(x =>\
    \ x.toString.toDouble).count\n        val zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n\
    \        val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n   \
    \     val zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n    \
    \    val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n       \
    \ val zerosDecimalCount = zeros.map(x => x.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp656ibbrq.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp656ibbrq.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e[36mx\e\
    [0m => x.toString.toDouble).count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp656ibbrq.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zeros.map(\e[36mx\e[0m => x.toString.toDouble).count\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp656ibbrq.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e\
    [36mx\e[0m => x.toString.toDouble).count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp656ibbrq.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zeros.map(\e[36mx\e[0m => x.toString.toDouble).count\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795064
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal *\
    \ 10\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal * 10\n    \
    \    val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal *\
    \ 10\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6_vvmvdp.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp6_vvmvdp.scala:25:47 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimal\e[0m\
    \ = onesDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m  \
    \                                             ^\e[0m\n\e[31m   |\e[0m        \
    \     Recursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimal\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6_vvmvdp.scala:26:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimal\
    \ * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m                                     \
    \           ^\e[0m\n\e[31m   |\e[0m            Recursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6_vvmvdp.scala:39:96\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDe"
  stdout: ''
  timestamp: 1659795037
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZerosList\
    \ = onesZeros.toList\n        val onesZerosListSorted = onesZerosList.reverse\n\
    \        val onesZerosListSortedSortedWithZeros = onesZerosListSorted.zipWithIndex.filter(_._2\
    \ == 0).map(_._1)\n        val onesZerosListSortedWithOnes = onesZerosListSorted.zipWithIndex.filter(_._2\
    \ == 1).map(_._1)\n        val onesZerosListSortedWithOnesAndZeros = onesZerosListSorted.zipWithIndex.filter(_._2\
    \ == 1 && _._2 == 0).map(_._1)\n        val onesZerosListSortedWithOnesAndZerosReversed\
    \ = onesZerosListSortedWithOnesAndZeros.reverse\n        val onesZerosListSortedWithOnesAndZerosReversedWithZeros\
    \ = onesZerosListSortedWithOnesAndZerosReversed.zipWithIndex.filter(_._2 == 0).map(_._1)\n\
    \        val onesZerosListSortedWithOnesAndZerosReversedWithOnes = onesZerosListSortedWithOnesAndZerosReversed.zipWithIndex.filter(_._2\
    \ == 1).map(_._1)\n        val onesZerosListSortedWithOnesAndZerosReversedWithOnesAndZeros\
    \ = onesZerosListSortedWithOnesAndZerosReversed.zipWithIndex.filter(_._2 == 1\
    \ && _._2 == 0).map(_._1)\n        val onesZerosListSortedWithOnesAndZerosReversedWithOnesAndZerosReversed\
    \ = onesZerosListSortedWithOnesAndZerosReversedWithOnesAndZeros.reverse\n    \
    \    val onesZerosListSortedWithOnesAndZerosReversedWithOnesAndZerosReversedWithZeros\
    \ = onesZerosListSortedWithOnesAndZerosReversedWithOnesAndZerosReversed.zipWithIndex.filter(_._2\
    \ == 0).map(_._1)\n        val onesZerosListSortedWithOnesAndZerosReversedWithOnesAndZerosReversedWithOnes\
    \ = onesZerosListSortedWithOnesAndZerosReversedWithOnesAndZerosReversed.zipWithIndex.filter(_._2\
    \ == 1).map(_._1)\n        val onesZerosListSortedWithOnesAndZerosReversedWithOnesAndZeros\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwrkv8v3z.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwrkv8v3z.scala:18:38\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36monesZerosList\e[0m = onesZeros.toList\n\e[31m\e[31m   |\e[0m             \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     value toList is not\
    \ a member of Int - did you mean onesZeros.toInt?\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpwrkv8v3z.scala:31:5 ---------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795064
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(_.toInt).sum\n\
    \        val zerosCount = zeros.map(_.toInt).sum\n        val onesDecimal = ones.map(_.toLong).sum\
    \ / onesCount\n        val zerosDecimal = zeros.map(_.toLong).sum / zerosCount\n\
    \        val onesDecimalDecimal = onesDecimal / onesCount\n        val zerosDecimalDecimal\
    \ = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjg1ub1qg.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjg1ub1qg.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjg1ub1qg.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpjg1ub1qg.scala:33:75 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / one"
  stdout: ''
  timestamp: 1659795063
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val onesZeros = ones + zeros\n  \
    \      val onesZerosInv = onesZeros / arr.length\n        val onesZerosInv2 =\
    \ onesZerosInv * onesZerosInv\n        val onesZerosInv3 = onesZerosInv2 * onesZerosInv\n\
    \        val onesZerosInv4 = onesZerosInv3 * onesZerosInv\n        val onesZerosInv5\
    \ = onesZerosInv4 * onesZerosInv\n        val onesZerosInv6 = onesZerosInv5 *\
    \ onesZerosInv\n        val onesZerosInv7 = onesZerosInv6 * onesZerosInv\n   \
    \     val onesZerosInv8 = onesZerosInv7 * onesZerosInv\n        val onesZerosInv9\
    \ = onesZerosInv8 * onesZerosInv\n        val onesZerosInv10 = onesZerosInv9 *\
    \ onesZerosInv\n        val onesZerosInv11 = onesZerosInv10 * onesZerosInv\n \
    \       val onesZerosInv12 = onesZerosInv11 * onesZerosInv\n        val onesZerosInv13\
    \ = onesZerosInv12 * onesZerosInv\n        val onesZerosInv14 = onesZerosInv13\
    \ * onesZerosInv\n        val onesZerosInv15 = onesZerosInv14 * onesZerosInv\n\
    \        val onesZerosInv16 = onesZerosInv15 * onesZerosInv\n        val onesZerosInv17\
    \ = onesZerosInv16 * onesZerosInv\n        val onesZerosInv18 = onesZerosInv17\
    \ * onesZerosInv\n        val onesZerosInv19 = onesZerosInv18 * onesZerosInv\n\
    \        val onesZerosInv20 = onesZerosInv19 * onesZerosInv\n        val onesZerosInv21\
    \ = onesZerosInv20 * onesZerosInv\n        val onesZerosInv22 = onesZerosInv21\
    \ * onesZerosInv\n        val onesZerosInv23 = onesZerosInv22 * onesZerosInv\n\
    \        val ones\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmx9guu94.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpmx9guu94.scala:42:5 ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795063
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n  \
    \      val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpz1i6d87t.scala:31:68 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpz1i6d87t.scala:32:119\
    \ --------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                             ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz1i6d87t.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz1i6d87t.scala:36:83\
    \ ------------------------\e"
  stdout: ''
  timestamp: 1659795065
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1)\n        val zerosArr\
    \ = arr.filter(_ == 0)\n        val onesCount = onesArr.length\n        val zerosCount\
    \ = zerosArr.length\n        val onesArr = onesArr.sortBy(x => math.abs(x))\n\
    \        val zerosArr = zerosArr.sortBy(x => math.abs(x))\n        val onesCount\
    \ = onesArr.length\n        val zerosCount = zerosArr.length\n        val onesArr\
    \ = onesArr.sortBy(x => math.abs(x))\n        val zerosArr = zerosArr.sortBy(x\
    \ => math.abs(x))\n        val onesCount = onesArr.length\n        val zerosCount\
    \ = zerosArr.length\n        val onesArr = onesArr.sortBy(x => math.abs(x))\n\
    \        val zerosArr = zerosArr.sortBy(x => math.abs(x))\n        val onesCount\
    \ = onesArr.length\n        val zerosCount = zerosArr.length\n        val onesArr\
    \ = onesArr.sortBy(x => math.abs(x))\n        val zerosArr = zerosArr.sortBy(x\
    \ => math.abs(x))\n        val onesCount = onesArr.length\n        val zerosCount\
    \ = zerosArr.length\n        val onesArr = onesArr.sortBy(x => math.abs(x))\n\
    \        val zerosArr = zerosArr.sortBy(x => math.abs(x))\n        val onesCount\
    \ = onesArr.length\n        val zerosCount = zerosArr.length\n        val onesArr\
    \ = onesArr.sortBy(x => math.abs(x))\n        val zerosArr = zerosArr.sortBy(x\
    \ => math.abs(x))\n        val onesCount = onesArr.length\n        val zerosCount\
    \ = zerosArr.length\n        val onesArr = onesArr.sortBy(x => math.abs(x))\n\
    \        val zerosArr = zerosArr.sortBy(x => math.abs(x))\n        val onesCount\
    \ = onesArr.length\n        val zerosCount = zerosArr.length\n        val onesArr\
    \ = onesArr.sortBy(x => math.abs(x))\n        val zerosArr = zerosArr.sortBy(x\
    \ => math.abs(x))\n        val onesCount = onesArr.length\n        val zerosCount\
    \ = zerosArr.length\n        val onesArr = onesArr.sortBy(x => math.abs(x))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzt3kdnfa.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortBy(\e\
    [36mx\e[0m => math.abs(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzt3kdnfa.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.sortBy(\e[36mx\e\
    [0m => math.abs(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArr is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzt3kdnfa.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36monesCount\e[0m = onesArr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesCount\
    \ is already defined as \e[33mvalue\e[0m \e[35monesCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzt3kdnfa.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosCount\e[0m = zerosArr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosCount is already defined as \e[33mvalue\e[0m \e[35mzerosCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzt3kdnfa.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortBy(\e[36mx\e\
    [0m => math.abs(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795065
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val onesZeros = ones + zeros\n  \
    \      val onesZero = onesZeros / (onesZeros + ones)\n        val onesZeros =\
    \ onesZeros % ones\n        val onesZero = onesZero / ones\n        val onesZeros\
    \ = onesZeros % ones\n        val onesZero = onesZero / ones\n        val onesZeros\
    \ = onesZeros % ones\n        val onesZero = onesZero / ones\n        val onesZeros\
    \ = onesZeros % ones\n        val onesZero = onesZero / ones\n        val onesZeros\
    \ = onesZeros % ones\n        val onesZero = onesZero / ones\n        val onesZeros\
    \ = onesZeros % ones\n        val onesZero = onesZero / ones\n        val onesZeros\
    \ = onesZeros % ones\n        val onesZero = onesZero / ones\n        val onesZeros\
    \ = onesZeros % ones\n        val onesZero = onesZero / ones\n        val onesZeros\
    \ = onesZeros % ones\n        val onesZero = onesZero / ones\n        val onesZeros\
    \ = onesZeros % ones\n        val onesZero = onesZero / ones\n        val onesZeros\
    \ = onesZeros % ones\n        val onesZero = onesZero / ones\n        val onesZeros\
    \ = onesZeros % ones\n        val onesZero = onesZero / ones\n        val onesZeros\
    \ = onesZeros % ones\n        val onesZero = onesZero / ones\n        val onesZeros\
    \ = onesZeros % ones\n        val onesZero = onesZero / ones\n        val onesZeros\
    \ = onesZeros % ones\n        val onesZero = onesZero / ones\n        val onesZeros\
    \ = onesZeros % ones\n        val onesZero = onesZero / one\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpytw6pc5b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros\
    \ % ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpytw6pc5b.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36monesZero\e[0m = onesZero / ones\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesZero\
    \ is already defined as \e[33mvalue\e[0m \e[35monesZero\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpytw6pc5b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeros\e[0m = onesZeros % ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpytw6pc5b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36monesZero\e[0m = onesZero / ones\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesZero\
    \ is already defined as \e[33mvalue\e[0m \e[35monesZero\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpytw6pc5b.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeros\e[0m = onesZeros % ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |"
  stdout: ''
  timestamp: 1659795065
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).max\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).max\n        val onesDecimal = ones.map(x => x.toString.toInt).max\n\
    \        val zerosDecimal = zeros.map(x => x.toString.toInt).max\n        val\
    \ onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n        val zerosDecimalCount\
    \ = zeros.map(x => zeros.count(_ == x)).max\n        val onesDecimalCount = ones.map(x\
    \ => ones.count(_ == x)).max\n        val zerosDecimalCount = zeros.map(x => zeros.count(_\
    \ == x)).max\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).max\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).max\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).max\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).max\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).max\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).max\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).max\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).max\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).max\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).max\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).max\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).max\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).max\n   \
    \     val onesDecimalCount = ones.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqk8xoxxy.scala:43:40 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ ones.map(\n\e[31m\e[31m   |\e[0m                                        ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpqk8xoxxy.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e[36mx\e\
    [0m => ones.count(_ == x)).max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpqk8xoxxy.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zeros.map(\e[36mx\e[0m => zeros.count(_ == x)).max\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqk8xoxxy.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e\
    [36mx\e[0m => ones.count(_ == x)).max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpqk8xoxxy.scala:26:12 ---------------------------\e\
    ["
  stdout: ''
  timestamp: 1659795065
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpku3h5p8o.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpku3h5p8o.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpku3h5p8o.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \ ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E"
  stdout: ''
  timestamp: 1659795002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesArr = arr.filter(_\
    \ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr = arr.filter(_ % 2 ==\
    \ 1).sortBy(_ % 2).reverse\n        val onesSortedArr = onesArr.take(ones)\n \
    \       val zerosSortedArr = zerosArr.take(zeros)\n        val sortedArr = onesSortedArr.zip(zerosSortedArr).sortBy(_._1).reverse\n\
    \        sortedArr\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsl2nebrx.scala:22:8\
    \ ---------------------\e[0m\e[0m\n\e[31m22 |\e[0m        sortedArr\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (sortedArr\
    \ : List[(Long, Long)])\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((x, y) => x.toLong == y.toLong ? x.toLong\
    \ - y.toLong : x.toLong - y.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8ur91pc5.scala:15:85 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) =>\
    \ x.toLong == y.toLong ? x.toLong - y.toLong : x.toLong \e[35m-\e[0m y.toLong)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \                               Not found: type -\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp8ur91pc5.scala:15:52 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) =>\
    \ x.toLong == y.toLong ? x.toLong - y.toLong : x.toLong \e[35m-\e[0m y.toLong)\n\
    \e[31m\e[31m   |\e[0m                                           ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                         value ? is not a member\
    \ of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1659795021
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesZeros = ones + zeros\n\
    \        val onesZerosSorted = onesZeros.sortBy(x => x.toString.toInt)\n     \
    \   val zerosSorted = zeros.sortBy(x => x.toString.toInt)\n        val onesZerosSortedWithZeros\
    \ = onesZerosSorted.zip(zerosSorted)\n        val onesZerosSortedWithZerosSorted\
    \ = onesZerosSortedWithZeros.sortBy(x => x._1 - x._2)\n        val onesZerosSortedWithZerosSortedWithZeros\
    \ = onesZerosSortedWithZerosSorted.zip(zerosSorted)\n        val onesZerosSortedWithZerosSortedWithZerosSorted\
    \ = onesZerosSortedWithZerosSortedWithZeros.sortBy(x => x._1 - x._2)\n       \
    \ val onesZerosSortedWithZerosSortedWithZerosSortedWithZeros = onesZerosSortedWithZerosSortedWithZerosSorted.zip(zerosSorted)\n\
    \        val onesZerosSortedWithZerosSortedWithZerosSortedWithZerosSorted = onesZerosSortedWithZerosSortedWithZerosSortedWithZeros.sortBy(x\
    \ => x._1 - x._2)\n        val onesZerosSortedWithZerosSortedWithZerosSortedWithZerosSortedWithZeros\
    \ = onesZerosSortedWithZerosSortedWithZerosSortedWithZerosSorted.zip(zerosSorted)\n\
    \        val onesZerosSortedWithZerosSortedWithZerosSortedWithZerosSortedWithZerosSorted\
    \ = onesZerosSortedWithZerosSortedWithZerosSortedWithZerosSortedWithZeros.sortBy(x\
    \ => x._1 - x._2)\n        val onesZerosSortedWithZerosSortedWithZerosSortedWithZerosSortedWithZerosSortedWithZeros\
    \ = onesZerosSortedWithZerosSortedWithZerosSortedWithZerosSortedWithZerosSortedWithZeros.sortBy(x\
    \ => x._1 - x._2)\n        val onesZerosSortedWith\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_isrtmrq.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_isrtmrq.scala:17:29\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeros\e[0m = ones + zeros\n\e[31m\e[31m   |\e[0m                     \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmp_isrtmrq.scala:28:99 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36monesZerosSortedWithZerosSortedWithZerosSortedWithZerosSortedWithZerosSortedWithZeros\e\
    [0m = onesZerosSortedWithZerosSortedWithZerosSortedWithZerosSortedWithZerosSortedWithZeros.sortBy(\e\
    [36mx\e[0m => x._1 - x._2)\n\e[31m\e[31m   |\e[0m                            \
    \                                                                       ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZerosSortedWithZerosSortedWithZerosSortedWithZerosSortedWithZerosSortedWithZeros\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp_isrtmrq.scala:30:5 ---------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795069
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesZeros = ones + zeros\n        val onesZeroArr = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr2 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr3\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr4 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr5 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr6\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr7 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr8 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr9\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr10 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr11 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr12\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr13 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr14 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr15\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr16 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr17 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr18\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr19 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr20 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr21\
    \ = onesZeros.sortBy(\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl3k5fyoa.scala:40:45 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr21\e[0m = onesZeros.sortBy(\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl3k5fyoa.scala:20:36\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeroArr\e[0m = onesZeros.sortBy(_.toString.toInt)\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                value sortBy is not a member of Int\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpl3k5fyoa.scala:21:37 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr2\e[0m = onesZeros.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value sortBy is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpl3k5fyoa.scala:22:37 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr3\e[0m = onesZeros.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value sortBy is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpl3k5fyoa.scala:23:37 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr4\e[0m = onesZeros.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value sortBy is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpl3k5fyoa.scala:24:37 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr5\e[0m = onesZeros.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                "
  stdout: ''
  timestamp: 1659795071
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimal = ones.map(x => x.toString.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(x => x.toString.toDouble).sum\n        val\
    \ onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount\
    \ = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp35x2paw2.scala:43:40 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ ones.map(\n\e[31m\e[31m   |\e[0m                                        ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp35x2paw2.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e[36mx\e\
    [0m => ones.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp35x2paw2.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zeros.map(\e[36mx\e[0m => zeros.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp35x2paw2.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e\
    [36mx\e[0m => ones.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp35x2paw2.scala:26:12 ---------------------------\e\
    ["
  stdout: ''
  timestamp: 1659795070
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toLong).sum\n        val zerosCount = zeros.map(x => x.toLong).sum\n  \
    \      val onesDecimal = onesCount / 2\n        val zerosDecimal = zerosCount\
    \ / 2\n        val onesDecimalDecimal = onesDecimal + zerosDecimal\n        val\
    \ zerosDecimalDecimal = zerosDecimal + onesDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal.toDouble\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal.toInt\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi73qimds.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimal.toDouble\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimal is already defined\
    \ as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimal\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpi73qimds.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi73qimds.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi73qimds."
  stdout: ''
  timestamp: 1659795073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.count(_ == 1)\n\
    \        val zerosCount = zeros.count(_ == 0)\n        val onesZeros = onesCount\
    \ + zerosCount\n        val onesZeroCount = onesZeros + onesCount\n        val\
    \ onesZeroZero = onesZeroCount + zerosCount\n        val onesZeroZeroCount = onesZeroZero\
    \ + onesCount\n        val onesZeroZeroZero = onesZeroZeroCount + zerosCount\n\
    \        val onesZeroZeroZeroCount = onesZeroZeroZero + onesCount\n        val\
    \ onesZeroZeroZeroZero = onesZeroZeroZeroCount + zerosCount\n        val onesZeroZeroZeroZeroCount\
    \ = onesZeroZeroZeroZero + onesCount\n        val onesZeroZeroZeroZeroCount =\
    \ onesZeroZeroZeroZeroCount + zerosCount\n        val onesZeroZeroZeroZeroZero\
    \ = onesZeroZeroZeroZeroZeroCount + zerosCount\n        val onesZeroZeroZeroZeroZero\
    \ = onesZeroZeroZeroZeroZeroCount + zerosCount\n        val onesZeroZeroZeroZeroZero\
    \ = onesZeroZeroZeroZeroZeroCount + zerosCount\n        val onesZeroZeroZeroZeroZero\
    \ = onesZeroZeroZeroZeroZeroCount + zerosCount\n        val onesZeroZeroZeroZeroZero\
    \ = onesZeroZeroZeroZeroZeroCount + zerosCount\n        val onesZeroZeroZeroZeroZero\
    \ = onesZeroZeroZeroZeroZeroCount + zerosCount\n        val onesZeroZeroZeroZeroZero\
    \ = onesZeroZeroZeroZeroZeroCount + zerosCount\n        val onesZeroZeroZeroZeroZero\
    \ = onesZeroZeroZeroZeroZeroCount + zerosCount\n        val onesZeroZeroZeroZeroZero\
    \ = onesZeroZeroZeroZeroZeroCount + zerosCount\n        val onesZeroZeroZeroZeroZero\
    \ = onesZeroZeroZeroZeroZeroCount + zerosCount\n        val onesZeroZeroZeroZeroZero\
    \ = onesZeroZeroZeroZeroZeroCount + zerosCount\n        val onesZeroZeroZeroZeroZero\
    \ = onesZeroZeroZeroZeroZeroCount + zerosCount\n        val onesZeroZeroZeroZeroZero\
    \ = onesZeroZeroZeroZeroZeroCount + zerosCount\n        val onesZeroZeroZeroZeroZero\
    \ = onesZeroZeroZeroZeroZeroCount + zerosCount\n        val onesZeroZeroZero\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppcywugbv.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppcywugbv.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroZeroZeroZeroCount\e[0m = onesZeroZeroZeroZeroCount + zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroCount is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppcywugbv.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroZero\e\
    [0m = onesZeroZeroZeroZeroZeroCount + zerosCount\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroZero is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroZero\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppcywugbv.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroZero\e\
    [0m = onesZeroZeroZeroZeroZeroCount + zerosCount\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroZero is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroZero\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppcywugbv.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroZero\e\
    [0m = onesZeroZeroZeroZeroZeroCount + zerosCount\n\e[31m\e[31m   |\e[0m  "
  stdout: ''
  timestamp: 1659795072
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((x, y) => x.toLong == y.toLong ? x.toLong\
    \ - y.toLong : x.toLong - y.toLong * 2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfguqn4if.scala:15:85 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) =>\
    \ x.toLong == y.toLong ? x.toLong - y.toLong : x.toLong \e[35m-\e[0m y.toLong\
    \ \e[35m*\e[0m \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                          \
    \                                                           ^\e[0m\n\e[31m   |\e\
    [0m                                                       Not found: type -\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfguqn4if.scala:15:52\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.toLong == y.toLong ? x.toLong - y.toLong : x.toLong\
    \ \e[35m-\e[0m y.toLong \e[35m*\e[0m \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \                                       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                    value ? is not a member of Long\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((x, y) => x.toLong == y.toLong ? x.toLong\
    \ - y.toLong : x.toLong > y.toLong ? 1 : -1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvd7za0_v.scala:15:100 --------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) =>\
    \ x.toLong == y.toLong ? x.toLong - y.toLong : x.toLong \e[35m>\e[0m y.toLong\
    \ \e[35m?\e[0m \e[31m1\e[0m : -\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m          \
    \                                                                            \
    \              ^\e[0m\n\e[31m   |\e[0m                                       \
    \      ')' expected, but ':' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvd7za0_v.scala:15:85\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.toLong == y.toLong ? x.toLong - y.toLong : x.toLong\
    \ \e[35m>\e[0m y.toLong \e[35m?\e[0m \e[31m1\e[0m : -\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                  ^\e[0m\n\e[31m   |\e[0m                                   \
    \                    Not found: type >\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpvd7za0_v.scala:15:52 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.toLong\
    \ == y.toLong ? x.toLong - y.toLong : x.toLong \e[35m>\e[0m y.toLong \e[35m?\e\
    [0m \e[31m1\e[0m : -\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \                   value ? is not a member of Long\n3 errors found\n"
  stdout: ''
  timestamp: 1659795072
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(x => x == 1l)\n        val zeros\
    \ = arr.count(x => x == 0l)\n        val onesZeros = ones + zeros\n        val\
    \ onesZeroArray = arr.map(x => if (x == 1l) 1 else 0)\n        val onesZeroArraySorted\
    \ = onesZeroArray.sortWith(_ < _)\n        val onesZeroArraySortedSortedWithOnes\
    \ = onesZeroArraySorted.take(onesZeros)\n        val onesZeroArraySortedSortedWithZeros\
    \ = onesZeroArraySorted.drop(onesZeros)\n        val onesZeroArraySortedSortedWithOnesAndZeros\
    \ = onesZeroArraySorted.take(onesZeros).zip(onesZeroArraySortedSortedWithOnes)\n\
    \        val onesZeroArraySortedSortedWithOnesAndZerosSortedWithOnes = onesZeroArraySortedSortedWithOnesAndZeros.sortWith(_\
    \ < _)\n        val onesZeroArraySortedSortedWithOnesAndZerosSortedWithZeros =\
    \ onesZeroArraySortedSortedWithOnesAndZeros.sortWith(_ > _)\n        val onesZeroArraySortedSortedWithOnesAndZerosSortedWithOnesAndZeros\
    \ = onesZeroArraySortedSortedWithOnesAndZeros.sortWith(_ < _)\n        val onesZeroArraySortedSortedWithOnesAndZerosSortedWithOnesAndZerosSortedWithOnes\
    \ = onesZeroArraySortedSortedWithOnesAndZerosSortedWithOnes.sortWith(_ < _)\n\
    \        val onesZeroArraySortedSortedWithOnesAndZerosSortedWithOnesAndZerosSortedWithZeros\
    \ = onesZeroArraySortedSortedWithOnesAndZerosSortedWithOnesAndZeros.sortWith(_\
    \ > _)\n        val onesZeroArraySortedSortedWithOnesAndZerosSortedWithOnesAndZerosSortedWithOnesAndZeros\
    \ = onesZeroArraySortedSortedWithOnesAndZerosSortedWithOnesAndZerosSortedWithOnes.sortWith(_\
    \ > _)\n        val onesZeroArraySortedSortedWithOnesAndZerosSortedWithOnesAndZerosSortedWithOnesAndZerosSortedWithOnes\
    \ = onesZeroArraySortedSortedWithOnesAndZerosSortedWithOnesAndZerosSortedWithOnesAndZeros.sortWith(_\
    \ > _)\n        val onesZeroArraySortedSortedWithOnesAndZerosSortedWithOnesAndZerosSorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4iz_djz0.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4iz_djz0.scala:23:123\
    \ -----------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeroArraySortedSortedWithOnesAndZerosSortedWithOnes\e[0m = onesZeroArraySortedSortedWithOnesAndZeros.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                                                \
    \                                                                         ^^^\e\
    [0m\n\e[31m   |\e[0mvalue < is not a member of (Int, Int), but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4iz_djz0.scala:24:124 -----------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36monesZeroArraySortedSortedWithOnesAndZerosSortedWithZeros\e\
    [0m = onesZeroArraySortedSortedWithOnesAndZeros.sortWith(_ > _)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                                       ^^^\e[0m\n\e[31m   |\e\
    [0mvalue > is not a member of (Int, Int), but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4iz_djz0.scala:25:131 -----------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesZeroArraySortedSortedWithOnesAndZerosSortedWithOnesAndZeros\e\
    [0m = onesZeroArraySortedSortedWithOnesAndZeros.sortWith(_ < _)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                        "
  stdout: ''
  timestamp: 1659795078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppt2kjs_8.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppt2kjs_8.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmppt2kjs_8.scala:37:82 ------------------------\e[0m\e[0m\n\
    \e[31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m                                              \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e"
  stdout: ''
  timestamp: 1659795075
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l)\n        val zeros\
    \ = arr.filter(_ == 0l)\n        val onesCount = ones.count\n        val zerosCount\
    \ = zeros.count\n        val onesDecimal = onesCount / 2\n        val zerosDecimal\
    \ = zerosCount / 2\n        val onesDecimalDecimal = onesDecimal + zerosDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal + onesDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal.toDouble\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = ones\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpinvehzz0.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpinvehzz0.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpinvehzz0.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e"
  stdout: ''
  timestamp: 1659795076
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => 1l << x).toList\n        val zerosCount = zeros.map(x => 1l << x).toList\n\
    \        val onesZeros = ones.zip(zeros)\n        val onesZerosCount = onesZeros.map(x\
    \ => (x._1, 1l << x._2)).toList\n        val onesZerosCountSorted = onesZerosCount.sortBy(_._1).reverse\n\
    \        val zerosZerosCount = zeros.zip(zeros).map(x => (x._1, 1l << x._2)).toList\n\
    \        val zerosZerosCountSorted = zerosZerosCount.sortBy(_._1).reverse\n  \
    \      val onesZerosCountSortedSorted: Seq[(Long, Long)] = onesZerosCountSorted.sortBy(_._1).reverse\n\
    \        val zerosZerosCountSortedSorted: Seq[(Long, Long)] = zerosZerosCountSorted.sortBy(_._1).reverse\n\
    \        val onesZerosCountSortedSortedSorted: Seq[(Long, Long)] = onesZerosCountSortedSorted.sortBy(_._1).reverse\n\
    \        val zerosZerosCountSortedSortedSorted: Seq[(Long, Long)] = zerosZerosCountSortedSorted.sortBy(_._1).reverse\n\
    \        val onesZerosCountSortedSortedSortedSorted: Seq[(Long, Long)] = onesZerosCountSortedSortedSorted.sortBy(_._1).reverse\n\
    \        val zerosZerosCountSortedSortedSortedSorted: Seq[(Long, Long)] = zerosZerosCountSortedSortedSorted.sortBy(_._1).reverse\n\
    \        val onesZerosCountSortedSortedSortedSortedSorted: Seq[(Long, Long)] =\
    \ onesZerosCountSortedSortedSortedSorted.sortBy(_._1).reverse\n        val zerosZerosCountSortedSortedSortedSortedSorted:\
    \ Seq[(Long, Long)] = zerosZerosCountSortedSortedSortedSorted.sortBy(_._1).reverse\n\
    \        val onesZerosCountSortedSortedSortedSortedSortedSorted: Seq[(Long, Long)]\
    \ = onesZerosCountSortedSortedSortedSortedSorted.sortBy(_._1).reverse\n      \
    \  val zerosZerosCountSortedSortedSortedSortedSortedSorted: Seq[(Long, Long)]\
    \ = zerosZerosCountSortedSortedSortedSortedSor\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg2xecte6.scala:24:94\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36monesZerosCountSortedSorted\e\
    [0m: \e[35mSeq\e[0m[(\e[35mLong\e[0m, \e[35mLong\e[0m)] = onesZerosCountSorted.sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 Found:    \e[1m\e[31mList\e[0m[(Long, Long)]\n\e[31m   |\e[0m\
    \                          Required: \e[1m\e[32mcollection\e[0m\e[1m\e[32m.\e\
    [0m\e[1m\e[32mmutable\e[0m\e[1m\e[32m.\e[0m\e[1m\e[32mSeq\e[0m[(Long, Long)]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg2xecte6.scala:25:96\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mzerosZerosCountSortedSorted\e\
    [0m: \e[35mSeq\e[0m[(\e[35mLong\e[0m, \e[35mLong\e[0m)] = zerosZerosCountSorted.sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                   Found:    \e[1m\e[31mList\e[0m[(Long, Long)]\n\e[31m   |\e\
    [0m                          Required: \e[1m\e[32mcollection\e[0m\e[1m\e[32m.\e\
    [0m\e[1m\e[32mmutable\e[0m\e[1m\e[32m.\e[0m\e[1m\e[32mSeq\e[0m[(Long, Long)]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg2xecte6.scala:33:85\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosZerosCountSortedSortedSortedSortedSortedSorted\e[0m: \e[35mSeq\e[0m[(\e\
    [35mLong\e[0m, \e[35mLong\e[0m)] = zerosZerosCountSortedSortedSortedSortedSor\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                   Not found: zerosZerosCountSortedSortedSortedSortedSor\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mism"
  stdout: ''
  timestamp: 1659795077
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toLong).count(_ == 1)\n        val zerosCount = zeros.map(x => x.toLong).count(_\
    \ == 0)\n        val onesZeros = ones.zip(zeros)\n        val onesZeroCount =\
    \ onesZeros.map(x => x._1.toLong).count(_ == 1)\n        val onesZeroZeros = onesZeros.map(x\
    \ => x._2.toLong).count(_ == 0)\n        val onesZeroOnes = onesZeros.map(x =>\
    \ x._2.toLong).count(_ == 1)\n        val onesZeroOnesCount = onesZeroOnes.map(x\
    \ => x.toLong).count(_ == 1)\n        val onesZeroOnesZeros = onesZeroOnes.map(x\
    \ => x._2.toLong).count(_ == 0)\n        val onesZeroOnesOnes = onesZeroOnes.map(x\
    \ => x._2.toLong).count(_ == 1)\n        val onesZeroOnesOnesCount = onesZeroOnesOnes.map(x\
    \ => x.toLong).count(_ == 1)\n        val onesZeroOnesOnesZeros = onesZeroOnesOnes.map(x\
    \ => x._2.toLong).count(_ == 0)\n        val onesZeroOnesOnesOnes = onesZeroOnesOnes.map(x\
    \ => x._2.toLong).count(_ == 1)\n        val onesZeroOnesOnesOnesCount = onesZeroOnesOnesOnes.map(x\
    \ => x.toLong).count(_ == 1)\n        val onesZeroOnesOnesOnesZeros = onesZeroOnesOnesOnes.map(x\
    \ => x._2.toLong).count(_ == 0)\n        val onesZeroOnesOnesOnesOnes = onesZeroOnesOnesOnes.map(x\
    \ => x._2.toLong).count(_ == 1)\n        val onesZeroOnesOnesOnesOnesCount = onesZeroOnesOnesOnesOnes.map(x\
    \ => x.toLong).count(_ == 1)\n        val onesZeroOnesOnesOnesOnesZeros = onesZeroOnesOnesOnesOnes.map(x\
    \ => x._2.toLong).count(_ == 0)\n        val onesZeroOne\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpleexw44m.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpleexw44m.scala:23:45\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeroOnesCount\e[0m = onesZeroOnes.map(\e[36mx\e[0m => x.toLong).count(_\
    \ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                value map is not a member\
    \ of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpleexw44m.scala:24:45\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeroOnesZeros\e[0m = onesZeroOnes.map(\e[36mx\e[0m => x._2.toLong).count(_\
    \ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                value map is not a member\
    \ of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpleexw44m.scala:25:44\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeroOnesOnes\e[0m = onesZeroOnes.map(\e[36mx\e[0m => x._2.toLong).count(_\
    \ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value map is not a member of\
    \ Int\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpleexw44m.scala:35:5\
    \ ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659795077
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.count(_\
    \ == 1)\n        val zerosCount = zeros.count(_ == 0)\n        val onesZeros =\
    \ ones + zeros\n        val onesZeroCount = onesZeros.count(_ == 1)\n        val\
    \ onesZeroZeros = onesZeros + ones\n        val onesZeroZeroCount = onesZeroZeros.count(_\
    \ == 1)\n        val onesZeroZeroZeros = onesZeroZeros + onesZeros\n        val\
    \ onesZeroZeroZeroCount = onesZeroZeroZeros.count(_ == 1)\n        val onesZeroZeroZeroZeros\
    \ = onesZeroZeroZeros + onesZeroZeros\n        val onesZeroZeroZeroZeroCount =\
    \ onesZeroZeroZeroZeros.count(_ == 1)\n        val onesZeroZeroZeroZeroZeros =\
    \ onesZeroZeroZeroZeros + onesZeroZeroZeros\n        val onesZeroZeroZeroZeroZeroCount\
    \ = onesZeroZeroZeroZeroZeros.count(_ == 1)\n        val onesZeroZeroZeroZeroZeros\
    \ = onesZeroZeroZeroZeroZeros + onesZeroZeroZeros\n        val onesZeroZeroZeroZeroZeroCount\
    \ = onesZeroZeroZeroZeroZeroZeros.count(_ == 1)\n        val onesZeroZeroZeroZeroZeros\
    \ = onesZeroZeroZeroZeroZeros + onesZeroZeroZeros\n        val onesZeroZeroZeroZeroZeroCount\
    \ = onesZeroZeroZeroZeroZeroZeros.count(_ == 1)\n        val onesZeroZeroZeroZeroZeroZeros\
    \ = onesZeroZeroZeroZeroZeroZeros + onesZeroZeroZeros\n        val onesZeroZeroZeroZeroZeroZeroCount\
    \ = onesZeroZeroZeroZeroZeroZeroZeros.count(_ == 1)\n        val onesZeroZeroZeroZeroZeroZeros\
    \ = onesZeroZeroZeroZeroZeroZeroZeros + onesZeroZeroZeros\n        val onesZeroZeroZeroZeroZeroZeroCount\
    \ = onesZeroZeroZeroZeroZeroZeroZeroZeros.count(_ == 1)\n        val onesZeroZeroZeroZeroZeroZeroZeros\
    \ = onesZeroZeroZeroZeroZeroZeroZeroZeroZeros + onesZeroZeroZeros\n        val\
    \ onesZeroZeroZeroZeroZeroZeroZeroCount = onesZeroZeroZeroZeroZeroZeroZeroZeroZeros.count(_\
    \ == \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppsg4fl8x.scala:38:104 --------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroZeroZeroZeroCount\e\
    [0m = onesZeroZeroZeroZeroZeroZeroZeroZeroZeros.count(_ == \n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \                expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmppsg4fl8x.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroZeros\e\
    [0m = onesZeroZeroZeroZeroZeros + onesZeroZeroZeros\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroZeros is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppsg4fl8x.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroZeroCount\e\
    [0m = onesZeroZeroZeroZeroZeroZeros.count(_ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroZeroCount is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroZeroCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppsg4fl8x.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroZeros\e\
    [0m = onesZeroZeroZeroZeroZeros + onesZeroZeroZeros\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroZeros is already "
  stdout: ''
  timestamp: 1659795078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjpjpx_t7.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(_.toInt).sum\n\
    \        val zerosCount = zeros.map(_.toInt).sum\n        val onesDecimal = ones.map(_.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(_.toDouble).sum\n        val onesDecimal\
    \ = ones.map(_.toDouble).sum\n        val zerosDecimal = zeros.map(_.toDouble).sum\n\
    \        val onesDecimal = ones.map(_.toDouble).sum\n        val zerosDecimal\
    \ = zeros.map(_.toDouble).sum\n        val onesDecimal = ones.map(_.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(_.toDouble).sum\n        val onesDecimal\
    \ = ones.map(_.toDouble).sum\n        val zerosDecimal = zeros.map(_.toDouble).sum\n\
    \        val onesDecimal = ones.map(_.toDouble).sum\n        val zerosDecimal\
    \ = zeros.map(_.toDouble).sum\n        val onesDecimal = ones.map(_.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(_.toDouble).sum\n        val onesDecimal\
    \ = ones.map(_.toDouble).sum\n        val zerosDecimal = zeros.map(_.toDouble).sum\n\
    \        val onesDecimal = ones.map(_.toDouble).sum\n        val zerosDecimal\
    \ = zeros.map(_.toDouble).sum\n        val onesDecimal = ones.map(_.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(_.toDouble).sum\n        val onesDecimal\
    \ = ones.map(_.toDouble).sum\n        val zerosDecimal = zeros.map(_.toDouble).sum\n\
    \        val onesDecimal = ones.map(_.toDouble).sum\n        val zerosDecimal\
    \ = zeros.map(_.toDouble).sum\n        val onesDecimal = ones.map(_.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(_.toDouble).sum\n        val onesDecimal\
    \ = ones.map(_.toDouble).sum\n        val zerosDecimal = zeros.map(_.toDouble).sum\n\
    \        val onesDecimal = ones.map(_.toDouble).sum\n        val zerosDecimal\
    \ = zeros.map(_.toDouble).sum\n        val onesDecimal = ones.map(_.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(_.toDouble).sum\n        val onesDecimal\
    \ = ones.map(_.toDouble).\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvxn2_1ek.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpvxn2_1ek.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimal\e[0m = ones.map(_.toDouble).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesDecimal is already defined as \e[33mvalue\e[0m \e[35monesDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvxn2_1ek.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimal\e[0m = zeros.map(_.toDouble).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mzerosDecimal is already defined as \e[33mvalue\e[0m \e[35mzerosDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvxn2_1ek.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36monesDecimal\e[0m = ones.map(_.toDouble).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesDecimal is already defined as \e[33mvalue\e[0m \e[35monesDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvxn2_1ek.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimal\e[0m = zeros.map(_.toDouble).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mzerosDecimal is already defined as \e[33mvalue\e[0m \e[35mzerosDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E"
  stdout: ''
  timestamp: 1659795078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros_sorted\
    \ = onesZeros.sortBy(x => math.abs(x))\n        val onesZeros_sorted_reversed\
    \ = onesZeros_sorted.reverse\n        val onesZeros_sorted_reversed_sorted = onesZeros_sorted_reversed.sortBy(x\
    \ => math.abs(x))\n        val onesZeros_sorted_reversed_sorted_reversed = onesZeros_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted = onesZeros_sorted_reversed_sorted_reversed.sortBy(x\
    \ => math.abs(x))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted.reverse\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x => math.abs(x))\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => math.abs(x))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => math.abs(x))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => math.abs(x))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp8iytamh.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp8iytamh.scala:18:41\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeros_sorted\e[0m = onesZeros.sortBy(\e[36mx\e[0m => math.abs(x))\n\e\
    [31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                               value sortBy is not a member of Int\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpp8iytamh.scala:29:120 --------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\e\
    [0m = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(\e\
    [36mx\e[0m => math.abs(x))\n\e[31m\e[31m   |\e[0m                            \
    \                                                                            \
    \                ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e\
    [31m   |\e[0m  onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpp8iytamh.scala:30:127 --------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\e\
    [0m = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                       ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_r"
  stdout: ''
  timestamp: 1659795077
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = arr.count(_ == 1).map(_.toString.toDouble).sum\n\
    \        val zerosDecimal = arr.count(_ == 0).map(_.toString.toDouble).sum\n \
    \       val onesDecimalDecimal = onesDecimal / onesCount\n        val zerosDecimalDecimal\
    \ = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecim\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkuxgj_33.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpkuxgj_33.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpkuxgj_33.scala:19:44 ------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesDecimal\e[0m = arr.count(_ ==\
    \ \e[31m1\e[0m).map(_.toString.toDouble).sum\n\e[31m\e[31m   |\e[0m          \
    \                ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \         value map is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpkuxgj_33.scala:20:45 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m        \e[33mval\e[0m \e[36mzerosDecimal"
  stdout: ''
  timestamp: 1659795077
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjpjpx_t7.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l)\n        val zeros\
    \ = arr.filter(x => x == 0l)\n        val onesCount = ones.count(x => x == 1l)\n\
    \        val zerosCount = zeros.count(x => x == 0l)\n        val onesDecimal =\
    \ onesCount.toDouble / arr.length\n        val zerosDecimal = zerosCount.toDouble\
    \ / arr.length\n        val onesDecimalDecimal = onesDecimal.toDouble / onesCount\n\
    \        val zerosDecimalDecimal = zerosDecimal.toDouble / zerosCount\n      \
    \  val onesDecimalDecimalDecimal = onesDecimalDecimal.toDouble / onesCount\n \
    \       val zerosDecimalDecimalDecimal = zerosDecimalDecimal.toDouble / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal.toDouble\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal.toDouble\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal.toDouble\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / onesCount\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.to\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi2pd9gch.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi2pd9gch.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpi2pd9gch.scala:38:145 -----------------------\e[0m\e[0m\n\
    \e[31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.to\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue to is not a mem"
  stdout: ''
  timestamp: 1659795077
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val maxOnes = arr.filter(_\
    \ % 2 == 0).max\n        val maxZeros = arr.filter(_ % 2 == 1).max\n        val\
    \ maxOnesZeros = arr.filter(_ % 2 == 0).max / 2\n        val maxZerosOnes = arr.filter(_\
    \ % 2 == 1).max / 2\n        val maxOnesZerosOnes = arr.filter(_ % 2 == 0).max\
    \ / 2\n        val maxOnesZerosZeros = arr.filter(_ % 2 == 1).max / 2\n      \
    \  val maxZerosOnesZeros = arr.filter(_ % 2 == 1).max / 2\n        val maxOnesZerosOnesZeros\
    \ = arr.filter(_ % 2 == 0).max / 2\n        val maxOnesZerosOnesOnes = arr.filter(_\
    \ % 2 == 1).max / 2\n        val maxOnesZerosOnesZeros = arr.filter(_ % 2 == 1).max\
    \ / 2\n        val maxOnesZerosOnesOnesZeros = arr.filter(_ % 2 == 0).max / 2\n\
    \        val maxOnesZerosOnesOnesOnes = arr.filter(_ % 2 == 1).max / 2\n     \
    \   val maxOnesZerosOnesOnesZeros = arr.filter(_ % 2 == 1).max / 2\n        val\
    \ maxOnesZerosOnesOnesOnesZeros = arr.filter(_ % 2 == 0).max / 2\n        val\
    \ maxOnesZerosOnesOnesOnesOnes = arr.filter(_ % 2 == 1).max / 2\n        val maxOnesZerosOnesOnesOnesZeros\
    \ = arr.filter(_ % 2 == 1).max / 2\n        val maxOnesZerosOnesOnesOnesOnesZeros\
    \ = arr.filter(_ % 2 == 0).max / 2\n        val maxOnesZerosOnesOnesOnesOnesOnes\
    \ = arr.filter(_ % 2 == 1).max / 2\n        val maxOnesZerosOnesOnesOnesOnesZeros\
    \ = arr.filter(_ % 2 == 1).max / 2\n        val maxOnesZerosOnesOnesOnesOnesOnesZeros\
    \ = arr.filter(_ % 2 == 0).max / 2\n        val maxOnesZerosOnesOnesOnesOnesOnesOnes\
    \ = arr.filter(_ % 2 == 1).max / 2\n        val maxOnesZer\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppc1vyu39.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppc1vyu39.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxOnesZerosOnesZeros\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m1\e\
    [0m).max / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesZerosOnesZeros is already defined as \e[33mvalue\e\
    [0m \e[35mmaxOnesZerosOnesZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppc1vyu39.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesZerosOnesOnesZeros\e\
    [0m = arr.filter(_ % \e[31m2\e[0m == \e[31m1\e[0m).max / \e[31m2\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesZerosOnesOnesZeros is already defined as \e[33mvalue\e\
    [0m \e[35mmaxOnesZerosOnesOnesZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppc1vyu39.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesZerosOnesOnesOnesZeros\e\
    [0m = arr.filter(_ % \e[31m2\e[0m == \e[31m1\e[0m).max / \e[31m2\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesZerosOnesOnesOnesZeros is already defined as \e[33mvalue\e\
    [0m \e[35mmaxOnesZerosOnesOnesOnesZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppc1vyu39.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesZerosOnesOnesOnesOnesZeros\e\
    [0m = arr.filter(_ % \e[31m2\e[0m == "
  stdout: ''
  timestamp: 1659795078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((x, y) => x.toLong == y.toLong ? x.toLong\
    \ - y.toLong : x.toLong - y.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8ur91pc5.scala:15:85 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) =>\
    \ x.toLong == y.toLong ? x.toLong - y.toLong : x.toLong \e[35m-\e[0m y.toLong)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \                               Not found: type -\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp8ur91pc5.scala:15:52 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) =>\
    \ x.toLong == y.toLong ? x.toLong - y.toLong : x.toLong \e[35m-\e[0m y.toLong)\n\
    \e[31m\e[31m   |\e[0m                                           ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                         value ? is not a member\
    \ of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1659795021
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1)\n        val zerosArr\
    \ = arr.filter(_ == 0)\n        val onesCount = onesArr.length\n        val zerosCount\
    \ = zerosArr.length\n        val onesSum = onesArr.sum\n        val zerosSum =\
    \ zerosArr.sum\n        val onesSumInt = onesSum.toInt\n        val zerosSumInt\
    \ = zerosSum.toInt\n        val onesSumLong = onesSum.toLong\n        val zerosSumLong\
    \ = zerosSum.toLong\n        val onesSumLongInt = onesSumLong.toInt\n        val\
    \ zerosSumLongInt = zerosSumLong.toInt\n        val onesSumLongLong = onesSumLong.toLong\n\
    \        val zerosSumLongLong = zerosSumLong.toLong\n        val onesSumLongLongInt\
    \ = onesSumLongLong.toInt\n        val zerosSumLongLongInt = zerosSumLongLong.toInt\n\
    \        val onesSumLongLongLong = onesSumLongLong.toLong\n        val zerosSumLongLongLong\
    \ = zerosSumLongLong.toLong\n        val onesSumLongLongLongInt = onesSumLongLongLong.toInt\n\
    \        val zerosSumLongLongLongInt = zerosSumLongLongLong.toInt\n        val\
    \ onesSumLongLongLongLong = onesSumLongLongLong.toLong\n        val zerosSumLongLongLongLong\
    \ = zerosSumLongLongLong.toLong\n        val onesSumLongLongLongLongInt = onesSumLongLongLongLong.toInt\n\
    \        val zerosSumLongLongLongLongInt = zerosSumLongLongLongLong.toInt\n  \
    \      val onesSumLongLongLongLongLong = onesSumLongLongLongLongLong.toLong\n\
    \        val zerosSumLongLongLongLongLong = zerosSumLongLongLongLongLong.toLong\n\
    \        val onesSumLongLongLongLongLongInt = onesSumLongLongLongLongLongLong.toInt\n\
    \        val zerosSumLongLongLongLongLongInt = zerosSumLongLongLongLongLongLong.toInt\n\
    \        val onesSumLongLongLongLongLongLong = onesSumLongLongLongLongLongLong.toLong\n\
    \        val zerosSumLongLongLongLongLongLong = zerosSumLongLongLongLongLongLong.toLong\n\
    \        val onesSumLongLongLongLongLongLongInt = \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmph4nvgmmo.scala:47:48 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36monesSumLongLongLongLongLongLongInt\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmph4nvgmmo.scala:41:42 ---------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m        \e[33mval\e[0m \e[36monesSumLongLongLongLongLong\e[0m = onesSumLongLongLongLongLong.toLong\n\
    \e[31m\e[31m   |\e[0m                                          ^\e[0m\n\e[31m\
    \   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35monesSumLongLongLongLongLong\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmph4nvgmmo.scala:42:43\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosSumLongLongLongLongLong\e[0m = zerosSumLongLongLongLongLong.toLong\n\
    \e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m\
    \   |\e[0m                 Recursive \e[33mvalue\e[0m \e[35mzerosSumLongLongLongLongLong\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmph4nvgmmo.scala:45:46\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesSumLongLongLongLongLongLong\e[0m = onesSumLongLongLongLongLongLong.toLong\n\
    \e[31m\e[31m   |\e[0m                                              ^\e[0m\n\e\
    [31m   |\e[0m              Recursive \e[33mvalue\e[0m \e[35monesSumLongLongLongLongLongLong\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmph4nvgmmo.scala:46:47\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosSumLongLongLongLongLongLong\e[0m = zerosSumLongLongLongLongLo"
  stdout: ''
  timestamp: 1659795078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimal = ones.map(x => x.toString.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(x => x.toString.toDouble).sum\n        val\
    \ onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount\
    \ = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp35x2paw2.scala:43:40 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ ones.map(\n\e[31m\e[31m   |\e[0m                                        ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp35x2paw2.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e[36mx\e\
    [0m => ones.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp35x2paw2.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zeros.map(\e[36mx\e[0m => zeros.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp35x2paw2.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e\
    [36mx\e[0m => ones.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp35x2paw2.scala:26:12 ---------------------------\e\
    ["
  stdout: ''
  timestamp: 1659795070
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l)\n        val zeros\
    \ = arr.filter(_ == 0l)\n        val onesCount = ones.count\n        val zerosCount\
    \ = zeros.count\n        val onesDecimal = onesCount / 2\n        val zerosDecimal\
    \ = zerosCount / 2\n        val onesDecimalDecimal = onesDecimal + zerosDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal + onesDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal * 10\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n     \
    \   val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n     \
    \   val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjo97gpgh.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjo97gpgh.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e\
    [31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjo97gpgh.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659795079
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo01fl7_i.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo01fl7_i.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpo01fl7_i.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659795002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ / onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal /\
    \ zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpr4lfzj4l.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpr4lfzj4l.scala:29:61 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpr4lfzj4l.scala:30:62\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m                                                              ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr4lfzj4l.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36mones"
  stdout: ''
  timestamp: 1659795078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l)\n        val zeros\
    \ = arr.filter(_ == 0l)\n        val onesCount = ones.count(_ == 1l)\n       \
    \ val zerosCount = zeros.count(_ == 0l)\n        val onesDecimal = onesCount.toDouble\
    \ / ones.size\n        val zerosDecimal = zerosCount.toDouble / zeros.size\n \
    \       val onesDecimalString = onesDecimal.toString\n        val zerosDecimalString\
    \ = zerosDecimal.toString\n        val onesDecimalInt = onesDecimal.toInt\n  \
    \      val zerosDecimalInt = zerosDecimal.toInt\n        val onesDecimalLong =\
    \ onesDecimal.toLong\n        val zerosDecimalLong = zerosDecimal.toLong\n   \
    \     val onesDecimalFloat = onesDecimal.toFloat\n        val zerosDecimalFloat\
    \ = zerosDecimal.toFloat\n        val onesDecimalDouble = onesDecimal.toDouble\n\
    \        val zerosDecimalDouble = zerosDecimal.toDouble\n        val onesDecimalBigDecimal\
    \ = onesDecimal.toBigDecimal\n        val zerosDecimalBigDecimal = zerosDecimal.toBigDecimal\n\
    \        val onesDecimalDecimal = onesDecimal.toDecimal\n        val zerosDecimalDecimal\
    \ = zerosDecimal.toDecimal\n        val onesDecimalDecimalString = onesDecimalDecimal.toString\n\
    \        val zerosDecimalDecimalString = zerosDecimalDecimal.toString\n      \
    \  val onesDecimalDecimalInt = onesDecimalDecimal.toInt\n        val zerosDecimalDecimalInt\
    \ = zerosDecimalDecimal.toInt\n        val onesDecimalDecimalLong = onesDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalLong = zerosDecimalDecimal.toLong\n        val\
    \ onesDecimalDecimalFloat = onesDecimalDecimal.toFloat\n        val zerosDecimalDecimalFloat\
    \ = zerosDecimalDecimal.toFloat\n        val onesDecimalDecimalDouble = onesDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDouble = zerosDecimalDecimal.toDouble\n      \
    \  val onesDecimalDecimalBigDecimal = onesDecimalDecimal.toBigDecimal\n      \
    \  val zerosDecimalDecimalBigDecimal = zerosDecimalDecimal.toBigDecimal\n    \
    \    val onesDecimalDecimalDecimal = onesDecimalDecimal.toDecimal\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal.toDecimal\n        val onesDecimalDecimalDecimalString\
    \ = onesDecimalDecimalDecimal.toString\n        val zerosDecimalDecimalDecimalString\
    \ = zerosDecimalDecimalDecimal.toString\n        val onesDecimalDecimalDecimalInt\
    \ = onesDecimalDecimalDecimal.toInt\n        val zerosDecimalDecimalDecimalInt\
    \ = zerosDecimalDecimalDecimal.toInt\n        val onesDecimalDecimalDecimalLong\
    \ = ones\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeq1h5jzf.scala:31:48 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalBigDecimal\e\
    [0m = onesDecimal.toBigDecimal\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \          value toBigDecimal is not a member of Double\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpeq1h5jzf.scala:32:50 ------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalBigDecimal\e[0m =\
    \ zerosDecimal.toBigDecimal\n\e[31m\e[31m   |\e[0m                           \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \         value toBigDecimal is not a member of Double\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpeq1h5jzf.scala:33:45 ------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimal\e[0m = onesDecimal.toDecimal\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toDecimal is not a member\
    \ of Double\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeq1h5jzf.scala:34:47\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalDecimal\e[0m = zerosDecimal.toDecimal\n\e[31m\e[31m   |\e[0m \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                               value toDecimal is not a member of Double\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeq1h5jzf.scala:54:5 ---------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659795080
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpku3h5p8o.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpku3h5p8o.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpku3h5p8o.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \ ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E"
  stdout: ''
  timestamp: 1659795002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros_sorted\
    \ = arr.sortBy(x => if (x == 1l.toLong) onesZeros else x.toLong)\n        val\
    \ onesZeros_sorted_reversed = onesZeros_sorted.reverse\n        val onesZeros_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed.sortBy(x => if (x == 0l.toLong) onesZeros else x.toLong)\n\
    \        val onesZeros_sorted_reversed_sorted_reversed = onesZeros_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted = onesZeros_sorted_reversed_sorted_reversed.sortBy(x\
    \ => if (x == -1l.toLong) onesZeros else x.toLong)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted.reverse\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x => if (x\
    \ == -2l.toLong) onesZeros else x.toLong)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => if (x == -3l.toLong) onesZeros else x.toLong)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.sortBy(x\
    \ => if (x == -4l.toLong) onesZeros else x.toLong)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyogv8nfx.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpyogv8nfx.scala:18:91\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m18 |\e[0m       \
    \ \e[33mval\e[0m \e[36monesZeros_sorted\e[0m = arr.sortBy(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1l\e[0m.toLong) onesZeros \e[33melse\e[0m x.toLong)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                           ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering defined\
    \ for AnyVal..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e\
    [35mAnyVal\e[0m](\n\e[31m   |\e[0m      /* missing */summon[java.util.Comparator[AnyVal]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type java.util.Comparator[AnyVal].\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpyogv8nfx.scala:28:111 --------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\e\
    [0m = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.sortBy(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == -\e[31m4l\e[0m.toLong) onesZeros \e[33melse\e\
    [0m x.toLong)\n\e[31m\e[31m   |\e[0m                                         \
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpyogv8nfx.scala:29:120 -----------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\e\
    [0m = onesZeros_sorted_reversed_sorted"
  stdout: ''
  timestamp: 1659795082
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.size\n      \
    \  val zerosDecimal = zerosCount / arr.size\n        val onesDecimalDecimal =\
    \ onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n  \
    \      val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5dcl59ip.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5dcl59ip.scala:31:68\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m    \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5dcl59ip.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5dcl59ip.scala:36:83\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795082
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimal = ones.map(x => x.toString.toInt).sum /\
    \ onesCount.toDouble\n        val zerosDecimal = zeros.map(x => x.toString.toInt).sum\
    \ / zerosCount.toDouble\n        val onesDecimalDecimal = onesDecimal * onesDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal * zerosDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal * onesDecimalDecimal\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal * zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal * onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal * zerosDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal * onesDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ * zerosDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal * onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * zerosDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal * onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpi4sxqp18.scala:31:117 --------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal * onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpi4sxqp18.scala:32:119\
    \ --------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                             ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi4sxqp18.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e["
  stdout: ''
  timestamp: 1659795082
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo01fl7_i.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo01fl7_i.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpo01fl7_i.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659795002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimal = onesCount / arr.length\n        val zerosDecimal\
    \ = zerosCount / arr.length\n        val onesDecimalDecimal = onesDecimal / zerosDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal / onesDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal / onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zeros\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg_wil_yj.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg_wil_yj.scala:31:68\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m                                                                    ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg_wil_yj.scala:34:76\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg_wil_yj.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659795002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.size\n\
    \        val zerosCount = zeros.size\n        val onesDecimal = onesCount / 2\n\
    \        val zerosDecimal = zerosCount / 2\n        val onesDecimalDecimal = onesDecimal\
    \ / 2\n        val zerosDecimalDecimal = zerosDecimal / 2\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / 2\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 2\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6mn1mlnw.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / \e[31m2\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6mn1mlnw.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp6mn1mlnw.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / \e[31m2\e[0m\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \          ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-"
  stdout: ''
  timestamp: 1659795083
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesZeros = arr.filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).length\n        val onesOnes = arr.filter(_ % 2\
    \ == 1).filter(_ % 2 == 0).length\n        val onesZeroOnes = arr.filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).length\n        val onesOnesZeros\
    \ = arr.filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).length\n    \
    \    val onesZeroOnesOnes = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).length\n        val onesOnesZeroOnesOnes = arr.filter(_\
    \ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_\
    \ % 2 == 1).length\n        val onesZeroOnesOnesOnes = arr.filter(_ % 2 == 0).filter(_\
    \ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_\
    \ % 2 == 1).length\n        val onesOnesZeroOnesOnesOnes = arr.filter(_ % 2 ==\
    \ 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 ==\
    \ 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 ==\
    \ 1).length\n        val onesZeroOnesOnesOnesOnesOnes = arr.filter(_ % 2 == 0).filter(_\
    \ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_\
    \ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_\
    \ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).length\n        val onesOnesZeroOnesOnesOnesOnesOnes\
    \ = arr.filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).length\n    \
    \    val onesZeroOnesOnesOnesOnesOnesOnesOnes = arr.filter(_ % 2 == 0).filter(_\
    \ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_\
    \ % 2 == 1).\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpow2egp0x.scala:28:4 ----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpow2egp0x.scala:28:5 ---------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l)\n        val zeros\
    \ = arr.filter(_ == 0l)\n        val onesCount = ones.count(_ == 1l)\n       \
    \ val zerosCount = zeros.count(_ == 0l)\n        val onesDecimal = onesCount /\
    \ arr.length\n        val zerosDecimal = zerosCount / arr.length\n        val\
    \ onesDecimalDecimal = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal\
    \ = zerosDecimal + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal.toDouble\
    \ + zerosDecimalDecimal.toDouble\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal.toDouble\
    \ + onesDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal.toDouble + zerosDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal.toDouble\
    \ + onesDecimalDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal.toDouble + zerosDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal.toDouble\
    \ + onesDecimalDecimalDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble + zerosDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ + onesDecimalDecimalDecimalDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble + zerosDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ + onesDecimalDecimalDecimalDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble + zerosDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ + onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble + zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ + onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n        val onesDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplck3ojlu.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplck3ojlu.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ + onesDecimalDecimalDecimalDecimalDecimal.toDouble\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimal is already defined\
    \ as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimal\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmplck3ojlu.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble + zerosDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplck3ojlu.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimal.toDouble + onesDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesCount = onesArr.size\n        val zerosCount = zerosArr.size\n        val\
    \ onesSum = onesArr.sum\n        val zerosSum = zerosArr.sum\n        val onesSumInt\
    \ = onesSum.toInt\n        val zerosSumInt = zerosSum.toInt\n        val onesSumLong\
    \ = onesSum.toLong\n        val zerosSumLong = zerosSum.toLong\n        val onesSumLongInt\
    \ = onesSumLong.toInt\n        val zerosSumLongInt = zerosSumLong.toInt\n    \
    \    val onesSumLongLong = onesSumLong.toLong\n        val zerosSumLongLong =\
    \ zerosSumLong.toLong\n        val onesSumLongLongInt = onesSumLongLong.toInt\n\
    \        val zerosSumLongLongInt = zerosSumLongLong.toInt\n        val onesSumLongLongLong\
    \ = onesSumLongLong.toLong\n        val zerosSumLongLongLong = zerosSumLongLong.toLong\n\
    \        val onesSumLongLongLongInt = onesSumLongLongLong.toInt\n        val zerosSumLongLongLongInt\
    \ = zerosSumLongLongLong.toInt\n        val onesSumLongLongLongLong = onesSumLongLongLong.toLong\n\
    \        val zerosSumLongLongLongLong = zerosSumLongLongLong.toLong\n        val\
    \ onesSumLongLongLongLongInt = onesSumLongLongLongLong.toInt\n        val zerosSumLongLongLongLongInt\
    \ = zerosSumLongLongLongLong.toInt\n        val onesSumLongLongLongLongLong =\
    \ onesSumLongLongLongLong.toLong\n        val zerosSumLongLongLongLongLong = zerosSumLongLongLongLong.toLong\n\
    \        val onesSumLongLongLongLongLongInt = onesSumLongLongLongLongLong.toInt\n\
    \        val zerosSumLongLongLongLongLongInt = zerosSumLongLongLongLongLong.toInt\n\
    \        val onesSumLongLongLongLongLongLong = onesSumLongLongLongLongLongLong.toLong\n\
    \        val zerosSumLongLongLongLongLongLong = zerosSumLongLongLongLongLongLong.toLong\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpglhleuz1.scala:45:46 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36monesSumLongLongLongLongLongLong\e\
    [0m = onesSumLongLongLongLongLongLong.toLong\n\e[31m\e[31m   |\e[0m          \
    \                                    ^\e[0m\n\e[31m   |\e[0m              Recursive\
    \ \e[33mvalue\e[0m \e[35monesSumLongLongLongLongLongLong\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpglhleuz1.scala:46:47 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mzerosSumLongLongLongLongLongLong\e\
    [0m = zerosSumLongLongLongLongLongLong.toLong\n\e[31m\e[31m   |\e[0m         \
    \                                      ^\e[0m\n\e[31m   |\e[0m             Recursive\
    \ \e[33mvalue\e[0m \e[35mzerosSumLongLongLongLongLongLong\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpglhleuz1.scala:48:5\
    \ ---------------------\e[0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n  \
    \      val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimal\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqsul8je9.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqsul8je9.scala:31:68\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m    \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqsul8je9.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqsul8je9.scala:36:83\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(x => x == 1l)\n        val zeros\
    \ = arr.count(x => x == 0l)\n        val onesZeros = ones + zeros\n        val\
    \ onesZeroArray = arr.map(x => if (x == 1l) 1 else 0)\n        val onesZeroArraySorted\
    \ = onesZeroArray.sortWith(_ < _)\n        val onesZeroArraySortedWithOnes = onesZeroArraySorted.take(onesZeros)\n\
    \        val onesZeroArraySortedWithOnesSorted = onesZeroArraySortedWithOnes.sortWith(_\
    \ < _)\n        val onesZeroArraySortedWithOnesSortedWithZeros = onesZeroArraySortedWithOnesSorted.take(zeros)\n\
    \        val onesZeroArraySortedWithOnesSortedWithZerosSorted = onesZeroArraySortedWithOnesSortedWithZeros.sortWith(_\
    \ < _)\n        val onesZeroArraySortedWithOnesSortedWithZerosSortedWithOnes =\
    \ onesZeroArraySortedWithOnesSortedWithZerosSorted.take(ones)\n        val onesZeroArraySortedWithOnesSortedWithZerosSortedWithOnesSorted\
    \ = onesZeroArraySortedWithOnesSortedWithZerosSortedWithOnes.sortWith(_ < _)\n\
    \        val onesZeroArraySortedWithOnesSortedWithZerosSortedWithOnesSortedWithZeros\
    \ = onesZeroArraySortedWithOnesSortedWithZerosSortedWithOnesSorted.take(zeros)\n\
    \        val onesZeroArraySortedWithOnesSortedWithZerosSortedWithOnesSortedWithZerosSorted\
    \ = onesZeroArraySortedWithOnesSortedWithZerosSortedWithOnesSortedWithZeros.sortWith(_\
    \ < _)\n        val onesZeroArraySortedWithOnesSortedWithZerosSortedWithOnesSortedWithZerosSortedWithOnes\
    \ = onesZeroArraySortedWithOnesSortedWithZerosSortedWithOnesSortedWithZerosSortedWithOnes.sortWith(_\
    \ < _)\n        val onesZeroArraySortedWithOnesSortedWithZerosSortedWithOnesSortedWithZerosSortedWithOnesSortedWithZeros\
    \ = onesZeroArraySortedWithOnesSortedWithZerosSortedWithOnesSortedWithZerosSortedWithOnesSortedWithZeros.sortWith(_\
    \ < _)\n        val onesZeroArraySorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2qf9qvq1.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2qf9qvq1.scala:28:100\
    \ --------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroArraySortedWithOnesSortedWithZerosSortedWithOnesSortedWithZerosSortedWithOnes\e\
    [0m = onesZeroArraySortedWithOnesSortedWithZerosSortedWithOnesSortedWithZerosSortedWithOnes.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                                                \
    \                                                    ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZeroArraySortedWithOnesSortedWithZerosSortedWithOnesSortedWithZerosSortedWithOnes\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp2qf9qvq1.scala:29:115 --------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeroArraySortedWithOnesSortedWithZerosSortedWithOnesSortedWithZerosSortedWithOnesSortedWithZeros\e\
    [0m = onesZeroArraySortedWithOnesSortedWithZerosSortedWithOnesSortedWithZerosSortedWithOnesSortedWithZeros.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                                                \
    \                                                                   ^\e[0m\n\e\
    [31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZeroArraySortedWithOnesSortedWithZerosSortedWithOnesSortedWithZerosSortedWithOnesSortedWithZeros\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp2qf9qvq1.scala:31:5 ---------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795085
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesZeros = ones + zeros\n\
    \        val onesZeros_sorted = arr.sortBy(_ % 2 == 0).sortBy(_ % 2 == 1)\n  \
    \      val onesZeros_sorted_reversed = onesZeros_sorted.reverse\n        val onesZeros_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed.sortBy(_ % 2 == 0).sortBy(_ % 2 == 1)\n        val\
    \ onesZeros_sorted_reversed_sorted_reversed = onesZeros_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted = onesZeros_sorted_reversed_sorted_reversed.sortBy(_\
    \ % 2 == 0).sortBy(_ % 2 == 1)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted.reverse\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(_ % 2 ==\
    \ 0).sortBy(_ % 2 == 1)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(_\
    \ % 2 == 0).sortBy(_ % 2 == 1)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(_\
    \ % 2 == 0).sortBy(_ % 2 == 1)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd5_gffj0.scala:30:143 -----------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\e\
    [0m = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reverse\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd5_gffj0.scala:31:5\
    \ ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795086
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.map(x\
    \ => 1l.toLong).sum\n        val zerosCount = zeros.map(x => 0l.toLong).sum\n\
    \        val onesDecimal = ones.map(x => x.toLong).sum / onesCount\n        val\
    \ zerosDecimal = zeros.map(x => x.toLong).sum / zerosCount\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkx6lba0l.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkx6lba0l.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpkx6lba0l.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpkx6lba0l.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimal / zerosCount\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659795085
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesZeros = ones + zeros\n\
    \        val onesZeroCount = onesZeros.map(x => x.toString.toInt).sum\n      \
    \  val onesZeroCountSorted = onesZeroCount.sortBy(x => x)\n        val onesZeroCountSortedList\
    \ = onesZeroCountSorted.toList\n        val zerosZeroCount = zeros.map(x => x.toString.toInt).sum\n\
    \        val zerosZeroCountSorted = zerosZeroCount.sortBy(x => x)\n        val\
    \ zerosZeroCountSortedList = zerosZeroCountSorted.toList\n        val onesZeroCountSortedList\
    \ = onesZeroCountSortedList.sortBy(x => x)\n        val zerosZeroCountSortedList\
    \ = zerosZeroCountSortedList.sortBy(x => x)\n        val onesZeroCountSortedList\
    \ = onesZeroCountSortedList.sortBy(x => x)\n        val zerosZeroCountSortedList\
    \ = zerosZeroCountSortedList.sortBy(x => x)\n        val onesZeroCountSortedList\
    \ = onesZeroCountSortedList.sortBy(x => x)\n        val zerosZeroCountSortedList\
    \ = zerosZeroCountSortedList.sortBy(x => x)\n        val onesZeroCountSortedList\
    \ = onesZeroCountSortedList.sortBy(x => x)\n        val zerosZeroCountSortedList\
    \ = zerosZeroCountSortedList.sortBy(x => x)\n        val onesZeroCountSortedList\
    \ = onesZeroCountSortedList.sortBy(x => x)\n        val zerosZeroCountSortedList\
    \ = zerosZeroCountSortedList.sortBy(x => x)\n        val onesZeroCountSortedList\
    \ = onesZeroCountSortedList.sortBy(x => x)\n        val zerosZeroCountSortedList\
    \ = zerosZeroCountSortedList.sortBy(x => x)\n        val onesZeroCountSortedList\
    \ = onesZeroCountSortedList.sortBy(x => x)\n        val zerosZeroCountSortedList\
    \ = zerosZeroCountSortedList.sortBy(x => x)\n        val onesZeroCountSortedList\
    \ = onesZeroCountSortedList.sortBy(x => x)\n        val zerosZeroCountSortedList\
    \ = zerosZeroCountSortedList.sortBy(x => x)\n        val onesZeroCountSortedList\
    \ = onesZeroCountSortedList.sortBy(x => x)\n        val zerosZeroCountSortedList\
    \ = zerosZeroCountSortedList.sortBy(x => x)\n        val onesZeroCountSortedList\
    \ = onesZeroCountSortedList.sortBy(x => x)\n        val zerosZeroCountSorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx4_yowg6.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx4_yowg6.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroCountSortedList\e[0m = onesZeroCountSortedList.sortBy(\e[36mx\e\
    [0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroCountSortedList is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroCountSortedList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx4_yowg6.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mzerosZeroCountSortedList\e\
    [0m = zerosZeroCountSortedList.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosZeroCountSortedList is already defined as \e[33mvalue\e\
    [0m \e[35mzerosZeroCountSortedList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx4_yowg6.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36monesZeroCountSortedList\e\
    [0m = onesZeroCountSortedList.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroCountSortedList is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroCountSortedList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx4_yowg6.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mzerosZeroCountSortedList\e\
    [0m = zerosZeroCountSortedList.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   "
  stdout: ''
  timestamp: 1659795086
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimal)\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal.toDouble / Math.pow(10, onesDecimalDecimal)\n        val\
    \ onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimalDecimal)\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal.toDouble / Math.pow(10, onesDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimalDecimalDecimal)\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal.toDouble / Math.pow(10, onesDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimalDecimalDecimalDecimal)\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / Math.pow(10, onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / Math.pow(10, onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjpuhjuel.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble /\
    \ Math.pow(\e[31m10\e[0m, onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjpuhjuel.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpjpuhjuel.scala:25:47 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimal\e[0m\
    \ = onesDecimalDecimalDecimalDecimal.toDouble / Math.pow(\e[31m10\e[0m, zerosDecimalDecimalDecimal)\n\
    \e[31m\e[31m   |\e[0m                                               ^\e[0m\n\e\
    [31m   |\e[0m             Recursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimal\e\
    [0m needs ty"
  stdout: ''
  timestamp: 1659795085
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.map(_.toString.toInt).sum\n\
    \        val zerosCount = zeros.map(_.toString.toInt).sum\n        val onesDecimal\
    \ = ones.map(_.toString.toInt).map(_.toString.toInt).sum\n        val zerosDecimal\
    \ = zeros.map(_.toString.toInt).map(_.toString.toInt).sum\n        val onesDecimalDecimal\
    \ = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val zerosDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val onesDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val zerosDecimalDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val onesDecimalDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val zerosDecimalDecimalDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxc4if2eo.scala:29:136 --------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \    ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpxc4if2eo.scala:30:5 ---------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795086
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros_sorted\
    \ = arr.sortWith(\n            (x: Long, y: Long) => if (x == y) 0 else if (x\
    \ == 0 && y == 0) 1 else (x == 0 && y == 1) -1 )\n        val onesZeros_sortedWithOnes\
    \ = onesZeros_sorted.take(onesZeros)\n        val onesZeros_sortedWithOnesZeros\
    \ = onesZeros_sorted.take(onesZeros)\n        val onesZeros_sortedWithOnesZeros_sorted\
    \ = onesZeros_sorted.sortWith(\n            (x: Long, y: Long) => if (x == y)\
    \ 0 else if (x == 0 && y == 0) 1 else (x == 0 && y == 1) -1 )\n        val onesZeros_sortedWithOnesZeros_sortedWithOnes\
    \ = onesZeros_sorted.take(onesZeros)\n        val onesZeros_sortedWithOnesZeros_sortedWithOnesZeros\
    \ = onesZeros_sorted.take(onesZeros)\n        val onesZeros_sortedWithOnesZeros_sortedWithOnesZeros_sorted\
    \ = onesZeros_sorted.sortWith(\n            (x: Long, y: Long) => if (x == y)\
    \ 0 else if (x == 0 && y == 0) 1 else (x == 0 && y == 1) -1 )\n        val onesZeros_sortedWithOnesZeros_sortedWithOnesZeros_sortedWithOnes\
    \ = onesZeros_sorted.take(onesZeros)\n        val onesZeros_sortedWithOnesZeros_sortedWithOnesZeros_sortedWithOnesZeros\
    \ = onesZeros_sorted.take(onesZeros)\n        val onesZeros_sortedWithOnesZeros_sortedWithOnesZeros_sortedWithOnesZeros_sorted\
    \ = onesZeros_sorted.sortWith(\n            (x: Long, y: Long) => if (x == y)\
    \ 0 else if (x == 0 && y == 0) 1 else (x == 0 && y == 1) -1 )\n        val onesZeros_sortedWithOnesZeros_sortedWithOnesZeros_sortedWithOnesZeros_sortedWithOnes\
    \ = onesZeros_sorted.take(onesZeros)\n        val onesZeros_sortedWithOnesZeros_sortedWithOnesZeros_sortedWithOnesZeros_sortedWithOnesZeros\
    \ = onesZeros_sorted.take(onesZeros)\n        val onesZeros_sortedWithOnesZero\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6bnuc708.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp6bnuc708.scala:19:46 --------------------\e[0m\e[0m\n\e[31m19 |\e[0m\
    \            (\e[36mx\e[0m: \e[35mLong\e[0m, \e[36my\e[0m: \e[35mLong\e[0m) =>\
    \ \e[33mif\e[0m (x == y) \e[31m0\e[0m \e[33melse\e[0m \e[33mif\e[0m (x == \e[31m0\e\
    [0m && y == \e[31m0\e[0m) \e[31m1\e[0m \e[33melse\e[0m (x == \e[31m0\e[0m && y\
    \ == \e[31m1\e[0m) -\e[31m1\e[0m )\n\e[31m\e[31m   |\e[0m                    \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \                   Found:    (\e[31m0\e[0m : Int)\n\e[31m   |\e[0m          \
    \                                    Required: Boolean\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp6bnuc708.scala:19:75 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            (\e[36mx\e[0m: \e[35mLong\e[0m, \e[36my\e\
    [0m: \e[35mLong\e[0m) => \e[33mif\e[0m (x == y) \e[31m0\e[0m \e[33melse\e[0m \e\
    [33mif\e[0m (x == \e[31m0\e[0m && y == \e[31m0\e[0m) \e[31m1\e[0m \e[33melse\e\
    [0m (x == \e[31m0\e[0m && y == \e[31m1\e[0m) -\e[31m1\e[0m )\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \ ^\e[0m\n\e[31m   |\e[0m                                                    \
    \ Found:    (\e[31m1\e[0m : Int)\n\e[31m   |\e[0m                            \
    \                         Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp6bnuc708.scala:19:101 -----------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            (\e[36mx\e[0m: \e[35mLong\e[0m, \e[36my\e\
    [0m: \e[35mLong\e[0m) => \e[33mif\e[0m (x == y) \e[31m0\e[0m \e[33melse\e[0m \e\
    [33mif\e[0m (x == \e[31m0\e[0m && y == \e[31m0\e[0m) \e[31m1\e[0m \e[33melse\e\
    [0m (x == \e[31m0\e[0m && y == \e[31m1\e[0m) -\e[31m1\e[0m )\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \        ^^^^^^^^^"
  stdout: ''
  timestamp: 1659795087
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjpjpx_t7.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(_.toLong).sum\n\
    \        val zerosCount = zeros.map(_.toLong).sum\n        val onesDecimal = ones.map(_.toLong).map(_.toInt).sum\n\
    \        val zerosDecimal = zeros.map(_.toLong).map(_.toInt).sum\n        val\
    \ onesDecimalCount = ones.map(_.toLong).map(_.toInt).count\n        val zerosDecimalCount\
    \ = zeros.map(_.toLong).map(_.toInt).count\n        val onesDecimalCount = ones.map(_.toLong).map(_.toInt).count\n\
    \        val zerosDecimalCount = zeros.map(_.toLong).map(_.toInt).count\n    \
    \    val onesDecimalCount = ones.map(_.toLong).map(_.toInt).count\n        val\
    \ zerosDecimalCount = zeros.map(_.toLong).map(_.toInt).count\n        val onesDecimalCount\
    \ = ones.map(_.toLong).map(_.toInt).count\n        val zerosDecimalCount = zeros.map(_.toLong).map(_.toInt).count\n\
    \        val onesDecimalCount = ones.map(_.toLong).map(_.toInt).count\n      \
    \  val zerosDecimalCount = zeros.map(_.toLong).map(_.toInt).count\n        val\
    \ onesDecimalCount = ones.map(_.toLong).map(_.toInt).count\n        val zerosDecimalCount\
    \ = zeros.map(_.toLong).map(_.toInt).count\n        val onesDecimalCount = ones.map(_.toLong).map(_.toInt).count\n\
    \        val zerosDecimalCount = zeros.map(_.toLong).map(_.toInt).count\n    \
    \    val onesDecimalCount = ones.map(_.toLong).map(_.toInt).count\n        val\
    \ zerosDecimalCount = zeros.map(_.toLong).map(_.toInt).count\n        val onesDecimalCount\
    \ = ones.map(_.toLong).map(_.toInt).count\n        val zerosDecimalCount = zeros.map(_.toLong).map(_.toInt).count\n\
    \        val onesDecimalCount = ones.map(_.toLong).map(_.toInt).count\n      \
    \  val zerosDecimalCount = zeros.map(_.toLong).map(_.toInt).count\n        val\
    \ onesDecimalCount = ones.map(_.toLong).map(_.toInt).count\n        val zerosDecimalCount\
    \ = zeros.map(_.toLong).map(_.toInt).count\n        val ones\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbsyplm94.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbsyplm94.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalCount\e[0m = ones.map(_.toLong).map(_.toInt).count\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbsyplm94.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zeros.map(_.toLong).map(_.toInt).count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35mzerosDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbsyplm94.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ ones.map(_.toLong).map(_.toInt).count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbsyplm94.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zeros.map(_.toLong).map(_.toInt).count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalCount is already defined as \e"
  stdout: ''
  timestamp: 1659795086
