language: scala
name: HumanEval_110_exchange
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).length\n        val odd = lst2.filter(_ %\
    \ 2 == 1).length\n        if (even == odd) {\n            if (lst1.size == lst2.size)\
    \ {\n                val even = lst1.filter(_ % 2 == 0).length\n             \
    \   if (even > lst2.size) {\n                    return \"NO\"\n             \
    \   }\n                else {\n                    return \"YES\"\n          \
    \      }\n            }\n            else {\n                return \"NO\"\n \
    \           }\n        }\n        else {\n            return \"NO\"\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsqhhyfmn.scala:45)\n\tat Problem.main(tmpsqhhyfmn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst3 = lst1.toSet\n        val lst4 = lst2.toSet\n\
    \        val lst5 = lst3.intersect(lst4)\n        val lst6 = lst5.toList\n   \
    \     val lst7 = lst6.filter(x => x % 2 == 0)\n        val lst8 = lst7.map(x =>\
    \ lst1.indexOf(x))\n        val lst9 = lst8.map(x => lst2.indexOf(x))\n      \
    \  val lst10 = lst9.map(x => lst1.indexOf(x))\n        val lst11 = lst10.map(x\
    \ => lst2.indexOf(x))\n        val lst12 = lst11.map(x => lst1.indexOf(x))\n \
    \       val lst13 = lst12.map(x => lst2.indexOf(x))\n        val lst14 = lst13.map(x\
    \ => lst1.indexOf(x))\n        val lst15 = lst14.map(x => lst2.indexOf(x))\n \
    \       val lst16 = lst15.map(x => lst1.indexOf(x))\n        val lst17 = lst16.map(x\
    \ => lst2.indexOf(x))\n        val lst18 = lst17.map(x => lst1.indexOf(x))\n \
    \       val lst19 = lst18.map(x => lst2.indexOf(x))\n        val lst20 = lst19.map(x\
    \ => lst1.indexOf(x))\n        val lst21 = lst20.map(x => lst2.indexOf(x))\n \
    \       val lst22 = lst21.map(x => lst1.indexOf(x))\n        val lst23 = lst22.map(x\
    \ => lst2.indexOf(x))\n        val lst24 = lst23.map(x => lst1.indexOf(x))\n \
    \       val lst25 = lst24.map(x => lst2.indexOf(x))\n        val lst26 = lst25.map(x\
    \ => lst1.indexOf(x))\n        val lst27 = lst26.map(x => lst2.indexOf(x))\n \
    \       val lst28 = lst27.map(x => lst1.indexOf(x))\n        val lst29 = lst28.map(x\
    \ => lst2.indexOf(x))\n        val lst30 = lst29.map(x => lst1.indexOf(x))\n \
    \       val lst31 = lst30.map(x => lst2.indexOf(x))\n        val lst32 = lst31.map(x\
    \ => lst1.indexOf(x))\n        val lst33 = lst32.map(x => lst2.indexOf(x))\n \
    \       val lst34 = lst33.map(x => lst1.indexOf(x))\n        val lst35 = lst34.map(x\
    \ => lst2.indexOf(x))\n        val lst36 = lst35.map(x => lst1.indexOf(x))\n \
    \       val lst37 = lst36.map(x => lst2.indexOf(x))\n        val lst38 = lst37.map(x\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfxkhoe5t.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfxkhoe5t.scala:54:30\
    \ ------------------------\e[0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e\
    [36mlst38\e[0m = lst37.map(x \n\e[31m\e[31m   |\e[0m                         \
    \     ^\e[0m\n\e[31m   |\e[0m                              Not found: x\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfxkhoe5t.scala:55:5 ---------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659794624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst3 = lst1.filter(_ % 2 == 0)\n        val lst4\
    \ = lst2.filter(_ % 2 == 0)\n        val lst5 = lst3.filter(_ != lst4)\n     \
    \   val lst6 = lst5.filter(_ != lst3)\n        if(lst6.isEmpty) \"NO\" else \"\
    YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpxikut_22.scala:21:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlst5\e[0m = lst3.filter(_\
    \ != lst4)\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmpxikut_22.scala:22:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mlst6\e[0m = lst5.filter(_\
    \ != lst3)\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared with\
    \ == or !=\n2 errors found\n"
  stdout: ''
  timestamp: 1659794624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 0).toList\n        val evenAndOdd = even.intersect(odd)\n      \
    \  val evenAndEven = even.intersect(even)\n        val evenAndOddAndEven = evenAndEven.intersect(evenAndOdd)\n\
    \        val evenAndOddAndOdd = evenAndOdd.intersect(evenAndOdd)\n        val\
    \ evenAndOddAndEvenAndOdd = evenAndOddAndEven.intersect(evenAndOddAndOdd)\n  \
    \      val evenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(even\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoofgn69z.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoofgn69z.scala:26:92\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOdd\e[0m = evenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                    ^\e[0m\n\e[31m   |\e[0m         Recursive\
    \ \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOdd\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoofgn69z.scala:27:58\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^\e[0m\n\e[31m   |\e[0m  Recursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoofgn69z.scala:30:84\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(even\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling wit"
  stdout: ''
  timestamp: 1659794623
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val even = lst1.filter(x => x % 2 == 0).length\n\
    \        val odd = lst2.filter(x => x % 2 == 1).length\n        if (even > odd)\
    \ {\n            return \"NO\"\n        } else {\n            return \"YES\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd0mt3_19.scala:29)\n\tat Problem.main(tmpd0mt3_19.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).toList\n        val odd = lst2.filter(_ %\
    \ 2 != 0).toList\n        val evenAndOdd = even.intersect(odd)\n        val evenAndOddAndEven\
    \ = evenAndOdd.intersect(even)\n        val evenAndOddAndEvenAndOdd = evenAndOddAndEven.intersect(odd)\n\
    \        val evenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOdd.intersect(even)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEven.intersect(odd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(even)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(odd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(even)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd =\
    \ evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(odd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(even)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(odd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp502zlhb7.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp502zlhb7.scala:25:58\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(even)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^\e[0m\n\e[31m   |\e[0m  Recursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp502zlhb7.scala:26:64\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(odd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \        ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp502zlhb7.scala:30:90\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(odd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp502zlhb7.scala:32:5\
    \ ---------------"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst3 = lst1.toSet\n        val lst4 = lst2.toSet\n\
    \        val lst5 = lst3.intersect(lst4)\n        if(lst5.isEmpty) \"\" else \"\
    NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp92ygqk7w.scala:25)\n\tat Problem.main(tmp92ygqk7w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.zip(odd).filter(x => x._1\
    \ == x._2).map(x => x._1)\n        val evenAndOddList = evenAndOdd.toList\n  \
    \      val evenAndOddSet = evenAndOddList.map(x => x.toLong).toSet\n        val\
    \ evenAndOddSetList = evenAndOddSet.toList\n        val evenAndOddSetSet = evenAndOddSetList.map(x\
    \ => x.toLong).toSet\n        val evenAndOddSetSetList = evenAndOddSetSet.toList\n\
    \        val evenAndOddSetSetSetList = evenAndOddSetSetList.toList\n        val\
    \ evenAndOddSetSetSetListSet = evenAndOddSetSetSetList.toList\n        val evenAndOddSetSetSetListSetList\
    \ = evenAndOddSetSetSetListSet.toList\n        val evenAndOddSetSetSetListSetListSet\
    \ = evenAndOddSetSetSetListSetListSet.toList\n        val evenAndOddSetSetSetListSetListSetList\
    \ = evenAndOddSetSetSetListSetListSetList.toList\n        val evenAndOddSetSetSetListSetListSetListSet\
    \ = evenAndOddSetSetListSetListSetListSetList.toList\n        val evenAndOddSetSetListSetListSetListSetListSet\
    \ = evenAndOddSetSetListSetListSetListSetListSet.toList\n        val evenAndOddSetSetListSetListSetListSetListSetList\
    \ = evenAndOddSetSetListSetListSetListSetListSet.toList\n        val evenAndOddSetSetListSetListSetListSetListSetListSet\
    \ = evenAndOddSetSetListSetListSetListSetListSetListSet.toList\n        val evenAndOddSetSetListSetListSetListSetListSetListSetListSet\
    \ = evenAndOddSetSetListSetListSetListSetListSetListSetListSet.toList\n      \
    \  val evenAndOddSetSetListSetListSetListSetListSetListSetListSetListSet = evenAndOddSetSetListSetListSetListSetListSetListSetListSet.toList\n\
    \        val evenAndOddSetSetList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptvz7jli1.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptvz7jli1.scala:29:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddSetSetSetListSetListSet\e[0m = evenAndOddSetSetSetListSetListSet.toList\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m            Recursive \e[33mvalue\e[0m \e[35mevenAndOddSetSetSetListSetListSet\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptvz7jli1.scala:30:52\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddSetSetSetListSetListSetList\e[0m = evenAndOddSetSetSetListSetListSetList.toList\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0m        Recursive \e[33mvalue\e[0m \e[35mevenAndOddSetSetSetListSetListSetList\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptvz7jli1.scala:31:55\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddSetSetSetListSetListSetListSet\e[0m = evenAndOddSetSetListSetListSetListSetList.toList\n\
    \e[31m\e[31m   |\e[0m                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: evenAndOddSetSetListSetListSetListSetList\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptvz7jli1.scala:32:59\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddSetSetListSetListSetListSetListSet\e[0m = evenAndOddSetSetListSetListSetListSetListSet.toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \   ^\e[0m\n\e[31m   |\e[0m Recursive \e[33"
  stdout: ''
  timestamp: 1659794624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(_ % 2 == 0).toList\n        val lst2Even = lst2.filter(_\
    \ % 2 == 0).toList\n        val lst1Odd = lst1.filter(_ % 2 != 0).toList\n   \
    \     val lst2Odd = lst2.filter(_ % 2 != 0).toList\n        val lst1EvenEven =\
    \ lst1Even.intersect(lst2Even).toList\n        val lst2EvenEven = lst2Even.intersect(lst1Even).toList\n\
    \        val lst1EvenOdd = lst1Even.intersect(lst2Odd).toList\n        val lst2EvenOdd\
    \ = lst2Even.intersect(lst1Odd).toList\n        val lst1OddEven = lst1Odd.intersect(lst2Even).toList\n\
    \        val lst2OddEven = lst2Odd.intersect(lst1Even).toList\n        val lst1OddOdd\
    \ = lst1Odd.intersect(lst2Odd).toList\n        val lst2OddOdd = lst2Odd.intersect(lst1Odd).toList\n\
    \        val lst1OddEvenEven = lst1OddEven.intersect(lst2EvenEven).toList\n  \
    \      val lst2OddEvenEven = lst2OddEven.intersect(lst1EvenEven).toList\n    \
    \    val lst1OddEvenOdd = lst1OddEven.intersect(lst2OddEven).toList\n        val\
    \ lst2OddEvenOdd = lst2OddEven.intersect(lst1OddOdd).toList\n        val lst1OddOddEven\
    \ = lst1OddOdd.intersect(lst2EvenEven).toList\n        val lst2OddOddEven = lst2OddOdd.intersect(lst1EvenEven).toList\n\
    \        val lst1OddOddOdd = lst1OddOdd.intersect(lst2OddEven).toList\n      \
    \  val lst2OddOddOdd = lst2OddOdd.intersect(lst1OddOdd).toList\n        val lst1OddOddEvenEven\
    \ = lst1OddOddEven.intersect(lst2OddEvenEven).toList\n        val lst2OddOddEvenEven\
    \ = lst2OddOddEven.\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqii9_o87.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqii9_o87.scala:40:5 ---------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0)\n        val odd = lst2.filter(x =>\
    \ x % 2 == 1)\n        val evenAndOdd = even.zip(odd)\n        val evenAndOddSet\
    \ = evenAndOdd.toSet\n        val lst1Set = lst1.toSet\n        val lst2Set =\
    \ lst2.toSet\n        val evenAndOddSetSize = evenAndOddSet.size\n        val\
    \ lst1SetSize = lst1Set.size\n        val lst2SetSize = lst2Set.size\n       \
    \ val evenAndOddSetIsEven = evenAndOddSetSize == lst1SetSize * lst2SetSize\n \
    \       val lst1SetIsEven = lst1SetSize == evenAndOddSetSize * lst2SetSize\n \
    \       val lst2SetIsEven = lst2SetSize == evenAndOddSetSize * lst1SetSize\n \
    \       val evenAndOddSetIsOdd = evenAndOddSetSize == lst1SetSize * lst2SetSize\n\
    \        val lst1SetIsOdd = lst1SetSize == evenAndOddSetSize * lst2SetSize\n \
    \       val lst2SetIsOdd = lst2SetSize == evenAndOddSetSize * lst1SetSize\n  \
    \      val evenAndOddSetIsEvenAndOdd = evenAndOddSetIsEven && evenAndOddSetIsOdd\n\
    \        val lst1SetIsEvenAndOdd = lst1SetIsEven && lst1SetIsOdd\n        val\
    \ lst2SetIsEvenAndOdd = lst2SetIsEven && lst2SetIsOdd\n        val evenAndOddSetIsEvenAndOddAndIsEvenAndOddSetIsEvenAndOddSetIsOdd\
    \ = evenAndOddSetIsEvenAndOdd && evenAndOddSetIsEvenAndOddSetIsOdd && evenAndOddSetIsEvenAndOddSetIsEvenAndOddSetIsOdd\n\
    \        val lst1SetIsEvenAndOddAndIsEvenAndOddSetIsEvenAndOddSetIsOdd = lst1SetIsEvenAndOdd\
    \ && lst1SetIsEvenAndOddSetIsEvenAndOddSetIsOdd\n        val lst2SetIsEvenAndOddAndIsEvenAndOddSetIsEvenAndOddSetIsOdd\
    \ = lst2Set\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjqfra7wu.scala:36:107 -----------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddSetIsEvenAndOddAndIsEvenAndOddSetIsEvenAndOddSetIsOdd\e\
    [0m = evenAndOddSetIsEvenAndOdd && evenAndOddSetIsEvenAndOddSetIsOdd && evenAndOddSetIsEvenAndOddSetIsEvenAndOddSetIsOdd\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Not found: evenAndOddSetIsEvenAndOddSetIsOdd\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjqfra7wu.scala:36:144\
    \ -----------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddSetIsEvenAndOddAndIsEvenAndOddSetIsEvenAndOddSetIsOdd\e[0m = evenAndOddSetIsEvenAndOdd\
    \ && evenAndOddSetIsEvenAndOddSetIsOdd && evenAndOddSetIsEvenAndOddSetIsEvenAndOddSetIsOdd\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m             Not found: evenAndOddSetIsEvenAndOddSetIsEvenAndOddSetIsOdd\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjqfra7wu.scala:37:95\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e\
    [36mlst1SetIsEvenAndOddAndIsEvenAndOddSetIsEvenAndOddSetIsOdd\e[0m = lst1SetIsEvenAndOdd\
    \ && lst1SetIsEvenAndOddSetIsEvenAndOddSetIsOdd\n\e[31m\e[31m   |\e[0m       \
    \                                                                            \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                   Not found: lst1SetIsEvenAndOddSetIsEvenAndOddSetIsOdd\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjqfra7wu.scala:39:5\
    \ -----"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: Write your code here\n        val lst1Even = lst1.filter(x => x % 2\
    \ == 0)\n        val lst2Even = lst2.filter(x => x % 2 == 0)\n        val lst1Odd\
    \ = lst1.filter(x => x % 2 != 0)\n        val lst2Odd = lst2.filter(x => x % 2\
    \ != 0)\n        if (lst1Even.size == lst2Even.size && lst1Odd.size == lst2Odd.size)\
    \ {\n            val lst1EvenEven = lst1Even.zip(lst2Even)\n            val lst2EvenEven\
    \ = lst2Even.zip(lst1Even)\n            val lst1EvenOdd = lst1Even.zip(lst2Odd)\n\
    \            val lst2EvenOdd = lst2Even.zip(lst1Odd)\n            val lst1OddEven\
    \ = lst1Odd.zip(lst2Even)\n            val lst2OddEven = lst2Odd.zip(lst1Even)\n\
    \            val lst1OddOdd = lst1Odd.zip(lst2Odd)\n            val lst2OddOdd\
    \ = lst2Odd.zip(lst1Odd)\n            val lst1EvenEven = lst1EvenEven.filter(x\
    \ => x._1 == x._2)\n            val lst2EvenEven = lst2EvenEven.filter(x => x._1\
    \ == x._2)\n            val lst1EvenOdd = lst1EvenOdd.filter(x => x._1 == x._2)\n\
    \            val lst2EvenOdd = lst2EvenOdd.filter(x => x._1 == x._2)\n       \
    \     val lst1OddEven = lst1OddEven.filter(x => x._1 == x._2)\n            val\
    \ lst2OddEven = lst2OddEven.filter(x => x._1 == x._2)\n            val lst1OddOdd\
    \ = lst1OddOdd.filter(x => x._1 == x._2)\n            val lst2OddOdd = lst2OddOdd.filter(x\
    \ => x._1 == x._2)\n            val lst1EvenEven = lst1EvenEven.filter(x => x._2\
    \ == x._1)\n            val lst2EvenEven = lst2EvenEven.filter(x => x._2 == x._1)\n\
    \            val lst1EvenOdd = lst1EvenOdd.filter(x => x._2 == x._1)\n       \
    \     \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpk7ppd2nl.scala:56:0 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk7ppd2nl.scala:32:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mlst1EvenEven\e[0m = lst1EvenEven.filter(\e[36mx\e[0m => x._1 == x._2)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlst1EvenEven is already defined as \e[33mvalue\e[0m \e[35mlst1EvenEven\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk7ppd2nl.scala:33:16 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m            \e[33mval\e[0m \e[36mlst2EvenEven\e[0m = lst2EvenEven.filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlst2EvenEven is already defined as \e[33mvalue\e[0m \e[35mlst2EvenEven\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk7ppd2nl.scala:34:16 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m            \e[33mval\e[0m \e[36mlst1EvenOdd\e[0m = lst1EvenOdd.filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlst1EvenOdd is already defined as \e[33mvalue\e[0m \e[35mlst1EvenOdd\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk7ppd2nl.scala:35:16 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m            \e[33mval\e[0m \e[36mlst2EvenOdd\e[0m = lst2EvenOdd.filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlst2EvenOdd is already defined as \e[33mvalue\e[0m \e[35m"
  stdout: ''
  timestamp: 1659794625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Copy = lst1.toList\n        val lst2Copy\
    \ = lst2.toList\n        val lst1Copy.sortWith(_ < _)\n        val lst2Copy.sortWith(_\
    \ < _)\n        val even = lst1Copy.filter(x => x % 2 == 0)\n        val odd =\
    \ lst2Copy.filter(x => x % 2 == 1)\n        val evenOdd = even.zip(odd)\n    \
    \    val evenOddList = evenOdd.toList\n        val evenOddList2 = evenOddList.map(x\
    \ => x._1 + x._2)\n        val evenOddList3 = evenOddList2.filter(x => x % 2 ==\
    \ 0)\n        val evenOddList4 = evenOddList3.filter(x => x % 2 == 1)\n      \
    \  val evenOddList5 = evenOddList4.map(x => x._1 + x._2)\n        val evenOddList6\
    \ = evenOddList5.filter(x => x % 2 == 0)\n        val evenOddList7 = evenOddList6.filter(x\
    \ => x % 2 == 1)\n        val evenOddList8 = evenOddList7.map(x => x._1 + x._2)\n\
    \        val evenOddList9 = evenOddList8.filter(x => x % 2 == 0)\n        val\
    \ evenOddList10 = evenOddList9.filter(x => x % 2 == 1)\n        val evenOddList11\
    \ = evenOddList10.map(x => x._1 + x._2)\n        val evenOddList12 = evenOddList11.filter(x\
    \ => x % 2 == 0)\n        val evenOddList13 = evenOddList12.filter(x => x % 2\
    \ == 1)\n        val evenOddList14 = evenOddList13.map(x => x._1 + x._2)\n   \
    \     val evenOddList15 = evenOddList14.filter(x => x % 2 == 0)\n        val evenOddList16\
    \ = evenOddList15.filter(x => x % 2 == 1)\n        val evenOddList17 = evenOddList16.map(x\
    \ => x._1 + x._2)\n        val evenOddList18 = evenOddList17.filter(x => x % 2\
    \ == 0)\n        val evenOddList19 = evenOddList18.filter(x => x % 2 == 1)\n \
    \       val evenOddList20 = evenOddList19.map(x => x._1 + x._2)\n        \n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdxbbihmr.scala:22:0 ----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m lst2Copy.sortWith(_ < _)\n\e[31m\e\
    [31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0m'=' expected, but 'end of statement' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdxbbihmr.scala:23:0 ----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36meven\e[0m = lst1Copy.filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m^^^\e[0m\n\
    \e[31m   |\e[0m'=' expected, but 'end of statement' found\n\e[31m\e[31m-- [E127]\
    \ Syntax Error: /tmp/tmpdxbbihmr.scala:21:12 ---------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m        \e[33mval\e[0m lst1Copy.sortWith(_ < _)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlst1Copy.sortWith\
    \ cannot be used as an extractor in a pattern because it lacks an unapply or unapplySeq\
    \ method\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdxbbihmr.scala:21:32\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m lst1Copy.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m  \
    \ |\e[0m                                Not found: <\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E127] Syntax Error: /tmp/tmpdxbbihmr.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m lst2Copy.sortWith(_ < _)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlst2Copy.sortWith\
    \ cannot be used as an extractor in a pattern because it lacks an unapply or unapplySeq\
    \ method\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdxbbihmr.scala:22:32\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m lst2Copy.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m  \
    \ |\e[0m                                Not found: <\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explan"
  stdout: ''
  timestamp: 1659794631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.intersect(odd)\n      \
    \  val evenAndOddNotEmpty = evenAndOdd.filter(x => x != 0).toList\n        if\
    \ (evenAndOddNotEmpty.isEmpty) {\n            \"NO\"\n        } else {\n     \
    \       \"YES\"\n        }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpin0hmlny.scala:29)\n\tat Problem.main(tmpin0hmlny.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794626
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val even = lst1.filter(x => x % 2 == 0).length\n\
    \        val odd = lst2.filter(x => x % 2 == 1).length\n        if (even > odd)\
    \ {\n            return \"NO\"\n        }\n        else {\n            return\
    \ \"YES\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxrsaa58w.scala:30)\n\tat Problem.main(tmpxrsaa58w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmy87r7wz.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m19 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794622
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).toList\n        val odd = lst2.filter(_ %\
    \ 2 == 1).toList\n        val evenOdd = even.zip(odd)\n        val evenOddList\
    \ = evenOdd.toList\n        val evenOddListLength = evenOddList.size\n       \
    \ val evenOddListLength = evenOddListLength.toInt\n        val evenOddListLength\
    \ = evenOddListLength.toInt\n        val evenOddListLength = evenOddListLength.toInt\n\
    \        val evenOddListLength = evenOddListLength.toInt\n        val evenOddListLength\
    \ = evenOddListLength.toInt\n        val evenOddListLength = evenOddListLength.toInt\n\
    \        val evenOddListLength = evenOddListLength.toInt\n        val evenOddListLength\
    \ = evenOddListLength.toInt\n        val evenOddListLength = evenOddListLength.toInt\n\
    \        val evenOddListLength = evenOddListLength.toInt\n        val evenOddListLength\
    \ = evenOddListLength.toInt\n        val evenOddListLength = evenOddListLength.toInt\n\
    \        val evenOddListLength = evenOddListLength.toInt\n        val evenOddListLength\
    \ = evenOddListLength.toInt\n        val evenOddListLength = evenOddListLength.toInt\n\
    \        val evenOddListLength = evenOddListLength.toInt\n        val evenOddListLength\
    \ = evenOddListLength.toInt\n        val evenOddListLength = evenOddListLength.toInt\n\
    \        val evenOddListLength = evenOddListLength.toInt\n        val evenOddListLength\
    \ = evenOddListLength.toInt\n        val evenOddListLength = evenOddListLength.toInt\n\
    \        val evenOddListLength = evenOddListLength.toInt\n        val evenOddListLength\
    \ = evenOddListLength.toInt\n        val evenOddListLength = evenOddListLength.toInt\n\
    \        val evenOddListLength = evenOddListLength.toInt\n        val evenOddListLength\
    \ = evenOddListLength.toInt\n        val evenOddListLength = evenOddListLength.toInt\n\
    \        val evenOddListLength = evenOddListLength.toInt\n        val evenOddListLength\
    \ = evenOddListLength.toInt\n        val evenOddListLength = evenOddList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1pwxxwlp.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mevenOddListLength\e[0m =\
    \ evenOddListLength.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenOddListLength is already defined as \e[33mvalue\e[0m \e\
    [35mevenOddListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1pwxxwlp.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mevenOddListLength\e[0m =\
    \ evenOddListLength.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenOddListLength is already defined as \e[33mvalue\e[0m \e\
    [35mevenOddListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1pwxxwlp.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mevenOddListLength\e[0m =\
    \ evenOddListLength.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenOddListLength is already defined as \e[33mvalue\e[0m \e\
    [35mevenOddListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1pwxxwlp.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mevenOddListLength\e[0m =\
    \ evenOddListLength.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenOddListLength is already defined as \e[33mvalue\e[0m \e\
    [35mevenOddListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1pwxxwlp.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mev"
  stdout: ''
  timestamp: 1659794624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).toList\n        val odd = lst2.filter(_ %\
    \ 2 == 1).toList\n        val exchanged = even.zip(odd).filter(_._1 == _._2).map(_._1).mkString(\"\
    ,\")\n        if (exchanged.isEmpty) \"NO\" else \"YES\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0aj4cayk.scala:20:47 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mexchanged\e[0m = even.zip(odd).filter(_._1\
    \ == _._2).map(_._1).mkString(\e[31m\",\"\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \                                      ^^^^\e[0m\n\e[31m   |\e[0m            \
    \                            value _1 is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.intersect(odd)\n      \
    \  val evenAndOddAndEven = evenAndOdd.intersect(even)\n        val evenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEven.intersect(odd)\n        val evenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOdd.intersect(even)\n        val evenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEven.intersect(odd)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOdd.intersect(even)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(odd)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(even)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd =\
    \ evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(odd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(even)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(odd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOdd\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwo_nd5td.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwo_nd5td.scala:27:71\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(even)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwo_nd5td.scala:29:84\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(even)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwo_nd5td.scala:30:90\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(odd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddAndEvenAndOddAn"
  stdout: ''
  timestamp: 1659794623
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: Write your code here\n        val even = lst1.filter(_ % 2 == 0).length\n\
    \        val odd = lst2.filter(_ % 2 == 1).length\n        if (even == odd) {\n\
    \            return \"YES\"\n        } else {\n            return \"NO\"\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpndorb6vb.scala:34)\n\tat Problem.main(tmpndorb6vb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenOdd = even.zip(odd).filter(x => x._1\
    \ == x._2)\n        val evenOddList = evenOdd.map(x => x._1)\n        val evenOddList2\
    \ = evenOdd.map(x => x._2)\n        val evenOddList3 = evenOdd.map(x => x._1)\n\
    \        val evenOddList4 = evenOdd.map(x => x._2)\n        val evenOddList5 =\
    \ evenOdd.map(x => x._1)\n        val evenOddList6 = evenOdd.map(x => x._2)\n\
    \        val evenOddList7 = evenOdd.map(x => x._1)\n        val evenOddList8 =\
    \ evenOdd.map(x => x._2)\n        val evenOddList9 = evenOdd.map(x => x._1)\n\
    \        val evenOddList10 = evenOdd.map(x => x._2)\n        val evenOddList11\
    \ = evenOdd.map(x => x._1)\n        val evenOddList12 = evenOdd.map(x => x._2)\n\
    \        val evenOddList13 = evenOdd.map(x => x._1)\n        val evenOddList14\
    \ = evenOdd.map(x => x._2)\n        val evenOddList15 = evenOdd.map(x => x._1)\n\
    \        val evenOddList16 = evenOdd.map(x => x._2)\n        val evenOddList17\
    \ = evenOdd.map(x => x._1)\n        val evenOddList18 = evenOdd.map(x => x._2)\n\
    \        val evenOddList19 = evenOdd.map(x => x._1)\n        val evenOddList20\
    \ = evenOdd.map(x => x._2)\n        val evenOddList21 = evenOdd.map(x => x._1)\n\
    \        val evenOddList22 = evenOdd.map(x => x._2)\n        val evenOddList23\
    \ = evenOdd.map(x => x._1)\n        val evenOddList24 = evenOdd.map(x => x._2)\n\
    \        val evenOddList25 = evenOdd.map(x => x.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1kv1lrm2.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp1kv1lrm2.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).length\n        val odd = lst2.filter(_ %\
    \ 2 == 1).length\n        if (even == odd) {\n            lst1.filter(_ % 2 ==\
    \ 0).map(x => x -> 2l.toLong).toList.map(x => x -> 2l.toLong).toList\n       \
    \ } else {\n            lst1.filter(_ % 2 == 0).map(x => x -> 2l.toLong).toList.map(x\
    \ => x -> 2l.toLong).toList\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplm0bf3h1.scala:21:93\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            lst1.filter(_ % \e\
    [31m2\e[0m == \e[31m0\e[0m).map(\e[36mx\e[0m => x -> \e[31m2l\e[0m.toLong).toList.map(\e\
    [36mx\e[0m => x -> \e[31m2l\e[0m.toLong).toList\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    List[((Long, Long), Long)]\n\e[31m \
    \  |\e[0m            Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmplm0bf3h1.scala:23:93 --------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m            lst1.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).map(\e\
    [36mx\e[0m => x -> \e[31m2l\e[0m.toLong).toList.map(\e[36mx\e[0m => x -> \e[31m2l\e\
    [0m.toLong).toList\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    List[((Long, Long), Long)]\n\e[31m \
    \  |\e[0m            Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenodd = even.zip(odd).filter(x => x._1\
    \ == x._2)\n        val eveneven = even.zip(even).filter(x => x._1 == x._2)\n\
    \        val evenevenodd = eveneven.zip(odd).filter(x => x._1 == x._2)\n     \
    \   val eveneveneven = eveneven.zip(eveneven).filter(x => x._1 == x._2)\n    \
    \    val evenevenevenodd = eveneveneven.zip(odd).filter(x => x._1 == x._2)\n \
    \       val eveneveneveneven = eveneveneven.zip(eveneven).filter(x => x._1 ==\
    \ x._2)\n        val evenevenevenevenodd = eveneveneveneven.zip(odd).filter(x\
    \ => x._1 == x._2)\n        val eveneveneveneveneven = eveneveneveneven.zip(eveneven).filter(x\
    \ => x._1 == x._2)\n        val evenevenevenevenevenodd = eveneveneveneveneven.zip(odd).filter(x\
    \ => x._1 == x._2)\n        val eveneveneveneveneveneven = eveneveneveneveneven.zip(eveneven).filter(x\
    \ => x._1 == x._2)\n        val evenevenevenevenevenevenodd = eveneveneveneveneven.zip(odd).filter(x\
    \ => x._1 == x._2)\n        val eveneveneveneveneveneveneven = eveneveneveneveneven.zip(eveneven).filter(x\
    \ => x._1 == x._2)\n        val evenevenevenevenevenevenevenodd = eveneveneveneveneveneven.zip(odd).filter(x\
    \ => x._1 == x._2)\n        val eveneveneveneveneveneveneveneven = eveneveneveneveneveneven.zip(eveneven).filter(x\
    \ => x._1 == x._2)\n        val evenevenevenevenevenevenevenevenodd = eveneveneveneveneveneven.zip(odd).filter(x\
    \ => x._1 == x._2)\n        val eveneveneveneveneveneveneveneveneven = eveneveneveneveneveneven.zip(eveneven).filter(x\
    \ => x._1 == x._2)\n        val evenevenevenevenevenevenevenevenevenodd = eveneveneveneveneveneven.zip(odd).filter(x\
    \ => x._1 == x._2)\n        val eveneveneveneveneveneveneveneveneveneven = eveneveneven\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp6ofunbas.scala:22:56 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mevenevenodd\e[0m = eveneven.zip(odd).filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m                           \
    \                             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  Values of types\
    \ (Long, Long) and Long cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp6ofunbas.scala:24:64 -----------------------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mevenevenevenodd\e[0m = eveneveneven.zip(odd).filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m                           \
    \                                     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues\
    \ of types ((Long, Long), (Long, Long)) and Long cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- Error: /tmp/tmp6ofunbas.scala:25:70 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36meveneveneveneven\e[0m =\
    \ eveneveneven.zip(eveneven).filter(\e[36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues of types ((Long, Long), (Long, Long))\
    \ and (Long, Long) cannot be compared with == or !=.\n\e[31m   |\e[0mI found:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m    Tuple.canEqualTuple[\e[35mH1\e[0m, \e[35mT1\e\
    [0m, \e[35mH2\e[0m, \e[35mT2\e[0m](/* missing */summon[CanEqual[H1, H2]], ???)\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type\
    \ CanEqual[H1, H2].\n\e[31m\e[31m-- Error: /tmp/tmp6ofunbas.scala:26:72 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mevenevenevenevenodd\e[0m\
    \ = eveneveneveneven.zip(odd).filter(\e[36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues of types (((Long, Long), (Long,\
    \ Long)), (Long, Long)) and Long cannot be compared with == or !=\n\e[31m\e[31m--\
    \ Error: /tmp/tmp6ofunbas.scala:27:78 -----------------------------------------\e\
    [0m\e[0"
  stdout: ''
  timestamp: 1659794630
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.intersect(odd)\n      \
    \  val evenAndOddAndEven = evenAndOdd.intersect(even)\n        val evenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEven.intersect(odd)\n        val evenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOdd.intersect(even)\n        val evenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEven.intersect(odd)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(even)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(odd)\n       \
    \ val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(even)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(odd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(even)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.inter\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_jqo9jz9.scala:25:58 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e\
    [0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(even)\n\e[31m\e[31m\
    \   |\e[0m                                                          ^\e[0m\n\e\
    [31m   |\e[0m  Recursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_jqo9jz9.scala:26:64\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(odd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \        ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_jqo9jz9.scala:27:71\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(even)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_jqo9jz9.scala:29:90\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(even)\n\
    \e[31m\e[31m   |\e[0m                                   "
  stdout: ''
  timestamp: 1659794641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.zip(odd)\n        val evenAndOdd2\
    \ = evenAndOdd.filter(x => x._1 == x._2)\n        val evenAndOdd3 = evenAndOdd2.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd4 = evenAndOdd3.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd5 = evenAndOdd4.filter(x => x._1 == x._2)\n   \
    \     val evenAndOdd6 = evenAndOdd5.filter(x => x._1 == x._2)\n        val evenAndOdd7\
    \ = evenAndOdd6.filter(x => x._1 == x._2)\n        val evenAndOdd8 = evenAndOdd7.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd9 = evenAndOdd8.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd10 = evenAndOdd9.filter(x => x._1 == x._2)\n  \
    \      val evenAndOdd11 = evenAndOdd10.filter(x => x._1 == x._2)\n        val\
    \ evenAndOdd12 = evenAndOdd11.filter(x => x._1 == x._2)\n        val evenAndOdd13\
    \ = evenAndOdd12.filter(x => x._1 == x._2)\n        val evenAndOdd14 = evenAndOdd13.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd15 = evenAndOdd14.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd16 = evenAndOdd15.filter(x => x._1 == x._2)\n \
    \       val evenAndOdd17 = evenAndOdd16.filter(x => x._1 == x._2)\n        val\
    \ evenAndOdd18 = evenAndOdd17.filter(x => x._1 == x._2)\n        val evenAndOdd19\
    \ = evenAndOdd18.filter(x => x._1 == x._2)\n        val evenAndOdd20 = evenAndOdd19.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd21 = evenAndOdd20.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd22 = evenAndOdd21.filter(x => x._\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6him3w31.scala:41:54 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mevenAndOdd22\e[0m = evenAndOdd21.filter(\e\
    [36mx\e[0m => x._\n\e[31m\e[31m   |\e[0m                                     \
    \                 ^\e[0m\n\e[31m   |\e[0m                                   an\
    \ identifier expected, but '_' found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp6him3w31.scala:42:5 ---------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659794641
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).length\n        val odd = lst2.filter(_ %\
    \ 2 == 1).length\n        if (even > odd) {\n            val lst3 = lst1.filter(_\
    \ % 2 == 0).take(even)\n            val lst4 = lst2.filter(_ % 2 == 1).take(odd)\n\
    \            exchange(lst3, lst4)\n        } else {\n            val lst3 = lst1.filter(_\
    \ % 2 == 0).take(odd)\n            val lst4 = lst2.filter(_ % 2 == 1).take(even)\n\
    \            exchange(lst3, lst4)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659794648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(x => x % 2 == 0)\n        val lst2Even = lst2.filter(x\
    \ => x % 2 == 0)\n        val lst1Odd = lst1.filter(x => x % 2 != 0)\n       \
    \ val lst2Odd = lst2.filter(x => x % 2 != 0)\n        val lst1EvenAndOdd = lst1Even.intersect(lst1Odd)\n\
    \        val lst2EvenAndOdd = lst2Even.intersect(lst2Odd)\n        val lst1EvenAndOddAndNotBoth\
    \ = lst1EvenAndOdd.filter(x => !lst2EvenAndOdd.contains(x))\n        val lst2EvenAndOddAndNotBoth\
    \ = lst2EvenAndOdd.filter(x => !lst1EvenAndOdd.contains(x))\n        val lst1EvenAndOddAndNotBothAndNotBoth\
    \ = lst1EvenAndOdd.filter(x => !lst2EvenAndOdd.contains(x) && !lst1EvenAndOdd.contains(x))\n\
    \        val lst2EvenAndOddAndNotBothAndNotBoth = lst2EvenAndOdd.filter(x => !lst1EvenAndOdd.contains(x)\
    \ && !lst2EvenAndOdd.contains(x))\n        val lst1EvenAndOddAndNotBothAndNotBothAndNotBoth\
    \ = lst1EvenAndOdd.filter(x => !lst2EvenAndOdd.contains(x) && !lst1EvenAndOdd.contains(x)\
    \ && !lst2EvenAndOdd.contains(x))\n        val lst2EvenAndOddAndNotBothAndNotBothAndNotBoth\
    \ = lst2EvenAndOdd.filter(x => !lst1EvenAndOdd.contains(x) && !lst2EvenAndOdd.contains(x)\
    \ && !lst1EvenAndOdd.contains(x))\n        val lst1EvenAndOddAndNotBothAndNotBothAndNotBothAndNotBoth\
    \ = lst1EvenAndOdd.filter(x => !lst2EvenAndOdd.contains(x) && !lst1EvenAndOdd.contains(x)\
    \ && !lst2EvenAndOdd.contains(x) && !lst1EvenAndOdd.contains(x))\n        val\
    \ lst2EvenAndOddAndNotBothAndNotBothAndNotBothAndNotBoth = lst2EvenAndOdd.filter(x\
    \ => !lst1EvenAndOdd.contains(x) && !lst2EvenAndOdd.contains(x) && !\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj4hr8_a1.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj4hr8_a1.scala:31:158\
    \ -----------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mlst2EvenAndOddAndNotBothAndNotBothAndNotBothAndNotBoth\e[0m = lst2EvenAndOdd.filter(\e\
    [36mx\e[0m => !lst1EvenAndOdd.contains(x) && !lst2EvenAndOdd.contains(x) && !\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \                                 Not found: !\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpj4hr8_a1.scala:32:5 ---------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659794643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.intersect(odd)\n      \
    \  val evenAndOddAndEven = evenAndOdd.intersect(even)\n        if (evenAndOddAndEven.isEmpty)\
    \ \"YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc6o1b0yz.scala:26)\n\tat Problem.main(tmpc6o1b0yz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794646
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.zip(odd)\n        val evenAndOddList\
    \ = evenAndOdd.toList\n        val evenAndOddListLength = evenAndOddList.length\n\
    \        val evenAndOddListLength = evenAndOddList.length\n        val evenAndOddListLength\
    \ = evenAndOddList.length\n        val evenAndOddListLength = evenAndOddList.length\n\
    \        val evenAndOddListLength = evenAndOddList.length\n        val evenAndOddListLength\
    \ = evenAndOddList.length\n        val evenAndOddListLength = evenAndOddList.length\n\
    \        val evenAndOddListLength = evenAndOddList.length\n        val evenAndOddListLength\
    \ = evenAndOddList.length\n        val evenAndOddListLength = evenAndOddList.length\n\
    \        val evenAndOddListLength = evenAndOddList.length\n        val evenAndOddListLength\
    \ = evenAndOddList.length\n        val evenAndOddListLength = evenAndOddList.length\n\
    \        val evenAndOddListLength = evenAndOddList.length\n        val evenAndOddListLength\
    \ = evenAndOddList.length\n        val evenAndOddListLength = evenAndOddList.length\n\
    \        val evenAndOddListLength = evenAndOddList.length\n        val evenAndOddListLength\
    \ = evenAndOddList.length\n        val evenAndOddListLength = evenAndOddList.length\n\
    \        val evenAndOddListLength = evenAndOddList.length\n        val evenAndOddListLength\
    \ = evenAndOddList.length\n        val evenAndOddListLength = evenAndOddList.length\n\
    \        val evenAndOddListLength = evenAndOddList.length\n        val evenAndOddListLength\
    \ = evenAndOddList.length\n        val evenAndOddListLength = evenAndOddList.length\n\
    \        val evenAndOddListLength = evenAndOddList.length\n        val evenAndOddListLength\
    \ = evenAndOddList.length\n        val evenAndOddListLength = evenAndOddList.length\n\
    \        val evenAndOddListLength = evenAndOddList.length\n        val evenAndOddListLength\
    \ = evenAndOddList.length\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp888g4wmp.scala:52:11 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp888g4wmp.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddListLength\e[0m\
    \ = evenAndOddList.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenAndOddListLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mevenAndOddListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp888g4wmp.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddListLength\e[0m\
    \ = evenAndOddList.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenAndOddListLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mevenAndOddListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp888g4wmp.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddListLength\e[0m\
    \ = evenAndOddList.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenAndOddListLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mevenAndOddListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp888g4wmp.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddListLength\e[0m\
    \ = evenAndOddList.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenAndOddListLe"
  stdout: ''
  timestamp: 1659794644
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n        val lst3 = lst1.toSet\n        val lst4 = lst2.toSet\n\
    \        val lst5 = lst3.intersect(lst4)\n        val lst6 = lst5.toList\n   \
    \     if(lst6.forall(x => x % 2 == 0)){\n            return \"YES\"\n        }\n\
    \        else{\n            return \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu2vupxhx.scala:31)\n\tat Problem.main(tmpu2vupxhx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794646
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n        val lst1Even = lst1.filter(_ % 2 == 0)\n   \
    \     val lst2Even = lst2.filter(_ % 2 == 0)\n        val lst1Odd = lst1.filter(_\
    \ % 2 != 0)\n        val lst2Odd = lst2.filter(_ % 2 != 0)\n        val lst1EvenAndOdd\
    \ = lst1Even.intersect(lst2Odd)\n        val lst2EvenAndOdd = lst2Even.intersect(lst1Odd)\n\
    \        val lst1EvenAndOddAndEven = lst1EvenAndOdd.intersect(lst2EvenAndOdd)\n\
    \        val lst2EvenAndOddAndEven = lst2EvenAndOdd.intersect(lst1EvenAndOdd)\n\
    \        if(lst1EvenAndOddAndEven.isEmpty){\n            \"NO\"\n        }\n \
    \       else{\n            \"YES\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7cvgtj12.scala:35)\n\tat Problem.main(tmp7cvgtj12.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794646
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst3 = lst1.toList\n        val lst4 = lst2.toList\n\
    \        val lst5 = lst3.filter(_%2==0)\n        val lst6 = lst4.filter(_%2==0)\n\
    \        val lst7 = lst5.zip(lst6).filter(_._1==_._2).map(_._1)\n        if(lst7.isEmpty){\n\
    \            \"NO\"\n        }\n        else{\n            \"YES\"\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgy7y29_v.scala:23:43 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mlst7\e[0m = lst5.zip(lst6).filter(_._1==_._2).map(_._1)\n\
    \e[31m\e[31m   |\e[0m                                         ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                        value _1 is not a member of\
    \ Long\n1 error found\n"
  stdout: ''
  timestamp: 1659794643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).length\n        val odd = lst2.filter(_ %\
    \ 2 == 1).length\n        if (even == odd) {\n            lst1.filter(_ % 2 ==\
    \ 0).map(x => x -> lst2.filter(_ % 2 == 1).map(y => y -> x)).toList.map(x => x._1\
    \ -> x._2._1).mkString(\",\")\n        } else {\n            \"NO\"\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp13li6hy7.scala:21:121 -----------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            lst1.filter(_ % \e[31m2\e[0m == \e[31m0\e\
    [0m).map(\e[36mx\e[0m => x -> lst2.filter(_ % \e[31m2\e[0m == \e[31m1\e[0m).map(\e\
    [36my\e[0m => y -> x)).toList.map(\e[36mx\e[0m => x._1 -> x._2._1).mkString(\e\
    [31m\",\"\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \                                                                            \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                          value _1 is not a member\
    \ of List[(Long, Long)]\n1 error found\n"
  stdout: ''
  timestamp: 1659794644
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.zip(odd)\n        val evenAndOdd2\
    \ = evenAndOdd.filter(x => x._1 == x._2)\n        val evenAndOdd3 = evenAndOdd2.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd4 = evenAndOdd3.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd5 = evenAndOdd4.filter(x => x._1 == x._2)\n   \
    \     val evenAndOdd6 = evenAndOdd5.filter(x => x._1 == x._2)\n        val evenAndOdd7\
    \ = evenAndOdd6.filter(x => x._1 == x._2)\n        val evenAndOdd8 = evenAndOdd7.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd9 = evenAndOdd8.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd10 = evenAndOdd9.filter(x => x._1 == x._2)\n  \
    \      val evenAndOdd11 = evenAndOdd10.filter(x => x._1 == x._2)\n        val\
    \ evenAndOdd12 = evenAndOdd11.filter(x => x._1 == x._2)\n        val evenAndOdd13\
    \ = evenAndOdd12.filter(x => x._1 == x._2)\n        val evenAndOdd14 = evenAndOdd13.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd15 = evenAndOdd14.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd16 = evenAndOdd15.filter(x => x._1 == x._2)\n \
    \       val evenAndOdd17 = evenAndOdd16.filter(x => x._1 == x._2)\n        val\
    \ evenAndOdd18 = evenAndOdd17.filter(x => x._1 == x._2)\n        val evenAndOdd19\
    \ = evenAndOdd18.filter(x => x._1 == x._2)\n        val evenAndOdd20 = evenAndOdd19.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd21 = evenAndOdd20.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd22 = evenAndOdd21.filter(x => x._\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6him3w31.scala:41:54 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mevenAndOdd22\e[0m = evenAndOdd21.filter(\e\
    [36mx\e[0m => x._\n\e[31m\e[31m   |\e[0m                                     \
    \                 ^\e[0m\n\e[31m   |\e[0m                                   an\
    \ identifier expected, but '_' found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp6him3w31.scala:42:5 ---------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659794641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst3 = lst1.toSet\n        val lst4 = lst2.toSet\n        val lst5 = lst3.intersect(lst4)\n\
    \        val lst6 = lst5.toList\n        val lst7 = lst6.filter(_ % 2 == 0)\n\
    \        val lst8 = lst1.filter(_ % 2 == 0)\n        val lst9 = lst2.filter(_\
    \ % 2 == 0)\n        val lst10 = lst3.filter(_ % 2 == 0)\n        val lst11 =\
    \ lst4.filter(_ % 2 == 0)\n        val lst12 = lst5.filter(_ % 2 == 0)\n     \
    \   val lst13 = lst6.filter(_ % 2 == 0)\n        val lst14 = lst7.filter(_ % 2\
    \ == 0)\n        val lst15 = lst8.filter(_ % 2 == 0)\n        val lst16 = lst9.filter(_\
    \ % 2 == 0)\n        val lst17 = lst10.filter(_ % 2 == 0)\n        val lst18 =\
    \ lst11.filter(_ % 2 == 0)\n        val lst19 = lst12.filter(_ % 2 == 0)\n   \
    \     val lst20 = lst13.filter(_ % 2 == 0)\n        val lst21 = lst14.filter(_\
    \ % 2 == 0)\n        val lst22 = lst15.filter(_ % 2 == 0)\n        val lst23 =\
    \ lst16.filter(_ % 2 == 0)\n        val lst24 = lst17.filter(_ % 2 == 0)\n   \
    \     val lst25 = lst18.filter(_ % 2 == 0)\n        val lst26 = lst19.filter(_\
    \ % 2 == 0)\n        val lst27 = lst20.filter(_ % 2 == 0)\n        val lst28 =\
    \ lst21.filter(_ % 2 == 0)\n        val lst29 = lst22.filter(_ % 2 == 0)\n   \
    \     val lst30 = lst23.filter(_ % 2 == 0)\n        val lst31 = lst24.filter(_\
    \ % 2 == 0)\n        val lst32 = lst25.filter(_ % 2 == 0)\n        val lst33 =\
    \ lst26.filter(_ % 2 == 0)\n        val lst34 = lst27.filter(_ % 2 == 0)\n   \
    \     val lst35 = lst28.filter(_ % 2 == 0)\n        val lst36 = lst29.filter(_\
    \ % 2 == 0)\n        val lst37 = lst30.filter(_ % 2 == 0)\n        val lst38 =\
    \ lst31.filter(_ % 2 == 0)\n        val lst39 = lst32.filter(_ % 2 == 0)\n   \
    \     val lst40 = lst33.filter(_ % 2 == 0)\n        val lst41 = lst34.filter(_\
    \ % 2 == 0)\n        val lst42 = lst35.filter(_ % 2 == 0)\n        val lst43 =\
    \ lst36.filter(_ % 2 == \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpbpiir44b.scala:58:41 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \e[36mlst43\e[0m = lst36.filter(_\
    \ % \e[31m2\e[0m == \n\e[31m\e[31m   |\e[0m                                  \
    \       ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpbpiir44b.scala:59:5 ---------------------\e[0m\e[0m\n\e[31m59\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794645
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).length\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).length\n        if (even > odd) {\n            return \"NO\"\n\
    \        }\n        else {\n            return \"YES\"\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8z7h03_e.scala:29)\n\tat Problem.main(tmp8z7h03_e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794646
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even ++ odd\n        val evenAndOddSet\
    \ = evenAndOdd.toSet\n        if (evenAndOddSet.size == lst1.size) {\n       \
    \     return \"YES\"\n        } else {\n            return \"NO\"\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkw03idkx.scala:32)\n\tat Problem.main(tmpkw03idkx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794647
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Even = lst1.filter(x => x % 2 == 0).map(x\
    \ => x.toLong)\n        val lst2Even = lst2.filter(x => x % 2 == 0).map(x => x.toLong)\n\
    \        val lst1Odd = lst1.filter(x => x % 2 != 0).map(x => x.toLong)\n     \
    \   val lst2Odd = lst2.filter(x => x % 2 != 0).map(x => x.toLong)\n        val\
    \ lst1EvenOdd = lst1Even.zip(lst2Even).filter(x => x._1 == x._2).map(x => x._1)\n\
    \        val lst2EvenOdd = lst2Even.zip(lst1Even).filter(x => x._1 == x._2).map(x\
    \ => x._1)\n        val lst1EvenOddOdd = lst1EvenOdd.zip(lst2EvenOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val lst2EvenOddOdd = lst2EvenOdd.zip(lst1EvenOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val lst1EvenOddOddOdd = lst1EvenOddOdd.zip(lst2EvenOddOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val lst2EvenOddOddOdd = lst2EvenOddOdd.zip(lst1EvenOddOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val lst1EvenOddOddOddOdd = lst1EvenOddOddOdd.zip(lst2EvenOddOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val lst2EvenOddOddOddOdd = lst2EvenOddOddOdd.zip(lst1EvenOddOddOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val lst1EvenOddOddOddOddOdd = lst1EvenOddOddOddOdd.zip(lst2EvenOddOddOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val lst2EvenOddOddOddOddOdd = lst2EvenOddO\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcezl48si.scala:32:38 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlst2EvenOddOddOddOddOdd\e\
    [0m = lst2EvenOddO\n\e[31m\e[31m   |\e[0m                                    \
    \  ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                      Not\
    \ found: lst2EvenOddO\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcezl48si.scala:33:5\
    \ ---------------------\e[0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794646
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst3 = lst1.filter(_ % 2 == 0).filter(_ != lst2.last)\n\
    \        val lst4 = lst2.filter(_ % 2 == 0).filter(_ != lst1.last)\n        if(lst3.size\
    \ == lst4.size){\n            val lst5 = lst3.zip(lst4).filter(_._1 == _._2)\n\
    \            if(lst5.size == lst1.size){\n                val lst6 = lst5.map(x\
    \ => x._1)\n                val lst7 = lst5.map(x => x._2)\n                val\
    \ lst8 = lst1.filter(_ % 2 == 0).filter(_ != x.last)\n                if(lst6.size\
    \ == lst8.size){\n                    val lst9 = lst6.zip(lst8).filter(_._1 ==\
    \ _._2)\n                    if(lst9.size == lst1.size){\n                   \
    \     val lst10 = lst9.map(x => x._1)\n                        val lst11 = lst9.map(x\
    \ => x._2)\n                        if(lst10.size == lst11.size){\n          \
    \                  val lst12 = lst10.zip(lst11).filter(_._1 == _._2)\n       \
    \                     if(lst12.size == lst1.size){\n                         \
    \       val lst13 = lst12.map(x => x._1)\n                                val\
    \ lst14 = lst12.map(x => x._2)\n                                if(lst13.size\
    \ == lst14.size){\n                                    val lst15 = lst13.zip(lst14).filter(_._1\
    \ == _._2)\n                                    if(lst15.size == lst1.size){\n\
    \                                        val lst16 = lst15.map(x => x._1)\n  \
    \                                      val lst17 = lst15.map(x => x._2)\n    \
    \                                    if(lst16.size == lst17.size){\n         \
    \                                   val lst18 = lst16.zip(lst17).filter(_._1 ==\
    \ _._2)\n                                            if(lst18.size == lst1.size){\n\
    \                                                val lst19 = lst18.map(x => x._1)\n\
    \                                                val lst20 = lst18.map(x => x._2)\n\
    \                                                if(lst19.size == lst20.size){\n\
    \                                                    val lst21 = lst19.zip(lst20).filter(_._1\
    \ == _._2)\n                                                    if(lst21.size\
    \ == lst1.size){\n                                                        val\
    \ lst22 = lst21.map(x => x._1)\n                                             \
    \           val lst23 = lst21.map(x => x._2)\n                               \
    \                         if(lst22.size == lst23.size){\n                    \
    \                                        val lst24 = lst22.zip(lst23).filter(_._1\
    \ == _._2)\n                                                            if(lst24.size\
    \ == lst1.size){\n                                                           \
    \     val lst25 = lst24.map(x => x._1)\n                                     \
    \                           val lst26 = lst\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj7djnuaf.scala:69:0 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj7djnuaf.scala:22:47\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m\
    \ \e[36mlst5\e[0m = lst3.zip(lst4).filter(_._1 == _._2)\n\e[31m\e[31m   |\e[0m\
    \                                             ^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                   value _1 is not a member of Long\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpj7djnuaf.scala:26:63 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mval\e[0m \e[36mlst8\e[0m = lst1.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).filter(_ != x.last)\n\e[31m\e[31m   |\e[0m \
    \                                                              ^\e[0m\n\e[31m\
    \   |\e[0m                                                            Not found:\
    \ x\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj7djnuaf.scala:28:55\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                    \e[33mval\e\
    [0m \e[36mlst9\e[0m = lst6.zip(lst8).filter(_._1 == _._2)\n\e[31m\e[31m   |\e\
    [0m                                                     ^^^^\e[0m\n\e[31m   |\e\
    [0m                                        value _1 is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpj7djnuaf.scala:33:66 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                            \e[33mval\e[0m \e[36mlst12\e\
    [0m = lst10.zip(lst11).filter(_._1 == _._2)\n\e[31m\e[31m   |\e[0m           \
    \                                                     ^^^^\e[0m\n\e[31m   |\e\
    [0m                                        value _1 is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpj7djnuaf.scala:38:74 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                                    \e[33mval\e[0m \e\
    [36mlst15\e[0m = lst13.zip(lst14).filter(_._1 == _._2)\n\e[31m\e[31m   |\e[0m\
    \                                                             "
  stdout: ''
  timestamp: 1659794648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).toList\n        val odd = lst2.filter(_ %\
    \ 2 == 0).toList\n        val exchanged = even.zip(odd).filter(_._1 == _._2).map(_._1).toList\n\
    \        if(exchanged.size == lst1.size) \n            \"YES\" \n        else\
    \ \n            \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp15shex5n.scala:20:47 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mexchanged\e[0m = even.zip(odd).filter(_._1\
    \ == _._2).map(_._1).toList\n\e[31m\e[31m   |\e[0m                           \
    \                  ^^^^\e[0m\n\e[31m   |\e[0m                                \
    \        value _1 is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659794646
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val evens = lst1.filter(x => x % 2 == 0).toList\n        val odds = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evensAndOdds = evens.union(odds)\n      \
    \  val evensAndOddsSet = evensAndOdds.toSet\n        val evensAndOddsSetSize =\
    \ evensAndOddsSet.size\n        val evensAndOddsSetIsEven = evensAndOddsSet.forall(x\
    \ => x % 2 == 0)\n        val evensAndOddsSetIsOdd = evensAndOddsSet.forall(x\
    \ => x % 2 == 1)\n        if (evensAndOddsSetSize == evensAndOddsSetIsEven &&\
    \ evensAndOddsSetSize == evensAndOddsSetIsOdd) {\n            return \"YES\"\n\
    \        } else {\n            return \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpveluuqi8.scala:25:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mif\e[0m (evensAndOddsSetSize == evensAndOddsSetIsEven\
    \ && evensAndOddsSetSize == evensAndOddsSetIsOdd) {\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \       Values of types Int and Boolean cannot be compared with == or !=\n\e[31m\e\
    [31m-- Error: /tmp/tmpveluuqi8.scala:25:60 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mif\e[0m (evensAndOddsSetSize == evensAndOddsSetIsEven\
    \ && evensAndOddsSetSize == evensAndOddsSetIsOdd) {\n\e[31m\e[31m   |\e[0m   \
    \                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Int and Boolean cannot be compared\
    \ with == or !=\n2 errors found\n"
  stdout: ''
  timestamp: 1659794646
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst3 = lst1.toSet ++ lst2.toSet\n        if (lst3.size == lst1.size + lst2.size)\
    \ {\n            val lst4 = lst3.toList\n            val lst5 = lst4.sortWith(_\
    \ < _)\n            val lst6 = lst5.take(lst4.size - lst5.size)\n            val\
    \ lst7 = lst6.takeWhile(_ % 2 == 0)\n            val lst8 = lst7.takeWhile(_ <\
    \ lst5.size)\n            val lst9 = lst8.takeWhile(_ < lst4.size)\n         \
    \   val lst10 = lst9.takeWhile(_ < lst3.size)\n            val lst11 = lst10.takeWhile(_\
    \ < lst2.size)\n            val lst12 = lst11.takeWhile(_ < lst1.size)\n     \
    \       val lst13 = lst12.takeWhile(_ < lst3.size)\n            val lst14 = lst13.takeWhile(_\
    \ < lst2.size)\n            val lst15 = lst14.takeWhile(_ < lst1.size)\n     \
    \       val lst16 = lst15.takeWhile(_ < lst3.size)\n            val lst17 = lst16.takeWhile(_\
    \ < lst2.size)\n            val lst18 = lst17.takeWhile(_ < lst1.size)\n     \
    \       val lst19 = lst18.takeWhile(_ < lst3.size)\n            val lst20 = lst19.takeWhile(_\
    \ < lst2.size)\n            val lst21 = lst20.takeWhile(_ < lst1.size)\n     \
    \       val lst22 = lst21.takeWhile(_ < lst3.size)\n            val lst23 = lst22.takeWhile(_\
    \ < lst2.size)\n            val lst24 = lst23.takeWhile(_ < lst1.size)\n     \
    \       val lst25 = lst24.takeWhile(_ < lst3.size)\n            val lst26 = lst25.takeWhile(_\
    \ < lst2.size)\n            val lst27 = lst26.takeWhile(_ < lst1.size)\n     \
    \       val lst28 = lst27.takeWhile(_ < lst3.size)\n            val lst29 = lst28.takeWhile(_\
    \ < lst2.size)\n            val lst30 = lst29.takeWhile(_ < lst1.size)\n     \
    \       val lst31 = lst30.takeWhile(_ < lst3.size)\n            val lst32 = lst31.takeWhile(_\
    \ < lst2.size)\n            val lst33 = lst32.takeWhile(_ < lst1.size)\n     \
    \       val lst34 = lst33.takeWhile(_ < lst3.size)\n            val lst35 = lst34.takeWhile(_\
    \ < lst2.size)\n            val lst36 = lst35.takeWhile(_ < lst1.size)\n     \
    \       val lst37 = lst36.\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpufkdjwiy.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpufkdjwiy.scala:66:0 ----------------------------\e[0m\e[0m\n\e[31m66\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpufkdjwiy.scala:65:1 ---------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpufkdjwiy.scala:55:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m55 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659794647
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(x => x % 2 == 0).toList\n        val lst2Even = lst2.filter(x\
    \ => x % 2 == 0).toList\n        val lst1Odd = lst1.filter(x => x % 2 != 0).toList\n\
    \        val lst2Odd = lst2.filter(x => x % 2 != 0).toList\n        val lst1EvenAndOdd\
    \ = lst1Even.intersect(lst2Odd)\n        val lst2EvenAndOdd = lst2Even.intersect(lst1Odd)\n\
    \        val lst1EvenAndOddAndNotBoth = lst1EvenAndOdd.filter(x => !lst2EvenAndOdd.contains(x))\n\
    \        val lst2EvenAndOddAndNotBoth = lst2EvenAndOdd.filter(x => !lst1EvenAndOdd.contains(x))\n\
    \        val lst1EvenAndOddAndNotBothAndNotBoth = lst1EvenAndOddAndNotBoth.filter(x\
    \ => !lst2EvenAndOddAndNotBoth.contains(x))\n        val lst2EvenAndOddAndNotBothAndNotBoth\
    \ = lst2EvenAndOddAndNotBoth.filter(x => !lst1EvenAndOddAndNotBoth.contains(x))\n\
    \        if (lst1EvenAndOddAndNotBothAndNotBoth.isEmpty) {\n            \"YES\"\
    \n        } else if (lst2EvenAndOddAndNotBothAndNotBoth.isEmpty) {\n         \
    \   \"NO\"\n        } else {\n            exchange(lst1EvenAndOddAndNotBothAndNotBoth,\
    \ lst2EvenAndOddAndNotBothAndNotBoth)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1h1c27xg.scala:38)\n\tat Problem.main(tmp1h1c27xg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794649
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(x => x % 2 == 0)\n        val lst2Even = lst2.filter(x\
    \ => x % 2 == 0)\n        val lst1Odd = lst1.filter(x => x % 2 != 0)\n       \
    \ val lst2Odd = lst2.filter(x => x % 2 != 0)\n        val lst1EvenAndOdd = lst1Even.intersect(lst2Odd)\n\
    \        val lst2EvenAndOdd = lst2Even.intersect(lst1Odd)\n        val lst1EvenAndOddAndEven\
    \ = lst1EvenAndOdd.intersect(lst2EvenAndOdd)\n        val lst2EvenAndOddAndEven\
    \ = lst2EvenAndOdd.intersect(lst1EvenAndOdd)\n        val lst1EvenAndOddAndEvenAndOdd\
    \ = lst1EvenAndOddAndEven.intersect(lst2EvenAndOddAndEven)\n        val lst2EvenAndOddAndEvenAndOdd\
    \ = lst2EvenAndOddAndEven.intersect(lst1EvenAndOddAndEven)\n        val lst1EvenAndOddAndEvenAndOddAndEven\
    \ = lst1EvenAndOddAndEvenAndOdd.intersect(lst2EvenAndOddAndEvenAndOdd)\n     \
    \   val lst2EvenAndOddAndEvenAndOddAndEven = lst2EvenAndOddAndEvenAndOdd.intersect(lst1EvenAndOddAndEvenAndOdd)\n\
    \        val lst1EvenAndOddAndEvenAndOddAndEvenAndOdd = lst1EvenAndOddAndEvenAndOddAndEven.intersect(lst2EvenAndOddAndEvenAndOddAndEven)\n\
    \        val lst2EvenAndOddAndEvenAndOddAndEvenAndOdd = lst2EvenAndOddAndEvenAndOddAndEven.intersect(lst1EvenAndOddAndEvenAndOddAndEven)\n\
    \        val lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEven = lst1EvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(lst2EvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val lst2EvenAndOddAndEvenAndOddAndEvenAndOddAndEven = \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxyul3dar.scala:33:61 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mlst2EvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \             ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpxyul3dar.scala:34:5 ---------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794647
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(x => x % 2 == 0).toList\n        val lst2Even = lst2.filter(x\
    \ => x % 2 == 0).toList\n        val lst1Odd = lst1.filter(x => x % 2 != 0).toList\n\
    \        val lst2Odd = lst2.filter(x => x % 2 != 0).toList\n        val lst1EvenAndOdd\
    \ = lst1Even.zip(lst1Odd).filter(x => x._2 == x._1).map(x => x._1)\n        val\
    \ lst2EvenAndOdd = lst2Even.zip(lst2Odd).filter(x => x._2 == x._1).map(x => x._1)\n\
    \        val lst1EvenAndOddAndLst2EvenAndOdd = lst1EvenAndOdd.zip(lst2EvenAndOdd).filter(x\
    \ => x._2 == x._1).map(x => x._1)\n        val lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd\
    \ = lst1EvenAndOddAndLst2EvenAndOdd.zip(lst2EvenAndOddAndLst2EvenAndOdd).filter(x\
    \ => x._2 == x._1).map(x => x._1)\n        val lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd\
    \ = lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd.zip(lst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd).filter(x\
    \ => x._2 == x._1).map(x => x._1)\n        val lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd\
    \ = lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd.zip(lst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd).filter(x\
    \ => x._2 == x._1).map(x => x._1)\n        val lst1EvenAndOddAndLst2EvenAnd\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcj09a2ix.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcj09a2ix.scala:25:99\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mlst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd\e[0m = lst1EvenAndOddAndLst2EvenAndOdd.zip(lst2EvenAndOddAndLst2EvenAndOdd).filter(\e\
    [36mx\e[0m => x._2 == x._1).map(\e[36mx\e[0m => x._1)\n\e[31m\e[31m   |\e[0m \
    \                                                                            \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                             Not found: lst2EvenAndOddAndLst2EvenAndOdd\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcj09a2ix.scala:26:133 -----------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mlst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd\e\
    [0m = lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd.zip(lst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd).filter(\e\
    [36mx\e[0m => x._2 == x._1).map(\e[36mx\e[0m => x._1)\n\e[31m\e[31m   |\e[0m \
    \                                                                            \
    \                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Not found: lst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcj09a2ix.scala:27:97\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd\e\
    [0m = lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd.zip(lst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd).filter(\e\
    [36mx\e[0m => x._2 == x._1).map(\e[36mx\e[0m => x._1)\n\e["
  stdout: ''
  timestamp: 1659794648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenOdd = even.zip(odd).filter(x => x._1\
    \ == x._2)\n        val evenOddList = evenOdd.map(x => x._1)\n        val evenOddList2\
    \ = evenOdd.map(x => x._2)\n        val evenOddList3 = evenOdd.map(x => x._1)\n\
    \        val evenOddList4 = evenOdd.map(x => x._2)\n        val evenOddList5 =\
    \ evenOdd.map(x => x._1)\n        val evenOddList6 = evenOdd.map(x => x._2)\n\
    \        val evenOddList7 = evenOdd.map(x => x._1)\n        val evenOddList8 =\
    \ evenOdd.map(x => x._2)\n        val evenOddList9 = evenOdd.map(x => x._1)\n\
    \        val evenOddList10 = evenOdd.map(x => x._2)\n        val evenOddList11\
    \ = evenOdd.map(x => x._1)\n        val evenOddList12 = evenOdd.map(x => x._2)\n\
    \        val evenOddList13 = evenOdd.map(x => x._1)\n        val evenOddList14\
    \ = evenOdd.map(x => x._2)\n        val evenOddList15 = evenOdd.map(x => x._1)\n\
    \        val evenOddList16 = evenOdd.map(x => x._2)\n        val evenOddList17\
    \ = evenOdd.map(x => x._1)\n        val evenOddList18 = evenOdd.map(x => x._2)\n\
    \        val evenOddList19 = evenOdd.map(x => x._1)\n        val evenOddList20\
    \ = evenOdd.map(x => x._2)\n        val evenOddList21 = evenOdd.map(x => x._1)\n\
    \        val evenOddList22 = evenOdd.map(x => x._2)\n        val evenOddList23\
    \ = evenOdd.map(x => x._1)\n        val evenOddList24 = evenOdd.map(x => x._2)\n\
    \        val evenOddList25 = evenOdd.map(x => x.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1kv1lrm2.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp1kv1lrm2.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.zip(odd)\n        val evenAndOdd2\
    \ = evenAndOdd.filter(x => x._1 == x._2)\n        val evenAndOdd3 = evenAndOdd2.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd4 = evenAndOdd3.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd5 = evenAndOdd4.filter(x => x._1 == x._2)\n   \
    \     val evenAndOdd6 = evenAndOdd5.filter(x => x._1 == x._2)\n        val evenAndOdd7\
    \ = evenAndOdd6.filter(x => x._1 == x._2)\n        val evenAndOdd8 = evenAndOdd7.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd9 = evenAndOdd8.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd10 = evenAndOdd9.filter(x => x._1 == x._2)\n  \
    \      val evenAndOdd11 = evenAndOdd10.filter(x => x._1 == x._2)\n        val\
    \ evenAndOdd12 = evenAndOdd11.filter(x => x._1 == x._2)\n        val evenAndOdd13\
    \ = evenAndOdd12.filter(x => x._1 == x._2)\n        val evenAndOdd14 = evenAndOdd13.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd15 = evenAndOdd14.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd16 = evenAndOdd15.filter(x => x._1 == x._2)\n \
    \       val evenAndOdd17 = evenAndOdd16.filter(x => x._1 == x._2)\n        val\
    \ evenAndOdd18 = evenAndOdd17.filter(x => x._1 == x._2)\n        val evenAndOdd19\
    \ = evenAndOdd18.filter(x => x._1 == x._2)\n        val evenAndOdd20 = evenAndOdd19.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd21 = evenAndOdd20.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd22 = evenAndOdd21.filter(x => x._\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6him3w31.scala:41:54 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mevenAndOdd22\e[0m = evenAndOdd21.filter(\e\
    [36mx\e[0m => x._\n\e[31m\e[31m   |\e[0m                                     \
    \                 ^\e[0m\n\e[31m   |\e[0m                                   an\
    \ identifier expected, but '_' found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp6him3w31.scala:42:5 ---------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659794641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst3 = lst1.zip(lst2).filter(_._1 % 2 == 0).map(_._2)\n        if (lst3.isEmpty)\
    \ \"\"\n        else lst3.head == lst3.last ? \"YES\" : \"NO\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph1ot4a4f.scala:20:36 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m lst3.head == lst3.last ? \e[31m\"\
    YES\"\e[0m : \e[31m\"NO\"\e[0m\n\e[31m\e[31m   |\e[0m                        \
    \  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          value ? is not a\
    \ member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659794651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmy87r7wz.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m19 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794622
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(x => x % 2 == 0)\n        val lst2Even = lst2.filter(x\
    \ => x % 2 == 0)\n        val lst1Odd = lst1.filter(x => x % 2 != 0)\n       \
    \ val lst2Odd = lst2.filter(x => x % 2 != 0)\n        val lst1EvenAndOdd = lst1Even.intersect(lst1Odd)\n\
    \        val lst2EvenAndOdd = lst2Even.intersect(lst2Odd)\n        val lst1EvenAndOddAndNotBoth\
    \ = lst1EvenAndOdd.filter(x => !lst2EvenAndOdd.contains(x))\n        val lst2EvenAndOddAndNotBoth\
    \ = lst2EvenAndOdd.filter(x => !lst1EvenAndOdd.contains(x))\n        if (lst1EvenAndOddAndNotBoth.size\
    \ == 0) {\n            return \"NO\"\n        }\n        if (lst2EvenAndOddAndNotBoth.size\
    \ == 0) {\n            return \"NO\"\n        }\n        return \"YES\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvqnfbg_q.scala:35)\n\tat Problem.main(tmpvqnfbg_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Len = lst1.length\n        val lst2Len = lst2.length\n        val lst1Even\
    \ = lst1.filter(x => x % 2 == 0)\n        val lst2Even = lst2.filter(x => x %\
    \ 2 == 0)\n        val lst1Odd = lst1.filter(x => x % 2 != 0)\n        val lst2Odd\
    \ = lst2.filter(x => x % 2 != 0)\n        val lst1EvenOdd = lst1Even.zip(lst1Odd)\n\
    \        val lst2EvenOdd = lst2Even.zip(lst2Odd)\n        val lst1EvenOddLen =\
    \ lst1EvenOdd.length\n        val lst2EvenOddLen = lst2EvenOdd.length\n      \
    \  val lst1EvenOddEven = lst1EvenOdd.filter(x => x._1 == x._2)\n        val lst2EvenOddEven\
    \ = lst2EvenOdd.filter(x => x._1 == x._2)\n        val lst1EvenOddEvenLen = lst1EvenOddEven.length\n\
    \        val lst2EvenOddEvenLen = lst2EvenOddEven.length\n        val lst1EvenOddEvenEvenOdd\
    \ = lst1EvenOddEven.filter(x => x._1 == x._2)\n        val lst2EvenOddEvenEvenOdd\
    \ = lst2EvenOddEven.filter(x => x._1 == x._2)\n        val lst1EvenOddEvenEvenOddLen\
    \ = lst1EvenOddEvenEvenOdd.length\n        val lst2EvenOddEvenEvenOddLen = lst2EvenOddEvenEvenOdd.length\n\
    \        val lst1EvenOddEvenEvenOddEvenOdd = lst1EvenOddEvenEvenOdd.filter(x =>\
    \ x._1 == x._2)\n        val lst2EvenOddEvenEvenOddEvenOdd = lst2EvenOddEvenEvenOdd.filter(x\
    \ => x._1 == x._2)\n        val lst1EvenOddEvenEvenOddEvenOddLen = lst1EvenOddEvenEvenOddEvenOdd.length\n\
    \        val lst2EvenOddEvenEvenOddEvenOddLen = lst2EvenOddEvenEvenOddEvenOdd.length\n\
    \        val lst1EvenOddEvenEvenOddEvenOddEvenOddLen = lst1EvenOddEvenEven\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv281luv0.scala:40:54 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mlst1EvenOddEvenEvenOddEvenOddEvenOddLen\e\
    [0m = lst1EvenOddEvenEven\n\e[31m\e[31m   |\e[0m                             \
    \                         ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                                Not found: lst1EvenOddEvenEven\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv281luv0.scala:41:5 ---------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659794662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n        val lst1Even = lst1.filter(x => x % 2 == 0).sorted\n\
    \        val lst2Even = lst2.filter(x => x % 2 == 0).sorted\n        val lst1Odd\
    \ = lst1.filter(x => x % 2 != 0).sorted\n        val lst2Odd = lst2.filter(x =>\
    \ x % 2 != 0).sorted\n        val lst1EvenOdd = lst1Even.zip(lst2Even).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val lst2EvenOdd = lst2Even.zip(lst1Even).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val lst1EvenOddOdd = lst1EvenOdd.zip(lst2EvenOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val lst2EvenOddOdd = lst2EvenOdd.zip(lst1EvenOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val lst1EvenOddOddOdd = lst1EvenOddOdd.zip(lst2EvenOddOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val lst2EvenOddOddOdd = lst2EvenOddOdd.zip(lst1EvenOddOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val lst1EvenOddOddOddOdd = lst1EvenOddOddOdd.zip(lst2EvenOddOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val lst2EvenOddOddOdd = lst2EvenOddOdd.zip(lst1EvenOddOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val lst1EvenOddOddOddOdd = lst1EvenOddOddOdd.zip(lst2EvenOddOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val lst2EvenOddOddOdd = lst2EvenOddOdd.zip(lst1EvenOddOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val lst1EvenOddOddOddO\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc6hb85qj.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc6hb85qj.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlst2EvenOddOddOdd\e[0m = lst2EvenOddOdd.zip(lst1EvenOddOdd).filter(\e\
    [36mx\e[0m => x._1 == x._2).map(\e[36mx\e[0m => x._1)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlst2EvenOddOddOdd is already defined as \e[33mvalue\e[0m \e\
    [35mlst2EvenOddOddOdd\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpc6hb85qj.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlst1EvenOddOddOddOdd\e[0m\
    \ = lst1EvenOddOddOdd.zip(lst2EvenOddOdd).filter(\e[36mx\e[0m => x._1 == x._2).map(\e\
    [36mx\e[0m => x._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlst1EvenOddOddOddOdd is already defined as \e[33mvalue\e[0m\
    \ \e[35mlst1EvenOddOddOddOdd\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpc6hb85qj.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlst2EvenOddOddOdd\e[0m =\
    \ lst2EvenOddOdd.zip(lst1EvenOddOdd).filter(\e[36mx\e[0m => x._1 == x._2).map(\e\
    [36mx\e[0m => x._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlst2EvenOddOddOdd is already defined as \e[33mvalue\e[0m \e\
    [35mlst2EvenOddOddOdd\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /"
  stdout: ''
  timestamp: 1659794662
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0)\n        val odd = lst2.filter(_ % 2 == 1)\n\
    \        val evenAndOdd = even.intersect(odd)\n        val evenAndOddIsEven =\
    \ evenAndOdd.forall(x => x % 2 == 0)\n        if(evenAndOddIsEven) {\n       \
    \     \"YES\"\n        } else {\n            \"NO\"\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb31nhx_2.scala:30)\n\tat Problem.main(tmpb31nhx_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.zip(odd)\n        val evenAndOddAndEven\
    \ = evenAndOdd.filter(x => x._1 == x._2)\n        val evenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEven.filter(x => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOdd.filter(x => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEven.filter(x => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.filter(x => x._1 == x._2)\n  \
    \      val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.filter(x =>\
    \ x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3w0gfl2f.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3w0gfl2f.scala:25:58\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m                           \
    \                               ^\e[0m\n\e[31m   |\e[0m  Recursive \e[33mvalue\e\
    [0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3w0gfl2f.scala:26:64 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.filter(\e[36mx\e[0m =>\
    \ x._1 == x._2)\n\e[31m\e[31m   |\e[0m                                       \
    \                         ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e\
    [35mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3w0gfl2f.scala:27:71 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e\
    [0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m                           \
    \                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3w0gfl2f.scala:28:84\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[3"
  stdout: ''
  timestamp: 1659794668
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Len = lst1.length\n        val lst2Len = lst2.length\n        if (lst1Len\
    \ != lst2Len) {\n            return \"NO\"\n        }\n        val even = lst1.filter(x\
    \ => x % 2 == 0).toList\n        val odd = lst2.filter(x => x % 2 == 1).toList\n\
    \        val evenAndOdd = even.zip(odd)\n        val evenAndOddLen = evenAndOdd.length\n\
    \        val evenAndOddSum = evenAndOdd.map(x => x._1 + x._2).sum\n        if\
    \ (evenAndOddSum == lst1Len) {\n            return \"YES\"\n        }\n      \
    \  return \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4f4cydjo.scala:34)\n\tat Problem.main(tmp4f4cydjo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).toList\n        val odd = lst2.filter(_ %\
    \ 2 == 0).toList\n        val evenAndOdd = even.zip(odd).filter(_._1 == _._2).toList\n\
    \        val evenAndEven = even.zip(even).filter(_._1 == _._2).toList\n      \
    \  val evenAndOddAndEven = evenAndEven.zip(evenAndOdd).filter(_._1 == _._2).toList\n\
    \        val evenAndOddAndOdd = evenAndOdd.zip(evenAndOdd).filter(_._1 == _._2).toList\n\
    \        val evenAndOddAndEvenAndOdd = evenAndOddAndEven.zip(evenAndOddAndOdd).filter(_._1\
    \ == _._2).toList\n        val evenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOdd.zip(evenAndOddAndEvenAndOdd).filter(_._1\
    \ == _._2).toList\n        val evenAndOddAndEvenAndOddAndOdd = evenAndOddAndEvenAndOdd.zip(evenAndOddAndOdd).filter(_._1\
    \ == _._2).toList\n        val evenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEven.zip(evenAndOddAndEvenAndOddAndOdd).filter(_._1\
    \ == _._2).toList\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOdd.zip(evenAndOddAndEvenAndOddAndOdd).filter(_._1\
    \ == _._2).toList\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndOdd = evenAndOddAndEvenAndOddAndEvenAndOdd.zip(evenAndOddAndOddAndOdd).filter(_._1\
    \ == _._2).toList\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.zip(evenAndOddAndOddAndOddAndEvenAndOdd).filter(_._1\
    \ == _._2).toList\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndO\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpha608p24.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpha608p24.scala:20:48\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOdd\e[0m = even.zip(odd).filter(_._1 == _._2).toList\n\e[31m\e[31m\
    \   |\e[0m                                              ^^^^\e[0m\n\e[31m   |\e\
    [0m                                        value _1 is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpha608p24.scala:21:50 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mevenAndEven\e[0m = even.zip(even).filter(_._1\
    \ == _._2).toList\n\e[31m\e[31m   |\e[0m                                     \
    \           ^^^^\e[0m\n\e[31m   |\e[0m                                       \
    \ value _1 is not a member of Long\n\e[31m\e[31m-- Error: /tmp/tmpha608p24.scala:26:97\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mevenAndOddAndEvenAndOddAndOdd\e[0m = evenAndOddAndEvenAndOdd.zip(evenAndOddAndOdd).filter(_._1\
    \ == _._2).toList\n\e[31m\e[31m   |\e[0m                                     \
    \                                                            ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mValues of types ((Long, Long), (Long, Long)) and (Long, Long) cannot\
    \ be compared with == or !=.\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m    Tuple.canEqualTuple[\e[35mH1\e[0m, \e[35mT1\e[0m, \e[35mH2\e[0m,\
    \ \e[35mT2\e[0m](/* missing */summon[CanEqual[H1, H2]], ???)\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mBut no implicit values were found that match type CanEqual[H1,\
    \ H2].\n\e[31m\e[31m-- Error: /tmp/tmpha608p24.scala:27:124 ----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m = evenAndOddAndEvenAndOddAndEven.zip(evenAndOddAndEvenAndOddAndOdd).filter(_._1\
    \ == _._2).toList\n\e[31m\e[31m   |\e[0m                                     \
    \                                                          "
  stdout: ''
  timestamp: 1659794673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenOdd = even.zip(odd).filter(x => x._1\
    \ == x._2).map(x => x._1)\n        val evenOddOdd = evenOdd.zip(odd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val evenOddEvenOdd = evenOddOdd.zip(evenOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val evenOddEvenOddOdd = evenOddEvenOdd.zip(evenOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val evenOddEvenOddEvenOdd = evenOddEvenOddOdd.zip(evenOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val evenOddEvenOddEvenOddOdd = evenOddEvenOddEvenOdd.zip(evenOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val evenOddEvenOddEvenOddEvenOdd =\
    \ evenOddEvenOddEvenOddOdd.zip(evenOdd).filter(x => x._1 == x._2).map(x => x._1)\n\
    \        val evenOddEvenOddEvenOddEvenOddOdd = evenOddEvenOddEvenOddEvenOddOdd.zip(evenOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val evenOddEvenOddEvenOddEvenOddEvenOdd\
    \ = evenOddEvenOddEvenOddEvenOddEvenOdd.zip(evenOdd).filter(x => x._1 == x._2).map(x\
    \ => x._1)\n        val evenOddEvenOddEvenOddEvenOddEvenOddEvenOdd = evenOddEvenOddEvenOddEvenOddEvenOddEvenOdd.zip(evenOdd).filter(x\
    \ => x._1 == x._2).map(x => x._1)\n        val evenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOdd\
    \ = evenOddEvenOddEvenOddEvenOddEvenOddEvenOddEven\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpuz32xa60.scala:27:46 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mevenOddEvenOddEvenOddEvenOddOdd\e\
    [0m = evenOddEvenOddEvenOddEvenOddOdd.zip(evenOdd).filter(\e[36mx\e[0m => x._1\
    \ == x._2).map(\e[36mx\e[0m => x._1)\n\e[31m\e[31m   |\e[0m                  \
    \                            ^\e[0m\n\e[31m   |\e[0m              Recursive \e\
    [33mvalue\e[0m \e[35mevenOddEvenOddEvenOddEvenOddOdd\e[0m needs type\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpuz32xa60.scala:28:50 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mevenOddEvenOddEvenOddEvenOddEvenOdd\e\
    [0m = evenOddEvenOddEvenOddEvenOddEvenOdd.zip(evenOdd).filter(\e[36mx\e[0m =>\
    \ x._1 == x._2).map(\e[36mx\e[0m => x._1)\n\e[31m\e[31m   |\e[0m             \
    \                                     ^\e[0m\n\e[31m   |\e[0m          Recursive\
    \ \e[33mvalue\e[0m \e[35mevenOddEvenOddEvenOddEvenOddEvenOdd\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpuz32xa60.scala:29:57\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenOddEvenOddEvenOddEvenOddEvenOddEvenOdd\e[0m = evenOddEvenOddEvenOddEvenOddEvenOddEvenOdd.zip(evenOdd).filter(\e\
    [36mx\e[0m => x._1 == x._2).map(\e[36mx\e[0m => x._1)\n\e[31m\e[31m   |\e[0m \
    \                                                        ^\e[0m\n\e[31m   |\e\
    [0m   Recursive \e[33mvalue\e[0m \e[35mevenOddEvenOddEvenOddEvenOddEvenOddEvenOdd\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuz32xa60.scala:30:64\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mevenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOdd\e[0m = evenOddEvenOddEvenOddEvenOddEvenOddEvenOddEven\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[3"
  stdout: ''
  timestamp: 1659794666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(_ % 2 == 0).toList\n        val lst2Even = lst2.filter(_\
    \ % 2 == 0).toList\n        val lst1Odd = lst1.filter(_ % 2 != 0).toList\n   \
    \     val lst2Odd = lst2.filter(_ % 2 != 0).toList\n        val lst1EvenAndOdd\
    \ = lst1Even.intersect(lst1Odd)\n        val lst2EvenAndOdd = lst2Even.intersect(lst2Odd)\n\
    \        val lst1EvenAndOddAndNotBoth = lst1EvenAndOdd.filter(x => !lst2EvenAndOdd.contains(x))\n\
    \        val lst2EvenAndOddAndNotBoth = lst2EvenAndOdd.filter(x => !lst1EvenAndOdd.contains(x))\n\
    \        if(lst1EvenAndOddAndNotBoth.isEmpty) \"NO\" else \"YES\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkmrec2vy.scala:29)\n\tat Problem.main(tmpkmrec2vy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794670
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Even = lst1.filter(x => x % 2 == 0)\n   \
    \     val lst2Even = lst2.filter(x => x % 2 == 0)\n        val lst1Odd = lst1.filter(x\
    \ => x % 2 != 0)\n        val lst2Odd = lst2.filter(x => x % 2 != 0)\n       \
    \ if (lst1Even.size == lst2Even.size) {\n            if (lst1Even.size == lst2Odd.size)\
    \ {\n                if (lst1Even.size == lst2Even.size) {\n                 \
    \   if (lst1Even.size == lst2Odd.size) {\n                        if (lst1Even.size\
    \ == lst2Even.size) {\n                            if (lst1Even.size == lst2Odd.size)\
    \ {\n                                if (lst1Even.size == lst2Even.size) {\n \
    \                                   if (lst1Even.size == lst2Odd.size) {\n   \
    \                                     return \"YES\"\n                       \
    \             } else {\n                                        return \"NO\"\n\
    \                                    }\n                                } else\
    \ {\n                                    return \"NO\"\n                     \
    \           }\n                            } else {\n                        \
    \        return \"NO\"\n                            }\n                      \
    \  } else {\n                            return \"NO\"\n                     \
    \   }\n                    } else {\n                        return \"NO\"\n \
    \                   }\n                } else {\n                    return \"\
    NO\"\n                }\n            } else {\n                return \"NO\"\n\
    \            }\n        } else {\n            return \"NO\"\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo8bp3dy3.scala:61)\n\tat Problem.main(tmpo8bp3dy3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794670
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n        val even = lst1.filter(x => x % 2 == 0).toList\n\
    \        val odd = lst2.filter(x => x % 2 != 0).toList\n        val evenOdd =\
    \ even.zip(odd).filter(x => x._1 == x._2)\n        val evenOddEven = evenOdd.filter(x\
    \ => x._1 == x._2)\n        if(evenOddEven.size == even.size + odd.size){\n  \
    \          return \"YES\"\n        }\n        return \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyadg2ynw.scala:29)\n\tat Problem.main(tmpyadg2ynw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794670
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).size\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).size\n        if (even > odd) {\n            return \"NO\"\n\
    \        } else {\n            return \"YES\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7cfbw_52.scala:28)\n\tat Problem.main(tmp7cfbw_52.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794671
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.zip(odd).filter(x => x._1\
    \ == x._2)\n        val evenAndOddToList = evenAndOdd.map(x => x._1)\n       \
    \ val evenAndOddToListToList = evenAndOddToList.map(x => x.toList)\n        val\
    \ evenAndOddToListToListToList = evenAndOddToListToList.map(x => x.toList)\n \
    \       val evenAndOddToListToListToListToList = evenAndOddToListToListToList.map(x\
    \ => x.toList)\n        val evenAndOddToListToListToListToListToList = evenAndOddToListToListToListToList.map(x\
    \ => x.toList)\n        val evenAndOddToListToListToListToListToListToList = evenAndOddToListToListToListToListToList.map(x\
    \ => x.toList)\n        val evenAndOddToListToListToListToListToListToListToList\
    \ = evenAndOddToListToListToListToListToListToList.map(x => x.toList)\n      \
    \  val evenAndOddToListToListToListToListToListToListToListToListToList = evenAndOddToListToListToListToListToListToListToListToList.map(x\
    \ => x.toList)\n        val evenAndOddToListToListToListToListToListToListToListToListToListToList\
    \ = evenAndOddToListToListToListToListToListToListToListToListToList.map(x =>\
    \ x.toList)\n        val evenAndOddToListToListToListToListToListToListToListToListToListToListToList\
    \ = evenAndOddToListToListToListToListToListToListToListToListToListToListToList.map(x\
    \ => x.toList)\n        val evenAndOddToListToListToListToListToListToListToListToListToListToListToListToListToList\
    \ = evenAndOddToListToListToListToListToListToListToListToListToListToListToListToList.map(x\
    \ => x.toList)\n        val evenAndOdd\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpz1_61kbg.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz1_61kbg.scala:22:65\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddToListToList\e[0m = evenAndOddToList.map(\e[36mx\e[0m => x.toList)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \       ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value toList is not a member\
    \ of Long - did you mean x.toInt?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz1_61kbg.scala:23:77\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddToListToListToList\e[0m = evenAndOddToListToList.map(\e[36mx\e[0m\
    \ => x.toList)\n\e[31m\e[31m   |\e[0m                                        \
    \                                   ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList\
    \ is not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\e[31m   |\e\
    [0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m\
    \  import collection.convert.ImplicitConversions.list asScalaBuffer\n\e[31m  \
    \ |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator asScala\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.set asScala\n\e\
    [31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz1_61kbg.scala:24:89\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddToListToListToListToList\e[0m = evenAndOddToListToListToLi"
  stdout: ''
  timestamp: 1659794673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).toList\n        val odd = lst2.filter(_ %\
    \ 2 == 1).toList\n        val evenAndOdd = even.zip(odd)\n        val evenAndOdd2\
    \ = evenAndOdd.filter(_._1 == _._2)\n        val evenAndOdd3 = evenAndOdd2.filter(_._1\
    \ == _._2)\n        val evenAndOdd4 = evenAndOdd3.filter(_._1 == _._2)\n     \
    \   val evenAndOdd5 = evenAndOdd4.filter(_._1 == _._2)\n        val evenAndOdd6\
    \ = evenAndOdd5.filter(_._1 == _._2)\n        val evenAndOdd7 = evenAndOdd6.filter(_._1\
    \ == _._2)\n        val evenAndOdd8 = evenAndOdd7.filter(_._1 == _._2)\n     \
    \   val evenAndOdd9 = evenAndOdd8.filter(_._1 == _._2)\n        val evenAndOdd10\
    \ = evenAndOdd9.filter(_._1 == _._2)\n        val evenAndOdd11 = evenAndOdd10.filter(_._1\
    \ == _._2)\n        val evenAndOdd12 = evenAndOdd11.filter(_._1 == _._2)\n   \
    \     val evenAndOdd13 = evenAndOdd12.filter(_._1 == _._2)\n        val evenAndOdd14\
    \ = evenAndOdd13.filter(_._1 == _._2)\n        val evenAndOdd15 = evenAndOdd14.filter(_._1\
    \ == _._2)\n        val evenAndOdd16 = evenAndOdd15.filter(_._1 == _._2)\n   \
    \     val evenAndOdd17 = evenAndOdd16.filter(_._1 == _._2)\n        val evenAndOdd18\
    \ = evenAndOdd17.filter(_._1 == _._2)\n        val evenAndOdd19 = evenAndOdd18.filter(_._1\
    \ == _._2)\n        val evenAndOdd20 = evenAndOdd19.filter(_._1 == _._2)\n   \
    \     val evenAndOdd21 = evenAndOdd20.filter(_._1 == _._2)\n        val evenAndOdd22\
    \ = evenAndOdd21.filter(_._1 == _._2)\n        val evenAndOdd23 = evenAndOdd22.filter(_._1\
    \ == _._2)\n        val evenAndOdd24 = evenAndOdd23.filter(_._1 == _._2)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_6c_4rp4.scala:21:46 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mevenAndOdd2\e[0m = evenAndOdd.filter(_._1\
    \ == _._2)\n\e[31m\e[31m   |\e[0m                                            ^^^^\e\
    [0m\n\e[31m   |\e[0m                                        value _1 is not a\
    \ member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_6c_4rp4.scala:22:47\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOdd3\e[0m = evenAndOdd2.filter(_._1 == _._2)\n\e[31m\e[31m   |\e[0m\
    \                                             ^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                   value _1 is not a member of Long\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_6c_4rp4.scala:23:47 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mevenAndOdd4\e[0m = evenAndOdd3.filter(_._1\
    \ == _._2)\n\e[31m\e[31m   |\e[0m                                            \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                                        value _1 is\
    \ not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_6c_4rp4.scala:24:47\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOdd5\e[0m = evenAndOdd4.filter(_._1 == _._2)\n\e[31m\e[31m   |\e[0m\
    \                                             ^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                   value _1 is not a member of Long\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_6c_4rp4.scala:25:47 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mevenAndOdd6\e[0m = evenAndOdd5.filter(_._1\
    \ == _._2)\n\e[31m\e[31m   |\e[0m                                            \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                                        value _1 is\
    \ not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_6c_4rp4.scala:26:47\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOdd7\e[0m = evenAndOdd6.filter(_._1 == _._2)\n\e[31m\e[31m   |\e[0m\
    \                                             ^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                   v"
  stdout: ''
  timestamp: 1659794672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.zip(odd)\n        val evenAndOdd2\
    \ = evenAndOdd.filter(x => x._1 == x._2)\n        val evenAndOdd3 = evenAndOdd2.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd4 = evenAndOdd3.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd5 = evenAndOdd4.filter(x => x._1 == x._2)\n   \
    \     val evenAndOdd6 = evenAndOdd5.filter(x => x._1 == x._2)\n        val evenAndOdd7\
    \ = evenAndOdd6.filter(x => x._1 == x._2)\n        val evenAndOdd8 = evenAndOdd7.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd9 = evenAndOdd8.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd10 = evenAndOdd9.filter(x => x._1 == x._2)\n  \
    \      val evenAndOdd11 = evenAndOdd10.filter(x => x._1 == x._2)\n        val\
    \ evenAndOdd12 = evenAndOdd11.filter(x => x._1 == x._2)\n        val evenAndOdd13\
    \ = evenAndOdd12.filter(x => x._1 == x._2)\n        val evenAndOdd14 = evenAndOdd13.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd15 = evenAndOdd14.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd16 = evenAndOdd15.filter(x => x._1 == x._2)\n \
    \       val evenAndOdd17 = evenAndOdd16.filter(x => x._1 == x._2)\n        val\
    \ evenAndOdd18 = evenAndOdd17.filter(x => x._1 == x._2)\n        val evenAndOdd19\
    \ = evenAndOdd18.filter(x => x._1 == x._2)\n        val evenAndOdd20 = evenAndOdd19.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd21 = evenAndOdd20.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd22 = evenAndOdd21.filter(x => x._\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6him3w31.scala:41:54 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mevenAndOdd22\e[0m = evenAndOdd21.filter(\e\
    [36mx\e[0m => x._\n\e[31m\e[31m   |\e[0m                                     \
    \                 ^\e[0m\n\e[31m   |\e[0m                                   an\
    \ identifier expected, but '_' found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp6him3w31.scala:42:5 ---------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659794641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n        val lst3 = lst1.toSet\n        val lst4 = lst2.toSet\n\
    \        val lst5 = lst3.intersect(lst4)\n        val lst6 = lst5.toList\n   \
    \     val lst7 = lst6.filter(x => x % 2 == 0)\n        val lst8 = lst7.filter(x\
    \ => lst1.contains(x))\n        val lst9 = lst8.filter(x => lst2.contains(x))\n\
    \        val lst10 = lst9.filter(x => lst3.contains(x))\n        val lst11 = lst10.filter(x\
    \ => lst4.contains(x))\n        val lst12 = lst11.filter(x => lst5.contains(x))\n\
    \        val lst13 = lst12.filter(x => lst6.contains(x))\n        val lst14 =\
    \ lst13.filter(x => lst7.contains(x))\n        val lst15 = lst14.filter(x => lst8.contains(x))\n\
    \        val lst16 = lst15.filter(x => lst9.contains(x))\n        val lst17 =\
    \ lst16.filter(x => lst10.contains(x))\n        val lst18 = lst17.filter(x =>\
    \ lst11.contains(x))\n        val lst19 = lst18.filter(x => lst12.contains(x))\n\
    \        val lst20 = lst19.filter(x => lst13.contains(x))\n        val lst21 =\
    \ lst20.filter(x => lst14.contains(x))\n        val lst22 = lst21.filter(x =>\
    \ lst15.contains(x))\n        val lst23 = lst22.filter(x => lst16.contains(x))\n\
    \        val lst24 = lst23.filter(x => lst17.contains(x))\n        val lst25 =\
    \ lst24.filter(x => lst18.contains(x))\n        val lst26 = lst25.filter(x =>\
    \ lst19.contains(x))\n        val lst27 = lst26.filter(x => lst20.contains(x))\n\
    \        val lst28 = lst27.filter(x => lst21.contains(x))\n        val lst29 =\
    \ lst28.filter(x => lst22.contains(x))\n        val lst30 = lst29.filter(x =>\
    \ lst23.contains(x))\n        val lst31 = lst30.filter(x => lst24.contains(x))\n\
    \        val lst32 = lst31.filter(x => lst25.contains(x))\n        val lst33 =\
    \ lst32.filter(x => lst26.contains(x))\n        val lst34 = lst33.filter(x =>\
    \ lst27.contains(x))\n        val lst35 = lst34.filter(x => lst28.contains(x))\n\
    \        val lst36 = lst35.filter(x => lst29.contains(x))\n        val lst37 =\
    \ lst36.filter(x => lst30.contains(x))\n        val lst38 = lst37.filter(\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppdms33pf.scala:54:33 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e[36mlst38\e[0m = lst37.filter(\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m\
    \                                 expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppdms33pf.scala:55:5\
    \ ---------------------\e[0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst3 = lst1.filter(_ % 2 == 0)\n        val lst4 = lst2.filter(_ % 2 ==\
    \ 0)\n        val lst5 = lst3.filter(_ % 2 == 0)\n        val lst6 = lst4.filter(_\
    \ % 2 == 0)\n        val lst7 = lst5.filter(_ % 2 == 0)\n        val lst8 = lst6.filter(_\
    \ % 2 == 0)\n        val lst9 = lst7.filter(_ % 2 == 0)\n        val lst10 = lst8.filter(_\
    \ % 2 == 0)\n        val lst11 = lst9.filter(_ % 2 == 0)\n        val lst12 =\
    \ lst10.filter(_ % 2 == 0)\n        val lst13 = lst11.filter(_ % 2 == 0)\n   \
    \     val lst14 = lst12.filter(_ % 2 == 0)\n        val lst15 = lst13.filter(_\
    \ % 2 == 0)\n        val lst16 = lst14.filter(_ % 2 == 0)\n        val lst17 =\
    \ lst15.filter(_ % 2 == 0)\n        val lst18 = lst16.filter(_ % 2 == 0)\n   \
    \     val lst19 = lst17.filter(_ % 2 == 0)\n        val lst20 = lst18.filter(_\
    \ % 2 == 0)\n        val lst21 = lst19.filter(_ % 2 == 0)\n        val lst22 =\
    \ lst20.filter(_ % 2 == 0)\n        val lst23 = lst21.filter(_ % 2 == 0)\n   \
    \     val lst24 = lst22.filter(_ % 2 == 0)\n        val lst25 = lst23.filter(_\
    \ % 2 == 0)\n        val lst26 = lst24.filter(_ % 2 == 0)\n        val lst27 =\
    \ lst25.filter(_ % 2 == 0)\n        val lst28 = lst26.filter(_ % 2 == 0)\n   \
    \     val lst29 = lst27.filter(_ % 2 == 0)\n        val lst30 = lst28.filter(_\
    \ % 2 == 0)\n        val lst31 = lst29.filter(_ % 2 == 0)\n        val lst32 =\
    \ lst30.filter(_ % 2 == 0)\n        val lst33 = lst31.filter(_ % 2 == 0)\n   \
    \     val lst34 = lst32.filter(_ % 2 == 0)\n        val lst35 = lst33.filter(_\
    \ % 2 == 0)\n        val lst36 = lst34.filter(_ % 2 == 0)\n        val lst37 =\
    \ lst35.filter(_ % 2 == 0)\n        val lst38 = lst36.filter(_ % 2 == 0)\n   \
    \     val lst39 = lst37.filter(_ % 2 == 0)\n        val lst40 = lst38.filter(_\
    \ % 2 == 0)\n        val lst41 = lst39.filter(_ % 2 == 0)\n        val lst42 =\
    \ lst40.filter(_ % 2 == 0)\n\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe1kmrtku.scala:59:5\
    \ ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794668
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).length\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).length\n        if (even == odd) {\n            val lst3 = lst1.filter(x\
    \ => x % 2 == 0).zip(lst2.filter(x => x % 2 == 1)).filter(_._1 == 0).map(_._2)\n\
    \            lst3.toList.mkString(\",\")\n        } else {\n            \"NO\"\
    \n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq9b_v_xi.scala:28)\n\tat Problem.main(tmpq9b_v_xi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(_ % 2 == 0)\n        val lst2Even = lst2.filter(_\
    \ % 2 == 0)\n        val lst1Odd = lst1.filter(_ % 2 != 0)\n        val lst2Odd\
    \ = lst2.filter(_ % 2 != 0)\n        val lst1EvenAndOdd = lst1Even.zip(lst1Odd)\n\
    \        val lst2EvenAndOdd = lst2Even.zip(lst2Odd)\n        val lst1EvenAndOddAndOdd\
    \ = lst1EvenAndOdd.filter(_._1 % 2 == 0)\n        val lst2EvenAndOddAndOdd = lst2EvenAndOdd.filter(_._1\
    \ % 2 == 0)\n        val lst1EvenAndOddAndOddAndOdd = lst1EvenAndOddAndOdd.filter(_._1\
    \ % 2 != 0)\n        val lst2EvenAndOddAndOddAndOdd = lst2EvenAndOddAndOdd.filter(_._1\
    \ % 2 != 0)\n        val lst1EvenAndOddAndOddAndOddAndOdd = lst1EvenAndOddAndOddAndOdd.filter(_._1\
    \ % 2 != 0)\n        val lst2EvenAndOddAndOddAndOddAndOdd = lst2EvenAndOddAndOddAndOdd.filter(_._1\
    \ % 2 != 0)\n        val lst1EvenAndOddAndOddAndOddAndOddAndOdd = lst1EvenAndOddAndOddAndOddAndOdd.filter(_._1\
    \ % 2 != 0)\n        val lst2EvenAndOddAndOddAndOddAndOddAndOdd = lst2EvenAndOddAndOddAndOddAndOdd.filter(_._1\
    \ % 2 != 0)\n        val lst1EvenAndOddAndOddAndOddAndOddAndOddAndOdd = lst1EvenAndOddAndOddAndOddAndOddAndOdd.filter(_._1\
    \ % 2 != 0)\n        val lst2EvenAndOddAndOddAndOddAndOddAndOddAndOdd = lst2EvenAndOddAndOddAndOddAndOddAndOdd.filter(_._1\
    \ % 2 != 0)\n        val lst1EvenAndOddAndOddAndOddAndOddAndOddAndOddAnd\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpspn3151i.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpspn3151i.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(_ % 2 == 0).sorted\n        val lst2Even = lst2.filter(_\
    \ % 2 == 0).sorted\n        val lst1Odd = lst1.filter(_ % 2 != 0).sorted\n   \
    \     val lst2Odd = lst2.filter(_ % 2 != 0).sorted\n        val lst1EvenEven =\
    \ lst1Even.intersect(lst2Even)\n        val lst2EvenEven = lst2Even.intersect(lst1Even)\n\
    \        val lst1OddEven = lst1Odd.intersect(lst2Odd)\n        val lst2OddEven\
    \ = lst2Odd.intersect(lst1Odd)\n        val lst1EvenOdd = lst1Even.intersect(lst2Odd)\n\
    \        val lst2EvenOdd = lst2Even.intersect(lst1Odd)\n        val lst1OddOdd\
    \ = lst1Odd.intersect(lst2Even)\n        val lst2OddOdd = lst2Odd.intersect(lst1Even)\n\
    \        val lst1EvenEvenOdd = lst1EvenEven.intersect(lst2EvenEven)\n        val\
    \ lst2EvenEvenOdd = lst2EvenEven.intersect(lst1EvenEven)\n        val lst1OddEvenOdd\
    \ = lst1OddEven.intersect(lst2OddEven)\n        val lst2OddEvenOdd = lst2OddEven.intersect(lst1OddEven)\n\
    \        val lst1EvenOddOdd = lst1EvenOdd.intersect(lst2OddOdd)\n        val lst2EvenOddOdd\
    \ = lst2EvenOdd.intersect(lst1OddOdd)\n        val lst1OddOddOdd = lst1OddOdd.intersect(lst2EvenOdd)\n\
    \        val lst2OddOddOdd = lst2OddOdd.intersect(lst1EvenOdd)\n        val lst1EvenEvenOddOdd\
    \ = lst1EvenEvenOdd.intersect(lst2EvenEvenOdd)\n        val lst2EvenEvenOddOdd\
    \ = lst2EvenEvenOdd.intersect(lst1EvenEvenOdd)\n        val lst1OddEvenOddOdd\
    \ = lst1\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4toat4et.scala:41:5\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794670
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst3 = lst1.toSet\n        val lst4 = lst2.toSet\n        val lst5 = lst3.intersect(lst4)\n\
    \        val lst6 = lst5.toSet\n        if (lst6.size == lst5.size) {\n      \
    \      if (lst6.size == lst5.size) {\n                if (lst6.size == lst5.size)\
    \ {\n                    if (lst6.size == lst5.size) {\n                     \
    \   if (lst6.size == lst5.size) {\n                            if (lst6.size ==\
    \ lst5.size) {\n                                if (lst6.size == lst5.size) {\n\
    \                                    if (lst6.size == lst5.size) {\n         \
    \                               return \"YES\"\n                             \
    \       }\n                                }\n                            }\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n        return \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8x0ti2o9.scala:43)\n\tat Problem.main(tmp8x0ti2o9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(x => x % 2 == 0)\n        val lst2Even = lst2.filter(x\
    \ => x % 2 == 0)\n        val lst1Odd = lst1.filter(x => x % 2 != 0)\n       \
    \ val lst2Odd = lst2.filter(x => x % 2 != 0)\n        val lst1EvenAndOdd = lst1Even.zip(lst1Odd)\n\
    \        val lst2EvenAndOdd = lst2Even.zip(lst2Odd)\n        val lst1EvenAndOddAndLst2EvenAndOdd\
    \ = lst1EvenAndOdd.zip(lst2EvenAndOdd)\n        val lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd\
    \ = lst1EvenAndOddAndLst2EvenAndOdd.filter(x => x._1 == x._2)\n        val lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd\
    \ = lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd.filter(x => x._1 == x._2)\n\
    \        val lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd\
    \ = lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd.filter(x\
    \ => x._1 == x._2)\n        val lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd\
    \ = lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd.filter(x\
    \ => x._1 == x._2)\n        val lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd\
    \ = lst1\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxuynfc2d.scala:27:97 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mlst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd\e\
    [0m = lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd.filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m                           \
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpxuynfc2d.scala:28:114 --------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36mlst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd\e\
    [0m = lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd.filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m                           \
    \                                                                            \
    \           ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m \
    \  |\e[0m  lst1EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOddAndLst2EvenAndOdd\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpxuynfc2d.scala:30:5 ---------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659794670
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).toList\n        val odd = lst2.filter(_ %\
    \ 2 == 1).toList\n        val evenAndOdd = even.intersect(odd)\n        if (evenAndOdd.isEmpty)\
    \ {\n            \"NO\"\n        } else {\n            \"YES\"\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp126p1y7i.scala:28)\n\tat Problem.main(tmp126p1y7i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).size\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).size\n        if (even == odd) {\n            val evenList =\
    \ lst1.filter(x => x % 2 == 0)\n            val oddList = lst2.filter(x => x %\
    \ 2 == 1)\n            val evenList2 = evenList.zip(oddList).filter(_._1 == _._2).map(_._2)\n\
    \            val oddList2 = evenList.zip(oddList).filter(_._1 == _._2).map(_._1)\n\
    \            val evenList3 = evenList2.zip(oddList2).filter(_._1 == _._2).map(_._2)\n\
    \            val oddList3 = evenList2.zip(oddList2).filter(_._1 == _._2).map(_._1)\n\
    \            if (evenList3.size == evenList2.size) {\n                if (evenList3.size\
    \ == evenList2.size) {\n                    if (evenList3.size == evenList2.size)\
    \ {\n                        if (evenList3.size == evenList2.size) {\n       \
    \                     return \"YES\"\n                        }\n            \
    \        }\n                }\n            }\n        }\n        return \"NO\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkpgssvg7.scala:23:59 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mevenList2\e[0m = evenList.zip(oddList).filter(_._1\
    \ == _._2).map(_._2)\n\e[31m\e[31m   |\e[0m                                  \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \             value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpkpgssvg7.scala:24:58 ------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m            \e[33mval\e[0m \e[36moddList2\e[0m = evenList.zip(oddList).filter(_._1\
    \ == _._2).map(_._1)\n\e[31m\e[31m   |\e[0m                                  \
    \                      ^^^^\e[0m\n\e[31m   |\e[0m                            \
    \            value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpkpgssvg7.scala:25:61 ------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            \e[33mval\e[0m \e[36mevenList3\e[0m = evenList2.zip(oddList2).filter(_._1\
    \ == _._2).map(_._2)\n\e[31m\e[31m   |\e[0m                                  \
    \                         ^^^^\e[0m\n\e[31m   |\e[0m                         \
    \               value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpkpgssvg7.scala:26:60 ------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m            \e[33mval\e[0m \e[36moddList3\e[0m = evenList2.zip(oddList2).filter(_._1\
    \ == _._2).map(_._1)\n\e[31m\e[31m   |\e[0m                                  \
    \                        ^^^^\e[0m\n\e[31m   |\e[0m                          \
    \              value _1 is not a member of Long\n4 errors found\n"
  stdout: ''
  timestamp: 1659794676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.intersect(odd)\n      \
    \  val evenAndEven = even.intersect(even)\n        val evenAndOddAndEven = evenAndEven.intersect(evenAndOdd)\n\
    \        val evenAndOddAndOdd = evenAndOdd.intersect(evenAndOdd)\n        val\
    \ evenAndOddAndEvenAndOdd = evenAndOddAndEven.intersect(evenAndOddAndOdd)\n  \
    \      val evenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\n\
    \        val evenAnd\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsydiys8j.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsydiys8j.scala:26:92\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOdd\e[0m = evenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                    ^\e[0m\n\e[31m   |\e[0m         Recursive\
    \ \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOdd\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsydiys8j.scala:27:58\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^\e[0m\n\e[31m   |\e[0m  Recursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsydiys8j.scala:30:84\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e["
  stdout: ''
  timestamp: 1659794677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val evens = lst1.filter(x => x % 2 == 0).toList\n        val odds = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evensAndOdds = evens ++ odds\n        val\
    \ evensAndOddsSet = evensAndOdds.toSet\n        val evensAndOddsSetSize = evensAndOddsSet.size\n\
    \        val evensAndOddsSetSize = evensAndOddsSet.size\n        if (evensAndOddsSetSize\
    \ == evensAndOddsSet.size) {\n            val evensAndOddsSetSize = evensAndOddsSet.size\n\
    \            val evensAndOddsSetSize = evensAndOddsSet.size\n            if (evensAndOddsSetSize\
    \ == evensAndOddsSet.size) {\n                val evensAndOddsSetSize = evensAndOddsSet.size\n\
    \                val evensAndOddsSetSize = evensAndOddsSet.size\n            \
    \    if (evensAndOddsSetSize == evensAndOddsSet.size) {\n                    val\
    \ evensAndOddsSetSize = evensAndOddsSet.size\n                    val evensAndOddsSetSize\
    \ = evensAndOddsSet.size\n                    if (evensAndOddsSetSize == evensAndOddsSet.size)\
    \ {\n                        val evensAndOddsSetSize = evensAndOddsSet.size\n\
    \                        val evensAndOddsSetSize = evensAndOddsSet.size\n    \
    \                    if (evensAndOddsSetSize == evensAndOddsSet.size) {\n    \
    \                        val evensAndOddsSetSize = evensAndOddsSet.size\n    \
    \                        val evensAndOddsSetSize = evensAndOddsSet.size\n    \
    \                        if (evensAndOddsSetSize == evensAndOddsSet.size) {\n\
    \                                val evensAndOddsSetSize = evensAndOddsSet.size\n\
    \                                val evensAndOddsSetSize = evensAndOddsSet.size\n\
    \                                if (evensAndOddsSetSize == evensAndOddsSet.size)\
    \ {\n                                    val evensAndOddsSetSize = evensAndOddsSet.size\n\
    \                                    val evensAndOddsSetSize = evensAndOddsSet.size\n\
    \                                    if (evensAndOddsSetSize == evensAndOddsSet.size)\
    \ {\n                                        val evensAndOddsSetSize = evensAndOddsSet.size\n\
    \                                        val evensAndOddsSetSize = evensAndOdds\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpd2824pwt.scala:60:0 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd2824pwt.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevensAndOddsSetSize\e[0m = evensAndOddsSet.size\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mevensAndOddsSetSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mevensAndOddsSetSize\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpd2824pwt.scala:26:16 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m            \e[33mval\e[0m \e[36mevensAndOddsSetSize\e[0m = evensAndOddsSet.size\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensAndOddsSetSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mevensAndOddsSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpd2824pwt.scala:29:20 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mval\e[0m \e[36mevensAndOddsSetSize\e\
    [0m = evensAndOddsSet.size\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensAndOddsSetSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mevensAndOddsSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpd2824pwt.scala:32:24 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    \e[33mval\e[0m \e[36mevensAndOddsSetSize\e\
    [0m = evensAndOddsSet.size\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensAndOddsSetSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mevensAndOddsSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e"
  stdout: ''
  timestamp: 1659794677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val evens = lst1.filter(_ % 2 == 0).toList\n        val odds = lst2.filter(_\
    \ % 2 == 1).toList\n        val evensOdds = evens ++ odds\n        val evensOddsSet\
    \ = evensOdds.toSet\n        val evensOddsSetSize = evensOddsSet.size\n      \
    \  val evensOddsSetIsEven = evensOddsSet.forall(x => x % 2 == 0)\n        if (evensOddsSetSize\
    \ == evensOddsSetIsEven) {\n            \"YES\"\n        } else {\n          \
    \  \"NO\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp4v_8bjf9.scala:24:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mif\e[0m (evensOddsSetSize == evensOddsSetIsEven)\
    \ {\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Int and Boolean cannot be compared\
    \ with == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1659794682
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n        val lst3 = lst1.filter(_ % 2 == 0).filter(_\
    \ != lst1(0))\n        val lst4 = lst2.filter(_ % 2 == 0).filter(_ != lst2(0))\n\
    \        if (lst3.size == lst4.size) {\n            val lst5 = lst3.zip(lst4).filter(_._1\
    \ == _._2).map(_._1)\n            val lst6 = lst5.filter(_ % 2 == 0).filter(_\
    \ != lst5(0))\n            if (lst6.size == lst5.size) {\n                val\
    \ lst7 = lst6.zip(lst5).filter(_._1 == _._2).map(_._1)\n                val lst8\
    \ = lst7.filter(_ % 2 == 0).filter(_ != lst7(0))\n                if (lst8.size\
    \ == lst7.size) {\n                    val lst9 = lst8.zip(lst7).filter(_._1 ==\
    \ _._2).map(_._1)\n                    val lst10 = lst9.filter(_ % 2 == 0).filter(_\
    \ != lst9(0))\n                    if (lst10.size == lst9.size) {\n          \
    \              val lst11 = lst10.zip(lst9).filter(_._1 == _._2).map(_._1)\n  \
    \                      val lst12 = lst11.filter(_ % 2 == 0).filter(_ != lst11(0))\n\
    \                        if (lst12.size == lst11.size) {\n                   \
    \         val lst13 = lst12.zip(lst11).filter(_._1 == _._2).map(_._1)\n      \
    \                      val lst14 = lst13.filter(_ % 2 == 0).filter(_ != lst13(0))\n\
    \                            if (lst14.size == lst13.size) {\n               \
    \                 val lst15 = lst14.zip(lst13).filter(_._1 == _._2).map(_._1)\n\
    \                                val lst16 = lst15.filter(_ % 2 == 0).filter(_\
    \ != lst15(0))\n                                if (lst16.size == lst15.size)\
    \ {\n                                    val lst17 = lst16.zip(lst15).filter(_._1\
    \ == _._2).map(_._1)\n                                    val lst18 = lst17.filter(_\
    \ % 2 == 0).filter(_ != lst17(0))\n                                    if (lst18.size\
    \ == lst17.size) {\n                                        val lst19 = lst18.zip(lst17).filter(_._1\
    \ == _._2).map(_._1)\n                                        val lst20 = lst19.filter(_\
    \ % 2 == 0).filter(_ != lst19(0))\n                                        if\
    \ (lst20.size == lst19.size) {\n                                            val\
    \ lst21 = lst20.zip(lst19).filter(_._1 == _._2).map(_._1)\n                  \
    \                          val lst22 = lst21.filter(_ % 2 == 0).filter(_ != lst21(0))\n\
    \                                            if (lst22.size == lst21.size) {\n\
    \                                                val lst23 = lst22.zip(lst21).filter(_._1\
    \ == \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl2klnehk.scala:49:91 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m                                                \e[33mval\e\
    [0m \e[36mlst23\e[0m = lst22.zip(lst21).filter(_._1 == \n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \               ^\e[0m\n\e[31m   |\e[0m                                      \
    \ expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmpl2klnehk.scala:62:0 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl2klnehk.scala:22:47\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m\
    \ \e[36mlst5\e[0m = lst3.zip(lst4).filter(_._1 == _._2).map(_._1)\n\e[31m\e[31m\
    \   |\e[0m                                             ^^^^\e[0m\n\e[31m   |\e\
    [0m                                        value _1 is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpl2klnehk.scala:25:51 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mval\e[0m \e[36mlst7\e[0m = lst6.zip(lst5).filter(_._1\
    \ == _._2).map(_._1)\n\e[31m\e[31m   |\e[0m                                  \
    \               ^^^^\e[0m\n\e[31m   |\e[0m                                   \
    \     value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpl2klnehk.scala:28:55 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m                    \e[33mval\e[0m \e[36mlst9\e[0m = lst8.zip(lst7).filter(_._1\
    \ == _._2).map(_._1)\n\e[31m\e[31m   |\e[0m                                  \
    \                   ^^^^\e[0m\n\e[31m   |\e[0m                               \
    \         value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpl2klnehk.scala:31:61 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m                        \e[33mval\e[0m \e[36mlst11\e[0m = lst10.zip(lst9).filter(_._1\
    \ == _._2).map(_._1)\n\e[31m\e[31m   |\e[0m                       "
  stdout: ''
  timestamp: 1659794691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.zip(odd).filter(x => x._1\
    \ == x._2)\n        val evenAndEven = even.zip(even).filter(x => x._1 == x._2)\n\
    \        val evenAndOddAndEven = evenAndEven.filter(x => x._1 == x._2)\n     \
    \   val evenAndOddAndEvenAndOdd = evenAndOddAndEven.filter(x => x._1 == x._2)\n\
    \        val evenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOdd.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEven.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven =\
    \ evenAndOddAndEvenAndOddAndEvenAndOdd.filter(x => x._1 == x._2)\n        val\
    \ evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.filter(x => x._1\
    \ == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.filter(x =>\
    \ x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAnd\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6t_nv8hh.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6t_nv8hh.scala:28:71\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m                           \
    \                                            ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6t_nv8hh.scala:29:77\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e[0m =\
    \ evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.filter(\e[36mx\e\
    [0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m                                  \
    \                                           ^\e[0m\n\e[31m   |\e[0mRecursive \e\
    [33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6t_nv8hh.scala:30:84\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m                           \
    \                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanati"
  stdout: ''
  timestamp: 1659794687
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n        val even = lst1.filter(x => x % 2 == 0).length\n\
    \        val odd = lst2.filter(x => x % 2 == 1).length\n        if (even == odd)\
    \ {\n            return \"YES\"\n        } else {\n            return \"NO\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiggofjy5.scala:34)\n\tat Problem.main(tmpiggofjy5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794691
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).toList\n        val odd = lst2.filter(_ %\
    \ 2 == 1).toList\n        val evenAndOdd = even.intersect(odd)\n        if (evenAndOdd.isEmpty)\
    \ \"NO\" else \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp434_i3wi.scala:24)\n\tat Problem.main(tmp434_i3wi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).toList\n        val odd = lst2.filter(_ %\
    \ 2 == 0).toList\n        val evenAndOdd = even.intersect(odd)\n        val evenAndEven\
    \ = even.intersect(even)\n        val evenAndOddAndEven = evenAndEven.intersect(evenAndOdd)\n\
    \        val evenAndOddAndEvenAndOdd = evenAndOddAndEven.intersect(evenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOdd.intersect(evenAndOddAndEven)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd =\
    \ evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1e45o7rd.scala:27:118 --------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                              ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1e45o7rd.scala:29:77\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e[0m =\
    \ evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1e45o7rd.scala:30:84\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e\
    [0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                          ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e\
    [35mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1e45o7rd.scala:31:5\
    \ ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e["
  stdout: ''
  timestamp: 1659794687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n        val lst3 = lst1.toSet\n        val lst4 = lst2.toSet\n\
    \        val lst5 = lst3.intersect(lst4)\n        val lst6 = lst5.toSet\n    \
    \    if(lst6.size == lst1.size)\n        {\n            val lst7 = lst6.filter(_\
    \ % 2 == 0)\n            if(lst7.size == lst1.size)\n            {\n         \
    \       val lst8 = lst7.filter(_ % 2 == 0)\n                if(lst8.size == lst1.size)\n\
    \                {\n                    val lst9 = lst8.filter(_ % 2 == 0)\n \
    \                   if(lst9.size == lst1.size)\n                    {\n      \
    \                  val lst10 = lst9.filter(_ % 2 == 0)\n                     \
    \   if(lst10.size == lst1.size)\n                        {\n                 \
    \           val lst11 = lst10.filter(_ % 2 == 0)\n                           \
    \ if(lst11.size == lst1.size)\n                            {\n               \
    \                 val lst12 = lst11.filter(_ % 2 == 0)\n                     \
    \           if(lst12.size == lst1.size)\n                                {\n \
    \                                   val lst13 = lst12.filter(_ % 2 == 0)\n   \
    \                                 if(lst13.size == lst1.size)\n              \
    \                      {\n                                        val lst14 =\
    \ lst13.filter(_ % 2 == 0)\n                                        if(lst14.size\
    \ == lst1.size)\n                                        {\n                 \
    \                           val lst15 = lst14.filter(_ % 2 == 0)\n           \
    \                                 if(lst15.size == lst1.size)\n              \
    \                              {\n                                           \
    \     val lst16 = lst15.filter(_ % 2 == 0)\n                                 \
    \               if(lst16.size == lst1.size)\n                                \
    \                {\n                                                    val lst17\
    \ = lst16.filter(_ % 2 == 0)\n                                               \
    \     if(lst17.size == lst1.size)\n                                          \
    \          {\n                                                        val lst18\
    \ = lst17.filter(_ % 2 == 0)\n                                               \
    \         if(lst18.size == lst1.size)\n                                      \
    \                  {\n                                                       \
    \     val lst19 = lst18.filter(_ % 2 == 0)\n                                 \
    \                           if(lst19.size == lst1.size)\n                    \
    \                                        {\n                                 \
    \                               val lst20 = lst19.filter(_ % 2 == 0)\n       \
    \                                                         if(lst20.size == lst1.size)\n\
    \                                                                {\n         \
    \                                                           val lst21 = lst20.filter(_\
    \ % 2 == 0)\n                                                                \
    \    if(lst21.size == lst1.size)\n                                           \
    \                         {\n                                                \
    \                        val lst22 = lst21.filter(_ % 2 == 0)\n              \
    \                                                          if(lst22.size == lst1.size)\n\
    \                                                                        {\n \
    \                                                                           val\
    \ lst23 = lst22.filter(_ % 2 == 0)\n                                         \
    \                                   if(lst23.size == lst1.size)\n            \
    \                                                                {\n         \
    \                                                                       val lst24\
    \ = lst23.filter(_ % 2 == 0)\n                                               \
    \                                 if(lst24.size == lst1.size)\n              \
    \                                                                  {\n       \
    \                                                                            \
    \ val lst25 = lst24.filter(_\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgq64qkko.scala:80:4 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgq64qkko.scala:92:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpgq64qkko.scala:81:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m81 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659794684
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val evens = lst1.filter(x => x % 2 == 0).toList\n        val odds = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evensAndOdds = evens ++ odds\n        val\
    \ evensAndOddsSet = evensAndOdds.toSet\n        val evensAndOddsSetSize = evensAndOddsSet.size\n\
    \        if (evensAndOddsSetSize == 0) {\n            \"NO\"\n        } else if\
    \ (evensAndOddsSetSize == evensAndOddsSet.size) {\n            \"YES\"\n     \
    \   } else {\n            val evensAndOddsSetSize = evensAndOddsSet.size\n   \
    \         val evensAndOddsSet = evensAndOdds.toSet\n            val evensAndOddsSetSize\
    \ = evensAndOddsSet.size\n            if (evensAndOddsSetSize == 0) {\n      \
    \          \"NO\"\n            } else if (evensAndOddsSetSize == evensAndOddsSet.size)\
    \ {\n                \"YES\"\n            } else {\n                val evensAndOddsSetSize\
    \ = evensAndOddsSet.size\n                val evensAndOddsSet = evensAndOdds.toSet\n\
    \                val evensAndOddsSetSize = evensAndOddsSet.size\n            \
    \    if (evensAndOddsSetSize == 0) {\n                    \"NO\"\n           \
    \     } else if (evensAndOddsSetSize == evensAndOddsSet.size) {\n            \
    \        \"YES\"\n                } else {\n                    val evensAndOddsSetSize\
    \ = evensAndOddsSet.size\n                    val evensAndOddsSet = evensAndOdds.toSet\n\
    \                    val evensAndOddsSetSize = evensAndOddsSet.size\n        \
    \            if (evensAndOddsSetSize == 0) {\n                        \"NO\"\n\
    \                    } else if (evensAndOddsSetSize == evensAndOddsSet.size) {\n\
    \                        \"YES\"\n                    } else {\n             \
    \           val evensAndOddsSetSize = evensAndOddsSet.size\n                 \
    \       val evensAndOddsSet = evensAndOdds.toSet\n                        val\
    \ evensAndOddsSetSize = evensAndOddsSet.size\n                        if (evensAndOddsSetSize\
    \ == 0) {\n                            \"NO\"\n                        } else\
    \ if (evensAndOddsSetSize == evensAndOddsSet.size) {\n                       \
    \     \"YES\"\n                        } else {\n                            val\
    \ evensAndOddsSetSize = evensAndOddsSet.size\n                            val\
    \ evensAndOddsSet = evensAndOdd\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8b8zoxqk.scala:74:0 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8b8zoxqk.scala:30:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e\
    [0m \e[36mevensAndOddsSetSize\e[0m = evensAndOddsSet.size\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mevensAndOddsSetSize is already defined as \e[33mvalue\e[0m \e[35mevensAndOddsSetSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8b8zoxqk.scala:38:20 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m                \e[33mval\e[0m \e[36mevensAndOddsSetSize\e[0m = evensAndOddsSet.size\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensAndOddsSetSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mevensAndOddsSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp8b8zoxqk.scala:46:24 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                    \e[33mval\e[0m \e[36mevensAndOddsSetSize\e\
    [0m = evensAndOddsSet.size\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensAndOddsSetSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mevensAndOddsSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp8b8zoxqk.scala:54:28 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m                        \e[33mval\e[0m \e[36mevensAndOddsSetSize\e\
    [0m = evensAndOddsSet.size\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensAndOddsSetSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mevensAndOddsSetS"
  stdout: ''
  timestamp: 1659794691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenOdd = even.zip(odd)\n        val evenOddList\
    \ = evenOdd.toList\n        val evenOddList2 = evenOddList.map(x => x._1.toLong\
    \ + x._2.toLong)\n        val evenOddList3 = evenOddList2.filter(x => x % 2 ==\
    \ 0).toList\n        val evenOddList4 = evenOddList3.filter(x => x % 2 == 1).toList\n\
    \        val evenOddList5 = evenOddList4.map(x => x.toLong)\n        val evenOddList6\
    \ = evenOddList5.filter(x => x % 2 == 0).toList\n        val evenOddList7 = evenOddList6.filter(x\
    \ => x % 2 == 1).toList\n        val evenOddList8 = evenOddList7.map(x => x.toLong)\n\
    \        val evenOddList9 = evenOddList8.filter(x => x % 2 == 0).toList\n    \
    \    val evenOddList10 = evenOddList9.filter(x => x % 2 == 1).toList\n       \
    \ val evenOddList11 = evenOddList10.map(x => x.toLong)\n        val evenOddList12\
    \ = evenOddList11.filter(x => x % 2 == 0).toList\n        val evenOddList13 =\
    \ evenOddList12.filter(x => x % 2 == 1).toList\n        val evenOddList14 = evenOddList13.map(x\
    \ => x.toLong)\n        val evenOddList15 = evenOddList14.filter(x => x % 2 ==\
    \ 0).toList\n        val evenOddList16 = evenOddList15.filter(x => x % 2 == 1).toList\n\
    \        val evenOddList17 = evenOddList16.map(x => x.toLong)\n        val evenOddList18\
    \ = evenOddList17.filter(x => x % 2 == 0).toList\n        val evenOddList19 =\
    \ evenOddList18.filter(x => x % 2 == 1).toList\n        val evenOddList20 = evenOddList19.map(x\
    \ => x.toLong)\n        val evenOddList21 = evenOddList20.filter(x => x % 2 ==\
    \ 0).toList\n        val evenOddList22 = evenOddList21.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9ffee6d4.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp9ffee6d4.scala:43:5 ---------------------\e[0m\e[0m\n\e[31m43\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).toList\n        val odd = lst2.filter(_ %\
    \ 2 == 0).toList\n        val evenAndOdd = even.zip(odd)\n        val evenAndOddAndOdd\
    \ = evenAndOdd.filter(_._1 % 2 == 0).filter(_._2 % 2 == 0)\n        val evenAndOddAndOddAndOdd\
    \ = evenAndOddAndOdd.filter(_._1 % 2 == 0).filter(_._2 % 2 == 0).filter(_._3 %\
    \ 2 == 0)\n        val evenAndOddAndOddAndOddAndOdd = evenAndOddAndOddAndOdd.filter(_._1\
    \ % 2 == 0).filter(_._2 % 2 == 0).filter(_._3 % 2 == 0).filter(_._4 % 2 == 0)\n\
    \        val evenAndOddAndOddAndOddAndOddAndOdd = evenAndOddAndOddAndOddAndOdd.filter(_._1\
    \ % 2 == 0).filter(_._2 % 2 == 0).filter(_._3 % 2 == 0).filter(_._4 % 2 == 0).filter(_._5\
    \ % 2 == 0)\n        val evenAndOddAndOddAndOddAndOddAndOddAndOdd = evenAndOddAndOddAndOddAndOddAndOdd.filter(_._1\
    \ % 2 == 0).filter(_._2 % 2 == 0).filter(_._3 % 2 == 0).filter(_._4 % 2 == 0).filter(_._5\
    \ % 2 == 0).filter(_._6 % 2 == 0)\n        val evenAndOddAndOddAndOddAndOddAndOddAndOddAndOdd\
    \ = evenAndOddAndOddAndOddAndOddAndOddAndOddAndOdd.filter(_._1 % 2 == 0).filter(_._2\
    \ % 2 == 0).filter(_._3 % 2 == 0).filter(_._4 % 2 == 0).filter(_._5 % 2 == 0).filter(_._6\
    \ % 2 == 0).filter(_._7 % 2 == 0)\n        val evenAndOddAndOddAndOddAndOddAndOddAndOddAndOddAndOdd\
    \ = evenAndOddAndOddAndOddAndOddAndOddAndOddAndOddAndOddAndOdd.filter(_._1 % 2\
    \ == 0).filter(_._2 % 2 == 0).filter(_._3 % 2 == 0).filter(_._4 % 2 == 0).filter(_._5\
    \ % 2 == 0).filter(_._6 % 2 == 0).filter\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwz62llgp.scala:22:107 -----------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddAndOddAndOdd\e\
    [0m = evenAndOddAndOdd.filter(_._1 % \e[31m2\e[0m == \e[31m0\e[0m).filter(_._2\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).filter(_._3 % \e[31m2\e[0m == \e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                 ^^^^\e[0m\n\e[31m   |\e[0m \
    \        value _3 is not a member of (Long, Long) - did you mean _$7._1?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpwz62llgp.scala:23:119 -----------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddAndOddAndOddAndOdd\e\
    [0m = evenAndOddAndOddAndOdd.filter(_._1 % \e[31m2\e[0m == \e[31m0\e[0m).filter(_._2\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).filter(_._3 % \e[31m2\e[0m == \e[31m0\e[0m).filter(_._4\
    \ % \e[31m2\e[0m == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                                                                            \
    \                    ^^^^\e[0m\n\e[31m   |\e[0m        value _3 is not a member\
    \ of (Long, Long) - did you mean _$10._1?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpwz62llgp.scala:23:141 -----------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m        \e[33mval\e[0m \e[36mevenAndOddAndOddAndOddAndOdd\e[0m = evenAndOddAndOddAndOdd.filter(_._1\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).filter(_._2 % \e[31m2\e[0m == \e[31m0\e[0m).filter(_._3\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).filter(_._4 % \e[31m2\e[0m == \e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \       ^^^^\e[0m\n\e[31m   |\e[0m        value _4 is not a member of (Long, Long)\
    \ - did you mean _$11._1?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwz62llgp.scala:24:131\
    \ -----------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndOddAndOddAndOddAndOdd\e[0m = evenAndOddAndOddAndOddAndOdd.filter(_._1\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).filter(_._2 % \e[31m2\e[0m == \e[31m0\e[0m).filter(_._3\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).filt"
  stdout: ''
  timestamp: 1659794695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Size = lst1.size\n        val lst2Size = lst2.size\n        val lst1Even\
    \ = lst1.filter(_ % 2 == 0).size\n        val lst2Even = lst2.filter(_ % 2 ==\
    \ 0).size\n        val lst1Odd = lst1.filter(_ % 2 != 0).size\n        val lst2Odd\
    \ = lst2.filter(_ % 2 != 0).size\n        if (lst1Size == lst2Size && lst1Even\
    \ == lst2Even && lst1Odd == lst2Odd) {\n            val lst1EvenList = lst1.filter(_\
    \ % 2 == 0).sortBy(_).reverse\n            val lst2EvenList = lst2.filter(_ %\
    \ 2 == 0).sortBy(_).reverse\n            val lst1OddList = lst1.filter(_ % 2 !=\
    \ 0).sortBy(_).reverse\n            val lst2OddList = lst2.filter(_ % 2 != 0).sortBy(_).reverse\n\
    \            val lst1EvenListSize = lst1EvenList.size\n            val lst2EvenListSize\
    \ = lst2EvenList.size\n            val lst1OddListSize = lst1OddList.size\n  \
    \          val lst2OddListSize = lst2OddList.size\n            if (lst1EvenListSize\
    \ == lst2EvenListSize && lst1OddListSize == lst2OddListSize) {\n             \
    \   val lst1EvenListSorted = lst1EvenList.sortBy(_).reverse\n                val\
    \ lst2EvenListSorted = lst2EvenList.sortBy(_).reverse\n                val lst1OddListSorted\
    \ = lst1OddList.sortBy(_).reverse\n                val lst2OddListSorted = lst2OddList.sortBy(_).reverse\n\
    \                val lst1EvenListSortedSize = lst1EvenListSorted.size\n      \
    \          val lst2EvenListSortedSize = lst2EvenListSorted.size\n            \
    \    val lst1OddListSortedSize = lst1OddListSorted.size\n                val lst2OddListSortedSize\
    \ = lst2OddListSorted.size\n                if (lst1EvenListSortedSize == lst2EvenListSortedSize\
    \ && lst1OddListSortedSize == lst2OddListSortedSize) {\n                    val\
    \ lst1EvenListSortedSorted = lst1EvenListSorted.sortBy(_).reverse\n          \
    \          val lst2EvenListSortedSorted = lst2EvenListSorted.sortBy(_).reverse\n\
    \                    val lst1OddListSortedSorted = lst1OddListSorted.sortBy(_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5ymkt954.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5ymkt954.scala:58:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m58 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E081] Type\
    \ Error: /tmp/tmp5ymkt954.scala:25:62 -----------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m            \e[33mval\e[0m \e[36mlst1EvenList\e[0m = lst1.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                                           ^\e[0m\n\e[31m   |\e\
    [0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$6 of expanded function:\n\e[31m   |\e[0m   _$6 =>\
    \ lst1.filter(_$5 => _$5 % 2 == 0).sortBy(_$6).reverse.\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp5ymkt954.scala:25:64 -----------------------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mlst1EvenList\e[0m = lst1.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e\
    [33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e\
    [33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of\
    \ \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e\
    [31m\e[31m-- [E081] Type Error: /tmp/tmp5ymkt954.scala:26:62 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mlst2EvenList\e[0m =\
    \ lst2.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\e[31m\e[31m\
    \   |\e[0m                                                              ^\e[0m\n\
    \e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I\
    \ could not infer the type of the parameter _$8 of expanded function:\n\e[31m\
    \   |\e[0m   _$8 => lst2.filter(_$7 => _$7 % 2 == 0).sortBy(_$8).reverse.\n\e\
    [31m\e[31m-- Error: /tmp/tmp5ymkt"
  stdout: ''
  timestamp: 1659794688
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: Write your code here\n        val lst3 = lst1.toSet\n        val lst4\
    \ = lst2.toSet\n        if(lst3.intersect(lst4).isEmpty){\n            return\
    \ \"NO\"\n        }\n        else{\n            return \"YES\"\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzhpxsnua.scala:30)\n\tat Problem.main(tmpzhpxsnua.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst3 = lst1.filter(_ % 2 == 0)\n        val lst4 = lst2.filter(_ % 2 ==\
    \ 0)\n        val lst5 = lst3.filter(_ % 2 == 0)\n        val lst6 = lst4.filter(_\
    \ % 2 == 0)\n        val lst7 = lst5.filter(_ % 2 == 0)\n        val lst8 = lst6.filter(_\
    \ % 2 == 0)\n        val lst9 = lst7.filter(_ % 2 == 0)\n        val lst10 = lst8.filter(_\
    \ % 2 == 0)\n        val lst11 = lst9.filter(_ % 2 == 0)\n        val lst12 =\
    \ lst10.filter(_ % 2 == 0)\n        val lst13 = lst11.filter(_ % 2 == 0)\n   \
    \     val lst14 = lst12.filter(_ % 2 == 0)\n        val lst15 = lst13.filter(_\
    \ % 2 == 0)\n        val lst16 = lst14.filter(_ % 2 == 0)\n        val lst17 =\
    \ lst15.filter(_ % 2 == 0)\n        val lst18 = lst16.filter(_ % 2 == 0)\n   \
    \     val lst19 = lst17.filter(_ % 2 == 0)\n        val lst20 = lst18.filter(_\
    \ % 2 == 0)\n        val lst21 = lst19.filter(_ % 2 == 0)\n        val lst22 =\
    \ lst20.filter(_ % 2 == 0)\n        val lst23 = lst21.filter(_ % 2 == 0)\n   \
    \     val lst24 = lst22.filter(_ % 2 == 0)\n        val lst25 = lst23.filter(_\
    \ % 2 == 0)\n        val lst26 = lst24.filter(_ % 2 == 0)\n        val lst27 =\
    \ lst25.filter(_ % 2 == 0)\n        val lst28 = lst26.filter(_ % 2 == 0)\n   \
    \     val lst29 = lst27.filter(_ % 2 == 0)\n        val lst30 = lst28.filter(_\
    \ % 2 == 0)\n        val lst31 = lst29.filter(_ % 2 == 0)\n        val lst32 =\
    \ lst30.filter(_ % 2 == 0)\n        val lst33 = lst31.filter(_ % 2 == 0)\n   \
    \     val lst34 = lst32.filter(_ % 2 == 0)\n        val lst35 = lst33.filter(_\
    \ % 2 == 0)\n        val lst36 = lst34.filter(_ % 2 == 0)\n        val lst37 =\
    \ lst35.filter(_ % 2 == 0)\n        val lst38 = lst36.filter(_ % 2 == 0)\n   \
    \     val lst39 = lst37.filter(_ % 2 == 0)\n        val lst40 = lst38.filter(_\
    \ % 2 == 0)\n        val lst41 = lst39.filter(_ % 2 == 0)\n        val lst42 =\
    \ lst40.filter(_ % 2 == 0)\n\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe1kmrtku.scala:59:5\
    \ ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.zip(odd)\n        val evenAndOddAndEven\
    \ = evenAndOdd.filter(x => x._1 == x._2)\n        val evenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEven.filter(x => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOdd.filter(x => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEven.filter(x => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.filter(x => x._1 == x._2)\n  \
    \      val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEvenAndO\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmploh6z8_7.scala:25:58 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e\
    [0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.filter(\e[36mx\e[0m => x._1\
    \ == x._2)\n\e[31m\e[31m   |\e[0m                                            \
    \              ^\e[0m\n\e[31m   |\e[0m  Recursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmploh6z8_7.scala:29:84\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m                           \
    \                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmploh6z8_7.scala:30:90\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m = evenAndOddAndEvenAndOddAndEvenAndO\n\e[31m\e[31m   |\e[0m              \
    \                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: evenAndOddAndEvenAndOddAndEvenAndO\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmploh6z8_7.scala:31:5\
    \ ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n"
  stdout: ''
  timestamp: 1659794690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).toList\n        val odd = lst2.filter(_ %\
    \ 2 != 0).toList\n        val evenAndOdd = even ++ odd\n        if (evenAndOdd.isEmpty)\
    \ \"NO\" else \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpanitjacd.scala:25)\n\tat Problem.main(tmpanitjacd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.zip(odd)\n        val evenAndOdd2\
    \ = evenAndOdd.filter(x => x._1 == x._2)\n        val evenAndOdd3 = evenAndOdd2.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd4 = evenAndOdd3.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd5 = evenAndOdd4.filter(x => x._1 == x._2)\n   \
    \     val evenAndOdd6 = evenAndOdd5.filter(x => x._1 == x._2)\n        val evenAndOdd7\
    \ = evenAndOdd6.filter(x => x._1 == x._2)\n        val evenAndOdd8 = evenAndOdd7.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd9 = evenAndOdd8.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd10 = evenAndOdd9.filter(x => x._1 == x._2)\n  \
    \      val evenAndOdd11 = evenAndOdd10.filter(x => x._1 == x._2)\n        val\
    \ evenAndOdd12 = evenAndOdd11.filter(x => x._1 == x._2)\n        val evenAndOdd13\
    \ = evenAndOdd12.filter(x => x._1 == x._2)\n        val evenAndOdd14 = evenAndOdd13.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd15 = evenAndOdd14.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd16 = evenAndOdd15.filter(x => x._1 == x._2)\n \
    \       val evenAndOdd17 = evenAndOdd16.filter(x => x._1 == x._2)\n        val\
    \ evenAndOdd18 = evenAndOdd17.filter(x => x._1 == x._2)\n        val evenAndOdd19\
    \ = evenAndOdd18.filter(x => x._1 == x._2)\n        val evenAndOdd20 = evenAndOdd19.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd21 = evenAndOdd20.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd22 = evenAndOdd21.filter(x => x._\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6him3w31.scala:41:54 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mevenAndOdd22\e[0m = evenAndOdd21.filter(\e\
    [36mx\e[0m => x._\n\e[31m\e[31m   |\e[0m                                     \
    \                 ^\e[0m\n\e[31m   |\e[0m                                   an\
    \ identifier expected, but '_' found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp6him3w31.scala:42:5 ---------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659794641
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst3 = lst1.toSet -- lst2.toSet\n        if (lst3.isEmpty) \"\" else \"\
    NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7kphvdav.scala:22)\n\tat Problem.main(tmp7kphvdav.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(x => x % 2 == 0).toList\n        val lst2Even = lst2.filter(x\
    \ => x % 2 == 0).toList\n        val lst1Odd = lst1.filter(x => x % 2 != 0).toList\n\
    \        val lst2Odd = lst2.filter(x => x % 2 != 0).toList\n        val lst1EvenAndOdd\
    \ = lst1Even ++ lst1Odd\n        val lst2EvenAndOdd = lst2Even ++ lst2Odd\n  \
    \      val lst1EvenAndOddAndNotBoth = lst1EvenAndOdd ++ lst2EvenAndOdd\n     \
    \   val lst2EvenAndOddAndNotBoth = lst2EvenAndOdd ++ lst1EvenAndOdd\n        val\
    \ lst1EvenAndOddAndNotBoth = lst1EvenAndOdd ++ lst2EvenAndOdd\n        val lst2EvenAndOddAndNotBoth\
    \ = lst2EvenAndOdd ++ lst1EvenAndOdd\n        val lst1EvenAndOddAndNotBoth = lst1EvenAndOdd\
    \ ++ lst2EvenAndOdd\n        val lst2EvenAndOddAndNotBoth = lst2EvenAndOdd ++\
    \ lst1EvenAndOdd\n        val lst1EvenAndOddAndNotBoth = lst1EvenAndOdd ++ lst2EvenAndOdd\n\
    \        val lst2EvenAndOddAndNotBoth = lst2EvenAndOdd ++ lst1EvenAndOdd\n   \
    \     val lst1EvenAndOddAndNotBoth = lst1EvenAndOdd ++ lst2EvenAndOdd\n      \
    \  val lst2EvenAndOddAndNotBoth = lst2EvenAndOdd ++ lst1EvenAndOdd\n        val\
    \ lst1EvenAndOddAndNotBoth = lst1EvenAndOdd ++ lst2EvenAndOdd\n        val lst2EvenAndOddAndNotBoth\
    \ = lst2EvenAndOdd ++ lst1EvenAndOdd\n        val lst1EvenAndOddAndNotBoth = lst1EvenAndOdd\
    \ ++ lst2EvenAndOdd\n        val lst2EvenAndOddAndNotBoth = lst2EvenAndOdd ++\
    \ lst1EvenAndOdd\n        val lst1EvenAndOddAndNotBoth = lst1EvenAndOdd ++ lst2EvenAndOdd\n\
    \        val lst2EvenAndOddAndNot\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe4gfda_h.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe4gfda_h.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlst1EvenAndOddAndNotBoth\e[0m = lst1EvenAndOdd ++ lst2EvenAndOdd\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlst1EvenAndOddAndNotBoth is already defined as \e[33mvalue\e\
    [0m \e[35mlst1EvenAndOddAndNotBoth\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe4gfda_h.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mlst2EvenAndOddAndNotBoth\e\
    [0m = lst2EvenAndOdd ++ lst1EvenAndOdd\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlst2EvenAndOddAndNotBoth is already defined as \e[33mvalue\e\
    [0m \e[35mlst2EvenAndOddAndNotBoth\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe4gfda_h.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlst1EvenAndOddAndNotBoth\e\
    [0m = lst1EvenAndOdd ++ lst2EvenAndOdd\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlst1EvenAndOddAndNotBoth is already defined as \e[33mvalue\e\
    [0m \e[35mlst1EvenAndOddAndNotBoth\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe4gfda_h.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mlst2EvenAndOddAndNotBoth\e\
    [0m = lst2EvenAndOdd ++ lst1EvenAndOdd\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659794694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: Write your code here\n        val lst3 = lst1.filter(_ % 2 == 0).sortWith(_\
    \ < _)\n        val lst4 = lst2.filter(_ % 2 == 0).sortWith(_ < _)\n        if(lst3.size\
    \ == lst4.size){\n            val lst5 = lst3.zip(lst4).filter(_._1 == _._2).map(_._1).sortWith(_\
    \ < _)\n            if(lst5.size == lst1.size){\n                val lst6 = lst5.zip(lst1).filter(_._1\
    \ == _._2).map(_._1).sortWith(_ < _)\n                if(lst6.size == lst2.size){\n\
    \                    if(lst6.forall(x => lst1.contains(x) && lst2.contains(x)))\
    \ \n                        \"YES\"\n                    else\n              \
    \          \"NO\"\n                }\n            }\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7aenxpx3.scala:22:47 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36mlst5\e[0m = lst3.zip(lst4).filter(_._1\
    \ == _._2).map(_._1).sortWith(_ < _)\n\e[31m\e[31m   |\e[0m                  \
    \                           ^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                 value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp7aenxpx3.scala:24:51 ------------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m                \e[33mval\e[0m \e[36mlst6\e[0m = lst5.zip(lst1).filter(_._1\
    \ == _._2).map(_._1).sortWith(_ < _)\n\e[31m\e[31m   |\e[0m                  \
    \                               ^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                     value _1 is not a member of Long\n\e[33m\e[33m-- [E129]\
    \ Potential Issue Warning: /tmp/tmp7aenxpx3.scala:27:24 ----------------\e[0m\e\
    [0m\n\e[33m27 |\e[0m                        \e[31m\"YES\"\e[0m\n\e[33m\e[33m \
    \  |\e[0m                        ^^^^^\e[0m\n\e[33m   |\e[0mA pure expression\
    \ does nothing in statement position; you may be omitting necessary parentheses\n\
    \e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmp7aenxpx3.scala:29:24\
    \ ----------------\e[0m\e[0m\n\e[33m29 |\e[0m                        \e[31m\"\
    NO\"\e[0m\n\e[33m\e[33m   |\e[0m                        ^^^^\e[0m\n\e[33m   |\e\
    [0mA pure expression does nothing in statement position; you may be omitting necessary\
    \ parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 warnings found\n2 errors found\n"
  stdout: ''
  timestamp: 1659794697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n        val lst1Even = lst1.filter(_ % 2 == 0)\n   \
    \     val lst2Even = lst2.filter(_ % 2 == 0)\n        val lst1Odd = lst1.filter(_\
    \ % 2 != 0)\n        val lst2Odd = lst2.filter(_ % 2 != 0)\n        val lst1EvenOdd\
    \ = lst1Even.zip(lst2Even).filter(_._1 == _._2)\n        val lst2EvenOdd = lst2Even.zip(lst1Even).filter(_._1\
    \ == _._2)\n        val lst1EvenOddOdd = lst1EvenOdd.zip(lst2EvenOdd).filter(_._1\
    \ == _._2)\n        val lst2EvenOddOdd = lst2EvenOdd.zip(lst1EvenOdd).filter(_._1\
    \ == _._2)\n        val lst1EvenOddOddOdd = lst1EvenOddOdd.zip(lst2EvenOddOdd).filter(_._1\
    \ == _._2)\n        val lst2EvenOddOddOdd = lst2EvenOddOdd.zip(lst1EvenOddOdd).filter(_._1\
    \ == _._2)\n        val lst1EvenOddOddOddOdd = lst1EvenOddOddOdd.zip(lst2EvenOddOddOdd).filter(_._1\
    \ == _._2)\n        val lst2EvenOddOddOddOdd = lst2EvenOddOddOdd.zip(lst1EvenOddOddOdd).filter(_._1\
    \ == _._2)\n        val lst1EvenOddOddOddOddOdd = lst1EvenOddOddOddOdd.zip(lst2EvenOddOddOdd).filter(_._1\
    \ == _._2)\n        val lst2EvenOddOddOddOddOdd = lst2EvenOddOddOddOdd.zip(lst1EvenOddOddOddOdd).filter(_._1\
    \ == _._2)\n        val lst1EvenOddOddOddOddOddOdd = lst1EvenOddOddOddOddOdd.zip(lst2EvenOddOddOddOdd).filter(_._1\
    \ == _._2)\n        val lst2EvenOddOddOddOddOddOdd = lst2EvenOddOdd\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv7bwrnz3.scala:23:58 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mlst1EvenOdd\e[0m = lst1Even.zip(lst2Even).filter(_._1\
    \ == _._2)\n\e[31m\e[31m   |\e[0m                                            \
    \            ^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \  value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv7bwrnz3.scala:24:58\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mlst2EvenOdd\e[0m = lst2Even.zip(lst1Even).filter(_._1 == _._2)\n\e[31m\e[31m\
    \   |\e[0m                                                        ^^^^\e[0m\n\e\
    [31m   |\e[0m                                        value _1 is not a member\
    \ of Long\n\e[31m\e[31m-- Error: /tmp/tmpv7bwrnz3.scala:31:89 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlst1EvenOddOddOddOddOdd\e\
    [0m = lst1EvenOddOddOddOdd.zip(lst2EvenOddOddOdd).filter(_._1 == _._2)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues of types (((Long,\
    \ Long), (Long, Long)), ((Long, Long), (Long, Long))) and ((Long, Long), (Long,\
    \ Long)) cannot be compared with == or !=.\n\e[31m   |\e[0mI found:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m    Tuple.canEqualTuple[\e[35mH1\e[0m, \e[35mT1\e[0m,\
    \ \e[35mH2\e[0m, \e[35mT2\e[0m](\n\e[31m   |\e[0m      Tuple.canEqualTuple[\e\
    [35mH1\e[0m, \e[35mT1\e[0m, \e[35mH2\e[0m, \e[35mT2\e[0m](/* missing */summon[CanEqual[H1,\
    \ H2]], ???\n\e[31m   |\e[0m        )\n\e[31m   |\e[0m    , ???)\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mBut no implicit values were found that match type CanEqual[H1,\
    \ H2].\n\e[31m\e[31m-- Error: /tmp/tmpv7bwrnz3.scala:33:98 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mlst1EvenOddOddOddOddOddOdd\e\
    [0m = lst1EvenOddOddOddOddOdd.zip(lst2EvenOddOddOddOdd).filter(_._1 == _._2)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues"
  stdout: ''
  timestamp: 1659794700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmy87r7wz.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m19 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794622
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.zip(odd)\n        val evenAndOddList\
    \ = evenAndOdd.toList\n        val evenAndOddList2 = evenAndOddList.map(x => x._1\
    \ + x._2)\n        val evenAndOddList3 = evenAndOddList2.filter(x => x % 2 ==\
    \ 0).toList\n        val evenAndOddList4 = evenAndOddList3.filter(x => x % 2 ==\
    \ 1).toList\n        val evenAndOddList5 = evenAndOddList4.map(x => x._1 + x._2)\n\
    \        val evenAndOddList6 = evenAndOddList5.filter(x => x % 2 == 0).toList\n\
    \        val evenAndOddList7 = evenAndOddList6.filter(x => x % 2 == 1).toList\n\
    \        val evenAndOddList8 = evenAndOddList7.map(x => x._1 + x._2)\n       \
    \ val evenAndOddList9 = evenAndOddList8.filter(x => x % 2 == 0).toList\n     \
    \   val evenAndOddList10 = evenAndOddList9.filter(x => x % 2 == 1).toList\n  \
    \      val evenAndOddList11 = evenAndOddList10.map(x => x._1 + x._2)\n       \
    \ val evenAndOddList12 = evenAndOddList11.filter(x => x % 2 == 0).toList\n   \
    \     val evenAndOddList13 = evenAndOddList12.filter(x => x % 2 == 1).toList\n\
    \        val evenAndOddList14 = evenAndOddList13.map(x => x._1 + x._2)\n     \
    \   val evenAndOddList15 = evenAndOddList14.filter(x => x % 2 == 0).toList\n \
    \       val evenAndOddList16 = evenAndOddList15.filter(x => x % 2 == 1).toList\n\
    \        val evenAndOddList17 = evenAndOddList16.map(x => x._1 + x._2)\n     \
    \   val evenAndOddList18 = evenAndOddList17.filter(x => x % 2 == 0).toList\n \
    \       val evenAndOddList19 = evenAndOddList18.filter(x => x % 2 == 1).toList\n\
    \        val evenAndOddList20 = evenAndOddList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5252einx.scala:25:57 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddList5\e[0m = evenAndOddList4.map(\e\
    [36mx\e[0m => x._1 + x._2)\n\e[31m\e[31m   |\e[0m                            \
    \                           ^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                 value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp5252einx.scala:26:60 ------------------------\e[0m\e[0m\n\
    \e[31m26 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddList6\e[0m = evenAndOddList5.filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).toList\n\e[31m\e[31m   |\e[0m\
    \                                                          ^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue % is not a member of Nothing, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5252einx.scala:27:60 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddList7\e[0m = evenAndOddList6.filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m1\e[0m).toList\n\e[31m\e[31m   |\e[0m\
    \                                                          ^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue % is not a member of Nothing, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m "
  stdout: ''
  timestamp: 1659794701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).toList\n        val odd = lst2.filter(_ %\
    \ 2 == 1).toList\n        val evenOdd = even.zip(odd).filter(_._1 == _._2)\n \
    \       if(evenOdd.isEmpty) \"NO\" else \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf9z343pf.scala:20:45 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mevenOdd\e[0m = even.zip(odd).filter(_._1\
    \ == _._2)\n\e[31m\e[31m   |\e[0m                                           ^^^^\e\
    [0m\n\e[31m   |\e[0m                                        value _1 is not a\
    \ member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659794695
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).length\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).length\n        if (even > odd) {\n            return \"NO\"\n\
    \        } else {\n            return \"YES\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbe8p9d4v.scala:28)\n\tat Problem.main(tmpbe8p9d4v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst3 = lst1.toSet\n        val lst4 = lst2.toSet\n\
    \        val lst5 = lst3.intersect(lst4)\n        val lst6 = lst5.toList\n   \
    \     if(lst6.forall(x => x % 2 == 0)){\n            return \"YES\"\n        }\n\
    \        else{\n            return \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuh7tk_rr.scala:31)\n\tat Problem.main(tmpuh7tk_rr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794703
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Size = lst1.size\n        val lst2Size = lst2.size\n        val lst1Even\
    \ = lst1.filter(x => x % 2 == 0).size\n        val lst2Even = lst2.filter(x =>\
    \ x % 2 == 0).size\n        val lst1Odd = lst1.filter(x => x % 2 != 0).size\n\
    \        val lst2Odd = lst2.filter(x => x % 2 != 0).size\n        val lst1EvenToOdd\
    \ = lst1.filter(x => x % 2 == 0).filter(x => x % 2 != 0).size\n        val lst2EvenToOdd\
    \ = lst2.filter(x => x % 2 == 0).filter(x => x % 2 != 0).size\n        val lst1OddToEven\
    \ = lst1.filter(x => x % 2 != 0).filter(x => x % 2 == 0).size\n        val lst2OddToEven\
    \ = lst2.filter(x => x % 2 != 0).filter(x => x % 2 == 0).size\n        val lst1EvenToOddToEven\
    \ = lst1.filter(x => x % 2 == 0).filter(x => x % 2 != 0).filter(x => x % 2 ==\
    \ 0).size\n        val lst2EvenToOddToEven = lst2.filter(x => x % 2 == 0).filter(x\
    \ => x % 2 != 0).filter(x => x % 2 == 0).size\n        val lst1OddToEvenToOdd\
    \ = lst1.filter(x => x % 2 != 0).filter(x => x % 2 == 0).filter(x => x % 2 !=\
    \ 0).size\n        val lst2OddToEvenToOdd = lst2.filter(x => x % 2 != 0).filter(x\
    \ => x % 2 == 0).filter(x => x % 2 != 0).size\n        val lst1EvenToOddToEvenToOdd\
    \ = lst1.filter(x => x % 2 == 0).filter(x => x % 2 != 0).filter(x => x % 2 ==\
    \ 0).filter(x => x % 2 != 0).size\n        val lst2EvenToOddToEvenToOdd = lst2.filter(x\
    \ => x % 2 == 0).filter(x => x % 2 != 0).filter(x => x % 2 == 0).filter(x => x\
    \ % 2 != 0).size\n        val lst1OddToEvenToOddToEven = lst1.filter(x => x %\
    \ 2 != 0).filter(x => x % 2 == 0).filter(x => x % 2 != 0).filter(x => x % 2 !=\
    \ 0).size\n        val lst2OddToEvenToOddToEven\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpl6dn45ww.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpl6dn45ww.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n        val lst3 = lst1 ++ lst2\n        val lst4 =\
    \ lst3.filter(_ % 2 == 0)\n        val lst5 = lst4.filter(_ % 2 == 0)\n      \
    \  if(lst5.isEmpty){\n            \"NO\"\n        }else{\n            \"YES\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfqtwv67.scala:30)\n\tat Problem.main(tmpnfqtwv67.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).length\n        val odd = lst2.filter(_ %\
    \ 2 == 1).length\n        if (even > odd) {\n            return \"NO\"\n     \
    \   } else if (even < odd) {\n            return \"YES\"\n        } else {\n \
    \           val evenList = lst1.filter(_ % 2 == 0).map(_.toLong)\n           \
    \ val oddList = lst2.filter(_ % 2 == 1).map(_.toLong)\n            val evenList2\
    \ = evenList.zip(oddList).filter(_._1 == _._2).map(_._1).distinct\n          \
    \  val oddList2 = evenList.zip(oddList).filter(_._1 == _._2).map(_._2).distinct\n\
    \            if (evenList2.length == evenList.length && oddList2.length == oddList.length)\
    \ {\n                return \"YES\"\n            } else {\n                return\
    \ \"NO\"\n            }\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp37rd2wph.scala:27:59 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mevenList2\e[0m = evenList.zip(oddList).filter(_._1\
    \ == _._2).map(_._1).distinct\n\e[31m\e[31m   |\e[0m                         \
    \                                ^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                      value _1 is not a member of Long\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp37rd2wph.scala:28:58 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36moddList2\e[0m = evenList.zip(oddList).filter(_._1\
    \ == _._2).map(_._2).distinct\n\e[31m\e[31m   |\e[0m                         \
    \                               ^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                     value _1 is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1659794707
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(x => x % 2 == 0).length\n        val lst2Even = lst2.filter(x\
    \ => x % 2 == 0).length\n        if(lst1Even == lst2Even){\n            return\
    \ \"YES\"\n        }else{\n            return \"NO\"\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9mmf3dm1.scala:30)\n\tat Problem.main(tmp9mmf3dm1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794712
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).length\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).length\n        if (even > odd) {\n            return \"NO\"\n\
    \        } else {\n            return \"YES\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbe8p9d4v.scala:28)\n\tat Problem.main(tmpbe8p9d4v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 0).toList\n        val evenodd = even.zip(odd).filter(_._1 == _._2).map(_._1).toSet\n\
    \        evenodd.size == lst1.size ? \"YES\" : \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsi2ra6cx.scala:20:45 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mevenodd\e[0m = even.zip(odd).filter(_._1\
    \ == _._2).map(_._1).toSet\n\e[31m\e[31m   |\e[0m                            \
    \               ^^^^\e[0m\n\e[31m   |\e[0m                                   \
    \     value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpsi2ra6cx.scala:21:34 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m        evenodd.size == lst1.size ? \e[31m\"YES\"\e[0m : \e[31m\"NO\"\e[0m\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                        value ? is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1659794710
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0)\n        val odd = lst2.filter(_ % 2 != 0)\n\
    \        val evenOdd = even.zip(odd)\n        val evenOddList = evenOdd.toList\n\
    \        val evenOddList2 = evenOddList.map(x => x._1 + x._2)\n        val evenOddList3\
    \ = evenOddList2.filter(_ % 2 == 0)\n        val evenOddList4 = evenOddList3.filter(_\
    \ % 2 != 0)\n        val evenOddList5 = evenOddList4.map(x => x._1 + x._2)\n \
    \       val evenOddList6 = evenOddList5.filter(_ % 2 == 0)\n        val evenOddList7\
    \ = evenOddList6.filter(_ % 2 != 0)\n        val evenOddList8 = evenOddList7.map(x\
    \ => x._1 + x._2)\n        val evenOddList9 = evenOddList8.filter(_ % 2 == 0)\n\
    \        val evenOddList10 = evenOddList9.filter(_ % 2 != 0)\n        val evenOddList11\
    \ = evenOddList10.map(x => x._1 + x._2)\n        val evenOddList12 = evenOddList11.filter(_\
    \ % 2 == 0)\n        val evenOddList13 = evenOddList12.filter(_ % 2 != 0)\n  \
    \      val evenOddList14 = evenOddList13.map(x => x._1 + x._2)\n        val evenOddList15\
    \ = evenOddList14.filter(_ % 2 == 0)\n        val evenOddList16 = evenOddList15.filter(_\
    \ % 2 != 0)\n        val evenOddList17 = evenOddList16.map(x => x._1 + x._2)\n\
    \        val evenOddList18 = evenOddList17.filter(_ % 2 == 0)\n        val evenOddList19\
    \ = evenOddList18.filter(_ % 2 != 0)\n        val evenOddList20 = evenOddList19.map(x\
    \ => x._1 + x._2)\n        val evenOddList21 = evenOddList20.filter(_ % 2 == 0)\n\
    \        val evenOddList22 = evenOddList21.filter(_ % 2 != 0)\n        val evenOddList23\
    \ = evenOddList22.map(x => x._1 + x._2)\n        val evenOddList24 = evenOddList23.filter(_\
    \ % 2 == \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpglv1d3zw.scala:44:57 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mevenOddList24\e[0m = evenOddList23.filter(_\
    \ % \e[31m2\e[0m == \n\e[31m\e[31m   |\e[0m                                  \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \         expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpglv1d3zw.scala:25:51 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mevenOddList5\e[0m = evenOddList4.map(\e\
    [36mx\e[0m => x._1 + x._2)\n\e[31m\e[31m   |\e[0m                            \
    \                     ^^^^\e[0m\n\e[31m   |\e[0m                             \
    \           value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpglv1d3zw.scala:26:49 ------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mevenOddList6\e[0m = evenOddList5.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                          ^^^\e[0m\n\e[31m   |\e[0mvalue % is not a member of\
    \ Nothing, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\
    \e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\
    \e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2double\n\
    \e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m  import Char.char2int\n\
    \e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpglv1d3zw.scala:27:49\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mevenOddList7\e[0m = evenOddList6.filter(_ % \e[31m2\e[0m != \e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                               ^^^\e[0m\n\
    \e[31m   |\e[0mvalue % is not a member of Nothing, but "
  stdout: ''
  timestamp: 1659794716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).length\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).length\n        if (even > odd) {\n            return \"NO\"\n\
    \        } else if (even < odd) {\n            return \"YES\"\n        } else\
    \ {\n            val lst3 = lst1.filter(x => x % 2 == 0).map(x => x -> lst2.filter(x\
    \ => x % 2 == 1).map(y => y -> x)).toList\n            val lst4 = lst2.filter(x\
    \ => x % 2 == 1).map(x => x -> lst1.filter(x => x % 2 == 0).map(y => y -> x)).toList\n\
    \            exchange(lst3, lst4)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk7g46q25.scala:27:21\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            exchange(lst3, lst4)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^\e[0m\n\e[31m   |\e[0m         \
    \            Found:    (lst3 : List[(Long, List[(Long, Long)])])\n\e[31m   |\e\
    [0m                     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpk7g46q25.scala:27:27 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            exchange(lst3, lst4)\n\e[31m\e[31m   |\e\
    [0m                           ^^^^\e[0m\n\e[31m   |\e[0m                     Found:\
    \    (lst4 : List[(Long, List[(Long, Long)])])\n\e[31m   |\e[0m              \
    \       Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794714
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).toList\n        val odd = lst2.filter(_ %\
    \ 2 == 1).toList\n        val evenOdd = even.zip(odd).filter(_._1 == _._2).toList\n\
    \        if(evenOdd.isEmpty) \"NO\" else \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpms2hssin.scala:20:45 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mevenOdd\e[0m = even.zip(odd).filter(_._1\
    \ == _._2).toList\n\e[31m\e[31m   |\e[0m                                     \
    \      ^^^^\e[0m\n\e[31m   |\e[0m                                        value\
    \ _1 is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659794712
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).size\n        val odd = lst2.filter(_ % 2\
    \ == 1).size\n        if (even == odd) {\n            val lst3 = lst1.filter(_\
    \ % 2 == 0).zip(lst2.filter(_ % 2 == 1))\n            val lst4 = lst3.filter(_._1\
    \ == 0).map(_._2)\n            val lst5 = lst3.filter(_._1 == 1).map(_._2)\n \
    \           val lst6 = lst4.filter(_._1 == 0).map(_._2)\n            val lst7\
    \ = lst4.filter(_._1 == 1).map(_._2)\n            val lst8 = lst5.filter(_._1\
    \ == 0).map(_._2)\n            val lst9 = lst5.filter(_._1 == 1).map(_._2)\n \
    \           val lst10 = lst6.filter(_._1 == 0).map(_._2)\n            val lst11\
    \ = lst6.filter(_._1 == 1).map(_._2)\n            val lst12 = lst7.filter(_._1\
    \ == 0).map(_._2)\n            val lst13 = lst7.filter(_._1 == 1).map(_._2)\n\
    \            val lst14 = lst8.filter(_._1 == 0).map(_._2)\n            val lst15\
    \ = lst8.filter(_._1 == 1).map(_._2)\n            val lst16 = lst9.filter(_._1\
    \ == 0).map(_._2)\n            val lst17 = lst9.filter(_._1 == 1).map(_._2)\n\
    \            val lst18 = lst10.filter(_._1 == 0).map(_._2)\n            val lst19\
    \ = lst10.filter(_._1 == 1).map(_._2)\n            val lst20 = lst11.filter(_._1\
    \ == 0).map(_._2)\n            val lst21 = lst11.filter(_._1 == 1).map(_._2)\n\
    \            val lst22 = lst12.filter(_._1 == 0).map(_._2)\n            val lst23\
    \ = lst12.filter(_._1 == 1).map(_._2)\n            val lst24 = lst13.filter(_._1\
    \ == 0).map(_._2)\n            val lst25 = lst13.filter(_._1 == 1).map(_._2)\n\
    \            val lst26 = lst14.filter(_._1 == 0).map(_._2)\n            val lst27\
    \ = lst14.filter(_._1 == 1).map(_._2)\n            val lst28 = lst15.filter(_._1\
    \ == 0).map(_._2)\n            val lst29 = lst15.filter(_._1 == 1).map(_._2)\n\
    \            val lst30 = lst16.filter(_._1 == 0).map(_._2)\n            val lst31\
    \ = lst16.filter(_._\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqib8qio3.scala:49:39 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m            \e[33mval\e[0m \e[36mlst31\e[0m = lst16.filter(_._\n\
    \e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m   |\e\
    [0m                                   an identifier expected, but '_' found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqib8qio3.scala:62:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m62 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpqib8qio3.scala:24:37 ------------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m            \e[33mval\e[0m \e[36mlst6\e[0m = lst4.filter(_._1 ==\
    \ \e[31m0\e[0m).map(_._2)\n\e[31m\e[31m   |\e[0m                             \
    \      ^^^^\e[0m\n\e[31m   |\e[0m                                   value _1 is\
    \ not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqib8qio3.scala:24:52\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m\
    \ \e[36mlst6\e[0m = lst4.filter(_._1 == \e[31m0\e[0m).map(_._2)\n\e[31m\e[31m\
    \   |\e[0m                                                  ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                        value _2 is not a member of\
    \ Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqib8qio3.scala:25:37 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mlst7\e[0m = lst4.filter(_._1\
    \ == \e[31m1\e[0m).map(_._2)\n\e[31m\e[31m   |\e[0m                          \
    \         ^^^^\e[0m\n\e[31m   |\e[0m                                   value _1\
    \ is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqib8qio3.scala:25:52\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m\
    \ \e[36mlst7\e[0m = lst4.filter(_._1 == \e[31m1\e[0m).map(_._2)\n\e[31m\e[31m\
    \   |\e[0m                                                  ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                        value _2 is not a member of\
    \ Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqib8qio3.scala:26:37 ----"
  stdout: ''
  timestamp: 1659794719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenOdd = even.zip(odd).filter(x => x._1\
    \ == x._2)\n        val evenOddList = evenOdd.map(x => x._1)\n        val evenOddList2\
    \ = evenOdd.map(x => x._2)\n        val evenOddList3 = evenOdd.map(x => x._1)\n\
    \        val evenOddList4 = evenOdd.map(x => x._2)\n        val evenOddList5 =\
    \ evenOdd.map(x => x._1)\n        val evenOddList6 = evenOdd.map(x => x._2)\n\
    \        val evenOddList7 = evenOdd.map(x => x._1)\n        val evenOddList8 =\
    \ evenOdd.map(x => x._2)\n        val evenOddList9 = evenOdd.map(x => x._1)\n\
    \        val evenOddList10 = evenOdd.map(x => x._2)\n        val evenOddList11\
    \ = evenOdd.map(x => x._1)\n        val evenOddList12 = evenOdd.map(x => x._2)\n\
    \        val evenOddList13 = evenOdd.map(x => x._1)\n        val evenOddList14\
    \ = evenOdd.map(x => x._2)\n        val evenOddList15 = evenOdd.map(x => x._1)\n\
    \        val evenOddList16 = evenOdd.map(x => x._2)\n        val evenOddList17\
    \ = evenOdd.map(x => x._1)\n        val evenOddList18 = evenOdd.map(x => x._2)\n\
    \        val evenOddList19 = evenOdd.map(x => x._1)\n        val evenOddList20\
    \ = evenOdd.map(x => x._2)\n        val evenOddList21 = evenOdd.map(x => x._1)\n\
    \        val evenOddList22 = evenOdd.map(x => x._2)\n        val evenOddList23\
    \ = evenOdd.map(x => x._1)\n        val evenOddList24 = evenOdd.map(x => x._2)\n\
    \        val evenOddList25 = evenOdd.map(x => x.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1kv1lrm2.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp1kv1lrm2.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(_ % 2 == 0)\n        val lst2Even = lst2.filter(_\
    \ % 2 == 0)\n        val lst1Odd = lst1.filter(_ % 2 != 0)\n        val lst2Odd\
    \ = lst2.filter(_ % 2 != 0)\n        val lst1EvenAndOdd = lst1Even.intersect(lst1Odd)\n\
    \        val lst2EvenAndOdd = lst2Even.intersect(lst2Odd)\n        val lst1EvenAndOddAndNotBoth\
    \ = lst1EvenAndOdd.filter(_ != lst2EvenAndOdd)\n        val lst2EvenAndOddAndNotBoth\
    \ = lst2EvenAndOdd.filter(_ != lst1EvenAndOdd)\n        if(lst1EvenAndOddAndNotBoth.isEmpty)\
    \ {\n            \"NO\"\n        } else if(lst2EvenAndOddAndNotBoth.isEmpty) {\n\
    \            \"YES\"\n        } else {\n            exchange(lst1EvenAndOddAndNotBoth,\
    \ lst2EvenAndOddAndNotBoth)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpjeon7meu.scala:24:61 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mlst1EvenAndOddAndNotBoth\e\
    [0m = lst1EvenAndOdd.filter(_ != lst2EvenAndOdd)\n\e[31m\e[31m   |\e[0m      \
    \                                                       ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpjeon7meu.scala:25:61 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mlst2EvenAndOddAndNotBoth\e\
    [0m = lst2EvenAndOdd.filter(_ != lst1EvenAndOdd)\n\e[31m\e[31m   |\e[0m      \
    \                                                       ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared\
    \ with == or !=\n2 errors found\n"
  stdout: ''
  timestamp: 1659794714
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenodd = even.zip(odd)\n        val evenoddlist\
    \ = evenodd.map(x => x._1 + x._2)\n        val evenoddlist2 = evenoddlist.filter(x\
    \ => x % 2 == 0)\n        val evenoddlist3 = evenoddlist2.filter(x => x % 2 ==\
    \ 1)\n        val evenoddlist4 = evenoddlist3.filter(x => x % 2 == 0)\n      \
    \  val evenoddlist5 = evenoddlist4.filter(x => x % 2 == 1)\n        val evenoddlist6\
    \ = evenoddlist5.filter(x => x % 2 == 0)\n        val evenoddlist7 = evenoddlist6.filter(x\
    \ => x % 2 == 1)\n        val evenoddlist8 = evenoddlist7.filter(x => x % 2 ==\
    \ 0)\n        val evenoddlist9 = evenoddlist8.filter(x => x % 2 == 1)\n      \
    \  val evenoddlist10 = evenoddlist9.filter(x => x % 2 == 0)\n        val evenoddlist11\
    \ = evenoddlist10.filter(x => x % 2 == 1)\n        val evenoddlist12 = evenoddlist11.filter(x\
    \ => x % 2 == 0)\n        val evenoddlist13 = evenoddlist12.filter(x => x % 2\
    \ == 1)\n        val evenoddlist14 = evenoddlist13.filter(x => x % 2 == 0)\n \
    \       val evenoddlist15 = evenoddlist14.filter(x => x % 2 == 1)\n        val\
    \ evenoddlist16 = evenoddlist15.filter(x => x % 2 == 0)\n        val evenoddlist17\
    \ = evenoddlist16.filter(x => x % 2 == 1)\n        val evenoddlist18 = evenoddlist17.filter(x\
    \ => x % 2 == 0)\n        val evenoddlist19 = evenoddlist18.filter(x => x % 2\
    \ == 1)\n        val evenoddlist20 = evenoddlist19.filter(x => x % 2 == 0)\n \
    \       val evenoddlist21 = evenoddlist20.filter(x => x % 2 == 1)\n        val\
    \ evenoddlist22 = evenoddlist21.filter(x => x % 2 == 0)\n        val evenoddlist23\
    \ = evenoddlist22.filter(x => x % 2 == 1)\n        val evenoddlist24 = evenoddlist23.filter(x\
    \ => x % 2 == 0)\n        val evenoddlist25 = evenoddlist24.filter(x => x % 2\
    \ == 1)\n        val evenoddlist26 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpiy99yyps.scala:46:27 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mevenoddlist26\e[0m = \n\e\
    [31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m        \
    \                   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiy99yyps.scala:47:5 ---------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659794713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(x => x % 2 == 0)\n        val lst2Even = lst2.filter(x\
    \ => x % 2 == 0)\n        val lst1Odd = lst1.filter(x => x % 2 != 0)\n       \
    \ val lst2Odd = lst2.filter(x => x % 2 != 0)\n        val lst1EvenAndOdd = lst1Even.intersect(lst1Odd)\n\
    \        val lst2EvenAndOdd = lst2Even.intersect(lst2Odd)\n        val lst1EvenAndOddAndEvenAndOdd\
    \ = lst1EvenAndOdd.intersect(lst2EvenAndOdd)\n        val lst1EvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = lst1EvenAndOddAndEvenAndOdd.intersect(lst2EvenAndOdd)\n        val lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = lst1EvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(lst2EvenAndOdd)\n     \
    \   val lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(lst2EvenAndOdd)\n\
    \        val lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(lst2EvenAndOdd)\n\
    \        val lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(lst2EvenAndOdd)\n\
    \        val lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = lst1EvenAndOddAndEvenAndOddAndEvenAnd\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6sxenlpx.scala:30:120 -----------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m = lst1EvenAndOddAndEvenAndOddAndEvenAnd\n\e[31m\e[31m   |\e[0m           \
    \                                                                            \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        Not found: lst1EvenAndOddAndEvenAndOddAndEvenAnd\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6sxenlpx.scala:31:5\
    \ ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Len = lst1.length\n        val lst2Len = lst2.length\n        val evenList\
    \ = lst1.filter(x => x % 2 == 0).toList\n        val oddList = lst1.filter(x =>\
    \ x % 2 != 0).toList\n        val evenListLen = evenList.length\n        val oddListLen\
    \ = oddList.length\n        val evenListSet = evenList.map(x => x.toLong).toSet\n\
    \        val oddListSet = oddList.map(x => x.toLong).toSet\n        val evenListSetLen\
    \ = evenListSet.size\n        val oddListSetLen = oddListSet.size\n        val\
    \ evenListSetDiff = evenListSet.diff(oddListSet)\n        val oddListSetDiff =\
    \ oddListSet.diff(evenListSet)\n        val evenListSetDiffLen = evenListSetDiff.size\n\
    \        val oddListSetDiffLen = oddListSetDiff.size\n        val evenListSetDiffLen\
    \ = evenListSetDiff.size\n        val oddListSetDiffLen = oddListSetDiff.size\n\
    \        val evenListSetDiffLen = evenListSetDiff.size\n        val oddListSetDiffLen\
    \ = oddListSetDiff.size\n        val evenListSetDiffLen = evenListSetDiff.size\n\
    \        val oddListSetDiffLen = oddListSetDiff.size\n        val evenListSetDiffLen\
    \ = evenListSetDiff.size\n        val oddListSetDiffLen = oddListSetDiff.size\n\
    \        val evenListSetDiffLen = evenListSetDiff.size\n        val oddListSetDiffLen\
    \ = oddListSetDiff.size\n        val evenListSetDiffLen = evenListSetDiff.size\n\
    \        val oddListSetDiffLen = oddListSetDiff.size\n        val evenListSetDiffLen\
    \ = evenListSetDiff.size\n        val oddListSetDiffLen = oddListSetDiff.size\n\
    \        val evenListSetDiffLen = evenListSetDiff.size\n        val oddListSetDiffLen\
    \ = oddListSetDiff.size\n        val evenListSetDiffLen = evenListSetDiff.size\n\
    \        val oddListSetDiffLen = oddListSetDiff.size\n        val evenListSetDiffLen\
    \ = evenListSetDiff.size\n        val oddListSetDiffLen = oddListSetDiff.size\n\
    \        val evenListSetDiffLen = evenListSetDiff.size\n        val oddListSetDiffLen\
    \ = oddListSetDiff.size\n        val evenListSetDiffLen = evenListSetDiff.size\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6ej8cmhd.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mevenListSetDiffLen\e[0m\
    \ = evenListSetDiff.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenListSetDiffLen is already defined as \e[33mvalue\e[0m\
    \ \e[35mevenListSetDiffLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6ej8cmhd.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36moddListSetDiffLen\e[0m =\
    \ oddListSetDiff.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moddListSetDiffLen is already defined as \e[33mvalue\e[0m \e\
    [35moddListSetDiffLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6ej8cmhd.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mevenListSetDiffLen\e[0m\
    \ = evenListSetDiff.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenListSetDiffLen is already defined as \e[33mvalue\e[0m\
    \ \e[35mevenListSetDiffLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6ej8cmhd.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36moddListSetDiffLen\e[0m =\
    \ oddListSetDiff.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moddListSetDiffLen is already defined as \e[33mvalue\e[0m \e\
    [35moddListSetDiffLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6ej8cmhd.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenListSetDiffLen\e[0m"
  stdout: ''
  timestamp: 1659794715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Size = lst1.size\n        val lst2Size = lst2.size\n        val lst1Even\
    \ = lst1.filter(x => x % 2 == 0).toList\n        val lst2Even = lst2.filter(x\
    \ => x % 2 == 0).toList\n        val lst1Odd = lst1.filter(x => x % 2 != 0).toList\n\
    \        val lst2Odd = lst2.filter(x => x % 2 != 0).toList\n        val lst1EvenSize\
    \ = lst1Even.size\n        val lst2EvenSize = lst2Even.size\n        val lst1OddSize\
    \ = lst1Odd.size\n        val lst2OddSize = lst2Odd.size\n        val lst1EvenEven\
    \ = lst1Even.intersect(lst2Even).toList\n        val lst1OddEven = lst1Odd.intersect(lst2Even).toList\n\
    \        val lst1EvenOdd = lst1Even.intersect(lst2Odd).toList\n        val lst1OddOdd\
    \ = lst1Odd.intersect(lst2Odd).toList\n        val lst1EvenEvenSize = lst1EvenEven.size\n\
    \        val lst1OddEvenSize = lst1OddEven.size\n        val lst1EvenOddSize =\
    \ lst1EvenOdd.size\n        val lst1OddOddSize = lst1OddOdd.size\n        val\
    \ lst1EvenEvenEven = lst1EvenEven.intersect(lst2Even).toList\n        val lst1EvenOddEven\
    \ = lst1EvenOdd.intersect(lst2Even).toList\n        val lst1OddEvenEven = lst1OddEven.intersect(lst2Odd).toList\n\
    \        val lst1OddOddEven = lst1OddOdd.intersect(lst2Odd).toList\n        val\
    \ lst1EvenEvenOdd = lst1EvenEven.intersect(lst2Odd).toList\n        val lst1EvenOddOdd\
    \ = lst1EvenOdd.intersect(lst2Odd).toList\n        val lst1OddEvenEven = lst1OddEven.intersect(lst2Even).toList\n\
    \        val lst1OddOddEven = lst1OddOdd.intersect(lst2Even).toList\n        val\
    \ lst1OddEvenOdd = lst1OddEven.intersect(lst\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv9tip9mi.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv9tip9mi.scala:42:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlst1OddEvenEven\e[0m = lst1OddEven.intersect(lst2Even).toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlst1OddEvenEven is already defined as \e[33mvalue\e[0m \e\
    [35mlst1OddEvenEven\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpv9tip9mi.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mlst1OddOddEven\e[0m = lst1OddOdd.intersect(lst2Even).toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlst1OddOddEven is already defined as \e[33mvalue\e[0m \e[35mlst1OddOddEven\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpv9tip9mi.scala:44:51 ------------------------\e[0m\e[0m\n\
    \e[31m44 |\e[0m        \e[33mval\e[0m \e[36mlst1OddEvenOdd\e[0m = lst1OddEven.intersect(lst\n\
    \e[31m\e[31m   |\e[0m                                                   ^^^\e\
    [0m\n\e[31m   |\e[0m                                                   Not found:\
    \ lst\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv9tip9mi.scala:45:5\
    \ ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659794717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst3 = lst1.filter(_ % 2 == 0)\n        val lst4 = lst2.filter(_ % 2 ==\
    \ 0)\n        val lst5 = lst3.filter(_ < lst4.length)\n        val lst6 = lst4.filter(_\
    \ < lst5.length)\n        val lst7 = lst5.filter(_ < lst6.length)\n        val\
    \ lst8 = lst6.filter(_ < lst7.length)\n        val lst9 = lst7.filter(_ < lst8.length)\n\
    \        val lst10 = lst8.filter(_ < lst9.length)\n        val lst11 = lst9.filter(_\
    \ < lst10.length)\n        val lst12 = lst10.filter(_ < lst11.length)\n      \
    \  val lst13 = lst11.filter(_ < lst12.length)\n        val lst14 = lst12.filter(_\
    \ < lst13.length)\n        val lst15 = lst13.filter(_ < lst14.length)\n      \
    \  val lst16 = lst14.filter(_ < lst15.length)\n        val lst17 = lst15.filter(_\
    \ < lst16.length)\n        val lst18 = lst16.filter(_ < lst17.length)\n      \
    \  val lst19 = lst17.filter(_ < lst18.length)\n        val lst20 = lst18.filter(_\
    \ < lst19.length)\n        val lst21 = lst19.filter(_ < lst20.length)\n      \
    \  val lst22 = lst20.filter(_ < lst21.length)\n        val lst23 = lst21.filter(_\
    \ < lst22.length)\n        val lst24 = lst22.filter(_ < lst23.length)\n      \
    \  val lst25 = lst23.filter(_ < lst24.length)\n        val lst26 = lst24.filter(_\
    \ < lst25.length)\n        val lst27 = lst25.filter(_ < lst26.length)\n      \
    \  val lst28 = lst26.filter(_ < lst27.length)\n        val lst29 = lst27.filter(_\
    \ < lst28.length)\n        val lst30 = lst28.filter(_ < lst29.length)\n      \
    \  val lst31 = lst29.filter(_ < lst30.length)\n        val lst32 = lst30.filter(_\
    \ < lst31.length)\n        val lst33 = lst31.filter(_ < lst32.length)\n      \
    \  val lst34 = lst32.filter(_ < lst33.length)\n        val lst35 = lst33.filter(_\
    \ < lst34.length)\n        val lst36 = lst34.filter(_ < lst35.length)\n      \
    \  val lst37 = lst35.filter(_ < lst36.length)\n        val lst38 = lst36.filter(_\
    \ < \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmph954pyfe.scala:53:36 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36mlst38\e[0m = lst36.filter(_\
    \ < \n\e[31m\e[31m   |\e[0m                                    ^\e[0m\n\e[31m\
    \   |\e[0m                                    expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph954pyfe.scala:54:5\
    \ ---------------------\e[0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(_ % 2 == 0).toList\n        val lst2Even = lst2.filter(_\
    \ % 2 == 0).toList\n        val lst1Odd = lst1.filter(_ % 2 != 0).toList\n   \
    \     val lst2Odd = lst2.filter(_ % 2 != 0).toList\n        val lst1EvenOdd =\
    \ lst1Even.zip(lst2Even).filter(_._1 == _._2).toList\n        val lst2EvenOdd\
    \ = lst2Even.zip(lst1Even).filter(_._1 == _._2).toList\n        val lst1EvenOddOdd\
    \ = lst1EvenOdd.zip(lst2EvenOdd).filter(_._1 == _._2).toList\n        val lst2EvenOddOdd\
    \ = lst2EvenOdd.zip(lst1EvenOdd).filter(_._1 == _._2).toList\n        val lst1EvenOddOddOdd\
    \ = lst1EvenOddOdd.zip(lst2EvenOddOdd).filter(_._1 == _._2).toList\n        val\
    \ lst2EvenOddOddOdd = lst2EvenOddOdd.zip(lst1EvenOddOdd).filter(_._1 == _._2).toList\n\
    \        val lst1EvenOddOddOddOdd = lst1EvenOddOddOdd.zip(lst2EvenOddOdd).filter(_._1\
    \ == _._2).toList\n        val lst2EvenOddOddOdd = lst2EvenOddOdd.zip(lst1EvenOddOdd).filter(_._1\
    \ == _._2).toList\n        val lst1EvenOddOddOddOdd = lst1EvenOddOddOdd.zip(lst2EvenOddOdd).filter(_._1\
    \ == _._2).toList\n        val lst2EvenOddOddOddOdd = lst2EvenOddOddOdd.zip(lst1EvenOddOdd).filter(_._1\
    \ == _._2).toList\n        val lst1EvenOddOddOddOddOdd = lst1EvenOddOddOddOdd.zip(lst2EvenOddOddOdd).filter(_._1\
    \ == _._2).toList\n        val lst2EvenOddOddOddOdd = lst2EvenOddOddOdd.zip(lst1EvenO\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo0qoouc8.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo0qoouc8.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlst2EvenOddOddOdd\e[0m = lst2EvenOddOdd.zip(lst1EvenOddOdd).filter(_._1\
    \ == _._2).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlst2EvenOddOddOdd is already defined as \e[33mvalue\e[0m \e\
    [35mlst2EvenOddOddOdd\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpo0qoouc8.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlst1EvenOddOddOddOdd\e[0m\
    \ = lst1EvenOddOddOdd.zip(lst2EvenOddOdd).filter(_._1 == _._2).toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlst1EvenOddOddOddOdd is already defined as \e[33mvalue\e[0m\
    \ \e[35mlst1EvenOddOddOddOdd\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpo0qoouc8.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mlst2EvenOddOddOddOdd\e[0m\
    \ = lst2EvenOddOddOdd.zip(lst1EvenO\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlst2EvenOddOddOddOdd is already defined as \e[33mvalue\e[0m\
    \ \e[35mlst2EvenOddOddOddOdd\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpo0qoouc8.scala:22:58 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mlst1EvenOdd\e[0m = lst1Even.zip(lst2Even).filter(_._1\
    \ == _._2).toList\n\e[31m\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659794723
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Copy = lst1.toList\n        val lst2Copy = lst2.toList\n        val\
    \ lst1Copy2 = lst1Copy.filter(_ % 2 == 0)\n        val lst2Copy2 = lst2Copy.filter(_\
    \ % 2 == 0)\n        val lst1Copy3 = lst1Copy2.filter(_ % 3 == 0)\n        val\
    \ lst2Copy3 = lst2Copy2.filter(_ % 3 == 0)\n        val lst1Copy4 = lst1Copy3.filter(_\
    \ % 4 == 0)\n        val lst2Copy4 = lst2Copy3.filter(_ % 4 == 0)\n        val\
    \ lst1Copy5 = lst1Copy4.filter(_ % 5 == 0)\n        val lst2Copy5 = lst2Copy4.filter(_\
    \ % 5 == 0)\n        val lst1Copy6 = lst1Copy5.filter(_ % 6 == 0)\n        val\
    \ lst2Copy6 = lst2Copy5.filter(_ % 6 == 0)\n        val lst1Copy7 = lst1Copy6.filter(_\
    \ % 7 == 0)\n        val lst2Copy7 = lst2Copy6.filter(_ % 7 == 0)\n        val\
    \ lst1Copy8 = lst1Copy7.filter(_ % 8 == 0)\n        val lst2Copy8 = lst2Copy7.filter(_\
    \ % 8 == 0)\n        val lst1Copy9 = lst1Copy8.filter(_ % 9 == 0)\n        val\
    \ lst2Copy9 = lst2Copy8.filter(_ % 9 == 0)\n        val lst1Copy10 = lst1Copy9.filter(_\
    \ % 10 == 0)\n        val lst2Copy10 = lst2Copy9.filter(_ % 10 == 0)\n       \
    \ val lst1Copy11 = lst1Copy10.filter(_ % 11 == 0)\n        val lst2Copy11 = lst2Copy10.filter(_\
    \ % 11 == 0)\n        val lst1Copy12 = lst1Copy11.filter(_ % 12 == 0)\n      \
    \  val lst2Copy12 = lst2Copy11.filter(_ % 12 == 0)\n        val lst1Copy13 = lst1Copy12.filter(_\
    \ % 13 == 0)\n        val lst2Copy13 = lst2Copy12.filter(_ % 13 == 0)\n      \
    \  val lst1Copy14 = lst1Copy13.filter(_ % 14 == 0)\n        val lst2Copy14 = lst2Copy13.filter(_\
    \ % 14 == 0)\n        val lst1Copy15 = lst1Copy14.filter(_ % 15 == 0)\n      \
    \  val lst2Copy15 = lst2Copy14.filter(_ % 15 == 0)\n        val lst1Copy16 = lst1Copy15.filter\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpta9k46gf.scala:49:5\
    \ ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794719
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).length\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).length\n        if (even > odd) {\n            return \"NO\"\n\
    \        }\n        else {\n            return \"YES\"\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8z7h03_e.scala:29)\n\tat Problem.main(tmp8z7h03_e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794646
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenodd = even.zip(odd).filter(x => x._1\
    \ == x._2)\n        val evenoddlist = evenodd.map(x => x._1)\n        val evenoddlist2\
    \ = evenodd.map(x => x._2)\n        val evenoddlist3 = evenodd.map(x => x._1)\n\
    \        val evenoddlist4 = evenodd.map(x => x._2)\n        val evenoddlist5 =\
    \ evenodd.map(x => x._1)\n        val evenoddlist6 = evenodd.map(x => x._2)\n\
    \        val evenoddlist7 = evenodd.map(x => x._1)\n        val evenoddlist8 =\
    \ evenodd.map(x => x._2)\n        val evenoddlist9 = evenodd.map(x => x._1)\n\
    \        val evenoddlist10 = evenodd.map(x => x._2)\n        val evenoddlist11\
    \ = evenodd.map(x => x._1)\n        val evenoddlist12 = evenodd.map(x => x._2)\n\
    \        val evenoddlist13 = evenodd.map(x => x._1)\n        val evenoddlist14\
    \ = evenodd.map(x => x._2)\n        val evenoddlist15 = evenodd.map(x => x._1)\n\
    \        val evenoddlist16 = evenodd.map(x => x._2)\n        val evenoddlist17\
    \ = evenodd.map(x => x._1)\n        val evenoddlist18 = evenodd.map(x => x._2)\n\
    \        val evenoddlist19 = evenodd.map(x => x._1)\n        val evenoddlist20\
    \ = evenodd.map(x => x._2)\n        val evenoddlist21 = evenodd.map(x => x._1)\n\
    \        val evenoddlist22 = evenodd.map(x => x._2)\n        val evenoddlist23\
    \ = evenodd.map(x => x._1)\n        val evenoddlist24 = evenodd.map(x => x._2)\n\
    \        val evenoddlist25 = evenodd.map(x => x._1)\n        val evenoddlist26\
    \ = evenodd.map(x => x._2)\n        val evenoddlist27 = evenodd.map(x => x._1)\n\
    \        val evenoddlist28 = evenodd.map(x => x.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc0yup_oo.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpc0yup_oo.scala:49:5 ---------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794719
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val evens = lst1.filter(x => x % 2 == 0).toList\n        val odds = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evensAndOdds = evens ++ odds\n        val\
    \ evensAndOddsSet = evensAndOdds.toSet\n        val evensAndOddsSetSize = evensAndOddsSet.size\n\
    \        val evensAndOddsSetIsAllEven = evensAndOddsSetSize == evensAndOddsSet.size\n\
    \        if(evensAndOddsSetIsAllEven) {\n            return \"YES\"\n        }\n\
    \        else {\n            return \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7ioxuv56.scala:33)\n\tat Problem.main(tmp7ioxuv56.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794723
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst3 = lst1.toSet\n        val lst4 = lst2.toSet\n\
    \        val lst5 = lst3.intersect(lst4)\n        val lst6 = lst5.toList\n   \
    \     val lst7 = lst6.filter(_%2==0)\n        val lst8 = lst7.filter(_%2==0)\n\
    \        if(lst8.isEmpty)\n            \"YES\"\n        else\n            \"NO\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoul5fo8f.scala:31)\n\tat Problem.main(tmpoul5fo8f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794725
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even ++ odd\n        val evenAndEven\
    \ = even ++ even\n        val evenAndOddAndEven = evenAndEven ++ evenAndOdd\n\
    \        val evenAndOddAndOdd = evenAndEven ++ oddAndOdd\n        val evenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEven ++ evenAndOddAndOdd\n        val evenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOdd ++ evenAndOddAndEvenAndOdd\n        val evenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEven ++ evenAndOddAndEvenAndOddAndEvenAndOdd\n \
    \       val evenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ ++ evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd ++ evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ ++ evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\n        val\
    \ evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ ++ evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\n \
    \       val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndO\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxylu92p4.scala:23:46 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddAndOdd\e[0m =\
    \ evenAndEven ++ oddAndOdd\n\e[31m\e[31m   |\e[0m                            \
    \                  ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \                   Not found: oddAndOdd\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpxylu92p4.scala:26:85 ---------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m = evenAndOddAndEvenAndOddAndEven ++ evenAndOddAndEvenAndOddAndEvenAndOdd\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                             ^\e[0m\n\e[31m   |\e[0m         Recursive \e[33mvalue\e\
    [0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOdd\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxylu92p4.scala:27:58 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e\
    [0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEven ++ evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^\e[0m\n\e[31m   |\e[0m  Recursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxylu92p4.scala:28:64\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ ++ evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\n\e[31m\e[31m  \
    \ |\e[0m                                                                ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m needs type\n\e[31"
  stdout: ''
  timestamp: 1659794723
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Size = lst1.size\n        val lst2Size = lst2.size\n        val evenList\
    \ = lst1.filter(x => x % 2 == 0)\n        val oddList = lst1.filter(x => x % 2\
    \ != 0)\n        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenListSize = evenList.size\n        val oddListSize = odd\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpps397i9z.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mevenListSize\e[0m = evenList.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mevenListSize is already defined as \e[33mvalue\e[0m \e[35mevenListSize\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpps397i9z.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36moddListSize\e[0m = oddList.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0moddListSize\
    \ is already defined as \e[33mvalue\e[0m \e[35moddListSize\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpps397i9z.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenListSize\e[0m = evenList.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenListSize is already defined as \e[33mvalue\e[0m \e[35mevenListSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpps397i9z.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36moddListSize\e[0m = oddList.size\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0moddListSize\
    \ is already defined as \e[33mvalue\e[0m \e[35moddListSize\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpps397i9z.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenListSize\e[0m = evenList.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenListSize is already defined as \e[33mvalue\e[0m \e[35mevenListSi"
  stdout: ''
  timestamp: 1659794723
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0)\n        val odd = lst1.filter(_ % 2 != 0)\n\
    \        val even2 = lst2.filter(_ % 2 == 0)\n        val odd2 = lst2.filter(_\
    \ % 2 != 0)\n        if (even.size == 0 && odd.size == 0 && even2.size == 0 &&\
    \ odd2.size == 0) \"NO\"\n        else if (even.size == 0 && odd.size == 0 &&\
    \ even2.size == 0 && odd2.size == 0) \"YES\"\n        else if (even.size == 0\
    \ && odd.size == 0 && even2.size == 0 && odd2.size == 0) \"NO\"\n        else\
    \ if (even.size == 0 && odd.size == 0 && even2.size == 0 && odd2.size == 0) \"\
    NO\"\n        else if (even.size == 0 && odd.size == 0 && even2.size == 0 && odd2.size\
    \ == 0) \"NO\"\n        else if (even.size == 0 && odd.size == 0 && even2.size\
    \ == 0 && odd2.size == 0) \"NO\"\n        else if (even.size == 0 && odd.size\
    \ == 0 && even2.size == 0 && odd2.size == 0) \"NO\"\n        else if (even.size\
    \ == 0 && odd.size == 0 && even2.size == 0 && odd2.size == 0) \"NO\"\n       \
    \ else if (even.size == 0 && odd.size == 0 && even2.size == 0 && odd2.size ==\
    \ 0) \"NO\"\n        else if (even.size == 0 && odd.size == 0 && even2.size ==\
    \ 0 && odd2.size == 0) \"NO\"\n        else if (even.size == 0 && odd.size ==\
    \ 0 && even2.size == 0 && odd2.size == 0) \"NO\"\n        else if (even.size ==\
    \ 0 && odd.size == 0 && even2.size == 0 && odd2.size == 0) \"NO\"\n        else\
    \ if (even.size == 0 && odd.size == 0 && even2.size == 0 && odd2.size == 0) \"\
    NO\"\n        else if (even.size == 0 && odd.size == 0 && even2.size == 0 && odd2.size\
    \ == 0) \"NO\"\n        else if (even.size == 0 && odd.size == 0 && even2.size\
    \ == 0 && odd2.size == 0) \"NO\"\n        else if (even.size == 0 && odd.size\
    \ == 0 && even2.size == 0 && odd2.size == 0) \"NO\"\n        else if (even.size\
    \ == 0 && odd.size == 0 && even2.size == 0 && odd2.size == 0) \"NO\"\n       \
    \ else if (even.size == 0 && odd.size == 0 && even2.size == 0 && odd2.size ==\
    \ 0) \"NO\"\n        else if (even.size == 0 && odd.size == 0 && even2.size ==\
    \ 0 && odd2.size == 0) \"NO\"\n        else if (even.size == 0 && odd.size ==\
    \ 0 && even2.size == 0 && odd2.size == 0) \"NO\"\n        else if (even.size ==\
    \ 0 && odd.size == 0 && even2.size == 0 && odd2.size == 0) \"NO\"\n        else\
    \ if (even.size == 0 && odd.size == 0 && even2.size == 0 && odd2.size == 0) \"\
    NO\"\n\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph41i5uly.scala:43:13\
    \ --------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (even.size == \e[31m0\e[0m && odd.size == \e[31m0\e[0m && even2.size == \e\
    [31m0\e[0m && odd2.size == \e[31m0\e[0m) \e[31m\"NO\"\e[0m\n\e[31m\e[31m   |\e\
    [0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    Unit\n\e[31m   |\e[0m             Required:\
    \ String\n\e[31m   |\e[0m             Maybe you are missing an else part for the\
    \ conditional?\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794720
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.intersect(odd)\n      \
    \  val evenAndOddAndEven = evenAndOdd.intersect(even)\n        if (evenAndOddAndEven.isEmpty)\
    \ {\n            \"NO\"\n        } else {\n            \"YES\"\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptg8mbcz6.scala:29)\n\tat Problem.main(tmptg8mbcz6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794729
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: Write your code here\n        val even = lst1.filter(x => x % 2 ==\
    \ 0).length\n        val odd = lst2.filter(x => x % 2 == 1).length\n        if\
    \ (even > odd) {\n            return \"NO\"\n        } else {\n            return\
    \ \"YES\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyngdy2_t.scala:29)\n\tat Problem.main(tmpyngdy2_t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794731
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst3 = lst1.toSet.intersect(lst2.toSet)\n        if(lst3.isEmpty) \"\" else\
    \ \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmend8t07.scala:22)\n\tat Problem.main(tmpmend8t07.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Copy = lst1.toList\n        val lst2Copy = lst2.toList\n        val\
    \ evenList = lst1Copy.filter(x => x % 2 == 0)\n        val oddList = lst1Copy.filter(x\
    \ => x % 2 != 0)\n        val evenList2 = lst2Copy.filter(x => x % 2 == 0)\n \
    \       val oddList2 = lst2Copy.filter(x => x % 2 != 0)\n        val evenList3\
    \ = evenList.zip(oddList).filter(x => x._1 == x._2)\n        val oddList3 = evenList.zip(oddList).filter(x\
    \ => x._1 != x._2)\n        val evenList4 = evenList2.zip(oddList2).filter(x =>\
    \ x._1 == x._2)\n        val oddList4 = evenList2.zip(oddList2).filter(x => x._1\
    \ != x._2)\n        val evenList5 = evenList3.zip(oddList3).filter(x => x._1 ==\
    \ x._2)\n        val oddList5 = evenList3.zip(oddList3).filter(x => x._1 != x._2)\n\
    \        val evenList6 = evenList4.zip(oddList4).filter(x => x._1 == x._2)\n \
    \       val oddList6 = evenList4.zip(oddList4).filter(x => x._1 != x._2)\n   \
    \     val evenList7 = evenList5.zip(oddList5).filter(x => x._1 == x._2)\n    \
    \    val oddList7 = evenList5.zip(oddList5).filter(x => x._1 != x._2)\n      \
    \  val evenList8 = evenList6.zip(oddList6).filter(x => x._1 == x._2)\n       \
    \ val oddList8 = evenList6.zip(oddList6).filter(x => x._1 != x._2)\n        val\
    \ evenList9 = evenList7.zip(oddList7).filter(x => x._1 == x._2)\n        val oddList9\
    \ = evenList7.zip(oddList7).filter(x => x._1 != x._2)\n        val evenList10\
    \ = evenList8.zip(oddList8).filter(x => x._1 == x._2)\n        val oddList10 =\
    \ evenList8.zip(oddList8).filter(x => x._1 != x._2)\n        val evenList11 =\
    \ evenList9.zip(oddList9).filter(x => x._1 == x._2)\n        val oddList11 = evenList9.zip(oddList9).filter(x\
    \ => x._1 != x._2)\n        val evenList12 = evenList10.zip(oddList10).filter(x\
    \ => \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfu1os4_q.scala:42:62 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mevenList12\e[0m = evenList10.zip(oddList10).filter(\e\
    [36mx\e[0m => \n\e[31m\e[31m   |\e[0m                                        \
    \                      ^\e[0m\n\e[31m   |\e[0m                               \
    \        expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpfu1os4_q.scala:43:5 ---------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659794732
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even ++ odd\n        val evenAndOddSet\
    \ = evenAndOdd.toSet\n        if(evenAndOddSet.size == lst1.size)\n          \
    \  \"YES\"\n        else\n            \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplppdl3cc.scala:31)\n\tat Problem.main(tmplppdl3cc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794736
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.intersect(odd)\n      \
    \  val evenAndOddIsEven = evenAndOdd.filter(x => x % 2 == 0).toList.isEmpty\n\
    \        if (evenAndOddIsEven) {\n            return \"YES\"\n        } else {\n\
    \            return \"NO\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxe7s1c9b.scala:30)\n\tat Problem.main(tmpxe7s1c9b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794736
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenOdd = even.zip(odd).filter(x => x._1\
    \ == x._2)\n        val evenOddList = evenOdd.map(x => x._1)\n        val evenOddList2\
    \ = evenOdd.map(x => x._2)\n        val evenOddList3 = evenOdd.map(x => x._1)\n\
    \        val evenOddList4 = evenOdd.map(x => x._2)\n        val evenOddList5 =\
    \ evenOdd.map(x => x._1)\n        val evenOddList6 = evenOdd.map(x => x._2)\n\
    \        val evenOddList7 = evenOdd.map(x => x._1)\n        val evenOddList8 =\
    \ evenOdd.map(x => x._2)\n        val evenOddList9 = evenOdd.map(x => x._1)\n\
    \        val evenOddList10 = evenOdd.map(x => x._2)\n        val evenOddList11\
    \ = evenOdd.map(x => x._1)\n        val evenOddList12 = evenOdd.map(x => x._2)\n\
    \        val evenOddList13 = evenOdd.map(x => x._1)\n        val evenOddList14\
    \ = evenOdd.map(x => x._2)\n        val evenOddList15 = evenOdd.map(x => x._1)\n\
    \        val evenOddList16 = evenOdd.map(x => x._2)\n        val evenOddList17\
    \ = evenOdd.map(x => x._1)\n        val evenOddList18 = evenOdd.map(x => x._2)\n\
    \        val evenOddList19 = evenOdd.map(x => x._1)\n        val evenOddList20\
    \ = evenOdd.map(x => x._2)\n        val evenOddList21 = evenOdd.map(x => x._1)\n\
    \        val evenOddList22 = evenOdd.map(x => x._2)\n        val evenOddList23\
    \ = evenOdd.map(x => x._1)\n        val evenOddList24 = evenOdd.map(x => x._2)\n\
    \        val evenOddList25 = evenOdd.map(x => x.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1kv1lrm2.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp1kv1lrm2.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794624
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Copy = lst1.toList\n        val lst2Copy\
    \ = lst2.toList\n        val even = lst1Copy.filter(x => x % 2 == 0).toList\n\
    \        val odd = lst2Copy.filter(x => x % 2 == 1).toList\n        val evenAndOdd\
    \ = even.intersect(odd)\n        if (evenAndOdd.isEmpty) {\n            return\
    \ \"NO\"\n        } else {\n            return \"YES\"\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxwrvehhk.scala:31)\n\tat Problem.main(tmpxwrvehhk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenOdd = even.zip(odd).filter(x => x._1\
    \ == x._2)\n        val evenOddList = evenOdd.map(x => x._1).distinct\n      \
    \  val evenOddList2 = evenOdd.map(x => x._2).distinct\n        val evenOddList3\
    \ = evenOdd.map(x => x._1).distinct\n        val evenOddList4 = evenOdd.map(x\
    \ => x._2).distinct\n        val evenOddList5 = evenOdd.map(x => x._1).distinct\n\
    \        val evenOddList6 = evenOdd.map(x => x._2).distinct\n        val evenOddList7\
    \ = evenOdd.map(x => x._1).distinct\n        val evenOddList8 = evenOdd.map(x\
    \ => x._2).distinct\n        val evenOddList9 = evenOdd.map(x => x._1).distinct\n\
    \        val evenOddList10 = evenOdd.map(x => x._2).distinct\n        val evenOddList11\
    \ = evenOdd.map(x => x._1).distinct\n        val evenOddList12 = evenOdd.map(x\
    \ => x._2).distinct\n        val evenOddList13 = evenOdd.map(x => x._1).distinct\n\
    \        val evenOddList14 = evenOdd.map(x => x._2).distinct\n        val evenOddList15\
    \ = evenOdd.map(x => x._1).distinct\n        val evenOddList16 = evenOdd.map(x\
    \ => x._2).distinct\n        val evenOddList17 = evenOdd.map(x => x._1).distinct\n\
    \        val evenOddList18 = evenOdd.map(x => x._2).distinct\n        val evenOddList19\
    \ = evenOdd.map(x => x._1).distinct\n        val evenOddList20 = evenOdd.map(x\
    \ => x._2).distinct\n        val evenOddList21 = evenOdd.map(x => x._1).distinct\n\
    \        val evenOddList22 = evenOdd.map(x => x._2).distinct\n        val evenOddList23\
    \ = evenOdd.map(x => x._1).distinct\n        val evenOddList24 = evenOdd.\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuea98clb.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpuea98clb.scala:45:5 ---------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794735
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0)\n        val odd = lst2.filter(x =>\
    \ x % 2 == 1)\n        val evenAndOdd = even.intersect(odd)\n        if (evenAndOdd.isEmpty)\
    \ \"NO\" else \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpycktm1ds.scala:24)\n\tat Problem.main(tmpycktm1ds.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.zip(odd)\n        val evenAndOddList\
    \ = evenAndOdd.toList\n        val evenAndOddList2 = evenAndOddList.filter(x =>\
    \ x._1 == x._2)\n        val evenAndOddList3 = evenAndOddList2.toList\n      \
    \  val evenAndOddList4 = evenAndOddList3.filter(x => x._1 == x._2)\n        val\
    \ evenAndOddList5 = evenAndOddList4.toList\n        val evenAndOddList6 = evenAndOddList5.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddList7 = evenAndOddList6.toList\n   \
    \     val evenAndOddList8 = evenAndOddList7.filter(x => x._1 == x._2)\n      \
    \  val evenAndOddList9 = evenAndOddList8.toList\n        val evenAndOddList10\
    \ = evenAndOddList9.toList\n        val evenAndOddList11 = evenAndOddList10.toList\n\
    \        val evenAndOddList12 = evenAndOddList11.toList\n        val evenAndOddList13\
    \ = evenAndOddList12.toList\n        val evenAndOddList14 = evenAndOddList13.toList\n\
    \        val evenAndOddList15 = evenAndOddList14.toList\n        val evenAndOddList16\
    \ = evenAndOddList15.toList\n        val evenAndOddList17 = evenAndOddList16.toList\n\
    \        val evenAndOddList18 = evenAndOddList17.toList\n        val evenAndOddList19\
    \ = evenAndOddList18.toList\n        val evenAndOddList20 = evenAndOddList19.toList\n\
    \        val evenAndOddList21 = evenAndOddList20.toList\n        val evenAndOddList22\
    \ = evenAndOddList21.toList\n        val evenAndOddList23 = evenAndOddList22.toList\n\
    \        val evenAndOddList24 = evenAndOddList23.toList\n        val evenAndOddList25\
    \ = evenAndOddList24.toList\n        val evenAnd\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx99sjm91.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpx99sjm91.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794734
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Copy = lst1.toList\n        val lst2Copy\
    \ = lst2.toList\n        val lst1Copy2 = lst1Copy.filter(_ % 2 == 0)\n       \
    \ val lst2Copy2 = lst2Copy.filter(_ % 2 == 0)\n        val lst1Copy3 = lst1Copy2.filter(_\
    \ % 3 == 0)\n        val lst2Copy3 = lst2Copy2.filter(_ % 3 == 0)\n        val\
    \ lst1Copy4 = lst1Copy3.filter(_ % 4 == 0)\n        val lst2Copy4 = lst2Copy3.filter(_\
    \ % 4 == 0)\n        val lst1Copy5 = lst1Copy4.filter(_ % 5 == 0)\n        val\
    \ lst2Copy5 = lst2Copy4.filter(_ % 5 == 0)\n        val lst1Copy6 = lst1Copy5.filter(_\
    \ % 6 == 0)\n        val lst2Copy6 = lst2Copy5.filter(_ % 6 == 0)\n        val\
    \ lst1Copy7 = lst1Copy6.filter(_ % 7 == 0)\n        val lst2Copy7 = lst2Copy6.filter(_\
    \ % 7 == 0)\n        val lst1Copy8 = lst1Copy7.filter(_ % 8 == 0)\n        val\
    \ lst2Copy8 = lst2Copy7.filter(_ % 8 == 0)\n        val lst1Copy9 = lst1Copy8.filter(_\
    \ % 9 == 0)\n        val lst2Copy9 = lst2Copy8.filter(_ % 9 == 0)\n        val\
    \ lst1Copy10 = lst1Copy9.filter(_ % 10 == 0)\n        val lst2Copy10 = lst2Copy9.filter(_\
    \ % 10 == 0)\n        val lst1Copy11 = lst1Copy10.filter(_ % 11 == 0)\n      \
    \  val lst2Copy11 = lst2Copy10.filter(_ % 11 == 0)\n        val lst1Copy12 = lst1Copy11.filter(_\
    \ % 12 == 0)\n        val lst2Copy12 = lst2Copy11.filter(_ % 12 == 0)\n      \
    \  val lst1Copy13 = lst1Copy12.filter(_ % 13 == 0)\n        val lst2Copy13 = lst2Copy12.filter(_\
    \ % 13 == 0)\n        val lst1Copy14 = lst1Copy13.filter(_ % 14 == 0)\n      \
    \  val lst2Copy14 = lst2Copy13.filter(_ % 14 == 0)\n        val lst1Copy15 = lst1Copy14.filter(_\
    \ % 15 == 0)\n        val lst2Copy15 = lst2Copy14.filter(_ % 15 == 0)\n      \
    \  val lst1Copy16 = \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpaqqb4vub.scala:49:24 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mlst1Copy16\e[0m = \n\e[31m\e\
    [31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                 \
    \       expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpaqqb4vub.scala:50:5 ---------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659794737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).toList\n        val odd = lst2.filter(_ %\
    \ 2 == 1).toList\n        val evenAndOdd = even ++ odd\n        val evenAndOddSet\
    \ = evenAndOdd.toSet\n        val evenAndOddSetSize = evenAndOddSet.size\n   \
    \     val evenAndOddSetIterator = evenAndOddSet.iterator\n        val evenAndOddSetIteratorSize\
    \ = evenAndOddSetIterator.size\n        val evenAndOddSetIteratorIterator = evenAndOddSetIterator.iterator\n\
    \        val evenAndOddSetIteratorIteratorSize = evenAndOddSetIteratorIterator.size\n\
    \        val evenAndOddSetIteratorIteratorIterator = evenAndOddSetIteratorIterator.iterator\n\
    \        val evenAndOddSetIteratorIteratorIteratorSize = evenAndOddSetIteratorIteratorIterator.size\n\
    \        val evenAndOddSetIteratorIteratorIteratorIterator = evenAndOddSetIteratorIteratorIterator.iterator\n\
    \        val evenAndOddSetIteratorIteratorIteratorIteratorSize = evenAndOddSetIteratorIteratorIteratorIterator.size\n\
    \        val evenAndOddSetIteratorIteratorIteratorIteratorIterator = evenAndOddSetIteratorIteratorIteratorIterator.iterator\n\
    \        val evenAndOddSetIteratorIteratorIteratorIteratorIteratorSize = evenAndOddSetIteratorIteratorIteratorIteratorIterator.size\n\
    \        val evenAndOddSetIteratorIteratorIteratorIteratorIteratorIterator = evenAndOddSetIteratorIteratorIteratorIteratorIterator.iterator\n\
    \        val evenAndOddSetIteratorIteratorIteratorIteratorIteratorIteratorSize\
    \ = evenAndOddSetIteratorIteratorIteratorIteratorIteratorIterator.size\n     \
    \   val evenAndOddSetIteratorIteratorIteratorIteratorIteratorIteratorIterator\
    \ = evenAndOddSetIteratorIteratorIteratorIteratorIteratorIterator.iterator\n \
    \       val evenAndOddSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\
    \ = evenAndOddSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n\
    \        val evenAndOddSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\
    \ = evenAndOddSetIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n\
    \        val evenAndOddSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\
    \ = evenAndOddSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n\
    \        val evenAndOddSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\
    \ = evenAndOddSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n\
    \        val evenAndOddSetIteratorIteratorIteratorIterator\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7pvng9t2.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7pvng9t2.scala:36:96\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\e\
    [0m = evenAndOddSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7pvng9t2.scala:41:5\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659794737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.zip(odd)\n        val evenAndOddList\
    \ = evenAndOdd.toList\n        val evenAndOddList2 = evenAndOddList.map(x => x._1\
    \ + x._2)\n        val evenAndOddList3 = evenAndOddList2.filter(x => x % 2 ==\
    \ 0).toList\n        val evenAndOddList4 = evenAndOddList3.map(x => x._1 + x._2)\n\
    \        val evenAndOddList5 = evenAndOddList4.filter(x => x % 2 == 0).toList\n\
    \        val evenAndOddList6 = evenAndOddList5.map(x => x._1 + x._2)\n       \
    \ val evenAndOddList7 = evenAndOddList6.filter(x => x % 2 == 0).toList\n     \
    \   val evenAndOddList8 = evenAndOddList7.map(x => x._1 + x._2)\n        val evenAndOddList9\
    \ = evenAndOddList8.filter(x => x % 2 == 0).toList\n        val evenAndOddList10\
    \ = evenAndOddList9.map(x => x._1 + x._2)\n        val evenAndOddList11 = evenAndOddList10.filter(x\
    \ => x % 2 == 0).toList\n        val evenAndOddList12 = evenAndOddList11.map(x\
    \ => x._1 + x._2)\n        val evenAndOddList13 = evenAndOddList12.filter(x =>\
    \ x % 2 == 0).toList\n        val evenAndOddList14 = evenAndOddList13.map(x =>\
    \ x._1 + x._2)\n        val evenAndOddList15 = evenAndOddList14.filter(x => x\
    \ % 2 == 0).toList\n        val evenAndOddList16 = evenAndOddList15.map(x => x._1\
    \ + x._2)\n        val evenAndOddList17 = evenAndOddList16.filter(x => x % 2 ==\
    \ 0).toList\n        val evenAndOddList18 = evenAndOddList17.map(x => x._1 + x._2)\n\
    \        val evenAndOddList19 = evenAndOddList18.filter(x => x % 2 == 0).toList\n\
    \        val evenAndOddList20 = evenAndOddList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph2p3uzuw.scala:24:57 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddList4\e[0m = evenAndOddList3.map(\e\
    [36mx\e[0m => x._1 + x._2)\n\e[31m\e[31m   |\e[0m                            \
    \                           ^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                 value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmph2p3uzuw.scala:25:60 ------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddList5\e[0m = evenAndOddList4.filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).toList\n\e[31m\e[31m   |\e[0m\
    \                                                          ^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue % is not a member of Nothing, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph2p3uzuw.scala:26:57 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddList6\e[0m = evenAndOddList5.map(\e\
    [36mx\e[0m => x._1 + x._2)\n\e[31m\e[31m   |\e[0m                            \
    \                           ^^^^\e[0m\n\e[31m   |\e[0mvalue _1 is not a member\
    \ of Nothing, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import concurrent.duration.durationToPair\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph2p3uzuw.scala:27:60 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddList7\e[0m = evenAndOddList6.filter(\e\
    [36mx\e[0m => x"
  stdout: ''
  timestamp: 1659794743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(_ % 2 == 0)\n        val lst2Even = lst2.filter(_\
    \ % 2 == 0)\n        val lst1Odd = lst1.filter(_ % 2 != 0)\n        val lst2Odd\
    \ = lst2.filter(_ % 2 != 0)\n        val lst1EvenAndOdd = lst1Even.intersect(lst2Odd)\n\
    \        val lst2EvenAndOdd = lst2Even.intersect(lst1Odd)\n        val lst1EvenAndOddAndEvenAndOdd\
    \ = lst1EvenAndOdd.intersect(lst2EvenAndOdd)\n        val lst1EvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = lst1EvenAndOddAndEvenAndOdd.intersect(lst2EvenAndOdd)\n        val lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = lst1EvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(lst2EvenAndOdd)\n     \
    \   val lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(lst2EvenAndOdd)\n\
    \        val lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(lst2EvenAndOdd)\n\
    \        val lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(lst2EvenAndOdd)\n\
    \        val lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAnd\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf_z7rs2c.scala:30:120 -----------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m = lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAnd\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m     Not found: lst1EvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAnd\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf_z7rs2c.scala:31:5\
    \ ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val evens = lst1.filter(x => x % 2 == 0)\n        val odds = lst1.filter(x =>\
    \ x % 2 != 0)\n        val evens2 = lst2.filter(x => x % 2 == 0)\n        val\
    \ odds2 = lst2.filter(x => x % 2 != 0)\n        val evens3 = evens.zip(odds).filter(x\
    \ => x._1 == x._2)\n        val odds3 = evens.zip(odds).filter(x => x._1 != x._2)\n\
    \        val evens4 = evens2.zip(odds2).filter(x => x._1 == x._2)\n        val\
    \ odds4 = evens2.zip(odds2).filter(x => x._1 != x._2)\n        val evens5 = evens3.zip(odds3).filter(x\
    \ => x._1 == x._2)\n        val odds5 = evens3.zip(odds3).filter(x => x._1 !=\
    \ x._2)\n        val evens6 = evens4.zip(odds4).filter(x => x._1 == x._2)\n  \
    \      val odds6 = evens4.zip(odds4).filter(x => x._1 != x._2)\n        val evens7\
    \ = evens5.zip(odds5).filter(x => x._1 == x._2)\n        val odds7 = evens5.zip(odds5).filter(x\
    \ => x._1 != x._2)\n        val evens8 = evens6.zip(odds6).filter(x => x._1 ==\
    \ x._2)\n        val odds8 = evens6.zip(odds6).filter(x => x._1 != x._2)\n   \
    \     val evens9 = evens7.zip(odds7).filter(x => x._1 == x._2)\n        val odds9\
    \ = evens7.zip(odds7).filter(x => x._1 != x._2)\n        val evens10 = evens8.zip(odds8).filter(x\
    \ => x._1 == x._2)\n        val odds10 = evens8.zip(odds8).filter(x => x._1 !=\
    \ x._2)\n        val evens11 = evens9.zip(odds9).filter(x => x._1 == x._2)\n \
    \       val odds11 = evens9.zip(odds9).filter(x => x._1 != x._2)\n        val\
    \ evens12 = evens10.zip(odds10).filter(x => x._1 == x._2)\n        val odds12\
    \ = evens10.zip(odds10).filter(x => x._1 != x._2)\n        val evens13 = evens\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoxtao9xr.scala:43:5\
    \ ---------------------\e[0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Size = lst1.size\n        val lst2Size = lst2.size\n        val evenList\
    \ = lst1.filter(x => x % 2 == 0).toList\n        val oddList = lst1.filter(x =>\
    \ x % 2 != 0).toList\n        val evenListSize = evenList.size\n        val oddListSize\
    \ = oddList.size\n        val evenList2Size = evenList.filter(x => x % 2 == 0).toList\n\
    \        val oddList2Size = oddList.filter(x => x % 2 != 0).toList\n        val\
    \ evenList2Size = evenList.filter(x => x % 2 == 0).toList\n        val oddList2Size\
    \ = oddList.filter(x => x % 2 != 0).toList\n        val evenList2Size = evenList.filter(x\
    \ => x % 2 == 0).toList\n        val oddList2Size = oddList.filter(x => x % 2\
    \ != 0).toList\n        val evenList2Size = evenList.filter(x => x % 2 == 0).toList\n\
    \        val oddList2Size = oddList.filter(x => x % 2 != 0).toList\n        val\
    \ evenList2Size = evenList.filter(x => x % 2 == 0).toList\n        val oddList2Size\
    \ = oddList.filter(x => x % 2 != 0).toList\n        val evenList2Size = evenList.filter(x\
    \ => x % 2 == 0).toList\n        val oddList2Size = oddList.filter(x => x % 2\
    \ != 0).toList\n        val evenList2Size = evenList.filter(x => x % 2 == 0).toList\n\
    \        val oddList2Size = oddList.filter(x => x % 2 != 0).toList\n        val\
    \ evenList2Size = evenList.filter(x => x % 2 == 0).toList\n        val oddList2Size\
    \ = oddList.filter(x => x % 2 != 0).toList\n        val evenList2Size = evenList.filter(x\
    \ => x % 2 == 0).toList\n        val oddList2Size = oddList.filter(x => x % 2\
    \ != 0).toList\n        val evenList2Size = evenList.filter(x => x % 2 == 0).toList\n\
    \        val oddList2Size = oddList.filter(x => x % 2 != 0).toList\n        val\
    \ evenList2Size = evenList.filter(x => x % 2 == 0).toList\n        val oddList2Size\
    \ = oddList.filter(x => x % 2 != 0).toList\n        val evenList2Size = evenList.filter(x\
    \ => x % 2 == 0).toList\n        val oddList2Size = oddList.filter(x => x % 2\
    \ != 0).toList\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnkif8r9v.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mevenList2Size\e[0m = evenList.filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).toList\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mevenList2Size is already defined as \e[33mvalue\e[0m \e[35mevenList2Size\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnkif8r9v.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36moddList2Size\e[0m = oddList.filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m != \e[31m0\e[0m).toList\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0moddList2Size is already defined as \e[33mvalue\e[0m \e[35moddList2Size\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnkif8r9v.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mevenList2Size\e[0m = evenList.filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).toList\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mevenList2Size is already defined as \e[33mvalue\e[0m \e[35mevenList2Size\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnkif8r9v.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36moddList2Size\e[0m = oddList.filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m != \e[31m0\e[0m).toList\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0moddList2Size is already defined as \e[33mvalue\e[0m \e[35moddList2Size\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of t"
  stdout: ''
  timestamp: 1659794739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Copy = lst1.toList\n        val lst2Copy\
    \ = lst2.toList\n        val evenList = lst1Copy.filter(x => x % 2 == 0)\n   \
    \     val oddList = lst1Copy.filter(x => x % 2 != 0)\n        val evenListCopy\
    \ = evenList.toList\n        val oddListCopy = oddList.toList\n        val evenListCopy2\
    \ = evenListCopy.filter(x => x % 2 == 0)\n        val oddListCopy2 = oddListCopy.filter(x\
    \ => x % 2 != 0)\n        val evenListCopy3 = evenListCopy2.filter(x => x % 2\
    \ == 0)\n        val oddListCopy3 = oddListCopy2.filter(x => x % 2 != 0)\n   \
    \     val evenListCopy4 = evenListCopy3.filter(x => x % 2 == 0)\n        val oddListCopy4\
    \ = oddListCopy3.filter(x => x % 2 != 0)\n        val evenListCopy5 = evenListCopy4.filter(x\
    \ => x % 2 == 0)\n        val oddListCopy5 = oddListCopy4.filter(x => x % 2 !=\
    \ 0)\n        val evenListCopy6 = evenListCopy5.filter(x => x % 2 == 0)\n    \
    \    val oddListCopy6 = oddListCopy5.filter(x => x % 2 != 0)\n        val evenListCopy7\
    \ = evenListCopy6.filter(x => x % 2 == 0)\n        val oddListCopy7 = oddListCopy6.filter(x\
    \ => x % 2 != 0)\n        val evenListCopy8 = evenListCopy7.filter(x => x % 2\
    \ == 0)\n        val oddListCopy8 = oddListCopy7.filter(x => x % 2 != 0)\n   \
    \     val evenListCopy9 = evenListCopy8.filter(x => x % 2 == 0)\n        val oddListCopy9\
    \ = oddListCopy8.filter(x => x % 2 != 0)\n        val evenListCopy10 = evenListCopy9.filter(x\
    \ => x % 2 == 0)\n        val oddListCopy10 = oddListCopy9.filter(x => x % 2 !=\
    \ 0)\n        val evenListCopy11 = evenListCopy10.filter(x => x % 2 == 0)\n  \
    \      val oddListCopy11 = oddListCopy10.filter(x => x % 2 != 0)\n        val\
    \ evenListCopy12 = evenListCopy11.filter(x => x % 2 == 0)\n        val oddListCopy12\
    \ = oddListCopy11.filter(x => x % 2 != 0)\n        val evenListCopy13 = evenListCopy12.filter(x\
    \ => x % 2 == 0)\n        val oddList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpibcdnbn7.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpibcdnbn7.scala:49:5 ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst3 = lst1.filter(_ % 2 == 0).zip(lst2.filter(_\
    \ % 2 == 0)).filter(_._1 == _._2).map(_._1).mkString(\",\")\n        if (lst3.isEmpty)\
    \ \"\"\n        else lst3.toUpperCase()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwkskd74a.scala:19:81 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mlst3\e[0m = lst1.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).zip(lst2.filter(_ % \e[31m2\e[0m == \e[31m0\e\
    [0m)).filter(_._1 == _._2).map(_._1).mkString(\e[31m\",\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \            ^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \  value _1 is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659794740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(_ % 2 == 0)\n        val lst2Even = lst2.filter(_\
    \ % 2 == 0)\n        val lst1Odd = lst1.filter(_ % 2 != 0)\n        val lst2Odd\
    \ = lst2.filter(_ % 2 != 0)\n        val lst1EvenOdd = lst1Even.zip(lst1Odd).filter(_._1\
    \ % 2 == 0).map(_._2)\n        val lst2EvenOdd = lst2Even.zip(lst2Odd).filter(_._1\
    \ % 2 == 0).map(_._2)\n        val lst1EvenOddOdd = lst1EvenOdd.zip(lst2EvenOdd).filter(_._1\
    \ % 2 == 0).map(_._2)\n        val lst2EvenOddOdd = lst2EvenOdd.zip(lst1EvenOdd).filter(_._1\
    \ % 2 == 0).map(_._2)\n        val lst1EvenOddOddOdd = lst1EvenOddOdd.zip(lst2EvenOddOdd).filter(_._1\
    \ % 2 == 0).map(_._2)\n        val lst2EvenOddOddOdd = lst2EvenOddOdd.zip(lst1EvenOddOdd).filter(_._1\
    \ % 2 == 0).map(_._2)\n        val lst1EvenOddOddOddOdd = lst1EvenOddOddOdd.zip(lst2EvenOddOddOdd).filter(_._1\
    \ % 2 == 0).map(_._2)\n        val lst2EvenOddOddOddOdd = lst2EvenOddOddOdd.zip(lst1EvenOddOddOdd).filter(_._1\
    \ % 2 == 0).map(_._2)\n        val lst1EvenOddOddOddOddOdd = lst1EvenOddOddOddOdd.zip(lst2EvenOddOddOddOdd).filter(_._1\
    \ % 2 == 0).map(_._2)\n        val lst2EvenOddOddOddOddOdd = lst2EvenOddOddOddOdd.zip(lst1EvenOddOddOddOdd).filter(_._1\
    \ % 2 == 0).map(_._2)\n        val lst1EvenOddOddOddOddOddOdd = lst1EvenOddOddOddOddOdd.zip(lst2EvenOddOddOddOddOdd).filter(_._\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv3ud5cdr.scala:32:103 --------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlst1EvenOddOddOddOddOddOdd\e\
    [0m = lst1EvenOddOddOddOddOdd.zip(lst2EvenOddOddOddOddOdd).filter(_._\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                       ^\e[0m\n\e[31m   |\e[0m              \
    \                     an identifier expected, but '_' found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv3ud5cdr.scala:33:5 ---------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659794743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).toList\n        val odd = lst2.filter(_ %\
    \ 2 == 1).toList\n        val evenAndOdd = even.intersect(odd)\n        val evenAndEven\
    \ = even.intersect(even)\n        val evenAndOddAndEven = evenAndEven.intersect(evenAndOdd)\n\
    \        val evenAndOddAndOdd = evenAndOdd.intersect(evenAndOdd)\n        val\
    \ evenAndOddAndEvenAndOdd = evenAndOddAndEven.intersect(evenAndOddAndOdd)\n  \
    \      val evenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAnd\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppr270n9g.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppr270n9g.scala:26:92\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOdd\e[0m = evenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                    ^\e[0m\n\e[31m   |\e[0m         Recursive\
    \ \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOdd\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppr270n9g.scala:27:58\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^\e[0m\n\e[31m   |\e[0m  Recursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppr270n9g.scala:30:84\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAnd\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when comp"
  stdout: ''
  timestamp: 1659794743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(x => x % 2 == 0)\n        val lst2Even = lst2.filter(x\
    \ => x % 2 == 0)\n        val lst1Odd = lst1.filter(x => x % 2 != 0)\n       \
    \ val lst2Odd = lst2.filter(x => x % 2 != 0)\n        val lst1EvenOdd = lst1Even.zip(lst2Even).filter(x\
    \ => x._1 == x._2)\n        val lst2EvenOdd = lst2Even.zip(lst1Even).filter(x\
    \ => x._1 == x._2)\n        val lst1EvenEven = lst1Even.zip(lst2EvenEven).filter(x\
    \ => x._1 == x._2)\n        val lst2EvenEven = lst2Even.zip(lst1EvenEven).filter(x\
    \ => x._1 == x._2)\n        val lst1EvenOddOdd = lst1EvenOdd.zip(lst2EvenOdd).filter(x\
    \ => x._1 == x._2)\n        val lst2EvenOddOdd = lst2EvenOdd.zip(lst1EvenOdd).filter(x\
    \ => x._1 == x._2)\n        val lst1EvenEvenOdd = lst1EvenEven.zip(lst2EvenEvenOdd).filter(x\
    \ => x._1 == x._2)\n        val lst2EvenEvenOdd = lst2EvenEven.zip(lst1EvenEvenOdd).filter(x\
    \ => x._1 == x._2)\n        val lst1EvenOddEvenOdd = lst1EvenOddOdd.zip(lst2EvenOddOdd).filter(x\
    \ => x._1 == x._2)\n        val lst2EvenOddEvenOdd = lst2EvenOddOdd.zip(lst1EvenOddEvenOdd).filter(x\
    \ => x._1 == x._2)\n        val lst1EvenEvenEvenOdd = lst1EvenEvenOdd.zip(lst2EvenEvenOdd).filter(x\
    \ => x._1 == x._2)\n        val lst2EvenEvenEvenOdd = lst2EvenEvenOdd.zip(lst1EvenEvenEvenOdd).filter(x\
    \ => x._1 == x._2)\n        val lst1EvenOddOddEvenOdd = lst1EvenOddEvenOdd.zip(lst2EvenOddEvenOdd).filter(x\
    \ => x._1 == x._2)\n        val lst2EvenOddOddEvenOdd = lst2Even\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpq66qbmac.scala:25:40 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mlst2EvenEven\e[0m = lst2Even.zip(lst1EvenEven).filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m                           \
    \             ^\e[0m\n\e[31m   |\e[0m                                 Recursive\
    \ \e[33mvalue\e[0m \e[35mlst1EvenEven\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E051] Reference Error: /tmp/tmpq66qbmac.scala:25:71 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mlst2EvenEven\e[0m = lst2Even.zip(lst1EvenEven).filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m                           \
    \                                       ^^^^^^^\e[0m\n\e[31m   |\e[0mAmbiguous\
    \ overload. The overloaded alternatives of \e[33mmethod\e[0m \e[35m==\e[0m in\
    \ \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\
    \e[31m   |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m\
    \   |\e[0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\e[31m   |\e\
    [0m (x: Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m   |\e[0m (x$0:\
    \ Any): Boolean\n\e[31m   |\e[0mall match arguments ((x._2 : => Nothing))\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpq66qbmac.scala:24:66 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mlst1EvenEven\e[0m = lst1Even.zip(lst2EvenEven).filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m                           \
    \                                       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues\
    \ of types Long and (Long, Nothing) cannot be compared with == or !=\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpq66qbmac.scala:29:47 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mlst2EvenEvenOdd\e[0m = lst2EvenEven.zip(lst1EvenEvenOdd).filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m                           \
    \                    ^\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659794746
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst3 = lst1.toSet\n        val lst4 = lst2.toSet\n\
    \        val lst5 = lst3.intersect(lst4)\n        val lst6 = lst5.toSet\n    \
    \    if(lst6.size == lst1.size){\n            val lst7 = lst1.toSet\n        \
    \    val lst8 = lst2.toSet\n            val lst9 = lst7.intersect(lst8)\n    \
    \        val lst10 = lst9.filter(x => lst6.contains(x))\n            if(lst10.size\
    \ == lst1.size){\n                return \"YES\"\n            }\n        }\n \
    \       return \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz1m6z619.scala:38)\n\tat Problem.main(tmpz1m6z619.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794745
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0)\n        val odd = lst2.filter(_ % 2 != 0)\n\
    \        val evenAndOdd = even.intersect(odd)\n        if(evenAndOdd.isEmpty)\
    \ \"NO\" else \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe_i9wedt.scala:24)\n\tat Problem.main(tmpe_i9wedt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794746
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmy87r7wz.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m19 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794622
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val even = lst1.filter(x => x % 2 == 0).toList\n\
    \        val odd = lst2.filter(x => x % 2 != 0).toList\n        val evenodd =\
    \ even.zip(odd).filter(x => x._1 == x._2).map(x => x._1).distinct\n        if(evenodd.size\
    \ == lst1.size){\n            return \"YES\"\n        }\n        return \"NO\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq905avdr.scala:28)\n\tat Problem.main(tmpq905avdr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794748
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenAndOdd = even.intersect(odd)\n      \
    \  val evenAndOddIsEven = evenAndOdd.forall(x => x % 2 == 0)\n        if (evenAndOddIsEven)\
    \ {\n            \"YES\"\n        } else {\n            \"NO\"\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpne9kp36_.scala:30)\n\tat Problem.main(tmpne9kp36_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794749
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst3 = lst1.toSet\n        val lst4 = lst2.toSet\n\
    \        val lst5 = lst3.intersect(lst4)\n        val lst6 = lst5.toSet\n    \
    \    if(lst6.size == lst1.size) \n            \"YES\"\n        else\n        \
    \    \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp10hu00i2.scala:32)\n\tat Problem.main(tmp10hu00i2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794748
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Even = lst1.filter(x => x % 2 == 0)\n   \
    \     val lst2Even = lst2.filter(x => x % 2 == 0)\n        if(lst1Even.length\
    \ == lst2Even.length){\n            val lst1EvenList = lst1Even.map(x => x.toLong)\n\
    \            val lst2EvenList = lst2Even.map(x => x.toLong)\n            val lst1EvenSet\
    \ = lst1EvenList.distinct\n            val lst2EvenSet = lst2EvenList.distinct\n\
    \            if(lst1EvenSet.length == lst2EvenSet.length){\n                val\
    \ lst1EvenSetList = lst1EvenSet.map(x => x.toLong)\n                val lst2EvenSetList\
    \ = lst2EvenSet.map(x => x.toLong)\n                val lst1EvenSetSet = lst1EvenSetList.distinct\n\
    \                val lst2EvenSetSet = lst2EvenSetList.distinct\n             \
    \   if(lst1EvenSetSet.length == lst2EvenSetSet.length){\n                    val\
    \ lst1EvenSetSetList = lst1EvenSetSet.map(x => x.toLong)\n                   \
    \ val lst2EvenSetSetList = lst2EvenSetSet.map(x => x.toLong)\n               \
    \     val lst1EvenSetSetSetSet = lst1EvenSetSetList.distinct\n               \
    \     val lst2EvenSetSetSet = lst2EvenSetSetList.distinct\n                  \
    \  if(lst1EvenSetSetSetSet.length == lst2EvenSetSetSetSet.length){\n         \
    \               val lst1EvenSetSetSetSetList = lst1EvenSetSetSet.map(x => x.toLong)\n\
    \                        val lst2EvenSetSetSetList = lst2EvenSetSetList.map(x\
    \ => x.toLong)\n                        val lst1EvenSetSetSetSetSet = lst1EvenSetSetSetSetList.distinct\n\
    \                        val lst2EvenSetSetSetSet = lst2EvenSetSetSetList.distinct\n\
    \                        if(lst1EvenSetSetSetSetSet.length == lst2EvenSetSetSetSetSet.length){\n\
    \                            val lst1EvenSetSetSetSetSetList = lst1EvenSetSetSetSetSet.map(x\
    \ => x.toLong)\n                            val lst2EvenSetSetSetSetList = lst2EvenSetSetSetList.map(x\
    \ => x.toLong)\n                            val lst1EvenSetSetSetSetSetSet = lst1EvenSetSetSetSetSetList.distinct\n\
    \                            val lst2EvenSetSetSetSetSet = lst2EvenSetSetSetList.distinct\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpaglkr7nl.scala:59:0 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaglkr7nl.scala:36:54\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                    \e[33mif\e\
    [0m(lst1EvenSetSetSetSet.length == lst2EvenSetSetSetSet.length){\n\e[31m\e[31m\
    \   |\e[0m                                                      ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                         Not found: lst2EvenSetSetSetSet\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaglkr7nl.scala:37:55\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m                        \e\
    [33mval\e[0m \e[36mlst1EvenSetSetSetSetList\e[0m = lst1EvenSetSetSet.map(\e[36mx\e\
    [0m => x.toLong)\n\e[31m\e[31m   |\e[0m                                      \
    \                 ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                        Not found: lst1EvenSetSetSet\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmpaglkr7nl.scala:48:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m48 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659794746
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).length\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).length\n        if (even > odd) {\n            return \"NO\"\n\
    \        }\n        else {\n            return \"YES\"\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8z7h03_e.scala:29)\n\tat Problem.main(tmp8z7h03_e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794646
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmy87r7wz.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m19 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794622
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst3 = lst1.toSet\n        val lst4 = lst2.toSet\n\
    \        if(lst3.intersect(lst4).isEmpty){\n            return \"NO\"\n      \
    \  }\n        else{\n            return \"YES\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6jj6neve.scala:30)\n\tat Problem.main(tmp6jj6neve.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmy87r7wz.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m19 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794622
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_ % 2 == 0).toList\n        val odd = lst2.filter(_ %\
    \ 2 == 1).toList\n        val evenAndOdd = even.intersect(odd)\n        if (evenAndOdd.isEmpty)\
    \ \"NO\" else \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp434_i3wi.scala:24)\n\tat Problem.main(tmp434_i3wi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Size = lst1.size\n        val lst2Size = lst2.size\n        val evenList\
    \ = lst1.filter(x => x % 2 == 0)\n        val oddList = lst1.filter(x => x % 2\
    \ != 0)\n        val evenListSize = evenList.size\n        val oddListSize = oddList.size\n\
    \        val evenList2Size = evenList.filter(x => x % 2 == 0).size\n        val\
    \ oddList2Size = oddList.filter(x => x % 2 != 0).size\n        val evenList2Size2\
    \ = evenList.filter(x => x % 2 == 0).filter(x => x % 2 != 0).size\n        val\
    \ oddList2Size2 = oddList.filter(x => x % 2 != 0).filter(x => x % 2 == 0).size\n\
    \        val evenList2Size3 = evenList.filter(x => x % 2 == 0).filter(x => x %\
    \ 2 != 0).filter(x => x % 2 != 0).size\n        val oddList2Size3 = oddList.filter(x\
    \ => x % 2 != 0).filter(x => x % 2 == 0).filter(x => x % 2 != 0).size\n      \
    \  val evenList2Size4 = evenList.filter(x => x % 2 == 0).filter(x => x % 2 !=\
    \ 0).filter(x => x % 2 != 0).filter(x => x % 2 != 0).size\n        val oddList2Size4\
    \ = oddList.filter(x => x % 2 != 0).filter(x => x % 2 == 0).filter(x => x % 2\
    \ != 0).filter(x => x % 2 != 0).size\n        val evenList2Size5 = evenList.filter(x\
    \ => x % 2 == 0).filter(x => x % 2 != 0).filter(x => x % 2 != 0).filter(x => x\
    \ % 2 != 0).filter(x => x % 2 != 0).size\n        val oddList2Size5 = oddList.filter(x\
    \ => x % 2 != 0).filter(x => x % 2 == 0).filter(x => x % 2 != 0).filter(x => x\
    \ % 2 != 0).filter(x => x % 2 != 0).size\n        val evenList2Size6 = evenList.filter(x\
    \ => x % 2 == 0).filter(x => x % 2 != 0).filter(x => x % 2 != 0).filter(x => x\
    \ % 2 != 0).filter(x => x % 2 != 0).filter(x => x % 2 != 0).size\n        val\
    \ oddList2Size6 = oddList.filter(x => x % 2 != 0).filter(x => x % 2 == 0).filter(x\
    \ => x % 2 != 0).filter(x => x % 2 != 0).filter(x => x % 2 != 0).filter(x \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr2dxfeul.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr2dxfeul.scala:35:163\
    \ -----------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36moddList2Size6\e[0m = oddList.filter(\e[36mx\e[0m => x % \e[31m2\e[0m != \e\
    [31m0\e[0m).filter(\e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m != \e[31m0\e[0m).filter(\e[36mx\e[0m => x % \e\
    [31m2\e[0m != \e[31m0\e[0m).filter(\e[36mx\e[0m => x % \e[31m2\e[0m != \e[31m0\e\
    [0m).filter(x \n\e[31m\e[31m   |\e[0m                                        \
    \                                                                            \
    \                                               ^\e[0m\n\e[31m   |\e[0m      \
    \                                                      Not found: x\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr2dxfeul.scala:36:5 ---------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659794749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Even = lst1.filter(_ % 2 == 0).toList\n        val lst2Even = lst2.filter(_\
    \ % 2 == 0).toList\n        val lst1Odd = lst1.filter(_ % 2 != 0).toList\n   \
    \     val lst2Odd = lst2.filter(_ % 2 != 0).toList\n        val lst1EvenOdd =\
    \ lst1Even.zip(lst2Even).filter(_._1 == _._2).toList\n        val lst2EvenOdd\
    \ = lst2Even.zip(lst1Even).filter(_._1 == _._2).toList\n        val lst1EvenOddOdd\
    \ = lst1EvenOdd.zip(lst2EvenOdd).filter(_._1 == _._2).toList\n        val lst2EvenOddOdd\
    \ = lst2EvenOdd.zip(lst1EvenOdd).filter(_._1 == _._2).toList\n        val lst1EvenOddOddOdd\
    \ = lst1EvenOddOdd.zip(lst2EvenOddOdd).filter(_._1 == _._2).toList\n        val\
    \ lst2EvenOddOddOdd = lst2EvenOddOdd.zip(lst1EvenOddOdd).filter(_._1 == _._2).toList\n\
    \        val lst1EvenOddOddOddOdd = lst1EvenOddOddOdd.zip(lst2EvenOddOddOdd).filter(_._1\
    \ == _._2).toList\n        val lst2EvenOddOddOddOdd = lst2EvenOddOddOdd.zip(lst1EvenOddOddOdd).filter(_._1\
    \ == _._2).toList\n        val lst1EvenOddOddOddOddOdd = lst1EvenOddOddOddOdd.zip(lst2EvenOddOddOddOdd).filter(_._1\
    \ == _._2).toList\n        val lst2EvenOddOddOddOddOdd = lst2EvenOddOddOddOdd.zip(lst1EvenOddOddOddOdd).filter(_._1\
    \ == _._2).toList\n        val lst1EvenOddOddOddOddOddOdd = lst1EvenOddOddOddOddOdd.zip(lst2EvenOddOddOddOddOdd).filter(_._1\
    \ == _._2\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphe4fcf3d.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphe4fcf3d.scala:22:58\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mlst1EvenOdd\e[0m = lst1Even.zip(lst2Even).filter(_._1 == _._2).toList\n\e\
    [31m\e[31m   |\e[0m                                                        ^^^^\e\
    [0m\n\e[31m   |\e[0m                                        value _1 is not a\
    \ member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphe4fcf3d.scala:23:58\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mlst2EvenOdd\e[0m = lst2Even.zip(lst1Even).filter(_._1 == _._2).toList\n\e\
    [31m\e[31m   |\e[0m                                                        ^^^^\e\
    [0m\n\e[31m   |\e[0m                                        value _1 is not a\
    \ member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphe4fcf3d.scala:33:5\
    \ ---------------------\e[0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659794749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Even = lst1.filter(x => x % 2 == 0)\n   \
    \     val lst2Even = lst2.filter(x => x % 2 == 0)\n        if(lst1Even.length\
    \ == lst2Even.length){\n            val lst1EvenList = lst1Even.map(x => x.toLong)\n\
    \            val lst2EvenList = lst2Even.map(x => x.toLong)\n            val lst1EvenList2\
    \ = lst1EvenList.zip(lst2EvenList).map(x => x._1.toLong * x._2.toLong)\n     \
    \       val lst2EvenList2 = lst2EvenList.zip(lst1EvenList).map(x => x._1.toLong\
    \ * x._2.toLong)\n            val lst1EvenList3 = lst1EvenList.zip(lst2EvenList2).map(x\
    \ => x._1.toLong * x._2.toLong)\n            val lst2EvenList3 = lst2EvenList.zip(lst1EvenList2).map(x\
    \ => x._1.toLong * x._2.toLong)\n            val lst1EvenList4 = lst1EvenList.zip(lst2EvenList3).map(x\
    \ => x._1.toLong * x._2.toLong)\n            val lst2EvenList4 = lst2EvenList.zip(lst1EvenList3).map(x\
    \ => x._1.toLong * x._2.toLong)\n            val lst1EvenList5 = lst1EvenList.zip(lst2EvenList4).map(x\
    \ => x._1.toLong * x._2.toLong)\n            val lst2EvenList5 = lst2EvenList.zip(lst1EvenList4).map(x\
    \ => x._1.toLong * x._2.toLong)\n            val lst1EvenList6 = lst1EvenList.zip(lst2EvenList5).map(x\
    \ => x._1.toLong * x._2.toLong)\n            val lst2EvenList6 = lst2EvenList.zip(lst1EvenList5).map(x\
    \ => x._1.toLong * x._2.toLong)\n            val lst1EvenList7 = lst1EvenList.zip(lst2EvenList6).map(x\
    \ => x._1.toLong * x._2.toLong)\n            val lst2EvenList7 = lst2EvenList.zip(lst1EvenList6).map(x\
    \ => x._1.toLong * x._2.toLong)\n            val lst1EvenList8 = lst1EvenList.zip(lst2EvenList7).map(x\
    \ => x._1.to\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpns3mw9fi.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpns3mw9fi.scala:49:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m49 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E051] Reference\
    \ Error: /tmp/tmpns3mw9fi.scala:36:78 ------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m            \e[33mval\e[0m \e[36mlst1EvenList8\e[0m = lst1EvenList.zip(lst2EvenList7).map(\e\
    [36mx\e[0m => x._1.to\n\e[31m\e[31m   |\e[0m                                 \
    \                                        ^^^^^^^\e[0m\n\e[31m   |\e[0mAmbiguous\
    \ overload. The overloaded alternatives of \e[33mmethod\e[0m \e[35mto\e[0m in\
    \ \e[33mtrait\e[0m \e[35mIntegralProxy\e[0m with types\n\e[31m   |\e[0m (end:\
    \ Long, step: Long): scala.collection.immutable.NumericRange.Inclusive[Long]\n\
    \e[31m   |\e[0m (end: Long): scala.collection.immutable.NumericRange.Inclusive[Long]\n\
    \e[31m   |\e[0mboth match expected type B\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpns3mw9fi.scala:48:1 ---------------------\e[0m\e\
    [0m\n\e[31m48 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:  \
    \  Unit\n\e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpns3mw9fi.scala:38:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m38 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659794749
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst3 = lst1.filter(_ % 2 == 0).filter(_ != lst2.head).filter(_ != lst2.last)\n\
    \        if(lst3.isEmpty) \"\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsp5lie19.scala:22)\n\tat Problem.main(tmpsp5lie19.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794750
