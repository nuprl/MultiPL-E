language: scala
name: HumanEval_128_prod_signs
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.map(x => x * magnitudes.sum).sum\n\
    \        val productSign = signs.map(x => x * product).sum\n        val productMagnitude\
    \ = magnitudes.map(x => x * product).sum\n        if (productMagnitude == 0) None\
    \ else Some(productSign)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpufhfoy4v.scala:24)\n\tat Problem.main(tmpufhfoy4v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitudes = signs.map(x => math.abs(x))\n      \
    \  magnitudes.zip(product).map(x => x._1 * x._2).sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2jngvdao.scala:19:23\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    (product : Long)\n\e[31m\
    \   |\e[0m                       Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E051] Reference Error: /tmp/tmp2jngvdao.scala:19:46 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).map(\e[36mx\e[0m => x._1\
    \ * x._2).sum\n\e[31m\e[31m   |\e[0m                                         ^^^^^^\e\
    [0m\n\e[31m   |\e[0mAmbiguous overload. The overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m\
    \ (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x:\
    \ Long): Long\n\e[31m   |\e[0m (x: Int): Int\n\e[31m   |\e[0m (x: Char): Int\n\
    \e[31m   |\e[0m (x: Short): Int\n\e[31m   |\e[0m (x: Byte): Int\n\e[31m   |\e\
    [0mall match arguments ((x._2 : => Nothing))\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmp2jngvdao.scala:19:57 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).map(\e[36mx\e[0m => x._1\
    \ * x._2).sum\n\e[31m\e[31m   |\e[0m                                         \
    \                ^\e[0m\n\e[31m   |\e[0m          No implicit Ordering defined\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          where:    B is a type variable\
    \ with constraint <: Option[Long]\n\e[31m   |\e[0m          .\n3 errors found\n"
  stdout: ''
  timestamp: 1659795497
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, elem) => product * elem}\n        val signs = arr.map(elem\
    \ => if (elem < 0) -1 else if (elem > 0) 1 else 0)\n        signs.foldLeft(product)\
    \ { (product, sign) => product * sign}\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd2l4b7kk.scala:18:32\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        signs.foldLeft(product)\
    \ { (\e[36mproduct\e[0m, \e[36msign\e[0m) => product * sign}\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.map(x => x * magnitudes.sum).sum\n\
    \        Some(product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp09juycyu.scala:22)\n\tat Problem.main(tmp09juycyu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) {\n            (product, elem) => product * elem\n        }\n\
    \        val signs = arr.map(elem => if (elem < 0L) -1L else 1L)\n        val\
    \ magnitudes = signs.map(elem => math.abs(elem))\n        magnitudes.zip(product).map(elem\
    \ => elem._1 * elem._2)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpby239j9s.scala:21:23\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        magnitudes.zip(product).map(\e\
    [36melem\e[0m => elem._1 * elem._2)\n\e[31m\e[31m   |\e[0m                   \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Found:    (product :\
    \ Long)\n\e[31m   |\e[0m                       Required: IterableOnce[Any]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E051] Reference Error: /tmp/tmpby239j9s.scala:21:52\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        magnitudes.zip(product).map(\e\
    [36melem\e[0m => elem._1 * elem._2)\n\e[31m\e[31m   |\e[0m                   \
    \                         ^^^^^^^^^\e[0m\n\e[31m   |\e[0mAmbiguous overload. The\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m\
    \ \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e\
    [0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int):\
    \ Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e\
    [31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mall match arguments ((elem._2 :\
    \ => Nothing))\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795497
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        signs.map(x => product * x).sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_kqnnjtk.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        signs.map(\e[36mx\e\
    [0m => product * x).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitudes = signs.map(x => math.abs(x))\n      \
    \  magnitudes.zip(product).map(x => (x._1 * x._2))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6gx7kyqs.scala:19:23\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).map(\e\
    [36mx\e[0m => (x._1 * x._2))\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    (product : Long)\n\e[31m\
    \   |\e[0m                       Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E051] Reference Error: /tmp/tmp6gx7kyqs.scala:19:47 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).map(\e[36mx\e[0m => (x._1\
    \ * x._2))\n\e[31m\e[31m   |\e[0m                                          ^^^^^^\e\
    [0m\n\e[31m   |\e[0mAmbiguous overload. The overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m\
    \ (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x:\
    \ Long): Long\n\e[31m   |\e[0m (x: Int): Int\n\e[31m   |\e[0m (x: Char): Int\n\
    \e[31m   |\e[0m (x: Short): Int\n\e[31m   |\e[0m (x: Byte): Int\n\e[31m   |\e\
    [0mall match arguments ((x._2 : => Nothing))\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        val result\
    \ = magnitude.map(x => x * product).getOrElse(None)\n        result\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl53h8k03.scala:19:31 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = magnitude.map(\e\
    [36mx\e[0m => x * product).getOrElse(None)\n\e[31m\e[31m   |\e[0m            \
    \         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     value map is\
    \ not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659795497
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduce(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsn0bc_fh.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitudes = signs.map(x => x * product)\n      \
    \  magnitudes.sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd9px4sx3.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.map(x => x * magnitudes.getOrElse(0l))\n\
    \        val sum = product.sum\n        if (sum > 0L) Some(sum) else None\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7solw_bp.scala:18:52 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = signs.map(\e\
    [36mx\e[0m => x * magnitudes.getOrElse(\e[31m0l\e[0m))\n\e[31m\e[31m   |\e[0m\
    \                                         ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                           value getOrElse is not a member of List[Long]\n\
    \e[31m\e[31m-- Error: /tmp/tmp7solw_bp.scala:19:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mShortIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mBigDecimalIsFractional\e[0m\
    \ in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num\
    \ of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val magnitude\
    \ = product.map(x => math.abs(x)).sum\n        Some(sum * magnitude)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkp1i1_nc.scala:17:45 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmpkp1i1_nc.scala:18:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mLongIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mBigDecimalIsFractional\e[0m\
    \ in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num\
    \ of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val result\
    \ = magnitudes.map(x => x * product).sum\n        if (result > 0) Some(result)\
    \ else None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppx8rf761.scala:23)\n\tat Problem.main(tmppx8rf761.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitudes = signs.map(x => x * product)\n      \
    \  magnitudes.sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd9px4sx3.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        signs.map(x => x * product).sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp80ddwdx_.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        signs.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduce(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsn0bc_fh.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        val result = magnitudes.map(x => x * product).sum / sum\n        Some(result)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp5wio3w7.scala:24)\n\tat Problem.main(tmpp5wio3w7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(math.pow(_,\
    \ product))\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm8bd3hxg.scala:19:22\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(math.pow(_,\
    \ product))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[Double]\n\e[31m   |\e[0m        Required:\
    \ Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0g9ydhp8.scala:23)\n\tat Problem.main(tmp0g9ydhp8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795498
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.map(x => x * x).sum\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ 1).sum\n        Some(signs * product)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphfwtb9ud.scala:21)\n\tat Problem.main(tmphfwtb9ud.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.map(x => x * x).sum\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val magnitude = signs.map(x => x * product).sum\n\
    \        magnitude\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplwbhw3zp.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitude\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (magnitude\
    \ : Long)\n\e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitudes = arr.map(x => math.abs(x)).sum\n    \
    \    val result = signs.map(x => x * product).sum * magnitudes\n        if (result\
    \ > 0) Some(result) else None\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeqexc8tl.scala:23)\n\tat Problem.main(tmpeqexc8tl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795498
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val product = signs.reduce(_ * _)\n        Some(signs.map(x => x * product).sum\
    \ / m)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps7vnsaws.scala:22)\n\tat Problem.main(tmps7vnsaws.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, elem) =>\n            product * elem\n        }\n\
    \        val signs = arr.map(elem => if (elem < 0) -1 else if (elem > 0) 1 else\
    \ 0)\n        val magnitudes = signs.map(elem => math.abs(elem))\n        magnitudes.zip(product).map(elem\
    \ => elem._1 * elem._2)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp647q2szy.scala:21:23\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        magnitudes.zip(product).map(\e\
    [36melem\e[0m => elem._1 * elem._2)\n\e[31m\e[31m   |\e[0m                   \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Found:    (product :\
    \ Long)\n\e[31m   |\e[0m                       Required: IterableOnce[Any]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E051] Reference Error: /tmp/tmp647q2szy.scala:21:52\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        magnitudes.zip(product).map(\e\
    [36melem\e[0m => elem._1 * elem._2)\n\e[31m\e[31m   |\e[0m                   \
    \                         ^^^^^^^^^\e[0m\n\e[31m   |\e[0mAmbiguous overload. The\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m\
    \ \e[35mInt\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e\
    [0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int):\
    \ Int\n\e[31m   |\e[0m (x: Char): Int\n\e[31m   |\e[0m (x: Short): Int\n\e[31m\
    \   |\e[0m (x: Byte): Int\n\e[31m   |\e[0mall match arguments ((elem._2 : => Nothing))\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp75us85n6.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(signs).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795515
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduce((x, y) => x * y)\n     \
    \   if (magnitudes.sum == product) Some(product) else None\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjfutlju3.scala:22)\n\tat Problem.main(tmpjfutlju3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(sum * product)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy4_uy09z.scala:23)\n\tat Problem.main(tmpy4_uy09z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(product).map(x\
    \ => x._1 * x._2)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb_3qrzwj.scala:19:23\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).map(\e\
    [36mx\e[0m => x._1 * x._2)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    (product : Int)\n\e[31m \
    \  |\e[0m                       Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E051] Reference Error: /tmp/tmpb_3qrzwj.scala:19:46 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).map(\e[36mx\e[0m => x._1\
    \ * x._2)\n\e[31m\e[31m   |\e[0m                                         ^^^^^^\e\
    [0m\n\e[31m   |\e[0mAmbiguous overload. The overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e\
    [0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x:\
    \ Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\
    \e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e\
    [0mall match arguments ((x._2 : => Nothing))\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795516
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitudes = arr.map(x => math.abs(x))\n  \
    \      val sum = magnitudes.foldLeft(0L) { (x, y) => x + y }\n        Some(sum\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzrskdr_q.scala:23)\n\tat Problem.main(tmpzrskdr_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        signs.map(x => x * product).sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp80ddwdx_.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        signs.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr9ycocdb.scala:23)\n\tat Problem.main(tmpr9ycocdb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        Some(sum * product)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5wy4rfo6.scala:23)\n\tat Problem.main(tmp5wy4rfo6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val productMagnitudes = product.zip(magnitudes)\n        productMagnitudes.foldLeft(0l){\
    \ (sum, tuple) =>\n            val productSign = tuple._1 * tuple._2\n       \
    \     sum + productSign\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3xgyu84i.scala:20:38\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        productMagnitudes.foldLeft(\e\
    [31m0l\e[0m){ (\e[36msum\e[0m, \e[36mtuple\e[0m) =>\n\e[31m\e[31m   |\e[0m   \
    \     ^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required:\
    \ Option[Long]\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mproductSign\e\
    [0m = tuple._1 * tuple._2\n\e[31m22 |\e[0m            sum + productSign\n\e[31m23\
    \ |\e[0m        }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795516
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr9ycocdb.scala:23)\n\tat Problem.main(tmpr9ycocdb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(product).map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpizpkpjb6.scala:19:23\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    (product : Int)\n\e[31m \
    \  |\e[0m                       Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E051] Reference Error: /tmp/tmpizpkpjb6.scala:19:46 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).map(\e[36mx\e[0m => x._1\
    \ * x._2).sum\n\e[31m\e[31m   |\e[0m                                         ^^^^^^\e\
    [0m\n\e[31m   |\e[0mAmbiguous overload. The overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e\
    [0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x:\
    \ Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\
    \e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e\
    [0mall match arguments ((x._2 : => Nothing))\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpizpkpjb6.scala:19:57 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).map(\e[36mx\e[0m => x._1\
    \ * x._2).sum\n\e[31m\e[31m   |\e[0m                                         \
    \                ^\e[0m\n\e[31m   |\e[0m          No implicit Ordering defined\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          where:    B is a type variable\
    \ with constraint <: Option[Long]\n\e[31m   |\e[0m          .\n3 errors found\n"
  stdout: ''
  timestamp: 1659795518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.sum\n        val productSign = signs.reduce(_ * _)\n        val magnitudeSign\
    \ = magnitudes.map(x => math.abs(x))\n        val magnitudeSignSum = magnitudeSign.sum\n\
    \        val magnitudeSignProduct = magnitudeSign.map(x => math.abs(x)).reduce(_\
    \ * _)\n        val magnitudeSignProductSum = magnitudeSignProduct.sum\n     \
    \   val magnitudeSignProductProduct = magnitudeSignProduct.map(x => math.abs(x)).reduce(_\
    \ * _)\n        val magnitudeSignProductProductSum = magnitudeSignProductProduct.sum\n\
    \        val magnitudeSignProductProductProduct = magnitudeSignProductProduct.map(x\
    \ => math.abs(x)).reduce(_ * _)\n        val magnitudeSignProductProductProductSum\
    \ = magnitudeSignProductProductProduct.sum\n        val magnitudeSignProductProductProductProduct\
    \ = magnitudeSignProductProductProduct.map(x => math.abs(x)).reduce(_ * _)\n \
    \       val magnitudeSignProductProductProductProductSum = magnitudeSignProductProductProductProduct.sum\n\
    \        val magnitudeSignProductProductProductProductProduct = magnitudeSignProductProductProductProduct.map(x\
    \ => math.abs(x)).reduce(_ * _)\n        val magnitudeSignProductProductProductProductSum\
    \ = magnitudeSignProductProductProductProductProduct.sum\n        val magnitudeSignProductProductProductProductProduct\
    \ = magnitudeSignProductProductProductProductProduct.map(x => math.abs(x)).reduce(_\
    \ * _)\n        val magnitudeSignProductProductProductProductProductSum = magnitudeSignProductProductProductProductProduct.sum\n\
    \        val magnitudeSignProductProductProductProductProductProduct = magnitudeSignProductProductProductProductProductProduct.map(x\
    \ => math.abs(x)).reduce(_ * _)\n        val magnitudeSignProductProductProductProductProductSum\
    \ = magnitudeSignProductProductProductProductProductProduct.sum\n        val magnitudeSignProductProductProductProductProductProduct\
    \ = magnitudeSignProductProductProductProductProductProduct.map(x => math.abs(x)).reduce(_\
    \ * _)\n        val magnitudeSignProductProductProductProductProductSum = magnitudeSignProductProductProductProductProductProduct.sum\n\
    \        val magnitudeSignProductProductProductProductProductProduct = magnitudeSignProductProductProductProductProductProduct.map(x\
    \ => math.abs(x)).reduce(_ * _)\n        val magnitudeSignProductProductProductProductProductSum\
    \ = magnitudeSignProductProductProductProductProductProductProduct.sum\n     \
    \   val magnitudeSignProductProductProductProductProductProduct\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq05204b3.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq05204b3.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmagnitudeSignProductProductProductProductSum\e[0m = magnitudeSignProductProductProductProductProduct.sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmagnitudeSignProductProductProductProductSum is already defined\
    \ as \e[33mvalue\e[0m \e[35mmagnitudeSignProductProductProductProductSum\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpq05204b3.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mmagnitudeSignProductProductProductProductProduct\e\
    [0m = magnitudeSignProductProductProductProductProduct.map(\e[36mx\e[0m => math.abs(x)).reduce(_\
    \ * _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmagnitudeSignProductProductProductProductProduct is already\
    \ defined as \e[33mvalue\e[0m \e[35mmagnitudeSignProductProductProductProductProduct\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpq05204b3.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mmagnitudeSignProductProductProductProductProductSum\e\
    [0m = magnitudeSignProductProductProductProductProductProduct.sum\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmagnitudeSignProductProductProductProductProductSum is already\
    \ de"
  stdout: ''
  timestamp: 1659795518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduce(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsn0bc_fh.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitudes = arr.map(x => math.abs(x))\n  \
    \      val sum = magnitudes.foldLeft(1L) { (x, y) => x * y }\n        Some(sum\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqbgyx23v.scala:23)\n\tat Problem.main(tmpqbgyx23v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val productMagnitudes = product.zip(magnitudes)\n        productMagnitudes.map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpantrvsd6.scala:20:8\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        productMagnitudes.map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795516
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val sum = magnitudes.sum\n        if (sum == 0) None else Some(sum * product.sum)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfz81161m.scala:23)\n\tat Problem.main(tmpfz81161m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitude = arr.map(x => x * x).map(x => math.abs(x)).sum\n\
    \        val result = signs.map(x => x * product).map(x => x * magnitude)\n  \
    \      if (result.isEmpty) None else Some(result.sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptv77etbf.scala:23)\n\tat Problem.main(tmptv77etbf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795520
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(x => if (x == 0) 0 else math.signum(x))\n        Some(arr.map(x\
    \ => x * m * s(x)).sum)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_jr1u5cx.scala:18:36\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        Some(arr.map(\e[36mx\e\
    [0m => x * m * s(x)).sum)\n\e[31m\e[31m   |\e[0m                             \
    \       ^\e[0m\n\e[31m   |\e[0m                                    Found:    (x\
    \ : Long)\n\e[31m   |\e[0m                                    Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795517
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz4mm5rjn.scala:23)\n\tat Problem.main(tmpz4mm5rjn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795521
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnq1zjnem.scala:23)\n\tat Problem.main(tmpnq1zjnem.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795521
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val product = signs.reduce(_ * _)\n        Some(product * m)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxhzgevs.scala:22)\n\tat Problem.main(tmpaxhzgevs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(product).filter(_._1\
    \ == _._2).map(_._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpugrcunob.scala:19:23\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).filter(_._1\
    \ == _._2).map(_._2).sum\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    (product : Int)\n\e[31m \
    \  |\e[0m                       Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpugrcunob.scala:19:41 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).filter(_._1 == _._2).map(_._2).sum\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                       value _1 is not a member of Long\n\
    \e[31m\e[31m-- Error: /tmp/tmpugrcunob.scala:19:66 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).filter(_._1 == _._2).map(_._2).sum\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \          ^\e[0m\n\e[31m   |\e[0m          No implicit Ordering defined for B\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m          where:    B is a type variable with\
    \ constraint <: Option[Long]\n\e[31m   |\e[0m          .\n3 errors found\n"
  stdout: ''
  timestamp: 1659795520
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val result\
    \ = magnitudes.zip(product).map(x => x._1 * x._2)\n        if (result.isEmpty)\
    \ None else Some(result.sum)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqlud3nk7.scala:19:36\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = magnitudes.zip(product).map(\e[36mx\e[0m => x._1 * x._2)\n\e[31m\e[31m \
    \  |\e[0m                                    ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                 Found:    (product : Int)\n\e[31m   |\e[0m \
    \                                   Required: IterableOnce[Any]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E051] Reference Error: /tmp/tmpqlud3nk7.scala:19:59 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = magnitudes.zip(product).map(\e\
    [36mx\e[0m => x._1 * x._2)\n\e[31m\e[31m   |\e[0m                            \
    \                          ^^^^^^\e[0m\n\e[31m   |\e[0mAmbiguous overload. The\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m\
    \ \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e\
    [0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int):\
    \ Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e\
    [31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mall match arguments ((x._2 : =>\
    \ Nothing))\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).getOrElse(None)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp90ic_0_6.scala:19:41 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e[0m => x * product).getOrElse(None)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        value getOrElse is not a member of List[Long]\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprxqaprpx.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, elem) => product * elem}\n        val signs = arr.map(elem\
    \ => if (elem < 0L) -1L else 0L)\n        val magnitudes = signs.map(elem => math.abs(elem))\n\
    \        val sum = magnitudes.sum\n        val productOfSigns = signs.foldLeft(1L)\
    \ { (product, elem) => product * elem}\n        val productOfMagnitudes = magnitudes.foldLeft(1L)\
    \ { (product, elem) => product * elem}\n        val productOfSums = magnitudes.foldLeft(1L)\
    \ { (product, elem) => product * elem}\n        val productOfProducts = productOfSigns\
    \ * productOfMagnitudes * productOfSums * productOfProducts\n        val productOfProductsAbs\
    \ = productOfProducts.abs\n        val productOfProductsAbsSum = productOfProductsAbs.sum\n\
    \        val productOfProductsAbsProduct = productOfProductsAbs.product\n    \
    \    val productOfProductsAbsProductSum = productOfProductsAbsProduct.sum\n  \
    \      val productOfProductsAbsProductProduct = productOfProductsAbsProduct.product\n\
    \        val productOfProductsAbsProductProductSum = productOfProductsAbsProductProduct.sum\n\
    \        val productOfProductsAbsProductProductProduct = productOfProductsAbsProductProduct.product\n\
    \        val productOfProductsAbsProductProductProductSum = productOfProductsAbsProductProductProduct.sum\n\
    \        val productOfProductsAbsProductProductProductProduct = productOfProductsAbsProductProductProduct.product\n\
    \        val productOfProductsAbsProductProductProductProductSum = productOfProductsAbsProductProductProductProduct.sum\n\
    \        val productOfProductsAbsProductProductProductProductProduct = productOfProductsAbsProductProductProductProduct.product\n\
    \        val productOfProductsAbsProductProductProductProductProductSum = productOfProductsAbsProductProductProductProductProduct.sum\n\
    \        val productOfProductsAbsProductProductProductProductProductProduct =\
    \ productOfProductsAbsProductProductProductProductProduct.product\n        val\
    \ productOfProductsAbsProductProductProductProductProductProductSum = productOfProductsAbsProductProductProductProductProductProduct.sum\n\
    \        val productOfProductsAbsProductProductProductProductProductProductProduct\
    \ = productOfProductsAbsProductProductProductProductProduct\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpium8t3ij.scala:23:87 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mproductOfProducts\e[0m =\
    \ productOfSigns * productOfMagnitudes * productOfSums * productOfProducts\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \    Recursive \e[33mvalue\e[0m \e[35mproductOfProducts\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpium8t3ij.scala:39:5 ---------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Option[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795520
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp75us85n6.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(signs).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795515
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        Some(sum * product)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5wy4rfo6.scala:23)\n\tat Problem.main(tmp5wy4rfo6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, num) => product * num }\n        val signs = arr.map(num\
    \ => if (num > 0) 1 else -1)\n        signs.foldLeft(product) { (product, sign)\
    \ => product * sign }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7zq93p6k.scala:18:32\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        signs.foldLeft(product)\
    \ { (\e[36mproduct\e[0m, \e[36msign\e[0m) => product * sign }\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795534
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x)).sum\n        val mag2 = mag * mag\n        if\
    \ (mag2 > sum) Some(mag) else None\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpng9h7zch.scala:17:45 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmpng9h7zch.scala:18:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mBigDecimalIsFractional\e[0m\
    \ in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num\
    \ of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659795535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val result\
    \ = magnitudes.zip(product).map(x => x._1 * x._2)\n        if (result.isEmpty)\
    \ None else Some(result.sum)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi774at4d.scala:19:36\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = magnitudes.zip(product).map(\e[36mx\e[0m => x._1 * x._2)\n\e[31m\e[31m \
    \  |\e[0m                                    ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                 Found:    (product : Int)\n\e[31m   |\e[0m \
    \                                   Required: IterableOnce[Any]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E051] Reference Error: /tmp/tmpi774at4d.scala:19:59 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = magnitudes.zip(product).map(\e\
    [36mx\e[0m => x._1 * x._2)\n\e[31m\e[31m   |\e[0m                            \
    \                          ^^^^^^\e[0m\n\e[31m   |\e[0mAmbiguous overload. The\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m\
    \ \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e\
    [0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int):\
    \ Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e\
    [31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mall match arguments ((x._2 : =>\
    \ Nothing))\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795537
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnq1zjnem.scala:23)\n\tat Problem.main(tmpnq1zjnem.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795521
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val sum = magnitudes.sum\n        if (sum > 0) Some(magnitudes.sum * product.sum)\
    \ else None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0v0v1qiz.scala:23)\n\tat Problem.main(tmp0v0v1qiz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795540
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduce(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsn0bc_fh.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitude = signs.map(x => x * product).sum\n   \
    \     magnitude.map(x => x.toLong)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwsrtm231.scala:19:18 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitude.map(\e[36mx\e[0m => x.toLong)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value map is not\
    \ a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659795538
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprxqaprpx.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitudes = arr.map(x => math.abs(x))\n        val\
    \ sum = magnitudes.zip(signs).map(x => x._1 * x._2).sum\n        if (sum == 0)\
    \ None else Some(sum)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps3wyjmur.scala:23)\n\tat Problem.main(tmps3wyjmur.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795542
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(product).filter(_._1\
    \ == _._2).map(_._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpugrcunob.scala:19:23\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).filter(_._1\
    \ == _._2).map(_._2).sum\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    (product : Int)\n\e[31m \
    \  |\e[0m                       Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpugrcunob.scala:19:41 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).filter(_._1 == _._2).map(_._2).sum\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                       value _1 is not a member of Long\n\
    \e[31m\e[31m-- Error: /tmp/tmpugrcunob.scala:19:66 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).filter(_._1 == _._2).map(_._2).sum\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \          ^\e[0m\n\e[31m   |\e[0m          No implicit Ordering defined for B\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m          where:    B is a type variable with\
    \ constraint <: Option[Long]\n\e[31m   |\e[0m          .\n3 errors found\n"
  stdout: ''
  timestamp: 1659795520
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitudes = signs.map(x => x * product).sum\n  \
    \      magnitudes.toOption\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8jtjst3n.scala:19:19 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.toOption\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value toOption is not\
    \ a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659795539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce((x,\
    \ y) => x * y)\n        val magnitudes = arr.map(x => math.abs(x))\n        val\
    \ result = magnitudes.map(x => x * product).sum\n        if (result > 0) Some(result)\
    \ else None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8h30udj8.scala:23)\n\tat Problem.main(tmp8h30udj8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        signs.foldLeft(product)(_ * _)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphhr1bskl.scala:18:31\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        signs.foldLeft(product)(_\
    \ * _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795538
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, elem) =>\n            product * elem\n        }\n\
    \        val signs = arr.map(elem => if (elem < 0) -1 else if (elem > 0) 1 else\
    \ 0)\n        signs.foldLeft(product) { (product, sign) =>\n            product\
    \ * sign\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpayccbtzf.scala:20:32\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        signs.foldLeft(product)\
    \ { (\e[36mproduct\e[0m, \e[36msign\e[0m) =>\n\e[31m\e[31m   |\e[0m        ^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m21 |\e[0m            product * sign\n\e[31m22 |\e[0m        }\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795539
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduce(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsn0bc_fh.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnq1zjnem.scala:23)\n\tat Problem.main(tmpnq1zjnem.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795521
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0g9ydhp8.scala:23)\n\tat Problem.main(tmp0g9ydhp8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).getOrElse(None)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp90ic_0_6.scala:19:41 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e[0m => x * product).getOrElse(None)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        value getOrElse is not a member of List[Long]\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        val result\
    \ = magnitude.map(x => product * x)\n        Some(result.sum)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvoq_b1ug.scala:19:31 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = magnitude.map(\e\
    [36mx\e[0m => product * x)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     value map is not a member of Long\n1\
    \ error found\n"
  stdout: ''
  timestamp: 1659795540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = product.map(math.abs)\n        val\
    \ sum = magnitudes.sum\n        if (sum > 0) Some(sum) else None\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_vd9mk03.scala:23)\n\tat Problem.main(tmp_vd9mk03.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795542
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val sum = magnitudes.sum\n        if (sum == 0) None else Some(sum * product.sum)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfz81161m.scala:23)\n\tat Problem.main(tmpfz81161m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L){\n            (product, elem) => product * elem\n        }\n\
    \        val signs = arr.map(elem => if (elem < 0L) -1L else 1L)\n        val\
    \ magnitudes = signs.map(elem => math.abs(elem))\n        val sum = magnitudes.foldLeft(product){\n\
    \            (sum, elem) => sum + elem\n        }\n        Some(sum)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp759fk_fj.scala:27)\n\tat Problem.main(tmp759fk_fj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795542
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduce((x, y) => x * y)\n     \
    \   magnitudes.map(x => x * product).sum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4sbx72kc.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795539
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).getOrElse(None)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp90ic_0_6.scala:19:41 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e[0m => x * product).getOrElse(None)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        value getOrElse is not a member of List[Long]\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduce(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsn0bc_fh.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnq1zjnem.scala:23)\n\tat Problem.main(tmpnq1zjnem.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795521
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.map(x => x * x).sum\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0).sum\n        Some(signs * product)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprg2md509.scala:21)\n\tat Problem.main(tmprg2md509.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795542
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(_.signum).sum\n        Some(signs * m * arr.product)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphbqejpo7.scala:21)\n\tat Problem.main(tmphbqejpo7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795543
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(_.signum).sum\n        Some(m * s)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjl2ha34u.scala:21)\n\tat Problem.main(tmpjl2ha34u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795542
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitudes = signs.map(x => math.abs(x))\n      \
    \  val productMagnitudes = magnitudes.map(x => x * product)\n        magnitudes.zip(productMagnitudes).filter(_._2\
    \ > 0).map(_._1)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp39kg_4dt.scala:20:62\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        magnitudes.zip(productMagnitudes).filter(_._2\
    \ > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[Int]\n\e[31m   |\e[0m        Required:\
    \ Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes\
    \ = magnitudes.map(x => x * product)\n        productMagnitudes.sum\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpar_i80bv.scala:20:8\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        productMagnitudes.sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \   Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        product.sum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpolz8c9ma.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        product.sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.foldLeft(0L)(_ + _)\n        Some(sum * product)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqkdvmahy.scala:23)\n\tat Problem.main(tmpqkdvmahy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795543
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(_.signum).sum\n        Some(signs * m * arr.product)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphbqejpo7.scala:21)\n\tat Problem.main(tmphbqejpo7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795543
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes\
    \ = magnitudes.map(x => x * product)\n        val productMagnitudesSum = productMagnitudes.sum\n\
    \        val productMagnitudesSumAbs = math.abs(productMagnitudesSum)\n      \
    \  if (productMagnitudesSumAbs == 0) None else Some(productMagnitudesSumAbs)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzciise6m.scala:25)\n\tat Problem.main(tmpzciise6m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795545
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).getOrElse(None)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp90ic_0_6.scala:19:41 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e[0m => x * product).getOrElse(None)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        value getOrElse is not a member of List[Long]\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz4mm5rjn.scala:23)\n\tat Problem.main(tmpz4mm5rjn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes\
    \ = magnitudes.map(x => x * product)\n        productMagnitudes.sum\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm6aisage.scala:20:8\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        productMagnitudes.sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \   Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795542
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitudes = arr.map(x => math.abs(x)).sum\n    \
    \    magnitudes * product * signs\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpci3udgj1.scala:19:29 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes * product * signs\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mLong\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m\
    \   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m\
    \ (x: Byte): Long\n\e[31m   |\e[0mmatch arguments ((signs : List[Int]))\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795550
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = product.map(x => math.abs(x))\n\
    \        magnitudes.sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4ckiwgh6.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795555
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        signs.foldLeft(product)(_ * _)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphhr1bskl.scala:18:31\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        signs.foldLeft(product)(_\
    \ * _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795538
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1l)(_ * _)\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ 1)\n        signs.foldLeft(product)(_ * _)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpojjp95p6.scala:18:31\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        signs.foldLeft(product)(_\
    \ * _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795557
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val sum = magnitudes.zip(product).map(x => x._1 * x._2).sum\n        if (sum\
    \ > 0) Some(sum) else None\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8v4hxmqt.scala:23)\n\tat Problem.main(tmp8v4hxmqt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795561
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).getOrElse(None)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp90ic_0_6.scala:19:41 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e[0m => x * product).getOrElse(None)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        value getOrElse is not a member of List[Long]\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprxqaprpx.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph7xspakn.scala:22)\n\tat Problem.main(tmph7xspakn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0g9ydhp8.scala:23)\n\tat Problem.main(tmp0g9ydhp8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) {\n            case (acc, x) => acc * x\n        }\n      \
    \  val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        signs.foldLeft(product)\
    \ {\n            case (acc, x) => acc * x\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpywcexqqa.scala:20:32\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        signs.foldLeft(product)\
    \ {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m21 |\e[0m            \e[33mcase\e\
    [0m (acc, x) => acc * x\n\e[31m22 |\e[0m        }\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795557
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x)).sum\n        mag match {\n            case 0 =>\
    \ None\n            case x if x == 0 => Some(sum)\n            case x => Some(sum\
    \ - mag)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpds9upb4j.scala:17:45 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmpds9upb4j.scala:18:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e\
    [33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795559
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.map(x => x * magnitudes.getOrElse(0l)).sum\n\
    \        val result = if (product == 0l) None else Some(product)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfpfl2dqv.scala:18:52 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = signs.map(\e\
    [36mx\e[0m => x * magnitudes.getOrElse(\e[31m0l\e[0m)).sum\n\e[31m\e[31m   |\e\
    [0m                                         ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value getOrElse is not a member of List[Long]\n\
    \e[31m\e[31m-- Error: /tmp/tmpfpfl2dqv.scala:18:70 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = signs.map(\e\
    [36mx\e[0m => x * magnitudes.getOrElse(\e[31m0l\e[0m)).sum\n\e[31m\e[31m   |\e\
    [0m                                                                      ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mCharIsIntegral\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter\
    \ num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659795559
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, elem) => product * elem}\n        val signs = arr.map(elem\
    \ => if (elem < 0L) -1L else 0L)\n        val magnitudes = arr.map(elem => if\
    \ (elem < 0L) elem else elem * product)\n        magnitudes.sum\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt_v1_g1s.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795558
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes\
    \ = magnitudes.map(x => x * product)\n        productMagnitudes.sum\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpna84lg6n.scala:20:8\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        productMagnitudes.sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \   Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795560
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyji_fyx7.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        Some(sum * product)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5wy4rfo6.scala:23)\n\tat Problem.main(tmp5wy4rfo6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph7xspakn.scala:22)\n\tat Problem.main(tmph7xspakn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val sum = magnitudes.sum\n        val result = if (sum == 0) None else Some(sum\
    \ * product.sum)\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbktq84z9.scala:24)\n\tat Problem.main(tmpbktq84z9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795565
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitudes = arr.map(x => math.abs(x))\n  \
    \      val sum = magnitudes.foldLeft(0L) { (x, y) => x + y }\n        Some(sum\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzrskdr_q.scala:23)\n\tat Problem.main(tmpzrskdr_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795518
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val sum = magnitudes.sum\n        if (sum == 0) None else Some(sum * product.sum)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfz81161m.scala:23)\n\tat Problem.main(tmpfz81161m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        signs.map(x => x * product).sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp80ddwdx_.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        signs.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = product.map(x => math.abs(x))\n\
    \        magnitudes.sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4ckiwgh6.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795555
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.map(x => x * x).sum\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        signs.map(x => product * x).sum\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpajzqeu9q.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        signs.map(\e[36mx\e\
    [0m => product * x).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795561
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprxqaprpx.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x)).filter(x => x != 0)\n\
    \        magnitudes.map(x => x * product).sum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_gfymwf3.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795562
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes\
    \ = magnitudes.map(x => x * product)\n        val productMagnitudesSum = productMagnitudes.sum\n\
    \        val productMagnitudesSumAbs = math.abs(productMagnitudesSum)\n      \
    \  val productMagnitudesSumAbsMinusOne = productMagnitudesSumAbs - 1\n       \
    \ val productMagnitudesSumAbsMinusOneAbs = math.abs(productMagnitudesSumAbsMinusOne)\n\
    \        val productMagnitudesSumAbsMinusOneAbsMinusOne = productMagnitudesSumAbsMinusOneAbs\
    \ - 1\n        val productMagnitudesSumAbsMinusOneAbsMinusOneAbs = math.abs(productMagnitudesSumAbsMinusOneAbsMinusOne)\n\
    \        val productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOne = productMagnitudesSumAbsMinusOneAbsMinusOneAbs\
    \ - 1\n        val productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne\
    \ = math.abs(productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOne)\n        val\
    \ productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne\
    \ = productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne\
    \ - 1\n        val productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne\
    \ = math.abs(productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne)\n\
    \        val productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpptwkilvz.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpptwkilvz.scala:28:90\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mproductMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne\e\
    [0m = productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                                    ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmpptwkilvz.scala:29:117 ----------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36mproductMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne\e\
    [0m = math.abs(productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                        ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mabs\e\
    [0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long):\
    \ Long\n\e[31m   |\e[0m (x: Int): Int\n\e[31m   |\e[0mmatch arguments ((\n\e[31m\
    \   |\e[0m  productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne\n\
    \e[31m   |\e[0m : Null))\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpptwkilvz.scala:31:5\
    \ ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when comp"
  stdout: ''
  timestamp: 1659795562
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        signs.map(x => product * x).sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_kqnnjtk.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        signs.map(\e[36mx\e\
    [0m => product * x).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        val result\
    \ = if (magnitude == 0) None else Some(magnitude * product)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9z_90hw9.scala:23)\n\tat Problem.main(tmp9z_90hw9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795565
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(product).filter(_._1\
    \ == _._2).map(_._1).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9zbce835.scala:19:23\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).filter(_._1\
    \ == _._2).map(_._1).sum\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    (product : Int)\n\e[31m \
    \  |\e[0m                       Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp9zbce835.scala:19:41 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).filter(_._1 == _._2).map(_._1).sum\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                       value _1 is not a member of Long\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795564
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val product = signs.reduce(_ * _)\n        Some(signs.map(x => x * product).sum\
    \ / m)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps7vnsaws.scala:22)\n\tat Problem.main(tmps7vnsaws.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795498
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val sum = magnitudes.sum\n        if (sum == 0) None else Some(sum * product.sum)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfz81161m.scala:23)\n\tat Problem.main(tmpfz81161m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        Some(sum * product)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5wy4rfo6.scala:23)\n\tat Problem.main(tmp5wy4rfo6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduce(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsn0bc_fh.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        val productSigns = signs.map(x => x * product)\n        val productSignsSum\
    \ = productSigns.sum\n        if (sum == productSignsSum) Some(sum) else None\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvnpnrkzc.scala:25)\n\tat Problem.main(tmpvnpnrkzc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795566
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        signs.map(x => x * product).sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp80ddwdx_.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        signs.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce((x,\
    \ y) => x * y)\n        val magnitudes = arr.map(x => math.abs(x))\n        val\
    \ productMagnitudes = magnitudes.reduce((x, y) => x * y)\n        if (productMagnitudes\
    \ == 0) None else Some(product * productMagnitudes)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo4y6p6f4.scala:23)\n\tat Problem.main(tmpo4y6p6f4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795566
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val productMagnitudes = product.zip(magnitudes)\n        productMagnitudes.foldLeft(0l)\
    \ { (sum, tuple) => sum + tuple._1 * tuple._2 }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqf1hpg_7.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        productMagnitudes.foldLeft(\e\
    [31m0l\e[0m) { (\e[36msum\e[0m, \e[36mtuple\e[0m) => sum + tuple._1 * tuple._2\
    \ }\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795563
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitude = arr.map(x => x * x).map(x => math.abs(x)).sum\n\
    \        val result = signs.zip(magnitude).map(x => x._1 * x._2)\n        Some(result.sum)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpixo801_s.scala:19:31\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = signs.zip(magnitude).map(\e[36mx\e[0m => x._1 * x._2)\n\e[31m\e[31m   |\e\
    [0m                               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                   Found:    (magnitude : Long)\n\e[31m   |\e[0m            \
    \                   Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E051] Reference Error: /tmp/tmpixo801_s.scala:19:56 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = signs.zip(magnitude).map(\e\
    [36mx\e[0m => x._1 * x._2)\n\e[31m\e[31m   |\e[0m                            \
    \                       ^^^^^^\e[0m\n\e[31m   |\e[0mAmbiguous overload. The overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mInt\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Int\n\e[31m\
    \   |\e[0m (x: Char): Int\n\e[31m   |\e[0m (x: Short): Int\n\e[31m   |\e[0m (x:\
    \ Byte): Int\n\e[31m   |\e[0mall match arguments ((x._2 : => Nothing))\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795564
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(product).map(x\
    \ => (x._1 * x._2)).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgclcmi5w.scala:19:23\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).map(\e\
    [36mx\e[0m => (x._1 * x._2)).sum\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Found:    (product : Int)\n\
    \e[31m   |\e[0m                       Required: IterableOnce[Any]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E051] Reference Error: /tmp/tmpgclcmi5w.scala:19:47 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).map(\e[36mx\e[0m => (x._1\
    \ * x._2)).sum\n\e[31m\e[31m   |\e[0m                                        \
    \  ^^^^^^\e[0m\n\e[31m   |\e[0mAmbiguous overload. The overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mall match arguments ((x._2 : => Nothing))\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpgclcmi5w.scala:19:59 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).map(\e[36mx\e[0m => (x._1\
    \ * x._2)).sum\n\e[31m\e[31m   |\e[0m                                        \
    \                   ^\e[0m\n\e[31m   |\e[0m          No implicit Ordering defined\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          where:    B is a type variable\
    \ with constraint <: Option[Long]\n\e[31m   |\e[0m          .\n3 errors found\n"
  stdout: ''
  timestamp: 1659795566
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitudes = signs.map(x => math.abs(x))\n      \
    \  val sum = magnitudes.map(x => x * product).sum\n        if (sum > 0) Some(sum)\
    \ else None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp52b9wans.scala:23)\n\tat Problem.main(tmp52b9wans.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795569
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce((x,\
    \ y) => x * y)\n        val magnitudes = arr.map(x => math.abs(x))\n        val\
    \ sum = magnitudes.reduce((x, y) => x + y)\n        val result = if (sum == product)\
    \ Some(product) else None\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdh0olh58.scala:21:8\
    \ ---------------------\e[0m\e[0m\n\e[31m21 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Option[Int])\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795569
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        val result = Some(sum * product)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqloulvfs.scala:24)\n\tat Problem.main(tmpqloulvfs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795579
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes\
    \ = magnitudes.map(x => x * product)\n        productMagnitudes.sum\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpar_i80bv.scala:20:8\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        productMagnitudes.sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \   Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.product\n        val result = magnitudes.map(x\
    \ => x * product).sum\n        if (result > 0) Some(result) else None\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd6etm1hw.scala:23)\n\tat Problem.main(tmpd6etm1hw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitudes = arr.map(x => math.abs(x))\n  \
    \      val sum = magnitudes.foldLeft(0L) { (x, y) => x + y }\n        Some(sum\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzrskdr_q.scala:23)\n\tat Problem.main(tmpzrskdr_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.map(x => x * magnitudes.getOrElse(0l))\n\
    \        magnitudes.zip(product).map(x => x._1 * x._2).sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwl0wtug3.scala:18:52 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = signs.map(\e\
    [36mx\e[0m => x * magnitudes.getOrElse(\e[31m0l\e[0m))\n\e[31m\e[31m   |\e[0m\
    \                                         ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                           value getOrElse is not a member of List[Long]\n\
    \e[31m\e[31m-- [E051] Reference Error: /tmp/tmpwl0wtug3.scala:19:46 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).map(\e[36mx\e[0m => x._1\
    \ * x._2).sum\n\e[31m\e[31m   |\e[0m                                         ^^^^^^\e\
    [0m\n\e[31m   |\e[0mAmbiguous overload. The overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e\
    [0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x:\
    \ Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\
    \e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e\
    [0mall match arguments ((x._2 : => Nothing))\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpwl0wtug3.scala:19:57 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).map(\e[36mx\e[0m => x._1\
    \ * x._2).sum\n\e[31m\e[31m   |\e[0m                                         \
    \                ^\e[0m\n\e[31m   |\e[0m          No implicit Ordering defined\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          where:    B is a type variable\
    \ with constraint <: Option[Long]\n\e[31m   |\e[0m          .\n3 errors found\n"
  stdout: ''
  timestamp: 1659795579
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        Some(sum * product)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5wy4rfo6.scala:23)\n\tat Problem.main(tmp5wy4rfo6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        product.sum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpolz8c9ma.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        product.sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6vtqaekx.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(signs).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).getOrElse(None)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp90ic_0_6.scala:19:41 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e[0m => x * product).getOrElse(None)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        value getOrElse is not a member of List[Long]\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce((x,\
    \ y) => x * y)\n        val magnitudes = arr.map(x => math.abs(x))\n        val\
    \ productMagnitudes = magnitudes.map(x => x * product)\n        val sum = productMagnitudes.reduce((x,\
    \ y) => x + y)\n        Some(sum)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj8f16n_8.scala:24)\n\tat Problem.main(tmpj8f16n_8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val sum = magnitudes.sum\n        if (sum > 0) Some(magnitudes.sum * product.sum)\
    \ else None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0v0v1qiz.scala:23)\n\tat Problem.main(tmp0v0v1qiz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795540
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x)).sum\n        Some(mag)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwe8yt9ir.scala:17:45 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmpwe8yt9ir.scala:18:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e\
    [33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduce(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsn0bc_fh.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        val result = if (product == 0) None else\
    \ Some(sum / product)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8i5oa5lq.scala:24)\n\tat Problem.main(tmp8i5oa5lq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.product\n        val productMagnitudes\
    \ = magnitudes.map(x => x * product)\n        val productMagnitudesSum = productMagnitudes.sum\n\
    \        val productMagnitudesSumAbs = productMagnitudesSum.abs\n        val productMagnitudesSumAbsProduct\
    \ = productMagnitudesSumAbs.product\n        val productMagnitudesSumAbsProductProduct\
    \ = productMagnitudesSumAbsProduct.product\n        val productMagnitudesSumAbsProductProductProduct\
    \ = productMagnitudesSumAbsProductProduct.product\n        val productMagnitudesSumAbsProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProduct.product\n        val productMagnitudesSumAbsProductProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProductProduct.product\n        val productMagnitudesSumAbsProductProductProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProductProductProduct.product\n     \
    \   val productMagnitudesSumAbsProductProductProductProductProductProduct = productMagnitudesSumAbsProductProductProductProductProductProduct.product\n\
    \        val productMagnitudesSumAbsProductProductProductProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProductProductProductProductProduct.product\n\
    \        val productMagnitudesSumAbsProductProductProductProductProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProductProductProductProductProductProduct.product\n\
    \        val productMagnitudesSumAbsProductProductProductProductProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProductProductProductProductProductProduct.product\n\
    \        val productMagnitudesSumAbsProductProductProductProductProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProductProductProductProductProductProductProduct.product\n\
    \        val productMagnitudesSumAbsProductProductProductProductProductProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProductProductProductProductProductProductProduct.product\n\
    \        val productMagnitudesSumAbsProductProductProductProductProductProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProductProductProductProductProductProductProduct.product\n\
    \        val product\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpthk91nhu.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpthk91nhu.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mproductMagnitudesSumAbsProductProductProductProductProductProduct\e[0m\
    \ = productMagnitudesSumAbsProductProductProductProductProductProduct.product\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mproductMagnitudesSumAbsProductProductProductProductProductProduct\
    \ is already defined as \e[33mvalue\e[0m \e[35mproductMagnitudesSumAbsProductProductProductProductProductProduct\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpthk91nhu.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mproductMagnitudesSumAbsProductProductProductProductProductProductProductProduct\e\
    [0m = productMagnitudesSumAbsProductProductProductProductProductProductProductProduct.product\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mproductMagnitudesSumAbsProductProductProductProductProductProductProductProduct\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  productMagnitudesSumAbsProductProductProductProductProductProductProductProduct\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpthk91nhu.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mproductMagnitudesSumAbsProductProductProductProductProductProductPr"
  stdout: ''
  timestamp: 1659795582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val sum = magnitudes.sum\n        val result = magnitudes.zip(product).map(x\
    \ => x._1 * x._2).sum\n        if (sum == 0) None else Some(result)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe2vp1vwn.scala:24)\n\tat Problem.main(tmpe2vp1vwn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val productMagnitudes = product.zip(magnitudes)\n        val productMagnitudesSum\
    \ = productMagnitudes.map(x => x._1 * x._2)\n        val productMagnitudesSumSum\
    \ = productMagnitudesSum.sum\n        val productMagnitudesSumSumAbs = math.abs(productMagnitudesSumSum)\n\
    \        val productMagnitudesSumSumAbsAbs = math.abs(productMagnitudesSumSumAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbs = math.abs(productMagnitudesSumSumAbsAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbsAbs = math.abs(productMagnitudesSumSumAbsAbsAbsAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbsAbsAbs = math.abs(productMagnitudesSumSumAbsAbsAbsAbsAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbsAbsAbsAbs = math.abs(productMagnitudesSumSumAbsAbsAbsAbsAbsAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbs = math.abs(productMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbs = math.abs(productMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbsAbs = math.abs(productMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbsAbsAbs = math.abs(productMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbsAbsAbsAb\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppknguct7.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppknguct7.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mproductMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbs\e[0m = math.abs(productMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbs)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mproductMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbs is already defined\
    \ as \e[33mvalue\e[0m \e[35mproductMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbs\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmppknguct7.scala:25:59 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mproductMagnitudesSumSumAbsAbsAbsAbs\e[0m\
    \ = math.abs(productMagnitudesSumSumAbsAbsAbsAbs)\n\e[31m\e[31m   |\e[0m     \
    \                                                      ^\e[0m\n\e[31m   |\e[0m\
    \          Recursive \e[33mvalue\e[0m \e[35mproductMagnitudesSumSumAbsAbsAbsAbs\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppknguct7.scala:26:62\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mproductMagnitudesSumSumAbsAbsAbsAbsAbs\e[0m = math.abs(productMagnitudesSumSumAbsAbsAbsAbsAbs)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      ^\e[0m\n\e[31m   |\e[0m       Recursive \e[33mvalue\e[0m \e[35mproductMagnitudesSumSumAbsAbsAbsAbsAbs\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppknguct7.scala:27:65\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mproductMagnitudesSumSumAbsAbsAbsAbsAbsAbs\e[0m = math.abs(prod"
  stdout: ''
  timestamp: 1659795579
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitude = signs.map(x => x * product).sum\n   \
    \     Some(magnitude)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9bdujhan.scala:22)\n\tat Problem.main(tmp9bdujhan.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitude = product.map(x => math.abs(x))\n \
    \       val sum = magnitude.sum\n        if (sum > 0) Some(sum) else None\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph01e1p4h.scala:23)\n\tat Problem.main(tmph01e1p4h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnq1zjnem.scala:23)\n\tat Problem.main(tmpnq1zjnem.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795521
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnq1zjnem.scala:23)\n\tat Problem.main(tmpnq1zjnem.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6vtqaekx.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(signs).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        val productOfSigns = signs.product\n        if (magnitude == 0) None\
    \ else Some(sum * productOfSigns)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq4obblma.scala:21:12 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (magnitude == \e[31m0\e[0m) None\
    \ \e[33melse\e[0m Some(sum * productOfSigns)\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Not found: magnitude\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprxqaprpx.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        Some(sum * product)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5wy4rfo6.scala:23)\n\tat Problem.main(tmp5wy4rfo6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        val productSign = signs.reduceLeft(_ *\
    \ _)\n        if (sum == product) return Some(product)\n        if (sum == productSign)\
    \ return Some(product)\n        None\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8g0b67r8.scala:26)\n\tat Problem.main(tmp8g0b67r8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph7xspakn.scala:22)\n\tat Problem.main(tmph7xspakn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr9ycocdb.scala:23)\n\tat Problem.main(tmpr9ycocdb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        product.sum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpolz8c9ma.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        product.sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val result\
    \ = magnitudes.map(x => x * product).sum\n        if (result > 0) Some(result)\
    \ else None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppx8rf761.scala:23)\n\tat Problem.main(tmppx8rf761.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        signs.map(x => x * product).sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp80ddwdx_.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        signs.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyji_fyx7.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph7xspakn.scala:22)\n\tat Problem.main(tmph7xspakn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795561
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduce(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsn0bc_fh.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0g9ydhp8.scala:23)\n\tat Problem.main(tmp0g9ydhp8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795498
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0g9ydhp8.scala:23)\n\tat Problem.main(tmp0g9ydhp8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        signs.map(x => product * x).sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_kqnnjtk.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        signs.map(\e[36mx\e\
    [0m => product * x).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => product * x).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd11m7gpo.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => product * x).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyji_fyx7.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.product\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1rnr1dqk.scala:23)\n\tat Problem.main(tmp1rnr1dqk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val productMagnitudes = product.zip(magnitudes)\n        productMagnitudes.foldLeft(0l){\
    \ (sum, tuple) => sum + tuple._1 * tuple._2 }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpebeyadae.scala:20:38\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        productMagnitudes.foldLeft(\e\
    [31m0l\e[0m){ (\e[36msum\e[0m, \e[36mtuple\e[0m) => sum + tuple._1 * tuple._2\
    \ }\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5j6i7rlt.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(product).filter(_._1\
    \ == _._2).map(_._2)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdjacmykw.scala:19:23\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).filter(_._1\
    \ == _._2).map(_._2)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Found:    (product : Int)\n\e[31m   |\e\
    [0m                       Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpdjacmykw.scala:19:41 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        magnitudes.zip(product).filter(_._1 == _._2).map(_._2)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                       value _1 is not a member of Long\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(_.signum).sum\n        Some(m * s)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjl2ha34u.scala:21)\n\tat Problem.main(tmpjl2ha34u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795542
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = product.map(x => math.abs(x))\n\
    \        magnitudes.sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4ckiwgh6.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        magnitudes.sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795555
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(x => if (x == 0) 0 else math.signum(x)).sum\n       \
    \ Some(s * m)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcaj3b2je.scala:21)\n\tat Problem.main(tmpcaj3b2je.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val result\
    \ = magnitudes.zip(product).map(x => x._1 * x._2)\n        if (result.isEmpty)\
    \ None else Some(result.sum)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxprrp2cw.scala:19:36\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = magnitudes.zip(product).map(\e[36mx\e[0m => x._1 * x._2)\n\e[31m\e[31m \
    \  |\e[0m                                    ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                 Found:    (product : Long)\n\e[31m   |\e[0m\
    \                                    Required: IterableOnce[Any]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E051] Reference Error: /tmp/tmpxprrp2cw.scala:19:59 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = magnitudes.zip(product).map(\e\
    [36mx\e[0m => x._1 * x._2)\n\e[31m\e[31m   |\e[0m                            \
    \                          ^^^^^^\e[0m\n\e[31m   |\e[0mAmbiguous overload. The\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m\
    \ \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e\
    [0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int):\
    \ Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e\
    [31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mall match arguments ((x._2 : =>\
    \ Nothing))\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795583
