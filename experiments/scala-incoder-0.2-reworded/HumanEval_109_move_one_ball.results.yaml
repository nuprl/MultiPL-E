language: scala
name: HumanEval_109_move_one_ball
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:34:12 ----------"
  stdout: ''
  timestamp: 1659797997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val max = (1 << n) - 1\n        val min = 0\n        val maxVal = arr.max\n\
    \        val minVal = arr.min\n        val maxPos = max - 1\n        val minPos\
    \ = min - 1\n        val maxPosVal = maxVal - 1\n        val minPosVal = minVal\
    \ - 1\n        val maxPosPos = maxPos - 1\n        val minPosPos = minPos - 1\n\
    \        val maxPosPosVal = maxPosVal - 1\n        val minPosPosVal = minPosVal\
    \ - 1\n        val maxPosPosPos = maxPosPos - 1\n        val minPosPosPos = minPosPos\
    \ - 1\n        val maxPosPosPosVal = maxPosPosVal - 1\n        val minPosPosPosVal\
    \ = minPosPosVal - 1\n        val maxPosPosPosPos = maxPosPosPos - 1\n       \
    \ val minPosPosPosPos = minPosPosPos - 1\n        val maxPosPosPosPosVal = maxPosPosPosVal\
    \ - 1\n        val minPosPosPosPosVal = minPosPosPosVal - 1\n        val maxPosPosPosPosPos\
    \ = maxPosPosPosPos - 1\n        val minPosPosPosPosPos = minPosPosPosPos - 1\n\
    \        val maxPosPosPosPosPosVal = maxPosPosPosPosVal - 1\n        val minPosPosPosPosPosVal\
    \ = minPosPosPosPosVal - 1\n        val maxPosPosPosPosPosPosVal = maxPosPosPosPosPosVal\
    \ - 1\n        val minPosPosPosPosPosPosVal = minPosPosPosPosPosPosVal - 1\n \
    \       val maxPosPosPosPosPosPosPosVal = maxPosPosPosPosPosPosPosVal - 1\n  \
    \      val minPosPosPosPosPosPosPosVal = minPosPosPosPosPosPosPosVal - 1\n   \
    \     val maxPosPosPosPosPosPosPosPosVal = maxPosPosPosPosPosPosPosPosPosVal -\
    \ 1\n        val minPosPosPosPosPosPosPosPosVal = minPosPosPosPosPosPosPosPosVal\
    \ - 1\n        val maxPosPosPosPosPosPosPosPosPosVal = maxPosPosPosPosPosPosPosPosPosPosVal\
    \ - 1\n        val minPosPosPosPosPosPosPosPosPosVal = minPosPosPosPosPosPosPosPosPosPosVal\
    \ - 1\n        val maxPosPosPosPosPosPosPosPosPosVal = maxPosPosPosPosPosPosPosPosPosPos\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8yqft3dw.scala:59:12 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \e[36mmaxPosPosPosPosPosPosPosPosPosVal\e\
    [0m = maxPosPosPosPosPosPosPosPosPosPos\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxPosPosPosPosPosPosPosPosPosVal is already defined as \e\
    [33mvalue\e[0m \e[35mmaxPosPosPosPosPosPosPosPosPosVal\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8yqft3dw.scala:52:39\
    \ ---------------------------\e[0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminPosPosPosPosPosPosVal\e[0m = minPosPosPosPosPosPosVal - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m   |\e\
    [0m                     Recursive \e[33mvalue\e[0m \e[35mminPosPosPosPosPosPosVal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8yqft3dw.scala:53:42\
    \ ---------------------------\e[0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxPosPosPosPosPosPosPosVal\e[0m = maxPosPosPosPosPosPosPosVal - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                                          ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35mmaxPosPosPosPosPosPosPosVal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8yqft3dw.scala:54:42\
    \ ---------------------------\e[0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminPosPosPosPosPosPosPosVal\e[0m = minPosPosPosPosPosPosPosVal - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                                          ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35mminPosPosPosPosPosPosPosVal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8yqft3dw.scala:57:48\
    \ -----------------"
  stdout: ''
  timestamp: 1659797997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        if (n == 0) true\n        else {\n            val m = arr.head\n    \
    \        val r = arr.tail\n            val m = m.toLong\n            val r = r.toLong\n\
    \            val rr = r.tail\n            val rr = rr.toLong\n            val\
    \ rrr = rr.tail\n            val rrr = rrr.toLong\n            val rrrr = rrr.tail\n\
    \            val rrrrr = rrrrr.toLong\n            val rrrrrr = rrrrrr.tail\n\
    \            val rrrrrrr = rrrrrrr.tail\n            val rrrrrrrr = rrrrrrrrr.tail\n\
    \            val rrrrrrrrr = rrrrrrrrrrr.tail\n            val rrrrrrrrrr = rrrrrrrrrrrrr.tail\n\
    \            val rrrrrrrrrrr = rrrrrrrrrrrrrrr.tail\n            val rrrrrrrrrrrr\
    \ = rrrrrrrrrrrrrrr.tail\n            val rrrrrrrrrrrr = rrrrrrrrrrrrrrr.tail\n\
    \            val rrrrrrrrrrrrr = rrrrrrrrrrrrrrr.tail\n            val rrrrrrrrrrrrrr\
    \ = rrrrrrrrrrrrrrrrr.tail\n            val rrrrrrrrrrrrrrr = rrrrrrrrrrrrrrrrr.tail\n\
    \            val rrrrrrrrrrrrrrrr = rrrrrrrrrrrrrrrrrrr.tail\n            val\
    \ rrrrrrrrrrrrrrrrrr = rrrrrrrrrrrrrrrrrrrrr.tail\n            val rrrrrrrrrrrrrrrrrrr\
    \ = rrrrrrrrrrrrrrrrrrr.tail\n            val rrrrrrrrrrrrrrrrrr = rrrrrrrrrrrrrrrrrrr.tail\n\
    \            val rrrrrrrrrrrrrrrrrrr = rrrrrrrrrrrrrrrrrrrrr.tail\n          \
    \  val rrrrrrrrrrrrrrrrrrrr = rrrrrrrrrrrrrrrrrrrrr.tail\n            val rrrrrrrrrrrrrrrrrrrrr\
    \ = rrrrrrrrrrrrrrrrrrrrrrr.tail\n            val rrrrrrrrrrrrrrrrrrrrrr = rrrrrrrrrrrrrrrrrrrrrrr.tail\n\
    \            val rrrrrrrrrrrrrrrrrrrrrr = rrrrrrrrrrrrrrrrrrrrrrr.tail\n     \
    \       val rr\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplticdbtv.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplticdbtv.scala:70:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m70 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplticdbtv.scala:31:16 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = m.toLong\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmplticdbtv.scala:32:16 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r.toLong\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmplticdbtv.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mrr\e[0m = rr.toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrr is\
    \ already defined as \e[33mvalue\e[0m \e[35mrr\e[0m\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplticdbtv.scala:36:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e\
    [0m \e[36mrrr\e[0m = rrr.toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrrr is already defined as \e[33mvalue\e[0m \e[35mrrr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmplticdbtv.scala:46:16 ---------------------------\e[0m\e[0"
  stdout: ''
  timestamp: 1659797997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val d = arr.tail\n        val r = new Array[Long](n)\n\
    \        val s = new Array[Long](n)\n        val t = new Array[Long](n)\n    \
    \    val u = new Array[Long](n)\n        val v = new Array[Long](n)\n        val\
    \ w = new Array[Long](n)\n        val x = new Array[Long](n)\n        val y =\
    \ new Array[Long](n)\n        val z = new Array[Long](n)\n        val a = new\
    \ Array[Long](n)\n        val b = new Array[Long](n)\n        val c = new Array[Long](n)\n\
    \        val d = new Array[Long](n)\n        val e = new Array[Long](n)\n    \
    \    val f = new Array[Long](n)\n        val g = new Array[Long](n)\n        val\
    \ h = new Array[Long](n)\n        val i = new Array[Long](n)\n        val j =\
    \ new Array[Long](n)\n        val k = new Array[Long](n)\n        val l = new\
    \ Array[Long](n)\n        val m = new Array[Long](n)\n        val n = new Array[Long](n)\n\
    \        val o = new Array[Long](n)\n        val p = new Array[Long](n)\n    \
    \    val q = new Array[Long](n)\n        val r = new Array[Long](n)\n        val\
    \ s = new Array[Long](n)\n        val t = new Array[Long](n)\n        val u =\
    \ new Array[Long](n)\n        val v = new Array[Long](n)\n        val w = new\
    \ Array[Long](n)\n        val x = new Array[Long](n)\n        val y = new Array[Long](n)\n\
    \        val z = new Array[Long](n)\n        val a = new Array[Long](n)\n    \
    \    val b = new Array[Long](n)\n        val c = new Array[Long](n)\n        val\
    \ d = new Array[Long](n)\n        val e = new Array[Long](n)\n        val f =\
    \ new Array[Long](n)\n        val g = new Array[Long](n)\n        val h = new\
    \ Array[Long](n)\n        val i = new Array[Long](n)\n        val j = new Array[Long](n)\n\
    \        val k = new Array[Long](n)\n        val l = new Array[Long](n)\n    \
    \    val m = new Array[Long](n)\n        val n = new Array[Long](n)\n        val\
    \ o = new Array[\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppe2p2k5l.scala:79:4 ----------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmppe2p2k5l.scala:41:12 ---------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m        \e[33mval\e[0m \e[36md\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0md is already defined as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmppe2p2k5l.scala:50:12 ---------------------------\e[0m\e[0m\n\e[31m50\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmppe2p2k5l.scala:51:12 ---------------------------\e[0m\e[0m\n\e[31m51\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmppe2p2k5l.scala:55:12 ---------------------------\e[0m\e[0m\n\e[31m55\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmppe2p2k5l.scala:56:12 ---------------------------\e[0m\e[0m\n\e[31m56\
    \ |\e[0m        \e[33mva"
  stdout: ''
  timestamp: 1659797996
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(_)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.takeRight(n)\n        arr.forall(x\
    \ => arr.contains(x))\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnhmsbrnr.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnhmsbrnr.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpnhmsbrnr.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.takeRight(n)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnhmsbrnr.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659797992
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toList\n        val len = arr.length\n \
    \       val arr = arr.toArray\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toArray\n  \
    \      val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toList\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toArray\n        val len = arr.length\n  \
    \      val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toArray\n        val len = arr.length\n  \
    \      val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toArray\n        val len = arr.length\n  \
    \      val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toArray\n        val len = arr.length\n  \
    \      val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toArray\n        val len = arr.length\n  \
    \      val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toArray\n        val len = arr.length\n  \
    \      val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toArray\n        val len = arr.length\n  \
    \      val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.to\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzjdjl6fj.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzjdjl6fj.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzjdjl6fj.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzjdjl6fj.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzjdjl6fj.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzjdjl6fj.scala:33:12\
    \ ------"
  stdout: ''
  timestamp: 1659797997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val s = arr.tail\n        val x = arr.toList\n        val y = x.toList\n\
    \        val z = x.toList\n        val w = x.toList\n        val a = x.toList\n\
    \        val b = x.toList\n        val c = x.toList\n        val d = x.toList\n\
    \        val e = x.toList\n        val f = x.toList\n        val g = x.toList\n\
    \        val h = x.toList\n        val i = x.toList\n        val j = x.toList\n\
    \        val k = x.toList\n        val l = x.toList\n        val m = x.toList\n\
    \        val n = x.toList\n        val o = x.toList\n        val p = x.toList\n\
    \        val q = x.toList\n        val r = x.toList\n        val s = x.toList\n\
    \        val t = x.toList\n        val u = x.toList\n        val v = x.toList\n\
    \        val w = x.toList\n        val x = x.toList\n        val y = x.toList\n\
    \        val z = x.toList\n        val w = x.toList\n        val a = x.toList\n\
    \        val b = x.toList\n        val c = x.toList\n        val d = x.toList\n\
    \        val e = x.toList\n        val f = x.toList\n        val g = x.toList\n\
    \        val h = x.toList\n        val i = x.toList\n        val j = x.toList\n\
    \        val k = x.toList\n        val l = x.toList\n        val m = x.toList\n\
    \        val n = x.toList\n        val o = x.toList\n        val p = x.toList\n\
    \        val q = x.toList\n        val r = x.toList\n        val s = x.toList\n\
    \        val t = x.toList\n        val u = x.toList\n        val v = x.toList\n\
    \        val w = x.toList\n        val x = x.toList\n        val y = x.toList\n\
    \        val z = x.toList\n        val w = x.toList\n        val a = x.toList\n\
    \        val b = x.toList\n        val c = x.toList\n        val d = x.toList\n\
    \        val e = x.toList\n        val f = x.toList\n        val g = x.toList\n\
    \        val h = x.toList\n        val i = x.toList\n        val j = x.toList\n\
    \        val k = x.toList\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qa1tqda.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = x.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qa1tqda.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = x.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qa1tqda.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = x.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qa1tqda.scala:52:12 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = x.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qa1tqda.scala:53:12 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = x.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qa1tqda.scala:57:12 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m "
  stdout: ''
  timestamp: 1659797998
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val max =\
    \ (len - 1)\n        val min = 0\n        val maxVal = arr(max)\n        val minVal\
    \ = arr(min)\n        val maxVal1 = (maxVal - minVal)\n        val maxVal2 = (maxVal\
    \ + minVal)\n        val maxVal3 = (maxVal - minVal)\n        val maxVal4 = (maxVal\
    \ + minVal)\n        val maxVal5 = (maxVal - minVal)\n        val maxVal6 = (maxVal\
    \ + minVal)\n        val maxVal7 = (maxVal - minVal)\n        val maxVal8 = (maxVal\
    \ + minVal)\n        val maxVal9 = (maxVal - minVal)\n        val maxVal10 = (maxVal\
    \ + minVal)\n        val maxVal11 = (maxVal - minVal)\n        val maxVal12 =\
    \ (maxVal + minVal)\n        val maxVal13 = (maxVal - minVal)\n        val maxVal14\
    \ = (maxVal + minVal)\n        val maxVal15 = (maxVal - minVal)\n        val maxVal16\
    \ = (maxVal + minVal)\n        val maxVal17 = (maxVal - minVal)\n        val maxVal18\
    \ = (maxVal + minVal)\n        val maxVal19 = (maxVal - minVal)\n        val maxVal20\
    \ = (maxVal + minVal)\n        val maxVal21 = (maxVal - minVal)\n        val maxVal22\
    \ = (maxVal + minVal)\n        val maxVal23 = (maxVal - minVal)\n        val maxVal24\
    \ = (maxVal + minVal)\n        val maxVal25 = (maxVal - minVal)\n        val maxVal26\
    \ = (maxVal + minVal)\n        val maxVal27 = (maxVal - minVal)\n        val maxVal28\
    \ = (maxVal + minVal)\n        val maxVal29 = (maxVal - minVal)\n        val maxVal30\
    \ = (maxVal + minVal)\n        val maxVal31 = (maxVal - minVal)\n        val maxVal32\
    \ = (maxVal + minVal)\n        val maxVal33 = (maxVal - minVal)\n        val maxVal34\
    \ = (maxVal + minVal)\n        val maxVal35 = (maxVal - minVal)\n        val maxVal36\
    \ = (max\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbzwsb1co.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbzwsb1co.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbzwsb1co.scala:69:5\
    \ ---------------------\e[0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659797996
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val len = arr.length\n\
    \        val newArr = new Array[Long](len)\n        var i = 0\n        var j =\
    \ 0\n        var k = 0\n        var temp = 0\n        var flag = true\n      \
    \  while(i < len) {\n            temp = arr(i)\n            while(j < len) {\n\
    \                if(arr(j) < temp) {\n                    newArr(i) = arr(j)\n\
    \                    newArr(j) = arr(i)\n                    i = j\n         \
    \           j = k\n                    k = i\n                    flag = false\n\
    \                }\n                j++\n            }\n            newArr(i)\
    \ = temp\n            i += 1\n        }\n        if(flag) {\n            return\
    \ true\n        }\n        else {\n            return false\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0chtjx6c.scala:44:19 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0chtjx6c.scala:34:22\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m            temp = arr(i)\n\e\
    [31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \        Found:    Long\n\e[31m   |\e[0m                   Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val max = (len - 1).toLong\n        val\
    \ min = 0l.toLong\n        val max = arr.max\n        val min = arr.min\n    \
    \    val max1 = (max - min).toLong\n        val min1 = (min - max).toLong\n  \
    \      val max2 = arr.max\n        val min2 = arr.min\n        val max3 = (max2\
    \ - min2).toLong\n        val min3 = (min2 - max2).toLong\n        val max4 =\
    \ (max3 - min3).toLong\n        val min4 = (min3 - max3).toLong\n        val max5\
    \ = (max4 - min4).toLong\n        val min5 = (min4 - max4).toLong\n        val\
    \ max6 = (max5 - min5).toLong\n        val min6 = (min5 - max5).toLong\n     \
    \   val max7 = (max6 - min6).toLong\n        val min7 = (min6 - max6).toLong\n\
    \        val max8 = (max7 - min7).toLong\n        val min8 = (min7 - max7).toLong\n\
    \        val max9 = (max8 - min8).toLong\n        val min9 = (min8 - max8).toLong\n\
    \        val max10 = (max9 - min9).toLong\n        val min10 = (min9 - max9).toLong\n\
    \        val max11 = (max10 - min10).toLong\n        val min11 = (min10 - max10).toLong\n\
    \        val max12 = (max11 - min11).toLong\n        val min12 = (min11 - max11).toLong\n\
    \        val max13 = (max12 - min12).toLong\n        val min13 = (min12 - max12).toLong\n\
    \        val max14 = (max13 - min13).toLong\n        val min14 = (min13 - max13).toLong\n\
    \        val max15 = (max14 - min14).toLong\n        val min15 = (min14 - max14).toLong\n\
    \        val max16 = (max15 - min15).toLong\n        val min16 = (min15 - max15).toLong\n\
    \        val max17 = (max16 - min16).toLong\n        val min17 = (min16 - max16).toLong\n\
    \        val max18 = (max17 - min17).toLong\n        val min18 = (min17 - max17).toLong\n\
    \        val max19 = (max18 - min18).toLong\n        val min19 = (min18 - max18).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkiaj892v.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = arr.max\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax is already defined\
    \ as \e[33mvalue\e[0m \e[35mmax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkiaj892v.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = arr.min\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmin is already defined\
    \ as \e[33mvalue\e[0m \e[35mmin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkiaj892v.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpkiaj892v.scala:70:5 ---------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659797996
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val max = arr.max\n        val min = arr.min\n\
    \        val maxIndex = arr.lastIndex\n        val minIndex = arr.lastIndex\n\
    \        val maxIndex2 = arr.lastIndex\n        val minIndex2 = arr.lastIndex\n\
    \        val maxIndex3 = arr.lastIndex\n        val minIndex3 = arr.lastIndex\n\
    \        val maxIndex4 = arr.lastIndex\n        val minIndex4 = arr.lastIndex\n\
    \        val maxIndex5 = arr.lastIndex\n        val minIndex5 = arr.lastIndex\n\
    \        val maxIndex6 = arr.lastIndex\n        val minIndex6 = arr.lastIndex\n\
    \        val maxIndex7 = arr.lastIndex\n        val minIndex7 = arr.lastIndex\n\
    \        val maxIndex8 = arr.lastIndex\n        val minIndex8 = arr.lastIndex\n\
    \        val maxIndex9 = arr.lastIndex\n        val minIndex9 = arr.lastIndex\n\
    \        val maxIndex10 = arr.lastIndex\n        val minIndex10 = arr.lastIndex\n\
    \        val maxIndex11 = arr.lastIndex\n        val minIndex11 = arr.lastIndex\n\
    \        val maxIndex12 = arr.lastIndex\n        val minIndex12 = arr.lastIndex\n\
    \        val maxIndex13 = arr.lastIndex\n        val minIndex13 = arr.lastIndex\n\
    \        val maxIndex14 = arr.lastIndex\n        val minIndex14 = arr.lastIndex\n\
    \        val maxIndex15 = arr.lastIndex\n        val minIndex15 = arr.lastIndex\n\
    \        val maxIndex16 = arr.lastIndex\n        val minIndex16 = arr.lastIndex\n\
    \        val maxIndex17 = arr.lastIndex\n        val minIndex17 = arr.lastIndex\n\
    \        val maxIndex18 = arr.lastIndex\n        val minIndex18 = arr.lastIndex\n\
    \        val maxIndex19 = arr.lastIndex\n        val minIndex19 = arr.lastIndex\n\
    \        val maxIndex20 = arr.lastIndex\n        val minIndex20 = arr.lastIndex\n\
    \        val maxIndex21 = arr.lastIndex\n        val minIndex21 = arr.lastIndex\n\
    \        val maxIndex22 = arr.lastIndex\n        val minIndex22 = arr.lastIndex\n\
    \        val maxIndex23 = arr.lastIndex\n        val minIndex23 = arr.lastIndex\n\
    \        val maxIndex24 = arr.lastIndex\n        val minIndex24 = arr.lastIndex\n\
    \        val maxIndex25 = arr.lastIndex\n        val minIndex25 = arr.lastIndex\n\
    \        val maxIndex26 = arr.lastIndex\n        val minIndex26 = arr.lastIndex\n\
    \        val maxIndex27 = arr.lastIndex\n        val minIndex27 = arr.lastIndex\n\
    \        val maxIndex28 = arr.lastIndex\n        val minIndex28 = arr.lastIndex\n\
    \        val maxIndex29 = arr.lastIndex\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphysrqdjc.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmphysrqdjc.scala:88:5 ---------------------\e\
    [0m\e[0m\n\e[31m88 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797996
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val result = new Array[Boolean](n + 1)\n        val arr = arr.toList\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n\
    \        var temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n       \
    \ var temp5 = 0\n        var temp6 = 0\n        var temp7 = 0\n        var temp8\
    \ = 0\n        var temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n\
    \        var temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n    \
    \    var temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n        var\
    \ temp18 = 0\n        var temp19 = 0\n        var temp20 = 0\n        var temp21\
    \ = 0\n        var temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n\
    \        var temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n    \
    \    var temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n        var\
    \ temp31 = 0\n        var temp32 = 0\n        var temp33 = 0\n        var temp34\
    \ = 0\n        var temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n\
    \        var temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n    \
    \    var temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n        var\
    \ temp44 = 0\n        var temp45 = 0\n        var temp46 = 0\n        var temp47\
    \ = 0\n        var temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n\
    \        var temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n    \
    \    var temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n        var\
    \ temp57 = 0\n        var temp58 = 0\n        var temp59 = 0\n        var temp60\
    \ = 0\n        var temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n\
    \        var temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n    \
    \    var temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n        var\
    \ temp70 = 0\n        var temp71 = 0\n        var temp72 = 0\n        var temp73\
    \ = 0\n        var temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n\
    \        var temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n    \
    \    var temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n        var\
    \ temp83 = 0\n        var temp84 = 0\n        var temp85 = 0\n        var temp86\
    \ = 0\n        var temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n\
    \        var temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n    \
    \    var temp93 = 0\n        var temp94 = 0\n        var temp95 = 0\n        var\
    \ temp96\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqc5xzhav.scala:128:4 ---------------------------\e\
    [0m\e[0m\n\e[31m128 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqc5xzhav.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqc5xzhav.scala:128:5\
    \ --------------------\e[0m\e[0m\n\e[31m128 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659797996
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val m = arr.head\n    \
    \        val r = arr.tail\n            val l = r.length\n            val r1 =\
    \ r.drop(1)\n            val r2 = r.drop(2)\n            val r3 = r.drop(3)\n\
    \            val r4 = r.drop(4)\n            val r5 = r.drop(5)\n            val\
    \ r6 = r.drop(6)\n            val r7 = r.drop(7)\n            val r8 = r.drop(8)\n\
    \            val r9 = r.drop(9)\n            val r10 = r.drop(10)\n          \
    \  val r11 = r.drop(11)\n            val r12 = r.drop(12)\n            val r13\
    \ = r.drop(13)\n            val r14 = r.drop(14)\n            val r15 = r.drop(15)\n\
    \            val r16 = r.drop(16)\n            val r17 = r.drop(17)\n        \
    \    val r18 = r.drop(18)\n            val r19 = r.drop(19)\n            val r20\
    \ = r.drop(20)\n            val r21 = r.drop(21)\n            val r22 = r.drop(22)\n\
    \            val r23 = r.drop(23)\n            val r24 = r.drop(24)\n        \
    \    val r25 = r.drop(25)\n            val r26 = r.drop(26)\n            val r27\
    \ = r.drop(27)\n            val r28 = r.drop(28)\n            val r29 = r.drop(29)\n\
    \            val r30 = r.drop(30)\n            val r31 = r.drop(31)\n        \
    \    val r32 = r.drop(32)\n            val r33 = r.drop(33)\n            val r34\
    \ = r.drop(34)\n            val r35 = r.drop(35)\n            val r36 = r.drop(36)\n\
    \            val r37 = r.drop(37)\n            val r38 = r.drop(38)\n        \
    \    val r39 = r.drop(39)\n            val r40 = r.drop(40)\n            val r41\
    \ = r.drop(41)\n            val r42 = r.drop(42)\n            val r43 = r.drop(43)\n\
    \            val r44 = r.drop(44)\n            val r45 = r.drop(45)\n        \
    \    val r46 = r.drop(46)\n            val r47 = r.drop(47)\n            val r48\
    \ = r.drop(48)\n            \n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwsj9_qtk.scala:91:0 ----------------------------\e\
    [0m\e[0m\n\e[31m91 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwsj9_qtk.scala:90:1\
    \ ---------------------\e[0m\e[0m\n\e[31m90 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpwsj9_qtk.scala:82:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m82 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1659797998
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val r = new Array[Long](n)\n        var i =\
    \ 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m1 =\
    \ m\n        var m2 = m\n        var m3 = m\n        var m4 = m\n        var m5\
    \ = m\n        var m6 = m\n        var m7 = m\n        var m8 = m\n        var\
    \ m9 = m\n        var m10 = m\n        var m11 = m\n        var m12 = m\n    \
    \    var m13 = m\n        var m14 = m\n        var m15 = m\n        var m16 =\
    \ m\n        var m17 = m\n        var m18 = m\n        var m19 = m\n        var\
    \ m20 = m\n        var m21 = m\n        var m22 = m\n        var m23 = m\n   \
    \     var m24 = m\n        var m25 = m\n        var m26 = m\n        var m27 =\
    \ m\n        var m28 = m\n        var m29 = m\n        var m30 = m\n        var\
    \ m31 = m\n        var m32 = m\n        var m33 = m\n        var m34 = m\n   \
    \     var m35 = m\n        var m36 = m\n        var m37 = m\n        var m38 =\
    \ m\n        var m39 = m\n        var m40 = m\n        var m41 = m\n        var\
    \ m42 = m\n        var m43 = m\n        var m44 = m\n        var m45 = m\n   \
    \     var m46 = m\n        var m47 = m\n        var m48 = m\n        var m49 =\
    \ m\n        var m50 = m\n        var m51 = m\n        var m52 = m\n        var\
    \ m53 = m\n        var m54 = m\n        var m55 = m\n        var m56 = m\n   \
    \     var m57 = m\n        var m58 = m\n        var m59 = m\n        var m60 =\
    \ m\n        var m61 = m\n        var m62 = m\n        var m63 = m\n        var\
    \ m64 = m\n        var m65 = m\n        var m66 = m\n        var m67 = m\n   \
    \     var m68 = m\n        var m69 = m\n        var m70 = m\n        var m71 =\
    \ m\n        var m72 = m\n        var m73 = m\n        var m74 = m\n        var\
    \ m75 = m\n        var m76 = m\n        var m77 = m\n        var m78 = m\n   \
    \     var m79 = m\n        var m80 = m\n        var m81 = m\n        var m82 =\
    \ m\n        var m83 = m\n        var m84 = m\n        var m85 = m\n        var\
    \ m86 = m\n        var m87 = m\n        var m88 = m\n        var m89 = m\n   \
    \     var m90 = m\n        var m91 = m\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbdvakd38.scala:125:5\
    \ --------------------\e[0m\e[0m\n\e[31m125 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797996
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr2 = arr.toList\n\
    \        val arr3 = arr2.reverse\n        val arr4 = arr3.toList\n        val\
    \ arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n        val arr7 = arr6.reverse\n\
    \        val arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n        val\
    \ arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n        val arr12 =\
    \ arr11.reverse\n        val arr13 = arr12.reverse\n        val arr14 = arr13.reverse\n\
    \        val arr15 = arr14.reverse\n        val arr16 = arr15.reverse\n      \
    \  val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n        val arr19\
    \ = arr18.reverse\n        val arr20 = arr19.reverse\n        val arr21 = arr20.reverse\n\
    \        val arr22 = arr21.reverse\n        val arr23 = arr22.reverse\n      \
    \  val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n        val arr26\
    \ = arr25.reverse\n        val arr27 = arr26.reverse\n        val arr28 = arr27.reverse\n\
    \        val arr29 = arr28.reverse\n        val arr30 = arr29.reverse\n      \
    \  val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n        val arr33\
    \ = arr32.reverse\n        val arr34 = arr33.reverse\n        val arr35 = arr34.reverse\n\
    \        val arr36 = arr35.reverse\n        val arr37 = arr36.reverse\n      \
    \  val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n        val arr40\
    \ = arr39.reverse\n        val arr41 = arr40.reverse\n        val arr42 = arr41.reverse\n\
    \        val arr43 = arr42.reverse\n        val arr44 = arr43.reverse\n      \
    \  val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n        val arr47\
    \ = arr46.reverse\n        val arr48 = arr47.reverse\n        val arr49 = arr48.reverse\n\
    \        val arr50 = arr49.reverse\n        val arr51 = arr50.reverse\n      \
    \  val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n        val arr54\
    \ = arr53.reverse\n        val arr55 = arr54.reverse\n        val arr56 = arr55.reverse\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpfdv8e_56.scala:84:11 ---------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfdv8e_56.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpfdv8e_56.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659797996
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val len = arr.length\n\
    \        if(len == 0) return true\n        val cur = arr(len-1)\n        val newArr\
    \ = arr.dropRight(1)\n        val newLen = newArr.length\n        if(newLen >\
    \ 0 && newArr(newLen-1) < cur) false\n        else moveOneBall(newArr)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplxnulj4v.scala:35)\n\tat Problem.main(tmplxnulj4v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797998
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val arr1 = arr.toArray\n        val arr2\
    \ = arr.toBuffer\n        val arr3 = arr.toStream\n        val arr4 = arr.toIterator\n\
    \        val arr5 = arr.toSeq\n        val arr6 = arr.toSet\n        val arr7\
    \ = arr.toMap\n        val arr8 = arr.toSet\n        val arr9 = arr.toSeq\n  \
    \      val arr10 = arr.toStream\n        val arr11 = arr.toIterator\n        val\
    \ arr12 = arr.toSeq\n        val arr13 = arr.toSet\n        val arr14 = arr.toMap\n\
    \        val arr15 = arr.toSet\n        val arr16 = arr.toSeq\n        val arr17\
    \ = arr.toStream\n        val arr18 = arr.toIterator\n        val arr19 = arr.toSeq\n\
    \        val arr20 = arr.toStream\n        val arr21 = arr.toIterator\n      \
    \  val arr22 = arr.toSeq\n        val arr23 = arr.toSet\n        val arr24 = arr.toMap\n\
    \        val arr25 = arr.toSet\n        val arr26 = arr.toSeq\n        val arr27\
    \ = arr.toStream\n        val arr28 = arr.toIterator\n        val arr29 = arr.toSeq\n\
    \        val arr30 = arr.toStream\n        val arr31 = arr.toIterator\n      \
    \  val arr32 = arr.toSeq\n        val arr33 = arr.toSet\n        val arr34 = arr.toMap\n\
    \        val arr35 = arr.toSet\n        val arr36 = arr.toSeq\n        val arr37\
    \ = arr.toStream\n        val arr38 = arr.toIterator\n        val arr39 = arr.toSeq\n\
    \        val arr40 = arr.toStream\n        val arr41 = arr.toIterator\n      \
    \  val arr42 = arr.toSeq\n        val arr43 = arr.toSet\n        val arr44 = arr.toMap\n\
    \        val arr45 = arr.toSet\n        val arr46 = arr.toSeq\n        val arr47\
    \ = arr.toStream\n        val arr48 = arr.toIterator\n        val arr49 = arr.toSeq\n\
    \        val arr50 = arr.toStream\n        val arr51 = arr.toIterator\n      \
    \  val arr52 = arr.toSeq\n        val arr53 = arr.toSet\n        val arr54 = arr.toMap\n\
    \        val arr55 = arr.toSet\n        val arr56 = arr.toSeq\n        val arr57\
    \ = arr.to\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpogl0yc2u.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpogl0yc2u.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val max = (len - 1).toLong\n        val\
    \ min = 0l.toLong\n        var i = 0\n        var j = 0\n        var k = 0\n \
    \       var temp = 0\n        var flag = false\n        while(i < len) {\n   \
    \         temp = arr(i)\n            j = i\n            while(j < len) {\n   \
    \             if(arr(j) > temp) {\n                    temp = arr(j)\n       \
    \             k = j\n                }\n                j+=1\n            }\n\
    \            arr(i) = arr(k)\n            arr(k) = temp\n            i += 1\n\
    \            k += 1\n        }\n        flag = arr.toList.sorted\n        flag\
    \ = flag.reverse\n        flag = flag.drop(1)\n        flag = flag.drop(0)\n \
    \       flag = flag.drop(1)\n        flag = flag.drop(0)\n        flag = flag.drop(1)\n\
    \        flag = flag.drop(0)\n        flag = flag.drop(1)\n        flag = flag.drop(0)\n\
    \        flag = flag.drop(1)\n        flag = flag.drop(0)\n        flag = flag.drop(1)\n\
    \        flag = flag.drop(0)\n        flag = flag.drop(1)\n        flag = flag.drop(0)\n\
    \        flag = flag.drop(1)\n        flag = flag.drop(0)\n        flag = flag.drop(1)\n\
    \        flag = flag.drop(0)\n        flag = flag.drop(1)\n        flag = flag.drop(0)\n\
    \        flag = flag.drop(1)\n        flag = flag.drop(0)\n        flag = flag.drop(1)\n\
    \        flag = flag.drop(0)\n        flag = flag.drop(1)\n        flag = flag.drop(0)\n\
    \        flag = flag.drop(1)\n        flag = flag.drop(0)\n        flag = flag.drop(1)\n\
    \        flag = flag.drop(0)\n        flag = flag.drop(1)\n        flag = flag.drop(0)\n\
    \        flag = flag.drop(1)\n        flag = flag.drop(0)\n        flag = flag.drop(1)\n\
    \        flag = flag.drop(0)\n        flag = flag.drop(1)\n        flag = flag.drop(0)\n\
    \        flag = flag.drop(1)\n        flag = flag.drop(0)\n        flag = flag.drop(1)\n\
    \        flag = flag.drop(0)\n        flag = flag.drop(1)\n        flag = flag.drop(0)\n\
    \        flag = flag.drop(1)\n        flag = flag.drop(0)\n        flag = flag.drop(1)\n\
    \        flag = flag.drop(0)\n        flag = flag.drop(1)\n        flag = flag.drop(0)\n\
    \        flag = flag.drop(1)\n        flag = flag.drop(0)\n        flag = flag.drop(1)\n\
    \        flag = flag.drop(0)\n\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6r6puw2w.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp6r6puw2w.scala:51:20 ------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        flag = flag.reverse\n\e[31m\e[31m   |\e[0m  \
    \             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               value reverse is\
    \ not a member of Boolean\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6r6puw2w.scala:52:20\
    \ ------------------------\e[0m\e[0m\n\e[31m52 |\e[0m        flag = flag.drop(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m               value drop is not a member of Boolean\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp6r6puw2w.scala:53:20 ------------------------\e[0m\e\
    [0m\n\e[31m53 |\e[0m        flag = flag.drop(\e[31m0\e[0m)\n\e[31m\e[31m   |\e\
    [0m               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m               value drop is\
    \ not a member of Boolean\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6r6puw2w.scala:54:20\
    \ ------------------------\e[0m\e[0m\n\e[31m54 |\e[0m        flag = flag.drop(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m               value drop is not a member of Boolean\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp6r6puw2w.scala:55:20 ------------------------\e[0m\e\
    [0m\n\e[31m55 |\e[0m        flag = flag.drop(\e[31m0\e[0m)\n\e[31m\e[31m   |\e\
    [0m               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m               value drop is\
    \ not a member of Boolean\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6r6puw2w.scala:56:20\
    \ ------------------------\e[0m\e[0m\n\e[31m56 |\e[0m        flag = flag.drop(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m               value drop is not a member of Boolean\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp6r6puw2w.scala:57:20 ------------------------\e[0m\e\
    [0m\n\e[31m57 |\e["
  stdout: ''
  timestamp: 1659798002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val max = (arr.head + arr.last)\
    \ / 2\n            val maxIndex = arr.indexWhere(x => x > max)\n            val\
    \ maxIndex1 = maxIndex - 1\n            val maxIndex2 = maxIndex + 1\n       \
    \     val maxIndex3 = maxIndex + 2\n            val maxIndex4 = maxIndex + 3\n\
    \            val maxIndex5 = maxIndex + 4\n            val maxIndex6 = maxIndex\
    \ + 5\n            val maxIndex7 = maxIndex + 6\n            val maxIndex8 = maxIndex\
    \ + 7\n            val maxIndex9 = maxIndex + 8\n            val maxIndex10 =\
    \ maxIndex + 9\n            val maxIndex11 = maxIndex + 10\n            val maxIndex12\
    \ = maxIndex + 11\n            val maxIndex13 = maxIndex + 12\n            val\
    \ maxIndex14 = maxIndex + 13\n            val maxIndex15 = maxIndex + 14\n   \
    \         val maxIndex16 = maxIndex + 15\n            val maxIndex17 = maxIndex\
    \ + 16\n            val maxIndex18 = maxIndex + 17\n            val maxIndex19\
    \ = maxIndex + 18\n            val maxIndex20 = maxIndex + 19\n            val\
    \ maxIndex21 = maxIndex + 20\n            val maxIndex22 = maxIndex + 21\n   \
    \         val maxIndex23 = maxIndex + 22\n            val maxIndex24 = maxIndex\
    \ + 23\n            val maxIndex25 = maxIndex + 24\n            val maxIndex26\
    \ = maxIndex + 25\n            val maxIndex27 = maxIndex + 26\n            val\
    \ maxIndex28 = maxIndex + 27\n            val maxIndex29 = maxIndex + 28\n   \
    \         val maxIndex30 = maxIndex + 29\n            val maxIndex31 = maxIndex\
    \ + 30\n            val maxIndex32 = maxIndex + 31\n            val maxIndex33\
    \ = maxIndex + 32\n            val maxIndex34 = maxIndex + 33\n            val\
    \ maxIndex35 = maxIndex + 34\n            val maxIndex36 = maxIndex + 35\n   \
    \         val maxIndex37 = maxIndex + 36\n            val maxIndex38 = maxIndex\
    \ + 37\n            val maxIndex39 = maxIndex + 38\n            val maxIndex40\
    \ = maxIndex + 39\n            val maxIndex41 = maxIndex + 40\n            val\
    \ maxIndex42 = maxIndex + 41\n            val maxIndex43 = maxIndex + 42\n   \
    \         val maxIndex44 = maxIndex + 43\n            val maxIndex45\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7alt53_4.scala:76:4 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7alt53_4.scala:86:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m86 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp7alt53_4.scala:85:1 ---------------------\e[0m\e[0m\n\
    \e[31m85 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp7alt53_4.scala:77:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m77 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1659797997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val k = arr.last\n        val l = arr.init\n\
    \        val r = arr.tail\n        val s = arr.init\n        val t = arr.tail\n\
    \        val u = arr.init\n        val v = arr.tail\n        val w = arr.init\n\
    \        val x = arr.tail\n        val y = arr.init\n        val z = arr.tail\n\
    \        val a = arr.init\n        val b = arr.tail\n        val c = arr.init\n\
    \        val d = arr.tail\n        val e = arr.init\n        val f = arr.tail\n\
    \        val g = arr.init\n        val h = arr.tail\n        val i = arr.init\n\
    \        val j = arr.tail\n        val k = arr.init\n        val l = arr.tail\n\
    \        val m = arr.init\n        val n = arr.tail\n        val o = arr.init\n\
    \        val p = arr.tail\n        val q = arr.init\n        val r = arr.tail\n\
    \        val s = arr.init\n        val t = arr.tail\n        val u = arr.init\n\
    \        val v = arr.tail\n        val w = arr.init\n        val x = arr.tail\n\
    \        val y = arr.init\n        val z = arr.tail\n        val a = arr.init\n\
    \        val b = arr.tail\n        val c = arr.init\n        val d = arr.tail\n\
    \        val e = arr.init\n        val f = arr.tail\n        val g = arr.init\n\
    \        val h = arr.tail\n        val i = arr.init\n        val j = arr.tail\n\
    \        val k = arr.init\n        val l = arr.tail\n        val m = arr.init\n\
    \        val n = arr.tail\n        val o = arr.init\n        val p = arr.tail\n\
    \        val q = arr.init\n        val r = arr.tail\n        val s = arr.init\n\
    \        val t = arr.tail\n        val u = arr.init\n        val v = arr.tail\n\
    \        val w = arr.init\n        val x = arr.tail\n        val y = arr.init\n\
    \        val z = arr.tail\n        val a = arr.init\n        val b = arr.tail\n\
    \        val c = arr.init\n        val d = arr.tail\n        val e = arr.init\n\
    \        val f = arr.tail\n        val g = arr.init\n        val h = arr.tail\n\
    \        val i = arr.init\n        val j = arr.tail\n        val k = arr.init\n\
    \        val l = arr.tail\n        val m = arr.init\n        val n = arr.tail\n\
    \        val o = arr.init\n        val p = arr.tail\n        val q = arr.init\n\
    \        val r = arr.tail\n        val s = arr.init\n        val t = arr.tail\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpofcdcw8f.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofcdcw8f.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mk\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mk is already defined\
    \ as \e[33mvalue\e[0m \e[35mk\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofcdcw8f.scala:50:12 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofcdcw8f.scala:51:12 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofcdcw8f.scala:52:12 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofcdcw8f.scala:56:12 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659797997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphl_jn05h.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphl_jn05h.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphl_jn05h.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphl_jn05h.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphl_jn05h.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the sam"
  stdout: ''
  timestamp: 1659797997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val r = new Array[Long](n)\n        val l =\
    \ new Array[Long](n)\n        val d = new Array[Long](n)\n        val v = new\
    \ Array[Long](n)\n        val x = new Array[Long](n)\n        val y = new Array[Long](n)\n\
    \        val z = new Array[Long](n)\n        val a = new Array[Long](n)\n    \
    \    val b = new Array[Long](n)\n        val c = new Array[Long](n)\n        val\
    \ d = new Array[Long](n)\n        val e = new Array[Long](n)\n        val f =\
    \ new Array[Long](n)\n        val g = new Array[Long](n)\n        val h = new\
    \ Array[Long](n)\n        val i = new Array[Long](n)\n        val j = new Array[Long](n)\n\
    \        val k = new Array[Long](n)\n        val l = new Array[Long](n)\n    \
    \    val m = new Array[Long](n)\n        val n = new Array[Long](n)\n        val\
    \ o = new Array[Long](n)\n        val p = new Array[Long](n)\n        val q =\
    \ new Array[Long](n)\n        val r = new Array[Long](n)\n        val s = new\
    \ Array[Long](n)\n        val t = new Array[Long](n)\n        val u = new Array[Long](n)\n\
    \        val v = new Array[Long](n)\n        val w = new Array[Long](n)\n    \
    \    val x = new Array[Long](n)\n        val y = new Array[Long](n)\n        val\
    \ z = new Array[Long](n)\n        val a = new Array[Long](n)\n        val b =\
    \ new Array[Long](n)\n        val c = new Array[Long](n)\n        val d = new\
    \ Array[Long](n)\n        val e = new Array[Long](n)\n        val f = new Array[Long](n)\n\
    \        val g = new Array[Long](n)\n        val h = new Array[Long](n)\n    \
    \    val i = new Array[Long](n)\n        val j = new Array[Long](n)\n        val\
    \ k = new Array[Long](n)\n        val l = new Array[Long](n)\n        val m =\
    \ new Array[Long](n)\n        val n = new Array[Long](n)\n        val o = new\
    \ Array[Long](n)\n        val p = new Array[Long](n)\n        val q = new Array[Long](n)\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp86tdm3xt.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0md is already defined as \e[33mvalue\e[0m \e[35md\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp86tdm3xt.scala:46:12 ---------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp86tdm3xt.scala:47:12 ---------------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp86tdm3xt.scala:48:12 ---------------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp86tdm3xt.scala:52:12 ---------------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m \
    \  |\e[0m\n\e["
  stdout: ''
  timestamp: 1659797997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val s = arr.tail\n        val m = arr.head\n        val r = arr.last\n\
    \        val l = arr.init\n        val s = arr.tail\n        val m = arr.head\n\
    \        val r = arr.last\n        val l = arr.init\n        val s = arr.tail\n\
    \        val m = arr.head\n        val r = arr.last\n        val l = arr.init\n\
    \        val s = arr.tail\n        val m = arr.head\n        val r = arr.last\n\
    \        val l = arr.init\n        val s = arr.tail\n        val m = arr.head\n\
    \        val r = arr.last\n        val l = arr.init\n        val s = arr.tail\n\
    \        val m = arr.head\n        val r = arr.last\n        val l = arr.init\n\
    \        val s = arr.tail\n        val m = arr.head\n        val r = arr.last\n\
    \        val l = arr.init\n        val s = arr.tail\n        val m = arr.head\n\
    \        val r = arr.last\n        val l = arr.init\n        val s = arr.tail\n\
    \        val m = arr.head\n        val r = arr.last\n        val l = arr.init\n\
    \        val s = arr.tail\n        val m = arr.head\n        val r = arr.last\n\
    \        val l = arr.init\n        val s = arr.tail\n        val m = arr.head\n\
    \        val r = arr.last\n        val l = arr.init\n        val s = arr.tail\n\
    \        val m = arr.head\n        val r = arr.last\n        val l = arr.init\n\
    \        val s = arr.tail\n        val m = arr.head\n        val r = arr.last\n\
    \        val l = arr.init\n        val s = arr.tail\n        val m = arr.head\n\
    \        val r = arr.last\n        val l = arr.init\n        val s = arr.tail\n\
    \        val m = arr.head\n        val r = arr.last\n        val l = arr.init\n\
    \        val s = arr.tail\n        val m = arr.head\n        val r = arr.last\n\
    \        val l = arr.init\n        val s = arr.tail\n        val m = arr.head\n\
    \        val r = arr.last\n        val l = arr.init\n        val s = arr.tail\n\
    \        val m = arr.head\n        val r = arr.last\n        val l = arr.init\n\
    \        val s = arr.tail\n        val m = arr.head\n        val r = arr.last\n\
    \        val l = arr.init\n        val s = arr.tail\n        val m = arr.head\n\
    \        val r = arr.last\n        val l = arr.init\n        val s = arr.tail\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp_0t5gfjt.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_0t5gfjt.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_0t5gfjt.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_0t5gfjt.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_0t5gfjt.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_0t5gfjt.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659797998
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val d = arr.last\n        val r = new Array[Long](n\
    \ + 1)\n        var i = 0\n        var j = 0\n        var k = 0\n        var l\
    \ = 0\n        var m1 = m\n        var m2 = m\n        var m3 = m\n        var\
    \ m4 = m\n        var m5 = m\n        var m6 = m\n        var m7 = m\n       \
    \ var m8 = m\n        var m9 = m\n        var m10 = m\n        var m11 = m\n \
    \       var m12 = m\n        var m13 = m\n        var m14 = m\n        var m15\
    \ = m\n        var m16 = m\n        var m17 = m\n        var m18 = m\n       \
    \ var m19 = m\n        var m20 = m\n        var m21 = m\n        var m22 = m\n\
    \        var m23 = m\n        var m24 = m\n        var m25 = m\n        var m26\
    \ = m\n        var m27 = m\n        var m28 = m\n        var m29 = m\n       \
    \ var m30 = m\n        var m31 = m\n        var m32 = m\n        var m33 = m\n\
    \        var m34 = m\n        var m35 = m\n        var m36 = m\n        var m37\
    \ = m\n        var m38 = m\n        var m39 = m\n        var m40 = m\n       \
    \ var m41 = m\n        var m42 = m\n        var m43 = m\n        var m44 = m\n\
    \        var m45 = m\n        var m46 = m\n        var m47 = m\n        var m48\
    \ = m\n        var m49 = m\n        var m50 = m\n        var m51 = m\n       \
    \ var m52 = m\n        var m53 = m\n        var m54 = m\n        var m55 = m\n\
    \        var m56 = m\n        var m57 = m\n        var m58 = m\n        var m59\
    \ = m\n        var m60 = m\n        var m61 = m\n        var m62 = m\n       \
    \ var m63 = m\n        var m64 = m\n        var m65 = m\n        var m66 = m\n\
    \        var m67 = m\n        var m68 = m\n        var m69 = m\n        var m70\
    \ = m\n        var m71 = m\n        var m72 = m\n        var m73 = m\n       \
    \ var m74 = m\n        var m75 = m\n        var m76 = m\n        var m77 = m\n\
    \        var m78 = m\n        var m79 = m\n        var m80 = m\n        var m81\
    \ = m\n        var m82 = m\n        var m83 = m\n        var m84 = m\n       \
    \ var m85 = m\n        var m86 = m\n        var m87 = m\n        var m88 = m\n\
    \        var m89 = m\n        var m90 = m\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcli6iqu4.scala:124:5\
    \ --------------------\e[0m\e[0m\n\e[31m124 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        if (n == 0) true\n        else {\n            val maxIndex = n - 1\n\
    \            val maxValue = arr(maxIndex)\n            val maxIndex1 = maxIndex\
    \ - 1\n            val maxValue1 = arr(maxIndex1)\n            val maxIndex2 =\
    \ maxIndex - 1\n            val maxValue2 = arr(maxIndex2)\n            val maxIndex3\
    \ = maxIndex - 1\n            val maxValue3 = arr(maxIndex3)\n            val\
    \ maxIndex4 = maxIndex - 1\n            val maxValue4 = arr(maxIndex4)\n     \
    \       val maxIndex5 = maxIndex - 1\n            val maxValue5 = arr(maxIndex5)\n\
    \            val maxIndex6 = maxIndex - 1\n            val maxValue6 = arr(maxIndex6)\n\
    \            val maxIndex7 = maxIndex - 1\n            val maxValue7 = arr(maxIndex7)\n\
    \            val maxIndex8 = maxIndex - 1\n            val maxValue8 = arr(maxIndex8)\n\
    \            val maxIndex9 = maxIndex - 1\n            val maxValue9 = arr(maxIndex9)\n\
    \            val maxIndex10 = maxIndex - 1\n            val maxValue10 = arr(maxIndex10)\n\
    \            val maxIndex11 = maxIndex - 1\n            val maxValue11 = arr(maxIndex11)\n\
    \            val maxIndex12 = maxIndex - 1\n            val maxValue12 = arr(maxIndex12)\n\
    \            val maxIndex13 = maxIndex - 1\n            val maxValue13 = arr(maxIndex13)\n\
    \            val maxIndex14 = maxIndex - 1\n            val maxValue14 = arr(maxIndex14)\n\
    \            val maxIndex15 = maxIndex - 1\n            val maxValue15 = arr(maxIndex15)\n\
    \            val maxIndex16 = maxIndex - 1\n            val maxValue16 = arr(maxIndex16)\n\
    \            val maxIndex17 = maxIndex - 1\n            val maxValue17 = arr(maxIndex17)\n\
    \            val maxIndex18 = maxIndex - 1\n            val maxValue18 = arr(maxIndex18)\n\
    \            val maxIndex19 = maxIndex - 1\n            val maxValue19 = arr(maxIndex19)\n\
    \            val maxIndex20 = maxIndex - 1\n            val maxValue20 = arr(maxIndex20)\n\
    \            val maxIndex21 = maxIndex - 1\n            val maxValue21 = arr(maxIndex21)\n\
    \            val maxIndex22 = maxIndex - 1\n            val maxValue22 = arr(maxIndex22)\n\
    \            val maxIndex23 = maxIndex - 1\n            val maxValue23 = arr(maxIndex23)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuigz7vn0.scala:87:0 ----------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuigz7vn0.scala:86:1\
    \ ---------------------\e[0m\e[0m\n\e[31m86 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpuigz7vn0.scala:78:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m78 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val r = arr.last\n        val s = arr.head\n\
    \        val t = arr.last\n        val u = arr.head\n        val v = arr.last\n\
    \        val w = arr.head\n        val x = arr.last\n        val y = arr.head\n\
    \        val z = arr.last\n        val a = arr.head\n        val b = arr.last\n\
    \        val c = arr.head\n        val d = arr.last\n        val e = arr.head\n\
    \        val f = arr.last\n        val g = arr.head\n        val h = arr.last\n\
    \        val i = arr.head\n        val j = arr.last\n        val k = arr.head\n\
    \        val l = arr.last\n        val m = arr.head\n        val n = arr.last\n\
    \        val o = arr.head\n        val p = arr.last\n        val q = arr.head\n\
    \        val r = arr.last\n        val s = arr.head\n        val t = arr.last\n\
    \        val u = arr.head\n        val v = arr.last\n        val w = arr.head\n\
    \        val x = arr.last\n        val y = arr.head\n        val z = arr.last\n\
    \        val a = arr.head\n        val b = arr.last\n        val c = arr.head\n\
    \        val d = arr.last\n        val e = arr.head\n        val f = arr.last\n\
    \        val g = arr.head\n        val h = arr.last\n        val i = arr.head\n\
    \        val j = arr.last\n        val k = arr.head\n        val l = arr.last\n\
    \        val m = arr.head\n        val n = arr.last\n        val o = arr.head\n\
    \        val p = arr.last\n        val q = arr.head\n        val r = arr.last\n\
    \        val s = arr.head\n        val t = arr.last\n        val u = arr.head\n\
    \        val v = arr.last\n        val w = arr.head\n        val x = arr.last\n\
    \        val y = arr.head\n        val z = arr.last\n        val a = arr.head\n\
    \        val b = arr.last\n        val c = arr.head\n        val d = arr.last\n\
    \        val e = arr.head\n        val f = arr.last\n        val g = arr.head\n\
    \        val h = arr.last\n        val i = arr.head\n        val j = arr.last\n\
    \        val k = arr.head\n        val l = arr.last\n        val m = arr.head\n\
    \        val n = arr.last\n        val o = arr.head\n        val p = arr.last\n\
    \        val q = arr.head\n        val r = arr.last\n        val s = arr.head\n\
    \        val t = arr.last\n        val u = arr.head\n        val v = arr.last\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpwbb70i_0.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwbb70i_0.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwbb70i_0.scala:50:12 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwbb70i_0.scala:54:12 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwbb70i_0.scala:55:12 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwbb70i_0.scala:56:12 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m        \e[33mval\e[0m \e[36mt\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659798007
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val sortedArr = arr.sortBy(-_)\n      \
    \  val sortedArr = sortedArr.toList\n        val result = sortedArr.foldLeft(true)\
    \ {\n            (acc, x) => acc && x != 0\n        }\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2fkdo_e_.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp2fkdo_e_.scala:27:18 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798001
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnogrev2w.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnogrev2w.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnogrev2w.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnogrev2w.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnogrev2w.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnogrev2w.scala:33:12 ---------------------------\e\
    [0m\e[0"
  stdout: ''
  timestamp: 1659798007
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.drop(arr.length - 1)\n        val arr = arr.take(n)\n        arr.toList.forall(x\
    \ => x < arr(0))\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqzbijn29.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpqzbijn29.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(arr.length - \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpqzbijn29.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.take(n)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpqzbijn29.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        else {\n            val l = arr.head\n            val r = arr.last\n\
    \            val mid = arr.size / 2\n            val left = arr.take(mid)\n  \
    \          val right = arr.drop(mid)\n            val leftSorted = left.sortBy(_)\n\
    \            val rightSorted = right.sortBy(_)\n            val leftSortedSortedRight\
    \ = leftSorted.sortBy(_)\n            val rightSortedSortedLeft = rightSorted.sortBy(_)\n\
    \            val leftSortedSortedRightSorted = leftSortedSortedRight.sortBy(_)\n\
    \            val rightSortedSortedLeftSorted = rightSortedSortedLeft.sortBy(_)\n\
    \            val leftSortedSortedRightSortedSorted = leftSortedSortedRightSorted.sortBy(_)\n\
    \            val rightSortedSortedLeftSortedSorted = rightSortedSortedLeftSorted.sortBy(_)\n\
    \            val leftSortedSortedRightSortedSortedSorted = leftSortedSortedRightSortedSorted.sortBy(_)\n\
    \            val rightSortedSortedLeftSortedSortedSorted = rightSortedSortedLeftSortedSorted.sortBy(_)\n\
    \            val leftSortedSortedRightSortedSortedSorted = leftSortedSortedRightSortedSorted.sortBy(_)\n\
    \            val rightSortedSortedLeftSortedSortedSorted = rightSortedSortedLeftSortedSorted.sortBy(_)\n\
    \            val leftSortedSortedRightSortedSortedSorted = leftSortedSortedRightSortedSorted.sortBy(_)\n\
    \            val rightSortedSortedLeftSortedSortedSorted = rightSortedSortedLeftSortedSorted.sortBy(_)\n\
    \            val leftSortedSortedRightSortedSortedSorted = leftSortedSortedRightSortedSorted.sortBy(_)\n\
    \            val rightSortedSortedLeftSortedSortedSorted = rightSortedSortedLeftSortedSorted.sortBy(_)\n\
    \            val leftSortedSortedRightSortedSortedSorted = leftSortedSortedRightSortedSorted.sortBy(_)\n\
    \            val rightSortedSortedLeftSortedSortedSorted = rightSortedSortedLeftSortedSorted.sortBy(_)\n\
    \            val leftSortedSortedRightSortedSortedSorted = leftSortedSortedRightSortedSorted.sortBy(_)\n\
    \            val rightSortedSortedLeftSortedSorted = rightSortedSortedLeftSorted.sortBy(_)\n\
    \            val leftSortedSortedRightSortedSorted = leftSortedSortedRightSorted.sortBy(_)\n\
    \            val rightSortedSortedLeftSorted = rightSortedSortedLeftSorted.sortBy(_)\n\
    \            val leftSortedSortedRightSorted = leftSortedSortedRightSorted.sortBy(_)\n\
    \            val rightSortedSortedLeftSorted = rightSortedSortedLeftSorted.sortBy(_)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkvxkvtg1.scala:68:0 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkvxkvtg1.scala:43:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m            \e[33mval\e\
    [0m \e[36mleftSortedSortedRightSortedSortedSorted\e[0m = leftSortedSortedRightSortedSorted.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftSortedSortedRightSortedSortedSorted is already defined\
    \ as \e[33mvalue\e[0m \e[35mleftSortedSortedRightSortedSortedSorted\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpkvxkvtg1.scala:44:16 ---------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m            \e[33mval\e[0m \e[36mrightSortedSortedLeftSortedSortedSorted\e\
    [0m = rightSortedSortedLeftSortedSorted.sortBy(_)\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightSortedSortedLeftSortedSortedSorted is already defined\
    \ as \e[33mvalue\e[0m \e[35mrightSortedSortedLeftSortedSortedSorted\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpkvxkvtg1.scala:45:16 ---------------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m            \e[33mval\e[0m \e[36mleftSortedSortedRightSortedSortedSorted\e\
    [0m = leftSortedSortedRightSortedSorted.sortBy(_)\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftSortedSortedRightSortedSortedSorted is already defined\
    \ as \e[33mvalue\e[0m \e[35mleftSortedSortedRightSortedSortedSorted\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Erro"
  stdout: ''
  timestamp: 1659798009
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        else {\n            val newList = arr.tail\n            val newList2\
    \ = newList.tail\n            val newList3 = newList2.tail\n            val newList4\
    \ = newList3.tail\n            val newList5 = newList4.tail\n            val newList6\
    \ = newList5.tail\n            val newList7 = newList6.tail\n            val newList8\
    \ = newList7.tail\n            val newList9 = newList8.tail\n            val newList10\
    \ = newList9.tail\n            val newList11 = newList10.tail\n            val\
    \ newList12 = newList11.tail\n            val newList13 = newList12.tail\n   \
    \         val newList14 = newList13.tail\n            val newList15 = newList14.tail\n\
    \            val newList16 = newList15.tail\n            val newList17 = newList16.tail\n\
    \            val newList18 = newList17.tail\n            val newList19 = newList18.tail\n\
    \            val newList20 = newList19.tail\n            val newList21 = newList20.tail\n\
    \            val newList22 = newList21.tail\n            val newList23 = newList22.tail\n\
    \            val newList24 = newList23.tail\n            val newList25 = newList24.tail\n\
    \            val newList26 = newList25.tail\n            val newList27 = newList26.tail\n\
    \            val newList28 = newList27.tail\n            val newList29 = newList28.tail\n\
    \            val newList30 = newList29.tail\n            val newList31 = newList30.tail\n\
    \            val newList32 = newList31.tail\n            val newList33 = newList32.tail\n\
    \            val newList34 = newList33.tail\n            val newList35 = newList34.tail\n\
    \            val newList36 = newList35.tail\n            val newList37 = newList36.tail\n\
    \            val newList38 = newList37.tail\n            val newList39 = newList38.tail\n\
    \            val newList40 = newList39.tail\n            val newList41 = newList40.tail\n\
    \            val newList42 = newList41.tail\n            val newList43 = newList42.tail\n\
    \            val newList44 = newList43.tail\n            val newList45 = newList44.tail\n\
    \            val newList46 = newList45.tail\n            val newList47 = newList46.tail\n\
    \            val newList48 = newList47.tail\n            val newList49 = newList48.tail\n\
    \            val newList\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp01dtq0ng.scala:78:4 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp01dtq0ng.scala:88:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m88 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp01dtq0ng.scala:87:1 ---------------------\e[0m\e[0m\n\
    \e[31m87 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp01dtq0ng.scala:79:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m79 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val shifts = arr.map(x => x >> 1)\n        val shifts = shifts.toList\n\
    \        val shifts = shifts.reverse\n        val shifts = shifts.reverse\n  \
    \      val shifts = shifts.reverse\n        val shifts = shifts.reverse\n    \
    \    val shifts = shifts.reverse\n        val shifts = shifts.reverse\n      \
    \  val shifts = shifts.reverse\n        val shifts = shifts.reverse\n        val\
    \ shifts = shifts.reverse\n        val shifts = shifts.reverse\n        val shifts\
    \ = shifts.reverse\n        val shifts = shifts.reverse\n        val shifts =\
    \ shifts.reverse\n        val shifts = shifts.reverse\n        val shifts = shifts.reverse\n\
    \        val shifts = shifts.reverse\n        val shifts = shifts.reverse\n  \
    \      val shifts = shifts.reverse\n        val shifts = shifts.reverse\n    \
    \    val shifts = shifts.reverse\n        val shifts = shifts.reverse\n      \
    \  val shifts = shifts.reverse\n        val shifts = shifts.reverse\n        val\
    \ shifts = shifts.reverse\n        val shifts = shifts.reverse\n        val shifts\
    \ = shifts.reverse\n        val shifts = shifts.reverse\n        val shifts =\
    \ shifts.reverse\n        val shifts = shifts.reverse\n        val shifts = shifts.reverse\n\
    \        val shifts = shifts.reverse\n        val shifts = shifts.reverse\n  \
    \      val shifts = shifts.reverse\n        val shifts = shifts.reverse\n    \
    \    val shifts = shifts.reverse\n        val shifts = shifts.reverse\n      \
    \  val shifts = shifts.reverse\n        val shifts = shifts.reverse\n        val\
    \ shifts = shifts.reverse\n        val shifts = shifts.reverse\n        val shifts\
    \ = shifts.reverse\n        val shifts = shifts.reverse\n        val shifts =\
    \ shifts.reverse\n        val shifts = shifts.reverse\n        val shifts = shifts.reverse\n\
    \        val shifts = shifts.reverse\n        val shifts = shifts.reverse\n  \
    \      val shifts = shifts.reverse\n        val shifts = shifts.reverse\n    \
    \    val shifts = shifts.reverse\n        val shifts = shifts.reverse\n      \
    \  val shifts = shifts.reverse\n        val shifts = shifts.reverse\n        val\
    \ shifts = shifts.reverse\n        val shifts = shifts.reverse\n        val shifts\
    \ = shifts.reverse\n        val shifts = shifts.reverse\n        val shifts =\
    \ shifts.reverse\n        \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8ewrm2lj.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mshifts\e[0m = shifts.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mshifts\
    \ is already defined as \e[33mvalue\e[0m \e[35mshifts\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8ewrm2lj.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mshifts\e[0m = shifts.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mshifts is already defined as \e[33mvalue\e[0m \e[35mshifts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8ewrm2lj.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mshifts\e[0m = shifts.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mshifts is\
    \ already defined as \e[33mvalue\e[0m \e[35mshifts\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8ewrm2lj.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mshifts\e[0m = shifts.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mshifts is already defined as \e[33mvalue\e[0m \e[35mshifts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8ewrm2lj.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mshifts\e[0m = shifts.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mshifts is\
    \ already defined as \e[33mvalue\e[0m \e[35mshifts\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group"
  stdout: ''
  timestamp: 1659798007
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        else {\n            val first = arr.head\n            val rest\
    \ = arr.tail\n            val newArr = rest.tail\n            val newRest = rest.reverse\n\
    \            val newFirst = first.reverse\n            val newRest2 = newRest.reverse\n\
    \            val newFirst2 = newFirst.reverse\n            val newRest3 = newRest2.reverse\n\
    \            val newFirst3 = newFirst2.reverse\n            val newRest4 = newRest3.reverse\n\
    \            val newFirst4 = newFirst3.reverse\n            val newRest5 = newRest4.reverse\n\
    \            val newFirst5 = newFirst4.reverse\n            val newRest6 = newRest5.reverse\n\
    \            val newFirst6 = newFirst5.reverse\n            val newRest7 = newRest6.reverse\n\
    \            val newFirst7 = newFirst6.reverse\n            val newRest8 = newRest7.reverse\n\
    \            val newFirst8 = newFirst7.reverse\n            val newRest9 = newRest8.reverse\n\
    \            val newFirst9 = newFirst8.reverse\n            val newRest10 = newRest9.reverse\n\
    \            val newFirst10 = newFirst9.reverse\n            val newRest11 = newRest10.reverse\n\
    \            val newFirst11 = newFirst10.reverse\n            val newRest12 =\
    \ newRest11.reverse\n            val newFirst12 = newFirst11.reverse\n       \
    \     val newRest13 = newRest12.reverse\n            val newFirst13 = newFirst12.reverse\n\
    \            val newRest14 = newRest13.reverse\n            val newFirst14 = newFirst13.reverse\n\
    \            val newRest15 = newRest14.reverse\n            val newFirst15 = newFirst14.reverse\n\
    \            val newRest16 = newRest15.reverse\n            val newFirst16 = newFirst15.reverse\n\
    \            val newRest17 = newRest16.reverse\n            val newFirst17 = newFirst16.reverse\n\
    \            val newRest18 = newRest17.reverse\n            val newFirst18 = newFirst17.reverse\n\
    \            val newRest19 = newRest18.reverse\n            val newFirst19 = newFirst18.reverse\n\
    \            val newRest20 = newRest19.reverse\n            val newFirst20 = newFirst19.reverse\n\
    \            val newRest21 = newRest20.reverse\n            val newFirst21 = newFirst20.reverse\n\
    \            val newRest22 = newRest21.reverse\n            val newFirst22 = newFirst21.reverse\n\
    \            val newRest23 = newRest22.reverse\n            val newFirst23 = newFirst22.reverse\n\
    \            val newRest24 = newRest23.reverse\n            val newFirst24 = newFirst23.reverse\n\
    \            val newRest25 = newRest\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4grulyzs.scala:90:0 ----------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4grulyzs.scala:32:33\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m\
    \ \e[36mnewFirst\e[0m = first.reverse\n\e[31m\e[31m   |\e[0m                 \
    \          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           value\
    \ reverse is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp4grulyzs.scala:89:1 ---------------------\e[0m\e[0m\n\e[31m89 |\e[0m}\n\
    \e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m\
    \ Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp4grulyzs.scala:81:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m81 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1659798009
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr1 = arr.toList\n\
    \        val arr2 = arr1.reverse\n        val arr3 = arr2.reverse\n        val\
    \ arr4 = arr3.reverse\n        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n\
    \        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val\
    \ arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n\
    \        val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n      \
    \  val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16\
    \ = arr15.reverse\n        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n\
    \        val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n      \
    \  val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23\
    \ = arr22.reverse\n        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n\
    \        val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n      \
    \  val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30\
    \ = arr29.reverse\n        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n\
    \        val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n      \
    \  val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37\
    \ = arr36.reverse\n        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n\
    \        val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n      \
    \  val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44\
    \ = arr43.reverse\n        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n\
    \        val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n      \
    \  val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51\
    \ = arr50.reverse\n        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n\
    \        val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n      \
    \  val arr5\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph5mcw5ze.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmph5mcw5ze.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph5mcw5ze.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpt70dp5n0.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt70dp5n0.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt70dp5n0.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt70dp5n0.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt70dp5n0.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt70dp5n0.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659798009
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val arr1 = arr.sortBy(x => x)\n       \
    \ val arr2 = arr1.reverse\n        val arr3 = arr2.sortBy(x => x)\n        val\
    \ arr4 = arr3.reverse\n        val arr5 = arr4.sortBy(x => x)\n        val arr6\
    \ = arr5.reverse\n        val arr7 = arr6.sortBy(x => x)\n        val arr8 = arr7.reverse\n\
    \        val arr9 = arr8.sortBy(x => x)\n        val arr10 = arr9.sortBy(x =>\
    \ x)\n        val arr11 = arr10.sortBy(x => x)\n        val arr12 = arr11.reverse\n\
    \        val arr13 = arr12.reverse\n        val arr14 = arr13.reverse\n      \
    \  val arr15 = arr14.reverse\n        val arr16 = arr15.reverse\n        val arr17\
    \ = arr16.reverse\n        val arr18 = arr17.reverse\n        val arr19 = arr18.reverse\n\
    \        val arr20 = arr19.reverse\n        val arr21 = arr20.reverse\n      \
    \  val arr22 = arr21.reverse\n        val arr23 = arr22.reverse\n        val arr24\
    \ = arr23.reverse\n        val arr25 = arr24.reverse\n        val arr26 = arr25.reverse\n\
    \        val arr27 = arr26.reverse\n        val arr28 = arr27.reverse\n      \
    \  val arr29 = arr28.reverse\n        val arr30 = arr29.reverse\n        val arr31\
    \ = arr30.reverse\n        val arr32 = arr31.reverse\n        val arr33 = arr32.reverse\n\
    \        val arr34 = arr33.reverse\n        val arr35 = arr34.reverse\n      \
    \  val arr36 = arr35.reverse\n        val arr37 = arr36.reverse\n        val arr38\
    \ = arr37.reverse\n        val arr39 = arr38.reverse\n        val arr40 = arr39.reverse\n\
    \        val arr41 = arr40.reverse\n        val arr42 = arr41.reverse\n      \
    \  val arr43 = arr42.reverse\n        val arr44 = arr43.reverse\n        val arr45\
    \ = arr44.reverse\n        val arr46 = arr45.reverse\n        val arr47 = arr46.reverse\n\
    \        val arr48 = arr47.reverse\n        val arr49 = arr48.reverse\n      \
    \  val arr50 = arr49.reverse\n        val arr51 = arr50.reverse\n        val arr52\
    \ = arr51.reverse\n        val arr53 = arr52.reverse\n        \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplff6di1l.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmplff6di1l.scala:82:5 ---------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr1 = arr.toList\n\
    \        val arr2 = arr1.reverse\n        val arr3 = arr2.toList\n        val\
    \ arr4 = arr3.reverse\n        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n\
    \        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val\
    \ arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n\
    \        val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n      \
    \  val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16\
    \ = arr15.reverse\n        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n\
    \        val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n      \
    \  val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23\
    \ = arr22.reverse\n        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n\
    \        val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n      \
    \  val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30\
    \ = arr29.reverse\n        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n\
    \        val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n      \
    \  val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37\
    \ = arr36.reverse\n        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n\
    \        val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n      \
    \  val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44\
    \ = arr43.reverse\n        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n\
    \        val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n      \
    \  val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51\
    \ = arr50.reverse\n        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n\
    \        val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n      \
    \  val arr\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp46q1477e.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp46q1477e.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp46q1477e.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr1 = arr.toList\n\
    \        val arr2 = arr1.reverse\n        val arr3 = arr2.reverse\n        val\
    \ arr4 = arr3.reverse\n        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n\
    \        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val\
    \ arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n\
    \        val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n      \
    \  val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16\
    \ = arr15.reverse\n        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n\
    \        val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n      \
    \  val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23\
    \ = arr22.reverse\n        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n\
    \        val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n      \
    \  val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30\
    \ = arr29.reverse\n        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n\
    \        val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n      \
    \  val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37\
    \ = arr36.reverse\n        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n\
    \        val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n      \
    \  val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44\
    \ = arr43.reverse\n        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n\
    \        val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n      \
    \  val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51\
    \ = arr50.reverse\n        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n\
    \        val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n      \
    \  val arr5\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvoj3cpdn.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvoj3cpdn.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvoj3cpdn.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798009
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp189lt9yf.scala:99:11 ---------------------------\e\
    [0m\e[0m\n\e[31m99 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp189lt9yf.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp189lt9yf.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp189lt9yf.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp189lt9yf.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp189lt9yf.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m "
  stdout: ''
  timestamp: 1659798009
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val maxIndex = n - 1\n\
    \            val maxValue = arr(maxIndex)\n            val maxValueIndex = maxIndex\
    \ - 1\n            val maxValueIndex = maxIndex - 1\n            val maxValueIndex\
    \ = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = max\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8_060opu.scala:95:0 ----------------------------\e\
    [0m\e[0m\n\e[31m95 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8_060opu.scala:32:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mmaxValueIndex\e[0m = maxIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValueIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValueIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8_060opu.scala:33:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m \e[36mmaxValueIndex\e[0m = maxIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValueIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValueIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8_060opu.scala:34:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e\
    [0m \e[36mmaxValueIndex\e[0m = maxIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValueIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValueIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8_060opu.scala:35:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e\
    [0m \e[36mmaxValueIndex\e[0m = maxIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValueIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValueIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8_06"
  stdout: ''
  timestamp: 1659798009
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val n = len - 1\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr1 = arr.toList\n        val arr2 = arr1.reverse\n    \
    \    val arr3 = arr2.reverse\n        val arr4 = arr3.reverse\n        val arr5\
    \ = arr4.reverse\n        val arr6 = arr5.reverse\n        val arr7 = arr6.reverse\n\
    \        val arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n        val\
    \ arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n        val arr12 =\
    \ arr11.reverse\n        val arr13 = arr12.reverse\n        val arr14 = arr13.reverse\n\
    \        val arr15 = arr14.reverse\n        val arr16 = arr15.reverse\n      \
    \  val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n        val arr19\
    \ = arr18.reverse\n        val arr20 = arr19.reverse\n        val arr21 = arr20.reverse\n\
    \        val arr22 = arr21.reverse\n        val arr23 = arr22.reverse\n      \
    \  val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n        val arr26\
    \ = arr25.reverse\n        val arr27 = arr26.reverse\n        val arr28 = arr27.reverse\n\
    \        val arr29 = arr28.reverse\n        val arr30 = arr29.reverse\n      \
    \  val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n        val arr33\
    \ = arr32.reverse\n        val arr34 = arr33.reverse\n        val arr35 = arr34.reverse\n\
    \        val arr36 = arr35.reverse\n        val arr37 = arr36.reverse\n      \
    \  val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n        val arr40\
    \ = arr39.reverse\n        val arr41 = arr40.reverse\n        val arr42 = arr41.reverse\n\
    \        val arr43 = arr42.reverse\n        val arr44 = arr43.reverse\n      \
    \  val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n        val arr47\
    \ = arr46.reverse\n        val arr48 = arr47.reverse\n        val arr49 = arr48.reverse\n\
    \        val arr50 = arr49.reverse\n        val arr51 = arr50.reverse\n      \
    \  val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n        val arr54\
    \ = arr53.reverse\n        val \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp0m5td57r.scala:84:11 ---------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp0m5td57r.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp0m5td57r.scala:26:18 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp0m5td57r.scala:85:5 ---------------------\e[0m\e[0m\n\e[31m85\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659798009
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr1 = arr.toList\n\
    \        val arr2 = arr1.reverse\n        val arr3 = arr2.reverse\n        val\
    \ arr4 = arr3.reverse\n        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n\
    \        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val\
    \ arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n\
    \        val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n      \
    \  val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16\
    \ = arr15.reverse\n        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n\
    \        val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n      \
    \  val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23\
    \ = arr22.reverse\n        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n\
    \        val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n      \
    \  val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30\
    \ = arr29.reverse\n        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n\
    \        val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n      \
    \  val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37\
    \ = arr36.reverse\n        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n\
    \        val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n      \
    \  val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44\
    \ = arr43.reverse\n        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n\
    \        val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n      \
    \  val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51\
    \ = arr50.reverse\n        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n\
    \        val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n      \
    \  val arr5\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph5mcw5ze.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmph5mcw5ze.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph5mcw5ze.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val d = arr.last\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val r = arr.init\n        val r = arr.init\n        val r = arr.init\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp11jrrz0f.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp11jrrz0f.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp11jrrz0f.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp11jrrz0f.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp11jrrz0f.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp11jrrz0f.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659798009
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.toSet\n\
    \        val len = arr.size\n        val max = (len.toDouble / 2).toInt\n    \
    \    val min = len - max\n        val arr2 = arr.toSeq.sortBy(x => x)\n      \
    \  val arr3 = arr2.reverse\n        val arr4 = arr3.take(min)\n        val arr5\
    \ = arr3.drop(min)\n        val arr6 = arr4.take(max)\n        val arr7 = arr4.drop(max)\n\
    \        val arr8 = arr5.take(max)\n        val arr9 = arr5.drop(max)\n      \
    \  val arr10 = arr6.take(max)\n        val arr11 = arr6.drop(max)\n        val\
    \ arr12 = arr7.take(max)\n        val arr13 = arr7.drop(max)\n        val arr14\
    \ = arr8.take(max)\n        val arr15 = arr8.drop(max)\n        val arr16 = arr9.take(max)\n\
    \        val arr17 = arr9.drop(max)\n        val arr18 = arr10.take(max)\n   \
    \     val arr19 = arr10.drop(max)\n        val arr20 = arr11.take(max)\n     \
    \   val arr21 = arr11.drop(max)\n        val arr22 = arr12.take(max)\n       \
    \ val arr23 = arr12.drop(max)\n        val arr24 = arr13.take(max)\n        val\
    \ arr25 = arr13.drop(max)\n        val arr26 = arr14.take(max)\n        val arr27\
    \ = arr14.drop(max)\n        val arr28 = arr15.take(max)\n        val arr29 =\
    \ arr15.drop(max)\n        val arr30 = arr16.take(max)\n        val arr31 = arr16.drop(max)\n\
    \        val arr32 = arr17.take(max)\n        val arr33 = arr17.drop(max)\n  \
    \      val arr34 = arr18.take(max)\n        val arr35 = arr18.drop(max)\n    \
    \    val arr36 = arr19.take(max)\n        val arr37 = arr19.drop(max)\n      \
    \  val arr38 = arr20.take(max)\n        val arr39 = arr20.drop(max)\n        val\
    \ arr40 = arr21.take(max)\n        val arr41 = arr21.drop(max)\n        val arr42\
    \ = arr22.take(max)\n        val arr43 = arr22.drop(max)\n        val arr44 =\
    \ arr23.take(max)\n        val arr45 = arr23.drop(max)\n        val arr46 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8nxfeq7z.scala:74:19 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \e[36marr46\e[0m = \n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp8nxfeq7z.scala:26:18 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toSet\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp8nxfeq7z.scala:75:5 ---------------------\e[0m\e[0m\n\e[31m75\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val d = arr.last\n        val r = arr.dropRight(1)\n\
    \        val s = arr.takeRight(1)\n        val a = arr.toArray\n        val b\
    \ = r.toArray\n        val c = s.toArray\n        val d = c.toArray\n        val\
    \ e = a.toArray\n        val f = b.toArray\n        val g = d.toArray\n      \
    \  val h = f.toArray\n        val i = g.toArray\n        val j = h.toArray\n \
    \       val k = i.toArray\n        val l = j.toArray\n        val m = l.toArray\n\
    \        val n = m.toArray\n        val o = n.toArray\n        val p = o.toArray\n\
    \        val q = p.toArray\n        val r = q.toArray\n        val s = r.toArray\n\
    \        val t = s.toArray\n        val u = t.toArray\n        val v = u.toArray\n\
    \        val w = v.toArray\n        val x = w.toArray\n        val y = x.toArray\n\
    \        val z = y.toArray\n        val a = z.toArray\n        val b = a.toArray\n\
    \        val c = b.toArray\n        val d = c.toArray\n        val e = d.toArray\n\
    \        val f = e.toArray\n        val g = f.toArray\n        val h = g.toArray\n\
    \        val i = h.toArray\n        val j = i.toArray\n        val k = j.toArray\n\
    \        val l = k.toArray\n        val m = l.toArray\n        val n = m.toArray\n\
    \        val o = n.toArray\n        val p = o.toArray\n        val q = p.toArray\n\
    \        val r = q.toArray\n        val s = r.toArray\n        val t = s.toArray\n\
    \        val u = t.toArray\n        val v = u.toArray\n        val w = v.toArray\n\
    \        val x = w.toArray\n        val y = x.toArray\n        val z = y.toArray\n\
    \        val a = z.toArray\n        val b = a.toArray\n        val c = b.toArray\n\
    \        val d = c.toArray\n        val e = d.toArray\n        val f = e.toArray\n\
    \        val g = f.toArray\n        val h = g.toArray\n        val i = h.toArray\n\
    \        val j = i.toArray\n        val k = j.toArray\n        val l = k.toArray\n\
    \        val m = l.toArray\n        val n = m.toArray\n        val o = n.toArray\n\
    \        val p = o.toArray\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp_eos0kjw.scala:99:11 ---------------------------\e\
    [0m\e[0m\n\e[31m99 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp_eos0kjw.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = c.toArray\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined\
    \ as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_eos0kjw.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = l.toArray\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_eos0kjw.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = m.toArray\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_eos0kjw.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = q.toArray\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_eos0kjw.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = r.toArray\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m "
  stdout: ''
  timestamp: 1659798011
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val result = new Array[Boolean](n)\n      \
    \  var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n      \
    \  var m1 = m\n        var m2 = m\n        var m3 = m\n        var m4 = m\n  \
    \      var m5 = m\n        var m6 = m\n        var m7 = m\n        var m8 = m\n\
    \        var m9 = m\n        var m10 = m\n        var m11 = m\n        var m12\
    \ = m\n        var m13 = m\n        var m14 = m\n        var m15 = m\n       \
    \ var m16 = m\n        var m17 = m\n        var m18 = m\n        var m19 = m\n\
    \        var m20 = m\n        var m21 = m\n        var m22 = m\n        var m23\
    \ = m\n        var m24 = m\n        var m25 = m\n        var m26 = m\n       \
    \ var m27 = m\n        var m28 = m\n        var m29 = m\n        var m30 = m\n\
    \        var m31 = m\n        var m32 = m\n        var m33 = m\n        var m34\
    \ = m\n        var m35 = m\n        var m36 = m\n        var m37 = m\n       \
    \ var m38 = m\n        var m39 = m\n        var m40 = m\n        var m41 = m\n\
    \        var m42 = m\n        var m43 = m\n        var m44 = m\n        var m45\
    \ = m\n        var m46 = m\n        var m47 = m\n        var m48 = m\n       \
    \ var m49 = m\n        var m50 = m\n        var m51 = m\n        var m52 = m\n\
    \        var m53 = m\n        var m54 = m\n        var m55 = m\n        var m56\
    \ = m\n        var m57 = m\n        var m58 = m\n        var m59 = m\n       \
    \ var m60 = m\n        var m61 = m\n        var m62 = m\n        var m63 = m\n\
    \        var m64 = m\n        var m65 = m\n        var m66 = m\n        var m67\
    \ = m\n        var m68 = m\n        var m69 = m\n        var m70 = m\n       \
    \ var m71 = m\n        var m72 = m\n        var m73 = m\n        var m74 = m\n\
    \        var m75 = m\n        var m76 = m\n        var m77 = m\n        var m78\
    \ = m\n        var m79 = m\n        var m80 = m\n        var m81 = m\n       \
    \ var m82 = m\n        var m83 = m\n        var m84 = m\n        var m85 = m\n\
    \        var m86 = m\n        var m87 = m\n        var m88 = m\n        var m89\
    \ = m\n        var m90 = m\n        var m91 = m\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqmt2v4_5.scala:125:5\
    \ --------------------\e[0m\e[0m\n\e[31m125 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr1 = arr.toList\n\
    \        val arr2 = arr1.reverse\n        val arr3 = arr2.reverse\n        val\
    \ arr4 = arr3.reverse\n        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n\
    \        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val\
    \ arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n\
    \        val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n      \
    \  val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16\
    \ = arr15.reverse\n        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n\
    \        val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n      \
    \  val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23\
    \ = arr22.reverse\n        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n\
    \        val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n      \
    \  val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30\
    \ = arr29.reverse\n        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n\
    \        val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n      \
    \  val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37\
    \ = arr36.reverse\n        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n\
    \        val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n      \
    \  val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44\
    \ = arr43.reverse\n        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n\
    \        val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n      \
    \  val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51\
    \ = arr50.reverse\n        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n\
    \        val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n      \
    \  val arr5\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvoj3cpdn.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvoj3cpdn.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvoj3cpdn.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798009
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val result = new Array[Boolean](n)\n  \
    \      val temp = new Array[Long](n)\n        val temp2 = new Array[Long](n)\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var temp3 =\
    \ 0\n        var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n   \
    \     var temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n        var\
    \ temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n        var temp13\
    \ = 0\n        var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n\
    \        var temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n    \
    \    var temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n        var\
    \ temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n        var temp26\
    \ = 0\n        var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n\
    \        var temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n    \
    \    var temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n        var\
    \ temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n        var temp39\
    \ = 0\n        var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n\
    \        var temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n    \
    \    var temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n        var\
    \ temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n        var temp52\
    \ = 0\n        var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n\
    \        var temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n    \
    \    var temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n        var\
    \ temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n        var temp65\
    \ = 0\n        var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n\
    \        var temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n    \
    \    var temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n        var\
    \ temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n        var temp78\
    \ = 0\n        var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n\
    \        var temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n    \
    \    var temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n        var\
    \ temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n        var temp91\
    \ = 0\n        var temp92 = 0\n        var temp93 = 0\n        var temp\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpt4y_pfnr.scala:126:4 ---------------------------\e\
    [0m\e[0m\n\e[31m126 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpt4y_pfnr.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt4y_pfnr.scala:126:5\
    \ --------------------\e[0m\e[0m\n\e[31m126 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798013
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val arr = arr.sortBy(x\
    \ => x)\n            val first = arr(0)\n            val last = arr(n)\n     \
    \       val mid = first + last\n            val left = arr.drop(1)\n         \
    \   val right = arr.dropRight(1)\n            val leftSorted = left.sortBy(x =>\
    \ x)\n            val rightSorted = right.sortBy(x => x)\n            val leftSortedSize\
    \ = leftSorted.length\n            val rightSortedSize = rightSorted.length\n\
    \            val leftSortedSize = leftSortedSize + rightSortedSize - 1\n     \
    \       if (leftSortedSize == rightSortedSize) {\n                if (leftSorted\
    \ == rightSorted) {\n                    if (leftSortedSize == n) true\n     \
    \               else false\n                }\n                else false\n  \
    \          }\n            else false\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjpnjkpgx.scala:39:16 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e[0m \e[36mleftSortedSize\e[0m\
    \ = leftSortedSize + rightSortedSize - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mleftSortedSize is already defined as \e[33mvalue\e[0m \e[35mleftSortedSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpjpnjkpgx.scala:29:22 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m            \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e[36mx\e\
    [0m => x)\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m\
    \                      Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798010
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val m = arr.head\n    \
    \        val r = arr.tail\n            val s = r.head\n            val t = r.tail\n\
    \            val u = t.head\n            val v = t.tail\n            val w = v.head\n\
    \            val x = v.tail\n            val y = x.head\n            val z = x.tail\n\
    \            val a = z.head\n            val b = z.tail\n            val c = b.head\n\
    \            val d = b.tail\n            val e = d.head\n            val f = d.tail\n\
    \            val g = e.head\n            val h = e.tail\n            val i = f.head\n\
    \            val j = f.tail\n            val k = j.head\n            val l = j.tail\n\
    \            val m = l.head\n            val n = l.tail\n            val o = n.head\n\
    \            val p = n.tail\n            val q = m.head\n            val r = m.tail\n\
    \            val s = r.head\n            val t = r.tail\n            val u = t.head\n\
    \            val v = t.tail\n            val w = v.head\n            val x = v.tail\n\
    \            val y = x.head\n            val z = x.tail\n            val a = z.head\n\
    \            val b = z.tail\n            val c = b.head\n            val d = b.tail\n\
    \            val e = d.head\n            val f = d.tail\n            val g = e.head\n\
    \            val h = e.tail\n            val i = f.head\n            val j = f.tail\n\
    \            val k = j.head\n            val l = j.tail\n            val m = l.head\n\
    \            val n = l.tail\n            val o = n.head\n            val p = n.tail\n\
    \            val q = m.head\n            val r = m.tail\n            val s = r.head\n\
    \            val t = r.tail\n            val u = t.head\n            val v = t.tail\n\
    \            val w = v.head\n            val x = v.tail\n            val y = x.head\n\
    \            val z = x.tail\n            val a = z.head\n            val b = z.tail\n\
    \            val c = b.head\n            val d = b.tail\n            val e = d.head\n\
    \            val f = d.tail\n            val g = e.head\n            val h = e.tail\n\
    \            val i = f.head\n            val j = f.tail\n            val k = j.head\n\
    \            val l = j.tail\n            val m = l.head\n            val n = l.tail\n\
    \            val o = n.head\n            val p = n.tail\n            val q = m.head\n\
    \            val r = m.tail\n            val s = r.head\n            val t = r.tail\n\
    \            val u = t.head\n            \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgrnzu3ge.scala:123:0 ---------------------------\e\
    [0m\e[0m\n\e[31m123 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgrnzu3ge.scala:51:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m51 |\e[0m            \e[33mval\e\
    [0m \e[36mm\e[0m = l.head\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgrnzu3ge.scala:56:16 ---------------------------\e[0m\e[0m\n\e[31m56\
    \ |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = m.tail\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e\
    [0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpgrnzu3ge.scala:57:16 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m            \e[33mval\e[0m \e[36ms\e[0m = r.head\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already\
    \ defined as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgrnzu3ge.scala:58:16 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m            \e[33mval\e[0m \e[36mt\e[0m = r.tail\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mt is already\
    \ defined as \e[33mvalue\e[0m \e[35mt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgrnzu3ge.scala:59:16 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m            \e[33mval\e[0m \e[36mu\e[0m = t.head\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mu is already\
    \ defined as \e[33mvalue\e[0m \e[35mu\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded me"
  stdout: ''
  timestamp: 1659798019
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.drop(arr.size - 1)\n        val arr = arr.take(arr.size - 1)\n       \
    \ val arr = arr.drop(1)\n        val arr = arr.take(1)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.drop(arr.size - 1)\n        val arr = arr.take(arr.size - 1)\n       \
    \ val arr = arr.drop(1)\n        val arr = arr.take(1)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.drop(arr.size - 1)\n        val arr = arr.take(arr.size - 1)\n       \
    \ val arr = arr.drop(1)\n        val arr = arr.take(1)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.drop(arr.size - 1)\n        val arr = arr.take(arr.size - 1)\n       \
    \ val arr = arr.drop(1)\n        val arr = arr.take(1)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.drop(arr.size - 1)\n        val arr = arr.take(arr.size - 1)\n       \
    \ val arr = arr.drop(1)\n        val arr = arr.take(1)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.drop(arr.size - 1)\n        val arr = arr.take(arr.size - 1)\n       \
    \ val arr = arr.drop(1)\n        val arr = arr.take(1)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.drop(arr.size - 1)\n        val arr = arr.take(arr.size - 1)\n       \
    \ val arr = arr.drop(1)\n        val arr = arr.take(1)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.drop(arr.size - 1)\n        val arr = arr.take(arr.size - 1)\n       \
    \ val arr = arr.drop(1)\n        val arr = arr.take(1)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.drop(\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpgjmvv_ux.scala:88:27 ---------------------------\e\
    [0m\e[0m\n\e[31m88 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(\n\e\
    [31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m        \
    \                   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgjmvv_ux.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgjmvv_ux.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgjmvv_ux.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgjmvv_ux.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(arr.size - \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgjmvv"
  stdout: ''
  timestamp: 1659798015
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val r = new Array[Long](n)\n        val x =\
    \ new Array[Long](n)\n        val y = new Array[Long](n)\n        val z = new\
    \ Array[Long](n)\n        val w = new Array[Long](n)\n        val v = new Array[Long](n)\n\
    \        val u = new Array[Long](n)\n        val t = new Array[Long](n)\n    \
    \    val s = new Array[Long](n)\n        val p = new Array[Long](n)\n        val\
    \ q = new Array[Long](n)\n        val r = new Array[Long](n)\n        val x =\
    \ new Array[Long](n)\n        val y = new Array[Long](n)\n        val z = new\
    \ Array[Long](n)\n        val w = new Array[Long](n)\n        val v = new Array[Long](n)\n\
    \        val u = new Array[Long](n)\n        val t = new Array[Long](n)\n    \
    \    val s = new Array[Long](n)\n        val p = new Array[Long](n)\n        val\
    \ q = new Array[Long](n)\n        val r = new Array[Long](n)\n        val x =\
    \ new Array[Long](n)\n        val y = new Array[Long](n)\n        val z = new\
    \ Array[Long](n)\n        val w = new Array[Long](n)\n        val v = new Array[Long](n)\n\
    \        val u = new Array[Long](n)\n        val t = new Array[Long](n)\n    \
    \    val s = new Array[Long](n)\n        val p = new Array[Long](n)\n        val\
    \ q = new Array[Long](n)\n        val r = new Array[Long](n)\n        val x =\
    \ new Array[Long](n)\n        val y = new Array[Long](n)\n        val z = new\
    \ Array[Long](n)\n        val w = new Array[Long](n)\n        val v = new Array[Long](n)\n\
    \        val u = new Array[Long](n)\n        val t = new Array[Long](n)\n    \
    \    val s = new Array[Long](n)\n        val p = new Array[Long](n)\n        val\
    \ q = new Array[Long](n)\n        val r = new Array[Long](n)\n        val x =\
    \ new Array[Long](n)\n        val y = new Array[Long](n)\n        val z = new\
    \ Array[Long](n)\n        val w = new Array[Long](n)\n        val v = new Array[Long](n)\n\
    \        val u = new \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8z5abo0i.scala:79:4 ----------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8z5abo0i.scala:39:12 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8z5abo0i.scala:40:12 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m        \e[33mval\e[0m \e[36mx\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mx is already defined as \e[33mvalue\e[0m \e[35mx\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8z5abo0i.scala:41:12 ---------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m        \e[33mval\e[0m \e[36my\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0my is already defined as \e[33mvalue\e[0m \e[35my\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8z5abo0i.scala:42:12 ---------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m        \e[33mval\e[0m \e[36mz\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mz is already defined as \e[33mvalue\e[0m \e[35mz\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8z5abo0i.scala:43:12 ---------------------------\e[0m\e[0m\n\e[31m43\
    \ |\e[0m        \e[33mva"
  stdout: ''
  timestamp: 1659798018
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr1 = arr.toList\n\
    \        val arr2 = arr1.reverse\n        val arr3 = arr2.reverse\n        val\
    \ arr4 = arr3.reverse\n        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n\
    \        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val\
    \ arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n\
    \        val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n      \
    \  val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16\
    \ = arr15.reverse\n        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n\
    \        val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n      \
    \  val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23\
    \ = arr22.reverse\n        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n\
    \        val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n      \
    \  val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30\
    \ = arr29.reverse\n        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n\
    \        val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n      \
    \  val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37\
    \ = arr36.reverse\n        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n\
    \        val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n      \
    \  val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44\
    \ = arr43.reverse\n        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n\
    \        val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n      \
    \  val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51\
    \ = arr50.reverse\n        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n\
    \        val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n      \
    \  val arr5\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvoj3cpdn.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvoj3cpdn.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvoj3cpdn.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798009
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val l = arr.last\n        val r = arr.head\n\
    \        val m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n    \
    \    val k = arr.indexOf(m) + 1\n        val m = arr.indexOf(n) + 1\n        val\
    \ l = arr.indexOf(k) + 1\n        val m = arr.indexOf(l) + 1\n        val r =\
    \ arr.indexOf(m) + 1\n        val m = arr.indexOf(r) + 1\n        val l = arr.indexOf(m)\
    \ + 1\n        val r = arr.indexOf(l) + 1\n        val m = arr.indexOf(r) + 1\n\
    \        val l = arr.indexOf(m) + 1\n        val r = arr.indexOf(l) + 1\n    \
    \    val m = arr.indexOf(r) + 1\n        val l = arr.indexOf(m) + 1\n        val\
    \ r = arr.indexOf(l) + 1\n        val m = arr.indexOf(r) + 1\n        val l =\
    \ arr.indexOf(m) + 1\n        val r = arr.indexOf(l) + 1\n        val m = arr.indexOf(r)\
    \ + 1\n        val l = arr.indexOf(m) + 1\n        val r = arr.indexOf(l) + 1\n\
    \        val m = arr.indexOf(r) + 1\n        val l = arr.indexOf(m) + 1\n    \
    \    val r = arr.indexOf(l) + 1\n        val m = arr.indexOf(r) + 1\n        val\
    \ l = arr.indexOf(m) + 1\n        val r = arr.indexOf(l) + 1\n        val m =\
    \ arr.indexOf(r) + 1\n        val l = arr.indexOf(m) + 1\n        val r = arr.indexOf(l)\
    \ + 1\n        val m = arr.indexOf(r) + 1\n        val l = arr.indexOf(m) + 1\n\
    \        val r = arr.indexOf(l) + 1\n        val m = arr.indexOf(r) + 1\n    \
    \    val l = arr.indexOf(m) + 1\n        val r = arr.indexOf(l) + 1\n        val\
    \ m = arr.indexOf(r) + 1\n        val l = arr.indexOf(m) + 1\n        val r =\
    \ arr.indexOf(l) + 1\n        val m = arr.indexOf(r) + 1\n        val l = arr.indexOf(m)\
    \ + 1\n        val r = arr.indexOf(l) + 1\n        val m = arr.indexOf(r) + 1\n\
    \        val l = arr.indexOf(m) + 1\n        val r = arr.indexOf(l) + 1\n    \
    \    val m = arr.indexOf(r) + 1\n        val l = arr.indexOf(m) + 1\n        val\
    \ r = arr.indexOf(l) + 1\n        val m = arr.indexOf(r) + 1\n        val l =\
    \ arr.indexOf(m) + 1\n        val r = arr.indexOf(l) + 1\n        val m = arr.indexOf(r)\
    \ + 1\n        val l = arr.indexOf(m) + 1\n        val r = arr.indexOf(l) + 1\n\
    \        val m = arr.indexOf(r) + 1\n        val l = arr.indexOf(m) + 1\n    \
    \    val r = arr.indexOf(l) + 1\n        val m = arr.indexOf(r) + 1\n        val\
    \ l = arr.indexOf(m) + 1\n        val r = arr.indexOf(l) + 1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4jc73ql3.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.indexOf(r)\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp4jc73ql3.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.indexOf(n) + \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is\
    \ already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4jc73ql3.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36ml\e[0m = arr.indexOf(k) + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp4jc73ql3.scala:35:12 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.indexOf(l) + \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is\
    \ already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4jc73ql3.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = arr.indexOf(m) + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel "
  stdout: ''
  timestamp: 1659798020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val sortedArr = arr.sortBy(_)\n       \
    \ val lastElement = sortedArr.last\n        val firstElement = sortedArr.head\n\
    \        val newArr = arr.filter(_ != lastElement).filter(_ != firstElement)\n\
    \        val newSortedArr = newArr.sortBy(_)\n        val newLastElement = newSortedArr.last\n\
    \        val newFirstElement = newSortedArr.head\n        if(newLastElement ==\
    \ lastElement && newFirstElement == firstElement){\n            return true\n\
    \        }\n        return false\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgiw73kk6.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E081] Type Error: /tmp/tmpgiw73kk6.scala:28:35 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m\
    \   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 =>\
    \ arr.sortBy(_$1).\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpgiw73kk6.scala:32:41\
    \ -----------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e\
    [0m \e[36mnewSortedArr\e[0m = newArr.sortBy(_)\n\e[31m\e[31m   |\e[0m        \
    \                                 ^\e[0m\n\e[31m   |\e[0m   Missing parameter\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$4 of expanded function:\n\e[31m   |\e[0m   _$4 => newArr.sortBy(_$4).\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798015
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.drop(arr.length-1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphqz8tara.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphqz8tara.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(arr.length-\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphqz8tara.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.take(arr.length-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined\
    \ as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphqz8tara.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphqz8tara.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(arr.length-\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overl"
  stdout: ''
  timestamp: 1659798020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpp50je4a1.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp50je4a1.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp50je4a1.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already\
    \ defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp50je4a1.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp50je4a1.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp50je4a1.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^"
  stdout: ''
  timestamp: 1659798019
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val result = new Array[Boolean](n)\n        val left = new Array[Long](n)\n\
    \        val right = new Array[Long](n)\n        val temp = new Array[Long](n)\n\
    \        val temp1 = new Array[Long](n)\n        val temp2 = new Array[Long](n)\n\
    \        val temp3 = new Array[Long](n)\n        val temp4 = new Array[Long](n)\n\
    \        val temp5 = new Array[Long](n)\n        val temp6 = new Array[Long](n)\n\
    \        val temp7 = new Array[Long](n)\n        val temp8 = new Array[Long](n)\n\
    \        val temp9 = new Array[Long](n)\n        val temp10 = new Array[Long](n)\n\
    \        val temp11 = new Array[Long](n)\n        val temp12 = new Array[Long](n)\n\
    \        val temp13 = new Array[Long](n)\n        val temp14 = new Array[Long](n)\n\
    \        val temp15 = new Array[Long](n)\n        val temp16 = new Array[Long](n)\n\
    \        val temp17 = new Array[Long](n)\n        val temp18 = new Array[Long](n)\n\
    \        val temp19 = new Array[Long](n)\n        val temp20 = new Array[Long](n)\n\
    \        val temp21 = new Array[Long](n)\n        val temp22 = new Array[Long](n)\n\
    \        val temp23 = new Array[Long](n)\n        val temp24 = new Array[Long](n)\n\
    \        val temp25 = new Array[Long](n)\n        val temp26 = new Array[Long](n)\n\
    \        val temp27 = new Array[Long](n)\n        val temp28 = new Array[Long](n)\n\
    \        val temp29 = new Array[Long](n)\n        val temp30 = new Array[Long](n)\n\
    \        val temp31 = new Array[Long](n)\n        val temp32 = new Array[Long](n)\n\
    \        val temp33 = new Array[Long](n)\n        val temp34 = new Array[Long](n)\n\
    \        val temp35 = new Array[Long](n)\n        val temp36 = new Array[Long](n)\n\
    \        val temp37 = new Array[Long](n)\n        val temp38 = new Array[Long](n)\n\
    \        val temp39 = new Array[Long](n)\n        val temp40 = new Array[Long](n)\n\
    \        val temp41 = new Array[Long](n)\n        val temp42 = new Array[Long](n)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbmcxcvvt.scala:74:5\
    \ ---------------------\e[0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798019
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val r = new Array[Long](n + 1)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n        var\
    \ flag = true\n        var flag2 = true\n        var flag3 = true\n        var\
    \ flag4 = true\n        var flag5 = true\n        var flag6 = true\n        var\
    \ flag7 = true\n        var flag8 = true\n        var flag9 = true\n        var\
    \ flag10 = true\n        var flag11 = true\n        var flag12 = true\n      \
    \  var flag13 = true\n        var flag14 = true\n        var flag15 = true\n \
    \       var flag16 = true\n        var flag17 = true\n        var flag18 = true\n\
    \        var flag19 = true\n        var flag20 = true\n        var flag21 = true\n\
    \        var flag22 = true\n        var flag23 = true\n        var flag24 = true\n\
    \        var flag25 = true\n        var flag26 = true\n        var flag27 = true\n\
    \        var flag28 = true\n        var flag29 = true\n        var flag30 = true\n\
    \        var flag31 = true\n        var flag32 = true\n        var flag33 = true\n\
    \        var flag34 = true\n        var flag35 = true\n        var flag36 = true\n\
    \        var flag37 = true\n        var flag38 = true\n        var flag39 = true\n\
    \        var flag40 = true\n        var flag41 = true\n        var flag42 = true\n\
    \        var flag43 = true\n        var flag44 = true\n        var flag45 = true\n\
    \        var flag46 = true\n        var flag47 = true\n        var flag48 = true\n\
    \        var flag49 = true\n        var flag50 = true\n        var flag51 = true\n\
    \        var flag52 = true\n        var flag53 = true\n        var flag54 = true\n\
    \        var flag55 = true\n        var flag56 = true\n        var flag57 = true\n\
    \        var flag58 = true\n        var flag59 = true\n        var flag60 = true\n\
    \        var flag61 = true\n        var flag62 = true\n        var flag63 = true\n\
    \        var flag64 = true\n        var flag65 = true\n        var flag66 = true\n\
    \        var flag67 = true\n        var flag68 = true\n        var flag69 = true\n\
    \        var flag70 = true\n        var flag71 = true\n        var flag72 = true\n\
    \        var flag73 = true\n        var flag74 = true\n        var flag75 = true\n\
    \        var flag76 = true\n        var flag77 = true\n        var flag78 = true\n\
    \        var flag79 = true\n        var flag80 = true\n        var flag81 = true\n\
    \        var flag82 = true\n        var flag83 = true\n        var flag84 = true\n\
    \        var flag85 = true\n        var flag86 = true\n        var flag87 = true\n\
    \        var flag88 = true\n        var flag89 = true\n        var flag90 = true\n\
    \        var flag91 = \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5f_2sb8w.scala:123:20 --------------------------\e\
    [0m\e[0m\n\e[31m123 |\e[0m        \e[33mvar\e[0m \e[36mflag91\e[0m = \n\e[31m\e\
    [31m    |\e[0m                    ^\e[0m\n\e[31m    |\e[0m                   \
    \ expression expected but \e[31m'}'\e[0m found\n\e[31m    |\e[0m\n\e[31m    |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp5f_2sb8w.scala:124:5 --------------------\e\
    [0m\e[0m\n\e[31m124 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Boolean\n\e[31m  \
    \  |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798019
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val max = (arr.max)(_)\n        val min = (arr.min)(_)\n        val maxIndex\
    \ = (max - min).toInt\n        val maxIndex2 = maxIndex + 1\n        val maxIndex3\
    \ = maxIndex2 + 1\n        val maxIndex4 = maxIndex3 + 1\n        val maxIndex5\
    \ = maxIndex4 + 1\n        val maxIndex6 = maxIndex5 + 1\n        val maxIndex7\
    \ = maxIndex6 + 1\n        val maxIndex8 = maxIndex7 + 1\n        val maxIndex9\
    \ = maxIndex8 + 1\n        val maxIndex10 = maxIndex9 + 1\n        val maxIndex11\
    \ = maxIndex10 + 1\n        val maxIndex12 = maxIndex11 + 1\n        val maxIndex13\
    \ = maxIndex12 + 1\n        val maxIndex14 = maxIndex13 + 1\n        val maxIndex15\
    \ = maxIndex14 + 1\n        val maxIndex16 = maxIndex15 + 1\n        val maxIndex17\
    \ = maxIndex16 + 1\n        val maxIndex18 = maxIndex17 + 1\n        val maxIndex19\
    \ = maxIndex18 + 1\n        val maxIndex20 = maxIndex19 + 1\n        val maxIndex21\
    \ = maxIndex20 + 1\n        val maxIndex22 = maxIndex21 + 1\n        val maxIndex23\
    \ = maxIndex22 + 1\n        val maxIndex24 = maxIndex23 + 1\n        val maxIndex25\
    \ = maxIndex24 + 1\n        val maxIndex26 = maxIndex25 + 1\n        val maxIndex27\
    \ = maxIndex26 + 1\n        val maxIndex28 = maxIndex27 + 1\n        val maxIndex29\
    \ = maxIndex28 + 1\n        val maxIndex30 = maxIndex29 + 1\n        val maxIndex31\
    \ = maxIndex30 + 1\n        val maxIndex32 = maxIndex31 + 1\n        val maxIndex33\
    \ = maxIndex32 + 1\n        val maxIndex34 = maxIndex33 + 1\n        val maxIndex35\
    \ = maxIndex34 + 1\n        val maxIndex36 = maxIndex35 + 1\n        val maxIndex37\
    \ = maxIndex36 + 1\n        val maxIndex38 = maxIndex37 + 1\n        val maxIndex39\
    \ = maxIndex38 + 1\n        val maxIndex40 = maxIndex39 + 1\n        val maxIndex41\
    \ = maxIndex40 + 1\n        val maxIndex42 = maxIndex41 + 1\n        val maxIndex43\
    \ = maxIndex42 + 1\n        val maxIndex44 = maxIndex43 + 1\n        val maxIndex45\
    \ = maxIndex44 + 1\n        \n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8l5g08hb.scala:29:28 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = (max - min).toInt\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ - is not a member of Ordering[Long] => Long, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8l5g08hb.scala:75:5\
    \ ---------------------\e[0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798021
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val result = new mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while(i < n) {\n            val j = i\n          \
    \  while(j < n) {\n                val k = j\n                while(k >= 0 &&\
    \ arr(k) > arr(j)) {\n                    k -= 1\n                }\n        \
    \        val temp = arr(j)\n                arr(j) = arr(k)\n                arr(k)\
    \ = temp\n                j -= 1\n                k += 1\n            }\n    \
    \        i += 1\n        }\n        arr.toList.sortWith(_ < _)\n        arr.toList.size\
    \ == result.size\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyz3f2yt7.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpyz3f2yt7.scala:28:25 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyz3f2yt7.scala:35:22\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                    k -=\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^\e[0m\n\e[31m   |\e\
    [0m                    value -= is not a member of Int - did you mean k.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpyz3f2yt7.scala:40:18 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                j -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^\e[0m\n\e[31m   |\e[0m                value -= is not a\
    \ member of Int - did you mean j.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyz3f2yt7.scala:41:18\
    \ ------------------------\e[0m\e[0m\n\e[31m41 |\e[0m                k += \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m         \
    \       value += is not a member of Int - did you mean k.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1659798020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphl_jn05h.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphl_jn05h.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphl_jn05h.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphl_jn05h.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphl_jn05h.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the sam"
  stdout: ''
  timestamp: 1659797997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val first = arr.head\n\
    \            val rest = arr.tail\n            val restLength = rest.length\n \
    \           val restHead = rest(0)\n            val restTail = rest(restLength\
    \ - 1)\n            val restHeadIndex = restHead.asInstanceOf[Long]\n        \
    \    val restTailIndex = restTail.asInstanceOf[Long]\n            val restHeadIndex\
    \ = restHeadIndex + 1\n            val restTailIndex = restTailIndex - 1\n   \
    \         val restHead = restHead.asInstanceOf[Long]\n            val restTail\
    \ = restTail.asInstanceOf[Long]\n            val restHeadIndex = restHeadIndex\
    \ - 1\n            val restTailIndex = restTailIndex + 1\n            val restHead\
    \ = restHead.asInstanceOf[Long]\n            val restTail = restTail.asInstanceOf[Long]\n\
    \            val restHeadIndex = restHeadIndex + 1\n            val restTailIndex\
    \ = restTailIndex - 1\n            val restHead = restHead.asInstanceOf[Long]\n\
    \            val restTail = restTail.asInstanceOf[Long]\n            val restHeadIndex\
    \ = restHeadIndex - 1\n            val restTailIndex = restTailIndex + 1\n   \
    \         val restHead = restHead.asInstanceOf[Long]\n            val restTail\
    \ = restTail.asInstanceOf[Long]\n            val restHeadIndex = restHeadIndex\
    \ + 1\n            val restTailIndex = restTailIndex - 1\n            val restHead\
    \ = restHead.asInstanceOf[Long]\n            val restTail = restTail.asInstanceOf[Long]\n\
    \            val restHeadIndex = restHeadIndex - 1\n            val restTailIndex\
    \ = restTailIndex + 1\n            val restHead = restHead.asInstanceOf[Long]\n\
    \            val restTail = restTail.asInstanceOf[Long]\n            val restHeadIndex\
    \ = restHeadIndex + 1\n            val restTailIndex = restTailIndex - 1\n   \
    \         val restHead = restHead.asInstanceOf[Long]\n            val restTail\
    \ = restTail.asInstanceOf[Long]\n            val restHeadIndex = restHeadIndex\
    \ - 1\n            val restTailIndex = restTailIndex + 1\n            val restHead\
    \ = restHead.asInstanceOf[Long]\n            val restTail = restTail.asInstanceOf[Long]\n\
    \            val restHeadIndex = restHeadIndex + 1\n            val restTailIndex\
    \ = restTailIndex - 1\n            val restHead = restHead.asInstance\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2k5zd8mf.scala:81:0 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2k5zd8mf.scala:36:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e\
    [0m \e[36mrestHeadIndex\e[0m = restHeadIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrestHeadIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mrestHeadIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2k5zd8mf.scala:37:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e\
    [0m \e[36mrestTailIndex\e[0m = restTailIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrestTailIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mrestTailIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2k5zd8mf.scala:38:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e\
    [0m \e[36mrestHead\e[0m = restHead.asInstanceOf[\e[35mLong\e[0m]\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mrestHead is already defined as \e[33mvalue\e[0m \e[35mrestHead\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp2k5zd8mf.scala:39:16 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m            \e[33mval\e[0m \e[36mrestTail\e[0m = restTail.asInstanceOf[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrestTail is already defined as \e[33mvalue\e[0m \e[35mrestTail\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e"
  stdout: ''
  timestamp: 1659798020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val r = new Array[Long](n)\n        val c =\
    \ new Array[Long](n)\n        val d = new Array[Long](n)\n        val e = new\
    \ Array[Long](n)\n        val f = new Array[Long](n)\n        val g = new Array[Long](n)\n\
    \        val h = new Array[Long](n)\n        val i = new Array[Long](n)\n    \
    \    val j = new Array[Long](n)\n        val k = new Array[Long](n)\n        val\
    \ l = new Array[Long](n)\n        val m1 = new Array[Long](n)\n        val m2\
    \ = new Array[Long](n)\n        val m3 = new Array[Long](n)\n        val m4 =\
    \ new Array[Long](n)\n        val m5 = new Array[Long](n)\n        val m6 = new\
    \ Array[Long](n)\n        val m7 = new Array[Long](n)\n        val m8 = new Array[Long](n)\n\
    \        val m9 = new Array[Long](n)\n        val m10 = new Array[Long](n)\n \
    \       val m11 = new Array[Long](n)\n        val m12 = new Array[Long](n)\n \
    \       val m13 = new Array[Long](n)\n        val m14 = new Array[Long](n)\n \
    \       val m15 = new Array[Long](n)\n        val m16 = new Array[Long](n)\n \
    \       val m17 = new Array[Long](n)\n        val m18 = new Array[Long](n)\n \
    \       val m19 = new Array[Long](n)\n        val m20 = new Array[Long](n)\n \
    \       val m21 = new Array[Long](n)\n        val m22 = new Array[Long](n)\n \
    \       val m23 = new Array[Long](n)\n        val m24 = new Array[Long](n)\n \
    \       val m25 = new Array[Long](n)\n        val m26 = new Array[Long](n)\n \
    \       val m27 = new Array[Long](n)\n        val m28 = new Array[Long](n)\n \
    \       val m29 = new Array[Long](n)\n        val m30 = new Array[Long](n)\n \
    \       val m31 = new Array[Long](n)\n        val m32 = new Array[Long](n)\n \
    \       val m33 = new Array[Long](n)\n        val m34 = new Array[Long](n)\n \
    \       val m35 = new Array[Long](n)\n        val m36 = new \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp54qzxd12.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp54qzxd12.scala:75:5 ---------------------\e[0m\e[0m\n\e[31m75\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) {\n            return true\n        }\n        val m = arr.head\n\
    \        val r = arr.tail\n        val s = r.head\n        val t = r.tail\n  \
    \      val u = t.head\n        val v = t.tail\n        val w = v.head\n      \
    \  val x = v.tail\n        val y = x.head\n        val z = x.tail\n        val\
    \ a = z.head\n        val b = z.tail\n        val c = b.head\n        val d =\
    \ b.tail\n        val e = d.head\n        val f = d.tail\n        val g = f.head\n\
    \        val h = f.tail\n        val i = h.head\n        val j = h.tail\n    \
    \    val k = i.head\n        val l = i.tail\n        val m = l.head\n        val\
    \ n = l.tail\n        val o = n.head\n        val p = n.tail\n        val q =\
    \ m.head\n        val r = m.tail\n        val s = r.head\n        val t = r.tail\n\
    \        val u = t.head\n        val v = t.tail\n        val w = v.head\n    \
    \    val x = v.tail\n        val y = x.head\n        val z = x.tail\n        val\
    \ a = z.head\n        val b = z.tail\n        val c = b.head\n        val d =\
    \ b.tail\n        val e = d.head\n        val f = d.tail\n        val g = f.head\n\
    \        val h = f.tail\n        val i = h.head\n        val j = h.tail\n    \
    \    val k = i.head\n        val l = i.tail\n        val m = l.head\n        val\
    \ n = l.tail\n        val o = n.head\n        val p = n.tail\n        val q =\
    \ m.head\n        val r = m.tail\n        val s = r.head\n        val t = r.tail\n\
    \        val u = t.head\n        val v = t.tail\n        val w = v.head\n    \
    \    val x = v.tail\n        val y = x.head\n        val z = x.tail\n        val\
    \ a = z.head\n        val b = z.tail\n        val c = b.head\n        val d =\
    \ b.tail\n        val e = d.head\n        val f = d.tail\n        val g = f.head\n\
    \        val h = f.tail\n        val i = h.head\n        val j = h.tail\n    \
    \    val k = i.head\n        val l = i.tail\n        val m = l.head\n        val\
    \ n = l.tail\n        val o = n.head\n        val p = n.tail\n        val q =\
    \ m.head\n        val r = m.tail\n        val s = r.head\n        val t = r.tail\n\
    \        val u = t.head\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppyxayon1.scala:52:12 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = l.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppyxayon1.scala:53:12 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = l.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppyxayon1.scala:57:12 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = m.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppyxayon1.scala:58:12 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = r.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppyxayon1.scala:59:12 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \e[36mt\e[0m = r.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mt is already defined\
    \ as \e[33mvalue\e[0m \e[35mt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppyxayon1.scala:60:12 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e[36mu\e[0m = t.head\n"
  stdout: ''
  timestamp: 1659798022
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val d = arr.last\n        val r = arr.init\n        val l = arr.last\n\
    \        val r = arr.init\n        val l = arr.last\n        val r = arr.init\n\
    \        val l = arr.last\n        val r = arr.init\n        val l = arr.last\n\
    \        val r = arr.init\n        val l = arr.last\n        val r = arr.init\n\
    \        val l = arr.last\n        val r = arr.init\n        val l = arr.last\n\
    \        val r = arr.init\n        val l = arr.last\n        val r = arr.init\n\
    \        val l = arr.last\n        val r = arr.init\n        val l = arr.last\n\
    \        val r = arr.init\n        val l = arr.last\n        val r = arr.init\n\
    \        val l = arr.last\n        val r = arr.init\n        val l = arr.last\n\
    \        val r = arr.init\n        val l = arr.last\n        val r = arr.init\n\
    \        val l = arr.last\n        val r = arr.init\n        val l = arr.last\n\
    \        val r = arr.init\n        val l = arr.last\n        val r = arr.init\n\
    \        val l = arr.last\n        val r = arr.init\n        val l = arr.last\n\
    \        val r = arr.init\n        val l = arr.last\n        val r = arr.init\n\
    \        val l = arr.last\n        val r = arr.init\n        val l = arr.last\n\
    \        val r = arr.init\n        val l = arr.last\n        val r = arr.init\n\
    \        val l = arr.last\n        val r = arr.init\n        val l = arr.last\n\
    \        val r = arr.init\n        val l = arr.last\n        val r = arr.init\n\
    \        val l = arr.last\n        val r = arr.init\n        val l = arr.last\n\
    \        val r = arr.init\n        val l = arr.last\n        val r = arr.init\n\
    \        val l = arr.last\n        val r = arr.init\n        val l = arr.last\n\
    \        val r = arr.init\n        val l = arr.last\n        val r = arr.init\n\
    \        val l = arr.last\n        val r = arr.init\n        val l = arr.last\n\
    \        val r = arr.init\n        val l = arr.last\n        val r = arr.init\n\
    \        val l = arr.last\n        val r = arr.init\n        val l = arr.last\n\
    \        val r = arr.init\n        val l = arr.last\n        val r = arr.init\n\
    \        val l = arr.last\n        val r = arr.init\n        val l = arr.last\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp4lpg3eh5.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4lpg3eh5.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4lpg3eh5.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4lpg3eh5.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4lpg3eh5.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4lpg3eh5.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659798021
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val s = arr.tail\n        val p = arr.init\n        val q = arr.tail\n\
    \        val r = arr.init\n        val l = arr.last\n        val p = arr.init\n\
    \        val q = arr.tail\n        val r = arr.init\n        val l = arr.last\n\
    \        val p = arr.init\n        val q = arr.tail\n        val r = arr.init\n\
    \        val l = arr.last\n        val p = arr.init\n        val q = arr.tail\n\
    \        val r = arr.init\n        val l = arr.last\n        val p = arr.init\n\
    \        val q = arr.tail\n        val r = arr.init\n        val l = arr.last\n\
    \        val p = arr.init\n        val q = arr.tail\n        val r = arr.init\n\
    \        val l = arr.last\n        val p = arr.init\n        val q = arr.tail\n\
    \        val r = arr.init\n        val l = arr.last\n        val p = arr.init\n\
    \        val q = arr.tail\n        val r = arr.init\n        val l = arr.last\n\
    \        val p = arr.init\n        val q = arr.tail\n        val r = arr.init\n\
    \        val l = arr.last\n        val p = arr.init\n        val q = arr.tail\n\
    \        val r = arr.init\n        val l = arr.last\n        val p = arr.init\n\
    \        val q = arr.tail\n        val r = arr.init\n        val l = arr.last\n\
    \        val p = arr.init\n        val q = arr.tail\n        val r = arr.init\n\
    \        val l = arr.last\n        val p = arr.init\n        val q = arr.tail\n\
    \        val r = arr.init\n        val l = arr.last\n        val p = arr.init\n\
    \        val q = arr.tail\n        val r = arr.init\n        val l = arr.last\n\
    \        val p = arr.init\n        val q = arr.tail\n        val r = arr.init\n\
    \        val l = arr.last\n        val p = arr.init\n        val q = arr.tail\n\
    \        val r = arr.init\n        val l = arr.last\n        val p = arr.init\n\
    \        val q = arr.tail\n        val r = arr.init\n        val l = arr.last\n\
    \        val p = arr.init\n        val q = arr.tail\n        val r = arr.init\n\
    \        val l = arr.last\n        val p = arr.init\n        val q = arr.tail\n\
    \        val r = arr.init\n        val l = arr.last\n        val p = arr.init\n\
    \        val q = arr.tail\n        val r = arr.init\n        val l = arr.last\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmphi0bh5j7.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphi0bh5j7.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphi0bh5j7.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphi0bh5j7.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mp is already defined\
    \ as \e[33mvalue\e[0m \e[35mp\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphi0bh5j7.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mq is already defined\
    \ as \e[33mvalue\e[0m \e[35mq\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphi0bh5j7.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659798021
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.toSet\n\
    \        val len = arr.size\n        val arr = arr.toList\n        val len = arr.size\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toSeq\n        val len = arr.length\n        val arr = arr.toIterator\n\
    \        val len = arr.length\n        val arr = arr.toStream\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.to\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwb6c33r0.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwb6c33r0.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.size\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwb6c33r0.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwb6c33r0.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpwb6c33r0.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toSeq\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpwb6c33r0.scala:33:12 --------------"
  stdout: ''
  timestamp: 1659798021
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val max = arr.max\n        val min = arr.min\n\
    \        val maxIndex = arr.lastIndex\n        val minIndex = arr.lastIndex\n\
    \        val maxIndex1 = arr.lastIndex - 1\n        val minIndex1 = arr.lastIndex\
    \ + 1\n        val maxIndex2 = arr.lastIndex - 2\n        val minIndex2 = arr.lastIndex\
    \ + 2\n        val maxIndex3 = arr.lastIndex - 3\n        val minIndex3 = arr.lastIndex\
    \ + 3\n        val maxIndex4 = arr.lastIndex - 4\n        val minIndex4 = arr.lastIndex\
    \ + 4\n        val maxIndex5 = arr.lastIndex - 5\n        val minIndex5 = arr.lastIndex\
    \ + 5\n        val maxIndex6 = arr.lastIndex - 6\n        val minIndex6 = arr.lastIndex\
    \ + 6\n        val maxIndex7 = arr.lastIndex - 7\n        val minIndex7 = arr.lastIndex\
    \ + 7\n        val maxIndex8 = arr.lastIndex - 8\n        val minIndex8 = arr.lastIndex\
    \ + 8\n        val maxIndex9 = arr.lastIndex - 9\n        val minIndex9 = arr.lastIndex\
    \ + 9\n        val maxIndex10 = arr.lastIndex - 10\n        val minIndex10 = arr.lastIndex\
    \ + 10\n        val maxIndex11 = arr.lastIndex - 11\n        val minIndex11 =\
    \ arr.lastIndex + 11\n        val maxIndex12 = arr.lastIndex - 12\n        val\
    \ minIndex12 = arr.lastIndex + 12\n        val maxIndex13 = arr.lastIndex - 13\n\
    \        val minIndex13 = arr.lastIndex + 13\n        val maxIndex14 = arr.lastIndex\
    \ - 14\n        val minIndex14 = arr.lastIndex + 14\n        val maxIndex15 =\
    \ arr.lastIndex - 15\n        val minIndex15 = arr.lastIndex + 15\n        val\
    \ maxIndex16 = arr.lastIndex - 16\n        val minIndex16 = arr.lastIndex + 16\n\
    \        val maxIndex17 = arr.lastIndex - 17\n        val minIndex17 = arr.lastIndex\
    \ + 17\n        val maxIndex18 = arr.lastIndex - 18\n        val minIndex18 =\
    \ arr.lastIndex + 18\n        val maxIndex19 = arr.lastIndex - 19\n        val\
    \ minIndex19 = arr.lastIndex + 19\n        val maxIndex20 = arr.lastIndex - 20\n\
    \        val minIndex20 = arr.lastIndex + 20\n        val maxIndex21 = arr.lastIndex\
    \ - 21\n        val minIndex21 = arr.lastIndex + 21\n        val maxIndex22 =\
    \ arr.lastIndex - 22\n        val minIndex22 = arr.lastIndex + 22\n        val\
    \ maxIndex23 = arr.lastIndex - 23\n        val minIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm60p8r3k.scala:78:4 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpm60p8r3k.scala:26:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm60p8r3k.scala:78:5\
    \ ---------------------\e[0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798021
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr1 = arr.toList\n\
    \        val arr2 = arr1.reverse\n        val arr3 = arr2.toList\n        val\
    \ arr4 = arr3.reverse\n        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n\
    \        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val\
    \ arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n\
    \        val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n      \
    \  val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16\
    \ = arr15.reverse\n        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n\
    \        val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n      \
    \  val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23\
    \ = arr22.reverse\n        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n\
    \        val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n      \
    \  val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30\
    \ = arr29.reverse\n        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n\
    \        val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n      \
    \  val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37\
    \ = arr36.reverse\n        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n\
    \        val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n      \
    \  val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44\
    \ = arr43.reverse\n        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n\
    \        val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n      \
    \  val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51\
    \ = arr50.reverse\n        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n\
    \        val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n      \
    \  val arr\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp46q1477e.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp46q1477e.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp46q1477e.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr1\
    \ = arr.take(len-1)\n        val arr2 = arr.drop(len-1)\n        val arr3 = arr2.take(len-1)\n\
    \        val arr4 = arr2.drop(len-1)\n        val arr5 = arr3.take(len-1)\n  \
    \      val arr6 = arr3.drop(len-1)\n        val arr7 = arr4.take(len-1)\n    \
    \    val arr8 = arr4.drop(len-1)\n        val arr9 = arr5.take(len-1)\n      \
    \  val arr10 = arr5.drop(len-1)\n        val arr11 = arr6.take(len-1)\n      \
    \  val arr12 = arr6.drop(len-1)\n        val arr13 = arr7.take(len-1)\n      \
    \  val arr14 = arr7.drop(len-1)\n        val arr15 = arr8.take(len-1)\n      \
    \  val arr16 = arr8.drop(len-1)\n        val arr17 = arr9.take(len-1)\n      \
    \  val arr18 = arr9.drop(len-1)\n        val arr19 = arr10.take(len-1)\n     \
    \   val arr20 = arr10.drop(len-1)\n        val arr21 = arr11.take(len-1)\n   \
    \     val arr22 = arr11.drop(len-1)\n        val arr23 = arr12.take(len-1)\n \
    \       val arr24 = arr12.drop(len-1)\n        val arr25 = arr13.take(len-1)\n\
    \        val arr26 = arr13.drop(len-1)\n        val arr27 = arr14.take(len-1)\n\
    \        val arr28 = arr14.drop(len-1)\n        val arr29 = arr15.take(len-1)\n\
    \        val arr30 = arr15.drop(len-1)\n        val arr31 = arr16.take(len-1)\n\
    \        val arr32 = arr16.drop(len-1)\n        val arr33 = arr17.take(len-1)\n\
    \        val arr34 = arr17.drop(len-1)\n        val arr35 = arr18.take(len-1)\n\
    \        val arr36 = arr18.drop(len-1)\n        val arr37 = arr19.take(len-1)\n\
    \        val arr38 = arr19.drop(len-1)\n        val arr39 = arr20.take(len-1)\n\
    \        val arr40 = arr20.drop(len-1)\n        val arr41 = arr21.take(len-1)\n\
    \        val arr42 = arr21.drop(len-1)\n        val arr\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkaoxrzau.scala:72:4 ----------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkaoxrzau.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkaoxrzau.scala:72:5\
    \ ---------------------\e[0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val l = arr.length\n\
    \        val r = arr.last\n        val m = arr.head\n        val r = arr.last\n\
    \        val l = arr.length\n        val r = arr.last\n        val m = arr.head\n\
    \        val r = arr.last\n        val l = arr.length\n        val r = arr.last\n\
    \        val m = arr.head\n        val r = arr.last\n        val l = arr.length\n\
    \        val r = arr.last\n        val m = arr.head\n        val r = arr.last\n\
    \        val l = arr.length\n        val r = arr.last\n        val m = arr.head\n\
    \        val r = arr.last\n        val l = arr.length\n        val r = arr.last\n\
    \        val m = arr.head\n        val r = arr.last\n        val l = arr.length\n\
    \        val r = arr.last\n        val m = arr.head\n        val r = arr.last\n\
    \        val l = arr.length\n        val r = arr.last\n        val m = arr.head\n\
    \        val r = arr.last\n        val l = arr.length\n        val r = arr.last\n\
    \        val m = arr.head\n        val r = arr.last\n        val l = arr.length\n\
    \        val r = arr.last\n        val m = arr.head\n        val r = arr.last\n\
    \        val l = arr.length\n        val r = arr.last\n        val m = arr.head\n\
    \        val r = arr.last\n        val l = arr.length\n        val r = arr.last\n\
    \        val m = arr.head\n        val r = arr.last\n        val l = arr.length\n\
    \        val r = arr.last\n        val m = arr.head\n        val r = arr.last\n\
    \        val l = arr.length\n        val r = arr.last\n        val m = arr.head\n\
    \        val r = arr.last\n        val l = arr.length\n        val r = arr.last\n\
    \        val m = arr.head\n        val r = arr.last\n        val l = arr.length\n\
    \        val r = arr.last\n        val m = arr.head\n        val r = arr.last\n\
    \        val l = arr.length\n        val r = arr.last\n        val m = arr.head\n\
    \        val r = arr.last\n        val l = arr.length\n        val r = arr.last\n\
    \        val m = arr.head\n        val r = arr.last\n        val l = arr.length\n\
    \        val r = arr.last\n        val m = arr.head\n        val r = arr.last\n\
    \        val l = arr.length\n        val r = arr.last\n        val m = arr.head\n\
    \        val r = arr.last\n        val l = arr.length\n        val r = arr.last\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpeg4gyujr.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeg4gyujr.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeg4gyujr.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeg4gyujr.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already\
    \ defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeg4gyujr.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeg4gyujr.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m  "
  stdout: ''
  timestamp: 1659798022
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr2 = arr.toList\n\
    \        val arr3 = arr2.reverse\n        val arr4 = arr3.toList\n        val\
    \ arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n        val arr7 = arr6.reverse\n\
    \        val arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n        val\
    \ arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n        val arr12 =\
    \ arr11.reverse\n        val arr13 = arr12.reverse\n        val arr14 = arr13.reverse\n\
    \        val arr15 = arr14.reverse\n        val arr16 = arr15.reverse\n      \
    \  val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n        val arr19\
    \ = arr18.reverse\n        val arr20 = arr19.reverse\n        val arr21 = arr20.reverse\n\
    \        val arr22 = arr21.reverse\n        val arr23 = arr22.reverse\n      \
    \  val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n        val arr26\
    \ = arr25.reverse\n        val arr27 = arr26.reverse\n        val arr28 = arr27.reverse\n\
    \        val arr29 = arr28.reverse\n        val arr30 = arr29.reverse\n      \
    \  val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n        val arr33\
    \ = arr32.reverse\n        val arr34 = arr33.reverse\n        val arr35 = arr34.reverse\n\
    \        val arr36 = arr35.reverse\n        val arr37 = arr36.reverse\n      \
    \  val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n        val arr40\
    \ = arr39.reverse\n        val arr41 = arr40.reverse\n        val arr42 = arr41.reverse\n\
    \        val arr43 = arr42.reverse\n        val arr44 = arr43.reverse\n      \
    \  val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n        val arr47\
    \ = arr46.reverse\n        val arr48 = arr47.reverse\n        val arr49 = arr48.reverse\n\
    \        val arr50 = arr49.reverse\n        val arr51 = arr50.reverse\n      \
    \  val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n        val arr54\
    \ = arr53.reverse\n        val arr55 = arr54.reverse\n        val arr56 = arr55.reverse\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpfdv8e_56.scala:84:11 ---------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfdv8e_56.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpfdv8e_56.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659797996
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val l = arr.head\n    \
    \        val r = arr.last\n            val m = arr.indexOf(l) + 1\n          \
    \  val n = arr.indexOf(r) + 1\n            val k = arr.indexOf(l) + n\n      \
    \      val m = arr.indexOf(r) + n\n            val p = arr.indexOf(l) + k\n  \
    \          val q = arr.indexOf(r) + k\n            val x = arr.indexOf(l) + m\n\
    \            val y = arr.indexOf(r) + m\n            val z = arr.indexOf(l) +\
    \ p\n            val w = arr.indexOf(r) + p\n            val a = arr.indexOf(l)\
    \ + q\n            val b = arr.indexOf(r) + q\n            val c = arr.indexOf(l)\
    \ + x\n            val d = arr.indexOf(r) + x\n            val e = arr.indexOf(l)\
    \ + y\n            val f = arr.indexOf(r) + y\n            val g = arr.indexOf(l)\
    \ + z\n            val h = arr.indexOf(r) + z\n            val i = arr.indexOf(l)\
    \ + w\n            val j = arr.indexOf(r) + w\n            val k = arr.indexOf(l)\
    \ + a\n            val l = arr.indexOf(r) + a\n            val m = arr.indexOf(l)\
    \ + b\n            val n = arr.indexOf(r) + b\n            val o = arr.indexOf(l)\
    \ + c\n            val p = arr.indexOf(r) + c\n            val q = arr.indexOf(l)\
    \ + d\n            val r = arr.indexOf(r) + d\n            val s = arr.indexOf(l)\
    \ + e\n            val t = arr.indexOf(r) + e\n            val u = arr.indexOf(l)\
    \ + f\n            val v = arr.indexOf(r) + f\n            val w = arr.indexOf(l)\
    \ + g\n            val x = arr.indexOf(r) + g\n            val y = arr.indexOf(l)\
    \ + h\n            val z = arr.indexOf(r) + h\n            val a = arr.indexOf(l)\
    \ + i\n            val b = arr.indexOf(r) + i\n            val c = arr.indexOf(l)\
    \ + j\n            val d = arr.indexOf(r) + j\n            val e = arr.indexOf(l)\
    \ + k\n            val f = arr.indexOf(r) + k\n            val g = arr.indexOf(l)\
    \ + l\n            val h = arr.indexOf(r) + l\n            val i = arr.indexOf(l)\
    \ + m\n            val j = arr.indexOf(r) + m\n            val k = arr.indexOf(l)\
    \ + n\n            val l = arr.indexOf(r) + n\n            val m = arr.indexOf(l)\
    \ + o\n            val n = arr.indexOf(r) + o\n            val o = arr.indexOf(l)\
    \ + p\n            val p = arr.indexOf(r) + p\n            val q = arr.indexOf(l)\
    \ + q\n            val r = arr.indexOf(r) + q\n            val s = \n    }\n \
    \   def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpbqh8cb61.scala:85:19 ---------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m            \e[33mval\e[0m \e[36ms\e[0m = \n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpbqh8cb61.scala:96:0 ----------------------------\e[0m\e[0m\n\e[31m96\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbqh8cb61.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = arr.indexOf(r)\
    \ + n\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbqh8cb61.scala:51:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m51 |\e[0m            \e[33mval\e\
    [0m \e[36mk\e[0m = arr.indexOf(l) + a\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mk is already defined as \e[33mvalue\e[0m \e[35mk\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpbqh8cb61.scala:52:16 ---------------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m            \e[33mval\e[0m \e[36ml\e[0m = arr.indexOf(r) + a\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is\
    \ already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbqh8cb61.scala:53:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m53 |\e[0m            \e[33mval\e\
    [0m \e[36mm\e[0m = arr.indexOf(l) + b\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0"
  stdout: ''
  timestamp: 1659798024
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val len = arr.length\n\
    \        if (len == 0) return true\n        val first = arr(len - 1)\n       \
    \ val last = arr(0)\n        val mid = len / 2\n        val left = arr.take(mid)\n\
    \        val right = arr.drop(mid)\n        val leftSorted = left.sortBy(_)\n\
    \        val rightSorted = right.sortBy(_)\n        val leftSortedSortedRight\
    \ = leftSorted.sortBy(_)\n        val rightSortedSortedLeft = rightSorted.sortBy(_)\n\
    \        val leftSortedSortedRightSortedLeft = leftSortedSortedRight.sortBy(_)\n\
    \        val rightSortedSortedLeftSortedRight = rightSortedSortedLeft.sortBy(_)\n\
    \        val leftSortedSortedRightSortedLeftSortedRight = leftSortedSortedRightSortedLeft.sortBy(_)\n\
    \        val rightSortedSortedLeftSortedRightSortedLeft = rightSortedSortedLeftSortedRight.sortBy(_)\n\
    \        val leftSortedSortedRightSortedLeftSortedRightSortedLeft = leftSortedSortedRightSortedLeftSortedRight.sortBy(_)\n\
    \        val rightSortedSortedLeftSortedRightSortedLeftSortedRight = rightSortedSortedLeftSortedRightSortedLeft.sortBy(_)\n\
    \        val leftSortedSortedRightSortedLeftSortedRightSortedLeftSortedRight =\
    \ leftSortedSortedRightSortedLeftSortedRightSortedLeft.sortBy(_)\n        val\
    \ rightSortedSortedLeftSortedRightSortedLeftSortedRightSortedLeft = rightSortedSortedLeftSortedRightSortedLeftSortedRight.sortBy(_)\n\
    \        val leftSortedSortedRightSortedLeftSortedRightSortedLeftSortedRightSortedLeft\
    \ = leftSortedSortedRightSortedLeftSortedRightSortedLeftSortedRightSortedLeft.sortBy(_)\n\
    \        val rightSortedSortedLeftSortedRightSortedLeftSortedRightSortedLeftSortedRight\
    \ = rightSortedSortedLeftSortedRightSortedLeftSortedRightSortedLeftSortedRight.sortBy(_)\n\
    \        val leftSortedSortedRightSortedLeftSortedRightSortedLeftSortedRightSortedLeftSortedRightSortedLeft\
    \ = leftSortedSortedRightSortedLeftSortedRightSortedLeftSortedRightSortedLeftSortedRightSortedLeft.sortBy(_)\n\
    \        val rightSortedSortedLeftSortedRightSortedLeftSortedRightSortedLeftSortedRightSortedLeftSortedRight\
    \ = rightSortedSortedLeftSortedRightSortedLeftSortedRightSortedLeftSortedRightSortedLeftSortedRightSortedLeft.sortBy(_)\n\
    \        val leftSortedSortedRightSortedLeftSortedRightSortedLeftSortedRightSortedLeftSortedRightSortedLeftSortedRightSortedLeft\
    \ = leftSortedSortedRightSortedLeftSortedRightSortedLeftSortedRightSortedLeftSortedRightSortedLeftSortedRightSortedLeftSortedRight\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpotmion_a.scala:33:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mleftSorted\e[0m = left.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m   |\e\
    [0mNo implicit Ordering defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e[31m \
    \  |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[Any]]\n\e\
    [31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[Any].\n\e[31m\e[31m--\
    \ Error: /tmp/tmpotmion_a.scala:34:41 -----------------------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mrightSorted\e[0m = right.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0mNo implicit Ordering defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e\
    [31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[Any]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[Any].\n\e[31m\e[31m--\
    \ [E081] Type Error: /tmp/tmpotmion_a.scala:35:54 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mleftSortedSortedRight\e\
    [0m = leftSorted.sortBy(_)\n\e[31m\e[31m   |\e[0m                            \
    \                          ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$3\
    \ of expanded function:\n\e[31m   |\e[0m   _$3 => leftSorted.sortBy(_$3).\n\e\
    [31m\e[31m-- [E081] Type Error: /tmp/tmpotmion_a.scala:36:55 -----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mrightSortedSortedLeft\e\
    [0m = rightSorted.sortBy(_)\n\e[31m\e[31m   |\e[0m                           \
    \                            ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$4 of expanded function:"
  stdout: ''
  timestamp: 1659798025
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val result = new Array[Boolean](n + 1)\n  \
    \      result(0) = true\n        val arr = arr.tail\n        val len = arr.length\n\
    \        val max = (len - 1) * n\n        val min = 0\n        var i = 0\n   \
    \     var j = 0\n        var k = 0\n        var temp = 0\n        var flag = true\n\
    \        var temp2 = new Array[Long](n)\n        var temp3 = new Array[Long](n)\n\
    \        var temp4 = new Array[Long](n)\n        var temp5 = new Array[Long](n)\n\
    \        var temp6 = new Array[Long](n)\n        var temp7 = new Array[Long](n)\n\
    \        var temp8 = new Array[Long](n)\n        var temp9 = new Array[Long](n)\n\
    \        var temp10 = new Array[Long](n)\n        var temp11 = new Array[Long](n)\n\
    \        var temp12 = new Array[Long](n)\n        var temp13 = new Array[Long](n)\n\
    \        var temp14 = new Array[Long](n)\n        var temp15 = new Array[Long](n)\n\
    \        var temp16 = new Array[Long](n)\n        var temp17 = new Array[Long](n)\n\
    \        var temp18 = new Array[Long](n)\n        var temp19 = new Array[Long](n)\n\
    \        var temp20 = new Array[Long](n)\n        var temp21 = new Array[Long](n)\n\
    \        var temp22 = new Array[Long](n)\n        var temp23 = new Array[Long](n)\n\
    \        var temp24 = new Array[Long](n)\n        var temp25 = new Array[Long](n)\n\
    \        var temp26 = new Array[Long](n)\n        var temp27 = new Array[Long](n)\n\
    \        var temp28 = new Array[Long](n)\n        var temp29 = new Array[Long](n)\n\
    \        var temp30 = new Array[Long](n)\n        var temp31 = new Array[Long](n)\n\
    \        var temp32 = new Array[Long](n)\n        var temp33 = new Array[Long](n)\n\
    \        var temp34 = new Array[Long](n)\n        var temp35 = new Array[Long](n)\n\
    \        var temp36 = new Array[Long](n)\n        var temp37 = new Array[Long](n)\n\
    \        var temp38 = new Array[Long](n)\n        var temp39 = new Array[Long](n)\n\
    \        var temp40 = new Array[Long](n)\n        var temp41 = new Array[Long](n)\n\
    \        var temp42 = new Array[Long](n)\n        var temp43 = new Array[Long](n)\n\
    \        var temp44 = new Array[Long](n)\n        var temp45 = new Array[\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzrt3aqzs.scala:83:4 ----------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpzrt3aqzs.scala:30:18 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m\
    \                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpzrt3aqzs.scala:82:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m82 |\e[0m       \
    \ \e[33mvar\e[0m \e[36mtemp45\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument\
    \ for parameter _length of \e[33mconstructor\e[0m \e[35mArray\e[0m in \e[33mclass\e\
    [0m \e[35mArray\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzrt3aqzs.scala:83:5\
    \ ---------------------\e[0m\e[0m\n\e[31m83 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659798025
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        if (n == 0) true\n        else {\n            val leftmost = arr.head\n\
    \            val rightmost = arr.last\n            val leftmostIndex = arr.indexOf(0)\n\
    \            val rightmostIndex = arr.lastIndexOf(0)\n            val leftmostIndexInt\
    \ = leftmostIndex.toInt\n            val rightmostIndexInt = rightmostIndex.toInt\n\
    \            val leftmostIndexInt = leftmostIndexInt + 1\n            val rightmostIndexInt\
    \ = rightmostIndexInt + 1\n            val leftmostIndexLong = leftmostIndex.toLong\n\
    \            val rightmostIndexLong = rightmostIndex.toLong\n            val leftmostIndexLong\
    \ = leftmostIndexLong + 1\n            val rightmostIndexLong = rightmostIndexLong\
    \ + 1\n            val leftmostIndexInt = leftmostIndexInt.toInt\n           \
    \ val rightmostIndexInt = rightmostIndexInt.toInt\n            val leftmostIndexInt\
    \ = leftmostIndexInt + 1\n            val rightmostIndexInt = rightmostIndexInt\
    \ + 1\n            val leftmostIndexLong = leftmostIndex.toLong\n            val\
    \ rightmostIndexLong = rightmostIndex.toLong\n            val leftmostIndexLong\
    \ = leftmostIndexLong + 1\n            val rightmostIndexLong = rightmostIndexLong\
    \ + 1\n            val leftmostIndexInt = leftmostIndexInt.toInt\n           \
    \ val rightmostIndexInt = rightmostIndexInt.toInt\n            val leftmostIndexInt\
    \ = leftmostIndexInt + 1\n            val rightmostIndexInt = rightmostIndexInt\
    \ + 1\n            val leftmostIndexLong = leftmostIndex.toLong\n            val\
    \ rightmostIndexLong = rightmostIndex.toLong\n            val leftmostIndexLong\
    \ = leftmostIndexLong + 1\n            val rightmostIndexLong = rightmostIndexLong\
    \ + 1\n            val leftmostIndexInt = leftmostIndexInt.toInt\n           \
    \ val rightmostIndexInt = rightmostIndexInt.toInt\n            val leftmostIndexInt\
    \ = leftmostIndexInt + 1\n            val rightmostIndexInt = rightmostIndexInt\
    \ + 1\n            val leftmostIndexLong = leftmostIndex.toLong\n            val\
    \ rightmostIndexLong = rightmostIndex.toLong\n            val leftmostIndexLong\
    \ = leftmostIndexLong + 1\n            val rightmostIndexLong = rightmostIndexLong\
    \ + 1\n            val leftmostIndexInt = leftmostIndexInt.toInt\n           \
    \ val rightmostIndexInt = rightmostIndexInt.to\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpd1bdkjif.scala:77:0 ----------------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd1bdkjif.scala:35:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e\
    [0m \e[36mleftmostIndexInt\e[0m = leftmostIndexInt + \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mleftmostIndexInt is already defined as \e[33mvalue\e[0m \e[35mleftmostIndexInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpd1bdkjif.scala:36:16 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m            \e[33mval\e[0m \e[36mrightmostIndexInt\e[0m = rightmostIndexInt\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightmostIndexInt is already defined as \e[33mvalue\e[0m \e\
    [35mrightmostIndexInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpd1bdkjif.scala:39:16 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e[0m \e[36mleftmostIndexLong\e\
    [0m = leftmostIndexLong + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftmostIndexLong is already defined as \e[33mvalue\e[0m \e\
    [35mleftmostIndexLong\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpd1bdkjif.scala:40:16 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e[0m \e[36mrightmostIndexLong\e\
    [0m = rightmostIndexLong + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightmostIndexLong is already defined as \e[33mvalue\e[0m\
    \ \e[35mrightmostIndexLong\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mN"
  stdout: ''
  timestamp: 1659798028
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.dropRight(1)\n\
    \        val d = arr.dropRight(2)\n        val r = arr.dropRight(3)\n        val\
    \ d = arr.dropRight(4)\n        val r = arr.dropRight(5)\n        val d = arr.dropRight(6)\n\
    \        val r = arr.dropRight(7)\n        val d = arr.dropRight(8)\n        val\
    \ r = arr.dropRight(9)\n        val d = arr.dropRight(10)\n        val r = arr.dropRight(11)\n\
    \        val d = arr.dropRight(12)\n        val r = arr.dropRight(13)\n      \
    \  val d = arr.dropRight(14)\n        val r = arr.dropRight(15)\n        val d\
    \ = arr.dropRight(16)\n        val r = arr.dropRight(17)\n        val d = arr.dropRight(18)\n\
    \        val r = arr.dropRight(19)\n        val d = arr.dropRight(20)\n      \
    \  val r = arr.dropRight(21)\n        val d = arr.dropRight(22)\n        val r\
    \ = arr.dropRight(23)\n        val d = arr.dropRight(24)\n        val r = arr.dropRight(25)\n\
    \        val d = arr.dropRight(26)\n        val r = arr.dropRight(27)\n      \
    \  val d = arr.dropRight(28)\n        val r = arr.dropRight(29)\n        val d\
    \ = arr.dropRight(30)\n        val r = arr.dropRight(31)\n        val d = arr.dropRight(32)\n\
    \        val r = arr.dropRight(33)\n        val d = arr.dropRight(34)\n      \
    \  val r = arr.dropRight(35)\n        val d = arr.dropRight(36)\n        val r\
    \ = arr.dropRight(37)\n        val d = arr.dropRight(38)\n        val r = arr.dropRight(39)\n\
    \        val d = arr.dropRight(40)\n        val r = arr.dropRight(41)\n      \
    \  val d = arr.dropRight(42)\n        val r = arr.dropRight(43)\n        val d\
    \ = arr.dropRight(44)\n        val r = arr.dropRight(45)\n        val d = arr.dropRight(46)\n\
    \        val r = arr.dropRight(47)\n        val d = arr.dropRight(48)\n      \
    \  val r = arr.dropRight(49)\n        val d = arr.dropRight(50)\n        val r\
    \ = arr.dropRight(51)\n        val d = arr.dropRight(52)\n        val r = arr.dropRight(53)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjonr_spz.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.dropRight(\e\
    [31m3\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjonr_spz.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36md\e[0m = arr.dropRight(\e[31m4\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0md is already defined as \e[33mvalue\e[0m \e[35md\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpjonr_spz.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.dropRight(\e[31m5\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is\
    \ already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjonr_spz.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36md\e[0m = arr.dropRight(\e[31m6\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0md is already defined as \e[33mvalue\e[0m \e[35md\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpjonr_spz.scala:35:12 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.dropRight(\e[31m7\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is\
    \ already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[3"
  stdout: ''
  timestamp: 1659798027
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val r = new Array[Long](n)\n        val l =\
    \ new Array[Long](n)\n        val r1 = new Array[Long](n)\n        val l1 = new\
    \ Array[Long](n)\n        val r2 = new Array[Long](n)\n        val l2 = new Array[Long](n)\n\
    \        val r3 = new Array[Long](n)\n        val l3 = new Array[Long](n)\n  \
    \      val r4 = new Array[Long](n)\n        val l4 = new Array[Long](n)\n    \
    \    val r5 = new Array[Long](n)\n        val l5 = new Array[Long](n)\n      \
    \  val r6 = new Array[Long](n)\n        val l6 = new Array[Long](n)\n        val\
    \ r7 = new Array[Long](n)\n        val l7 = new Array[Long](n)\n        val r8\
    \ = new Array[Long](n)\n        val l8 = new Array[Long](n)\n        val r9 =\
    \ new Array[Long](n)\n        val l9 = new Array[Long](n)\n        val r10 = new\
    \ Array[Long](n)\n        val l10 = new Array[Long](n)\n        val r11 = new\
    \ Array[Long](n)\n        val l11 = new Array[Long](n)\n        val r12 = new\
    \ Array[Long](n)\n        val l12 = new Array[Long](n)\n        val r13 = new\
    \ Array[Long](n)\n        val l13 = new Array[Long](n)\n        val r14 = new\
    \ Array[Long](n)\n        val l14 = new Array[Long](n)\n        val r15 = new\
    \ Array[Long](n)\n        val l15 = new Array[Long](n)\n        val r16 = new\
    \ Array[Long](n)\n        val l16 = new Array[Long](n)\n        val r17 = new\
    \ Array[Long](n)\n        val l17 = new Array[Long](n)\n        val r18 = new\
    \ Array[Long](n)\n        val l18 = new Array[Long](n)\n        val r19 = new\
    \ Array[Long](n)\n        val l19 = new Array[Long](n)\n        val r20 = new\
    \ Array[Long](n)\n        val l20 = new Array[Long](n)\n        val r21 = new\
    \ Array[Long](n)\n        val l21 = new Array[Long](n)\n        val r22 = new\
    \ Array[Long](n)\n        val l22 = new Array[Long\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpt2f5yq62.scala:74:4 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpt2f5yq62.scala:73:18\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m73 |\e[0m       \
    \ \e[33mval\e[0m \e[36ml22\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e\
    [0m\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmissing argument for parameter _length of \e[33mconstructor\e[0m \e[35mArray\e\
    [0m in \e[33mclass\e[0m \e[35mArray\e[0m: (_length: Int): Array[Long]\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpt2f5yq62.scala:74:5 ---------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798029
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps49t83wh.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps49t83wh.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmps49t83wh.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmps49t83wh.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmps49t83wh.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Nam"
  stdout: ''
  timestamp: 1659798030
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1enxt_uh.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp1enxt_uh.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1enxt_uh.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp1enxt_uh.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1enxt_uh.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the sam"
  stdout: ''
  timestamp: 1659798030
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val m = arr.head\n    \
    \        val r = arr.tail\n            val m = m.toLong\n            val r = r.toLong\n\
    \            val rr = r.reduceLeft((x, y) => x + y)\n            val rr = rr.toLong\n\
    \            val rrr = rr.reduceLeft((x, y) => x + y)\n            val rrr = rrr.toLong\n\
    \            val rrrr = rrrr.reduceLeft((x, y) => x + y)\n            val rrrr\
    \ = rrrrr.toLong\n            val rrrrrrr = rrrrrr.reduceLeft((x, y) => x + y)\n\
    \            val rrrrrrr = rrrrrrr.toLong\n            val rrrrrrrr = rrrrrrrr.reduceLeft((x,\
    \ y) => x + y)\n            val rrrrrrrr = rrrrrrrr.reduceLeft((x, y) => x + y)\n\
    \            val rrrrrrrrr = rrrrrrrr.reduceLeft((x, y) => x + y)\n          \
    \  val rrrrrrrrr = rrrrrrrr.reduceLeft((x, y) => x + y)\n            val rrrrrrrrrr\
    \ = rrrrrrrrr.reduceLeft((x, y) => x + y)\n            val rrrrrrrrrrr = rrrrrrrrrr.reduceLeft((x,\
    \ y) => x + y)\n            val rrrrrrrrrrrr = rrrrrrrrrrrr.reduceLeft((x, y)\
    \ => x + y)\n            val rrrrrrrrrrrrr = rrrrrrrrrrrrrr.reduceLeft((x, y)\
    \ => x + y)\n            val rrrrrrrrrrrrrrrr = rrrrrrrrrrrrrrrr.reduceLeft((x,\
    \ y) => x + y)\n            val rrrrrrrrrrrrrrrr = rrrrrrrrrrrrrrrr.reduceLeft((x,\
    \ y) => x + y)\n            val rrrrrrrrrrrrrrrrrr = rrrrrrrrrrrrrrrrrr.reduceLeft((x,\
    \ y) => x + y)\n            val rrrrrrrrrrrrrrrrrrrr = rrrrrrrrrrrrrrrrrrrr.reduceLeft((x,\
    \ y) => x + y)\n            val rrrrrrrrrrrrrrrrrrrrrr = rrrrrrrrrrrrrrrrrrrrrr.reduceLeft((x,\
    \ y) => x + y)\n            val rrrrrrrrrrrrrrrrrrrrrrrr = rrrrrrrrrrrrrrrrrrrrrrrr.reduceLeft((x,\
    \ y) => x + y)\n            val rrrrrrrrrrrr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdigxkmuq.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdigxkmuq.scala:66:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m66 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdigxkmuq.scala:31:16 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = m.toLong\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdigxkmuq.scala:32:16 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r.toLong\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdigxkmuq.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mrr\e[0m = rr.toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrr is\
    \ already defined as \e[33mvalue\e[0m \e[35mrr\e[0m\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdigxkmuq.scala:36:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e\
    [0m \e[36mrrr\e[0m = rrr.toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrrr is already defined as \e[33mvalue\e[0m \e[35mrrr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpdigxkmuq.scala:38:16 ---------------------------\e[0m\e[0"
  stdout: ''
  timestamp: 1659798032
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val r = new Array[Long](n)\n        val l =\
    \ new Array[Long](n)\n        val d = new Array[Long](n)\n        val h = new\
    \ Array[Long](n)\n        val v = new Array[Long](n)\n        val p = new Array[Long](n)\n\
    \        val q = new Array[Long](n)\n        val s = new Array[Long](n)\n    \
    \    val t = new Array[Long](n)\n        val u = new Array[Long](n)\n        val\
    \ v = new Array[Long](n)\n        val w = new Array[Long](n)\n        val x =\
    \ new Array[Long](n)\n        val y = new Array[Long](n)\n        val z = new\
    \ Array[Long](n)\n        val a = new Array[Long](n)\n        val b = new Array[Long](n)\n\
    \        val c = new Array[Long](n)\n        val d = new Array[Long](n)\n    \
    \    val e = new Array[Long](n)\n        val f = new Array[Long](n)\n        val\
    \ g = new Array[Long](n)\n        val h = new Array[Long](n)\n        val i =\
    \ new Array[Long](n)\n        val j = new Array[Long](n)\n        val k = new\
    \ Array[Long](n)\n        val l = new Array[Long](n)\n        val m = new Array[Long](n)\n\
    \        val n = new Array[Long](n)\n        val o = new Array[Long](n)\n    \
    \    val p = new Array[Long](n)\n        val q = new Array[Long](n)\n        val\
    \ r = new Array[Long](n)\n        val s = new Array[Long](n)\n        val t =\
    \ new Array[Long](n)\n        val u = new Array[Long](n)\n        val v = new\
    \ Array[Long](n)\n        val w = new Array[Long](n)\n        val x = new Array[Long](n)\n\
    \        val y = new Array[Long](n)\n        val z = new Array[Long](n)\n    \
    \    val a = new Array[Long](n)\n        val b = new Array[Long](n)\n        val\
    \ c = new Array[Long](n)\n        val d = new Array[Long](n)\n        val e =\
    \ new Array[Long](n)\n        val f = new Array[Long](n)\n        val g = new\
    \ Array[Long](n)\n        val h = new Array[Long](n)\n        val i = new Array[Long](n)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpgwu_gogk.scala:78:11 ---------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpgwu_gogk.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mv\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mv is already defined as \e[33mvalue\e[0m \e[35mv\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgwu_gogk.scala:46:12 ---------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m        \e[33mval\e[0m \e[36md\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0md is already defined as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgwu_gogk.scala:50:12 ---------------------------\e[0m\e[0m\n\e[31m50\
    \ |\e[0m        \e[33mval\e[0m \e[36mh\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mh is already defined as \e[33mvalue\e[0m \e[35mh\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgwu_gogk.scala:54:12 ---------------------------\e[0m\e[0m\n\e[31m54\
    \ |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Err"
  stdout: ''
  timestamp: 1659798032
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:34:12 ----------"
  stdout: ''
  timestamp: 1659797997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val l = arr.last\n        val r = arr.head\n\
    \        val m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n    \
    \    val k = arr.indexOf(l) + 2\n        val l = arr.indexOf(r) + 2\n        val\
    \ m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n        val k =\
    \ arr.indexOf(l) + 2\n        val l = arr.indexOf(r) + 2\n        val m = arr.indexOf(l)\
    \ + 1\n        val n = arr.indexOf(r) + 1\n        val k = arr.indexOf(l) + 2\n\
    \        val l = arr.indexOf(r) + 2\n        val m = arr.indexOf(l) + 1\n    \
    \    val n = arr.indexOf(r) + 1\n        val k = arr.indexOf(l) + 2\n        val\
    \ l = arr.indexOf(r) + 2\n        val m = arr.indexOf(l) + 1\n        val n =\
    \ arr.indexOf(r) + 1\n        val k = arr.indexOf(l) + 2\n        val l = arr.indexOf(r)\
    \ + 2\n        val m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n\
    \        val k = arr.indexOf(l) + 2\n        val l = arr.indexOf(r) + 2\n    \
    \    val m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n        val\
    \ k = arr.indexOf(l) + 2\n        val l = arr.indexOf(r) + 2\n        val m =\
    \ arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n        val k = arr.indexOf(l)\
    \ + 2\n        val l = arr.indexOf(r) + 2\n        val m = arr.indexOf(l) + 1\n\
    \        val n = arr.indexOf(r) + 1\n        val k = arr.indexOf(l) + 2\n    \
    \    val l = arr.indexOf(r) + 2\n        val m = arr.indexOf(l) + 1\n        val\
    \ n = arr.indexOf(r) + 1\n        val k = arr.indexOf(l) + 2\n        val l =\
    \ arr.indexOf(r) + 2\n        val m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r)\
    \ + 1\n        val k = arr.indexOf(l) + 2\n        val l = arr.indexOf(r) + 2\n\
    \        val m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n    \
    \    val k = arr.indexOf(l) + 2\n        val l = arr.indexOf(r) + 2\n        val\
    \ m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n        val k =\
    \ arr.indexOf(l) + 2\n        val l = arr.indexOf(r) + 2\n        val m = arr.indexOf(l)\
    \ + 1\n        val n = arr.indexOf(r) + 1\n        val k = arr.indexOf(l) + 2\n\
    \        val l = arr.indexOf(r) + 2\n        val m = arr.indexOf(l) + 1\n    \
    \    val n = \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpsy5s7tyq.scala:87:15 ---------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = \n\e[31m\e[31m\
    \   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpsy5s7tyq.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.indexOf(r) + \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is\
    \ already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsy5s7tyq.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36ml\e[0m = arr.indexOf(r) + \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpsy5s7tyq.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.indexOf(l) + \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is\
    \ already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsy5s7tyq.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mn\e[0m = arr.indexOf(r) + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpsy5s7tyq.scal"
  stdout: ''
  timestamp: 1659798032
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val s = arr.tail\n        val d = arr.init\n        val r = arr.tail\n\
    \        val l = arr.init\n        val r = arr.init\n        val l = arr.init\n\
    \        val r = arr.init\n        val l = arr.init\n        val r = arr.init\n\
    \        val l = arr.init\n        val r = arr.init\n        val l = arr.init\n\
    \        val r = arr.init\n        val l = arr.init\n        val r = arr.init\n\
    \        val l = arr.init\n        val r = arr.init\n        val l = arr.init\n\
    \        val r = arr.init\n        val l = arr.init\n        val r = arr.init\n\
    \        val l = arr.init\n        val r = arr.init\n        val l = arr.init\n\
    \        val r = arr.init\n        val l = arr.init\n        val r = arr.init\n\
    \        val l = arr.init\n        val r = arr.init\n        val l = arr.init\n\
    \        val r = arr.init\n        val l = arr.init\n        val r = arr.init\n\
    \        val l = arr.init\n        val r = arr.init\n        val l = arr.init\n\
    \        val r = arr.init\n        val l = arr.init\n        val r = arr.init\n\
    \        val l = arr.init\n        val r = arr.init\n        val l = arr.init\n\
    \        val r = arr.init\n        val l = arr.init\n        val r = arr.init\n\
    \        val l = arr.init\n        val r = arr.init\n        val l = arr.init\n\
    \        val r = arr.init\n        val l = arr.init\n        val r = arr.init\n\
    \        val l = arr.init\n        val r = arr.init\n        val l = arr.init\n\
    \        val r = arr.init\n        val l = arr.init\n        val r = arr.init\n\
    \        val l = arr.init\n        val r = arr.init\n        val l = arr.init\n\
    \        val r = arr.init\n        val l = arr.init\n        val r = arr.init\n\
    \        val l = arr.init\n        val r = arr.init\n        val l = arr.init\n\
    \        val r = arr.init\n        val l = arr.init\n        val r = arr.init\n\
    \        val l = arr.init\n        val r = arr.init\n        val l = arr.init\n\
    \        val r = arr.init\n        val l = arr.init\n        val r = arr.init\n\
    \        val l = arr.init\n        val r = arr.init\n        val l = arr.init\n\
    \        val r = arr.init\n        val l = arr.init\n        val r = arr.init\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp3kjtmbg7.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3kjtmbg7.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3kjtmbg7.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3kjtmbg7.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3kjtmbg7.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3kjtmbg7.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659798032
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val arr1 = arr.toArray\n        val arr2\
    \ = arr.toBuffer\n        val arr3 = arr.toSeq\n        val arr4 = arr.toSet\n\
    \        val arr5 = arr.toMap\n        val arr6 = arr.toIterator\n        val\
    \ arr7 = arr.toStream\n        val arr8 = arr.toListBuffer\n        val arr9 =\
    \ arr.toVector\n        val arr10 = arr.toIndexedSeq\n        val arr11 = arr.toIndexedSeq\n\
    \        val arr12 = arr.toArraySeq\n        val arr13 = arr.toArray\n       \
    \ val arr14 = arr.toArray\n        val arr15 = arr.toArray\n        val arr16\
    \ = arr.toArray\n        val arr17 = arr.toArray\n        val arr18 = arr.toArray\n\
    \        val arr19 = arr.toArray\n        val arr20 = arr.toArray\n        val\
    \ arr21 = arr.toArray\n        val arr22 = arr.toArray\n        val arr23 = arr.toArray\n\
    \        val arr24 = arr.toArray\n        val arr25 = arr.toArray\n        val\
    \ arr26 = arr.toArray\n        val arr27 = arr.toArray\n        val arr28 = arr.toArray\n\
    \        val arr29 = arr.toArray\n        val arr30 = arr.toArray\n        val\
    \ arr31 = arr.toArray\n        val arr32 = arr.toArray\n        val arr33 = arr.toArray\n\
    \        val arr34 = arr.toArray\n        val arr35 = arr.toArray\n        val\
    \ arr36 = arr.toArray\n        val arr37 = arr.toArray\n        val arr38 = arr.toArray\n\
    \        val arr39 = arr.toArray\n        val arr40 = arr.toArray\n        val\
    \ arr41 = arr.toArray\n        val arr42 = arr.toArray\n        val arr43 = arr.toArray\n\
    \        val arr44 = arr.toArray\n        val arr45 = arr.toArray\n        val\
    \ arr46 = arr.toArray\n        val arr47 = arr.toArray\n        val arr48 = arr.toArray\n\
    \        val arr49 = arr.toArray\n        val arr50 = arr.toArray\n        val\
    \ arr51 = arr.toArray\n        val arr52 = arr.toArray\n        val arr53 = arr.toArray\n\
    \        val arr54 = arr.toArray\n        val arr55 = arr.toArray\n        val\
    \ arr56 = arr.toArray\n        val arr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_z0vl1hx.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_z0vl1hx.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_z0vl1hx.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798031
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val shifts = mutable.ListBuffer[Long]()\n        val shift = 0\n    \
    \    var i = 0\n        while(i < n) {\n            val j = i + 1\n          \
    \  while(j < n) {\n                val k = j + 1\n                while(k <= n)\
    \ {\n                    val l = k + 1\n                    while(l <= n) {\n\
    \                        val m = l + 1\n                        while(m <= n)\
    \ {\n                            val n = m + 1\n                            while(n\
    \ <= n) {\n                                val o = n + 1\n                   \
    \             while(o <= n) {\n                                    val p = o +\
    \ 1\n                                    while(p <= n) {\n                   \
    \                     val q = p + 1\n                                        while(q\
    \ <= n) {\n                                            val r = q + 1\n       \
    \                                     while(1 <= n) {\n                      \
    \                          shifts += r\n                                     \
    \           shifts += p\n                                                shifts\
    \ += o\n                                                shifts += m\n        \
    \                                        shifts += k\n                       \
    \                         shifts += l\n                                      \
    \          shifts += j\n                                                shifts\
    \ += i\n                                                shifts += n\n        \
    \                                        shifts += m\n                       \
    \                         shifts += k\n                                      \
    \          shifts += j\n                                                shifts\
    \ += i\n                                                shifts += n\n        \
    \                                        shifts += m\n                       \
    \                         shifts += k\n                                      \
    \          shifts += l\n                                                shifts\
    \ += j\n                                                shifts += i\n        \
    \                                        shifts += n\n                       \
    \                         shifts += m\n                                      \
    \          shifts += k\n                                                shifts\
    \ += l\n                                                shifts += j\n        \
    \                                        shifts += i\n                       \
    \                         shifts += n\n                                      \
    \          shifts += m\n                                                shifts\
    \ += k\n                                                shifts += l\n        \
    \                                        shifts += j\n                       \
    \                         shifts += i\n                                      \
    \          shifts += n\n                                                shifts\
    \ += m\n                                                shifts += k\n        \
    \                                        shifts += l\n                       \
    \                         shifts += j\n                                      \
    \          shifts += i\n                                                shifts\
    \ += n\n                                                shifts += m\n        \
    \                                        shifts += k\n                       \
    \                         shifts += l\n                                      \
    \          shifts += j\n                                                shifts\
    \ += i\n                                                shifts += n\n        \
    \                                        shifts += m\n                       \
    \                         shifts += k\n                                      \
    \          shifts += l\n                                                shifts\
    \ += j\n                                                shifts += i\n        \
    \                                        shifts += n\n                       \
    \                         shifts += m\n                                      \
    \          shifts += k\n                                                shifts\
    \ += l\n                                                shifts += j\n        \
    \                                        shifts += i\n                       \
    \                         shifts += n\n                                      \
    \          shifts += m\n                                                shifts\
    \ += k\n                                                shifts += l\n        \
    \                                        shifts += j\n                       \
    \                         shifts += i\n                                      \
    \          shifts += n\n                                                shifts\
    \ += m\n                                                shifts += k\n        \
    \                                        shifts += l\n                       \
    \                         shifts += j\n                                      \
    \          shifts += i\n                                                shifts\
    \ += n\n                                                shifts += m\n        \
    \                                        shifts += k\n                       \
    \                         shifts += l\n                                      \
    \          \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp953bz7bf.scala:133:0 ---------------------------\e\
    [0m\e[0m\n\e[31m133 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp953bz7bf.scala:28:25\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp953bz7bf.scala:29:21 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mshifts\e[0m = mutable.ListBuffer[\e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp953bz7bf.scala:32:8 ---------------------\e[0m\e\
    [0m\n\e[31m 32 |\e[0m        \e[33mwhile\e[0m(i < n) {\n\e[31m\e[31m    |\e[0m\
    \        ^\e[0m\n\e[31m    |\e[0m        Found:    Unit\n\e[31m    |\e[0m    \
    \    Required: Boolean\n\e[31m 33 |\e[0m            \e[33mval\e[0m \e[36mj\e[0m\
    \ = i + \e[31m1\e[0m\n\e[31m 34 |\e[0m            \e[33mwhile\e[0m(j < n) {\n\e\
    [31m 35 |\e[0m                \e[33mval\e[0m \e[36mk\e[0m = j + \e[31m1\e[0m\n\
    \e[31m 36 |\e[0m                \e[33mwhile\e[0m(k <= n) {\n\e[31m 37 |\e[0m \
    \                   \e[33mval\e[0m \e[36ml\e[0m = k + \e[31m1\e[0m\n\e[31m 38\
    \ |\e[0m                    \e[33mwhile\e[0m(l <= n) {\n\e[31m 39 |\e[0m     \
    \                   \e[33mval\e[0m \e[36mm\e[0m = l + \e[31m1\e[0m\n\e[31m 40\
    \ |\e[0m                        \e[33mwhile\e[0m(m <= n) {\n\e[31m 41 |\e[0m \
    \                           \e[33mval\e[0m \e[36mn\e[0m = m + \e[31m1\e[0m\n\e\
    [31m 42 |\e[0m                            \e[33mwhile\e[0m(n <= n) {\n\e[31m 43\
    \ |\e[0m                                \e[33mval\e[0m \e[36mo\e[0m = n + \e[31m1\e\
    [0m\n\e[31m 44 |\e[0m                                \e[33mwhile\e[0m(o <= n)\
    \ {\n\e[31m "
  stdout: ''
  timestamp: 1659798033
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val l = arr.head\n    \
    \        val r = arr.last\n            val m = arr.length\n            val k =\
    \ arr.lastIndex\n            val x = arr.indexOf(l) + 1\n            val y = arr.lastIndexOf(r)\n\
    \            val z = arr.indexOf(r)\n            val w = arr.lastIndexOf(l) +\
    \ 1\n            val a = arr.indexOf(l) + 1\n            val b = arr.lastIndexOf(r)\n\
    \            val c = arr.indexOf(r)\n            val d = arr.lastIndexOf(l) +\
    \ 1\n            val e = arr.indexOf(l) + 1\n            val f = arr.lastIndexOf(r)\n\
    \            val g = arr.indexOf(r)\n            val h = arr.lastIndexOf(l) +\
    \ 1\n            val i = arr.indexOf(l) + 1\n            val j = arr.lastIndexOf(r)\n\
    \            val k = arr.indexOf(r)\n            val l = arr.lastIndexOf(l) +\
    \ 1\n            val m = arr.indexOf(l) + 1\n            val n = arr.lastIndexOf(r)\n\
    \            val o = arr.indexOf(l) + 1\n            val p = arr.lastIndexOf(r)\n\
    \            val q = arr.indexOf(l) + 1\n            val r = arr.lastIndexOf(r)\n\
    \            val s = arr.indexOf(l) + 1\n            val t = arr.lastIndexOf(r)\n\
    \            val u = arr.indexOf(l) + 1\n            val v = arr.lastIndexOf(r)\n\
    \            val w = arr.indexOf(l) + 1\n            val x = arr.indexOf(l) +\
    \ 1\n            val y = arr.lastIndexOf(r)\n            val z = arr.indexOf(r)\n\
    \            val a = arr.indexOf(l) + 1\n            val b = arr.lastIndexOf(r)\n\
    \            val c = arr.indexOf(r)\n            val d = arr.lastIndexOf(l) +\
    \ 1\n            val e = arr.indexOf(l) + 1\n            val f = arr.lastIndexOf(r)\n\
    \            val g = arr.indexOf(r)\n            val h = arr.lastIndexOf(l) +\
    \ 1\n            val i = arr.indexOf(l) + 1\n            val j = arr.lastIndexOf(r)\n\
    \            val k = arr.indexOf(r)\n            val l = arr.lastIndexOf(l) +\
    \ 1\n            val m = arr.indexOf(l) + 1\n            val n = arr.lastIndexOf(r)\n\
    \            val o = arr.indexOf(l) + 1\n            val p = arr.lastIndexOf(r)\n\
    \            val q = arr.indexOf(l) + 1\n            val r = arr.lastIndexOf(r)\n\
    \            val s = arr.indexOf(l) + 1\n            val t = arr.lastIndexOf(r)\n\
    \            val u = arr.indexOf(l) + 1\n            val v = arr.lastIndexOf(r)\n\
    \            val w = arr.indexOf(l) + 1\n            val x = arr.indexOf(l) +\
    \ 1\n            val y = arr.lastIndexOf(r)\n            val z = arr.indexOf(r)\n\
    \            val a = arr.indexOf(l) + 1\n            val b = arr.lastIndexOf(r)\n\
    \            val c = arr.indexOf(r)\n            val d = arr.lastIndexOf\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuq_l507h.scala:103:0 ---------------------------\e\
    [0m\e[0m\n\e[31m103 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuq_l507h.scala:47:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m            \e[33mval\e\
    [0m \e[36mk\e[0m = arr.indexOf(r)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mk is already defined as \e[33mvalue\e[0m \e[35mk\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpuq_l507h.scala:48:16 ---------------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m            \e[33mval\e[0m \e[36ml\e[0m = arr.lastIndexOf(l) + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuq_l507h.scala:49:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m49 |\e[0m            \e[33mval\e\
    [0m \e[36mm\e[0m = arr.indexOf(l) + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined as\
    \ \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpuq_l507h.scala:54:16 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = arr.lastIndexOf(r)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuq_l507h.scala:59:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m59 |\e[0m            \e[33mval\e\
    [0m \e[36mw\e[0m = arr.indexOf(l) + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m      \
    \   "
  stdout: ''
  timestamp: 1659798033
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val max =\
    \ (len - 1).toLong\n        val min = 0l\n        val max1 = (max - min).toLong\n\
    \        val max2 = max - max1\n        val max3 = max - max2\n        val max4\
    \ = max - max3\n        val max5 = max - max4\n        val max6 = max - max5\n\
    \        val max7 = max - max6\n        val max8 = max - max7\n        val max9\
    \ = max - max8\n        val max10 = max - max9\n        val max11 = max - max10\n\
    \        val max12 = max - max11\n        val max13 = max - max12\n        val\
    \ max14 = max - max13\n        val max15 = max - max14\n        val max16 = max\
    \ - max15\n        val max17 = max - max16\n        val max18 = max - max17\n\
    \        val max19 = max - max18\n        val max20 = max - max19\n        val\
    \ max21 = max - max20\n        val max22 = max - max21\n        val max23 = max\
    \ - max22\n        val max24 = max - max23\n        val max25 = max - max24\n\
    \        val max26 = max - max25\n        val max27 = max - max26\n        val\
    \ max28 = max - max27\n        val max29 = max - max28\n        val max30 = max\
    \ - max29\n        val max31 = max - max30\n        val max32 = max - max31\n\
    \        val max33 = max - max32\n        val max34 = max - max33\n        val\
    \ max35 = max - max34\n        val max36 = max - max35\n        val max37 = max\
    \ - max36\n        val max38 = max - max37\n        val max39 = max - max38\n\
    \        val max40 = max - max39\n        val max41 = max - max40\n        val\
    \ max42 = max - max41\n        val max43 = max - max42\n        val max44 = max\
    \ - max43\n        val max45 = max - max44\n        val max46 = max - max45\n\
    \        val max47 = max - max46\n        val max48 = max - max47\n        val\
    \ max49 = max - max48\n        val max50 = max - max49\n        val max51 = max\
    \ - max50\n        val max52 = max - max51\n        val max53 = max - max52\n\
    \        val max54 = max - max53\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpvtp988vq.scala:85:11 ---------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvtp988vq.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpvtp988vq.scala:86:5 ---------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798033
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        if (n == 0) {\n            return true\n        }\n        val m = arr.head\n\
    \        val r = arr.tail\n        val r1 = r.tail\n        val r2 = r1.tail\n\
    \        val r3 = r2.tail\n        val r4 = r3.tail\n        val r5 = r4.tail\n\
    \        val r6 = r5.tail\n        val r7 = r6.tail\n        val r8 = r7.tail\n\
    \        val r9 = r8.tail\n        val r10 = r9.tail\n        val r11 = r10.tail\n\
    \        val r12 = r11.tail\n        val r13 = r12.tail\n        val r14 = r13.tail\n\
    \        val r15 = r14.tail\n        val r16 = r15.tail\n        val r17 = r16.tail\n\
    \        val r18 = r17.tail\n        val r19 = r18.tail\n        val r20 = r19.tail\n\
    \        val r21 = r20.tail\n        val r22 = r21.tail\n        val r23 = r22.tail\n\
    \        val r24 = r23.tail\n        val r25 = r24.tail\n        val r26 = r25.tail\n\
    \        val r27 = r26.tail\n        val r28 = r27.tail\n        val r29 = r28.tail\n\
    \        val r30 = r29.tail\n        val r31 = r30.tail\n        val r32 = r31.tail\n\
    \        val r33 = r32.tail\n        val r34 = r33.tail\n        val r35 = r34.tail\n\
    \        val r36 = r35.tail\n        val r37 = r36.tail\n        val r38 = r37.tail\n\
    \        val r39 = r38.tail\n        val r40 = r39.tail\n        val r41 = r40.tail\n\
    \        val r42 = r41.tail\n        val r43 = r42.tail\n        val r44 = r43.tail\n\
    \        val r45 = r44.tail\n        val r46 = r45.tail\n        val r47 = r46.tail\n\
    \        val r48 = r47.tail\n        val r49 = r48.tail\n        val r50 = r49.tail\n\
    \        val r51 = r50.tail\n        val r52 = r51.tail\n        val r53 = r52.tail\n\
    \        val r54 = r53.tail\n        val r55 = r54.tail\n        val r56 = r55.tail\n\
    \        val r57 = r56.tail\n        val r58 = r57.tail\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpckn2v5fj.scala:91:5\
    \ ---------------------\e[0m\e[0m\n\e[31m91 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798033
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val m = arr.head\n    \
    \        val l = arr.tail\n            val r = arr.drop(1).reverse\n         \
    \   val m = arr.head\n            val l = arr.tail\n            val r = arr.drop(1).reverse\n\
    \            val m = arr.head\n            val l = arr.tail\n            val r\
    \ = arr.drop(1).reverse\n            val m = arr.head\n            val l = arr.tail\n\
    \            val r = arr.drop(1).reverse\n            val m = arr.head\n     \
    \       val l = arr.tail\n            val r = arr.drop(1).reverse\n          \
    \  val m = arr.head\n            val l = arr.tail\n            val r = arr.drop(1).reverse\n\
    \            val m = arr.head\n            val l = arr.tail\n            val r\
    \ = arr.drop(1).reverse\n            val m = arr.head\n            val l = arr.tail\n\
    \            val r = arr.drop(1).reverse\n            val m = arr.head\n     \
    \       val l = arr.tail\n            val r = arr.drop(1).reverse\n          \
    \  val m = arr.head\n            val l = arr.tail\n            val r = arr.drop(1).reverse\n\
    \            val m = arr.head\n            val l = arr.tail\n            val r\
    \ = arr.drop(1).reverse\n            val m = arr.head\n            val l = arr.tail\n\
    \            val r = arr.drop(1).reverse\n            val m = arr.head\n     \
    \       val l = arr.tail\n            val r = arr.drop(1).reverse\n          \
    \  val m = arr.head\n            val l = arr.tail\n            val r = arr.drop(1).reverse\n\
    \            val m = arr.head\n            val l = arr.tail\n            val r\
    \ = arr.drop(1).reverse\n            val m = arr.head\n            val l = arr.tail\n\
    \            val r = arr.drop(1).reverse\n            val m = arr.head\n     \
    \       val l = arr.tail\n            val r = arr.drop(1).reverse\n          \
    \  val m = arr.head\n            val l = arr.tail\n            val r = arr.drop(1).reverse\n\
    \            val m = arr.head\n            val l = arr.tail\n            val r\
    \ = arr.drop(1).reverse\n            val m = arr.head\n            val l = arr.tail\n\
    \            val r = arr.drop(1).reverse\n            val m = arr.head\n     \
    \       val l = arr.tail\n            val r = arr.drop(1).reverse\n          \
    \  val m = arr.head\n            val l = arr.tail\n            val r = arr.drop(1).reverse\n\
    \            val m = arr.head\n            val l = arr.tail\n            val r\
    \ = arr.drop(1).reverse\n            val m = arr.head\n            val l = arr.tail\n\
    \            val r = arr.\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqv3o04n0.scala:101:4 ---------------------------\e\
    [0m\e[0m\n\e[31m101 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpqv3o04n0.scala:111:0 ---------------------------\e[0m\e[0m\n\e[31m111\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqv3o04n0.scala:32:16 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already\
    \ defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqv3o04n0.scala:33:16 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36ml\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already\
    \ defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqv3o04n0.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = arr.drop(\e\
    [31m1\e[0m).reverse\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpqv3o04n0.scala:35:16 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined as \e\
    [33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpqv3o04n0.scala:36:16 -----"
  stdout: ''
  timestamp: 1659798033
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val l = arr.head\n    \
    \        val r = arr.last\n            val m = arr.indexOf(l) + 1\n          \
    \  val n = arr.indexOf(r)\n            val d = n - m\n            if (d > 0) moveOneBall(arr.drop(d\
    \ + 1))\n            else moveOneBall(arr.take(d).reverse)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmxlod6h7.scala:41)\n\tat Problem.main(tmpmxlod6h7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798034
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        \n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprpag83zj.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprpag83zj.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprpag83zj.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmprpag83zj.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprpag83zj.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprpag83zj.scala:"
  stdout: ''
  timestamp: 1659798032
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val result = new Array[Boolean](n + 1)\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n\
    \        var temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n       \
    \ var temp5 = 0\n        var temp6 = 0\n        var temp7 = 0\n        var temp8\
    \ = 0\n        var temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n\
    \        var temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n    \
    \    var temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n        var\
    \ temp18 = 0\n        var temp19 = 0\n        var temp20 = 0\n        var temp21\
    \ = 0\n        var temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n\
    \        var temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n    \
    \    var temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n        var\
    \ temp31 = 0\n        var temp32 = 0\n        var temp33 = 0\n        var temp34\
    \ = 0\n        var temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n\
    \        var temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n    \
    \    var temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n        var\
    \ temp44 = 0\n        var temp45 = 0\n        var temp46 = 0\n        var temp47\
    \ = 0\n        var temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n\
    \        var temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n    \
    \    var temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n        var\
    \ temp57 = 0\n        var temp58 = 0\n        var temp59 = 0\n        var temp60\
    \ = 0\n        var temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n\
    \        var temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n    \
    \    var temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n        var\
    \ temp70 = 0\n        var temp71 = 0\n        var temp72 = 0\n        var temp73\
    \ = 0\n        var temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n\
    \        var temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n    \
    \    var temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n        var\
    \ temp83 = 0\n        var temp84 = 0\n        var temp85 = 0\n        var temp86\
    \ = 0\n        var temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n\
    \        var temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n    \
    \    var temp93 = 0\n        var temp94 = 0\n        var temp95 = 0\n        var\
    \ temp96\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoacqwdij.scala:128:4 ---------------------------\e\
    [0m\e[0m\n\e[31m128 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoacqwdij.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoacqwdij.scala:128:5\
    \ --------------------\e[0m\e[0m\n\e[31m128 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798033
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val first = arr(0)\n  \
    \          val last = arr(n)\n            val mid = first + last/2\n         \
    \   val left = arr.drop(1)\n            val right = arr.dropRight(1)\n       \
    \     val leftSorted = left.sortWith(_ < _)\n            val rightSorted = right.sortWith(_\
    \ < _)\n            val leftSortedWithMid = leftSorted.take(mid)\n           \
    \ val rightSortedWithMid = rightSorted.take(mid)\n            val leftSortedWithMidSorted\
    \ = leftSortedWithMid.sortWith(_ < _)\n            val rightSortedWithMidSorted\
    \ = rightSortedWithMid.sortWith(_ < _)\n            if (leftSortedWithMidSorted.equals(rightSortedWithMidSorted))\
    \ {\n                moveOneBall(leftSortedWithMidSorted)\n            } else\
    \ {\n                moveOneBall(leftSortedWithMidSorted) || moveOneBall(rightSortedWithMidSorted)\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpesbivunv.scala:36:52\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e\
    [36mleftSortedWithMid\e[0m = leftSorted.take(mid)\n\e[31m\e[31m   |\e[0m     \
    \                                               ^^^\e[0m\n\e[31m   |\e[0m    \
    \                                              Found:    (mid : Long)\n\e[31m\
    \   |\e[0m                                                  Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpesbivunv.scala:37:54\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e[0m \e\
    [36mrightSortedWithMid\e[0m = rightSorted.take(mid)\n\e[31m\e[31m   |\e[0m   \
    \                                                   ^^^\e[0m\n\e[31m   |\e[0m\
    \                                                  Found:    (mid : Long)\n\e\
    [31m   |\e[0m                                                  Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798035
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val s = arr.tail\n        val d = arr.drop(n-1)\n\
    \        val r = arr.take(n-1)\n        val x = arr.take(n)\n        val y = arr.drop(n-1)\n\
    \        val z = arr.drop(n)\n        val a = arr.take(n-1)\n        val b = arr.drop(n-1)\n\
    \        val c = arr.drop(n)\n        val d = arr.take(n)\n        val e = arr.drop(n-1)\n\
    \        val f = arr.drop(n)\n        val g = arr.take(n)\n        val h = arr.drop(n-1)\n\
    \        val i = arr.drop(n)\n        val j = arr.take(n)\n        val k = arr.drop(n-1)\n\
    \        val l = arr.drop(n)\n        val m = arr.take(n)\n        val n = arr.drop(n-1)\n\
    \        val o = arr.drop(n)\n        val p = arr.take(n)\n        val q = arr.drop(n-1)\n\
    \        val r = arr.drop(n)\n        val s = arr.take(n)\n        val t = arr.drop(n-1)\n\
    \        val u = arr.drop(n)\n        val v = arr.take(n)\n        val w = arr.drop(n-1)\n\
    \        val x = arr.drop(n)\n        val y = arr.take(n)\n        val z = arr.drop(n-1)\n\
    \        val a = arr.drop(n-1)\n        val b = arr.drop(n)\n        val c = arr.drop(n)\n\
    \        val d = arr.take(n)\n        val e = arr.drop(n-1)\n        val f = arr.drop(n)\n\
    \        val g = arr.take(n)\n        val h = arr.drop(n-1)\n        val i = arr.drop(n)\n\
    \        val j = arr.take(n)\n        val k = arr.drop(n-1)\n        val l = arr.drop(n)\n\
    \        val m = arr.take(n)\n        val n = arr.drop(n-1)\n        val o = arr.drop(n)\n\
    \        val p = arr.take(n)\n        val q = arr.drop(n-1)\n        val r = arr.drop(n)\n\
    \        val s = arr.take(n)\n        val t = arr.drop(n-1)\n        val u = arr.drop(n)\n\
    \        val v = arr.take(n)\n        val w = arr.drop(n-1)\n        val x = arr.drop(n)\n\
    \        val y = arr.take(n)\n        val z = arr.drop(n-1)\n        val a = arr.drop(n-1)\n\
    \        val b = arr.drop(n)\n        val c = arr.drop(n)\n        val d = arr.take(n)\n\
    \        val e = arr.drop(n-1)\n        val f = arr.drop(n)\n        val g = arr.take(n)\n\
    \        val h = arr.drop(n-1)\n        val i = arr.drop(n)\n        val j = arr.take(n)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1876hwh9.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = arr.take(n)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already\
    \ defined as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1876hwh9.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(n)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already\
    \ defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1876hwh9.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.drop(n-\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn\
    \ is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1876hwh9.scala:51:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = arr.drop(n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp1876hwh9.scala:52:12 ---------------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = arr.take(n)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined as \e\
    [33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1876hwh9.scala:57:12 ---------------------------"
  stdout: ''
  timestamp: 1659798034
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val m = arr.head\n    \
    \        val r = arr.tail\n            val l = r.head\n            val r = r.tail\n\
    \            val m = m >> 1\n            val r = r >> 1\n            val l = l\
    \ >> 1\n            val r = r >> 1\n            val l = l >> 1\n            val\
    \ r = r >> 1\n            val l = l >> 1\n            val r = r >> 1\n       \
    \     val l = l >> 1\n            val r = r >> 1\n            val l = l >> 1\n\
    \            val r = r >> 1\n            val l = l >> 1\n            val r = r\
    \ >> 1\n            val l = l >> 1\n            val r = r >> 1\n            val\
    \ l = l >> 1\n            val r = r >> 1\n            val l = l >> 1\n       \
    \     val r = r >> 1\n            val l = l >> 1\n            val r = r >> 1\n\
    \            val l = l >> 1\n            val r = r >> 1\n            val l = l\
    \ >> 1\n            val r = r >> 1\n            val l = l >> 1\n            val\
    \ r = r >> 1\n            val l = l >> 1\n            val r = r >> 1\n       \
    \     val l = l >> 1\n            val r = r >> 1\n            val l = l >> 1\n\
    \            val r = r >> 1\n            val l = l >> 1\n            val r = r\
    \ >> 1\n            val l = l >> 1\n            val r = r >> 1\n            val\
    \ l = l >> 1\n            val r = r >> 1\n            val l = l >> 1\n       \
    \     val r = r >> 1\n            val l = l >> 1\n            val r = r >> 1\n\
    \            val l = l >> 1\n            val r = r >> 1\n            val l = l\
    \ >> 1\n            val r = r >> 1\n            val l = l >> 1\n            val\
    \ r = r >> 1\n            val l = l >> 1\n            val r = r >> 1\n       \
    \     val l = l >> 1\n            val r = r >> 1\n            val l = l >> 1\n\
    \            val r = r >> 1\n            val l = l >> 1\n            val r = r\
    \ >> 1\n            val l = l >> 1\n            val r = r >> 1\n            val\
    \ l = l >> 1\n            val r = r >> 1\n            val l = l >> 1\n       \
    \     val r = r >> 1\n            val l = l >> 1\n            val r = r >> 1\n\
    \            val l = l >> 1\n            val r = r >> 1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8j47q5ev.scala:111:0 ---------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8j47q5ev.scala:32:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mr\e[0m = r.tail\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8j47q5ev.scala:33:16 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = m >> \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8j47q5ev.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r >> \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is\
    \ already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8j47q5ev.scala:35:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e\
    [0m \e[36ml\e[0m = l >> \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8j47q5ev.scala:36:16 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r >> \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n"
  stdout: ''
  timestamp: 1659798037
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr1 = arr.toList\n\
    \        val arr2 = arr1.reverse\n        val arr3 = arr2.reverse\n        val\
    \ arr4 = arr3.reverse\n        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n\
    \        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val\
    \ arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n\
    \        val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n      \
    \  val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16\
    \ = arr15.reverse\n        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n\
    \        val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n      \
    \  val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23\
    \ = arr22.reverse\n        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n\
    \        val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n      \
    \  val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30\
    \ = arr29.reverse\n        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n\
    \        val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n      \
    \  val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37\
    \ = arr36.reverse\n        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n\
    \        val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n      \
    \  val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44\
    \ = arr43.reverse\n        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n\
    \        val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n      \
    \  val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51\
    \ = arr50.reverse\n        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n\
    \        val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n      \
    \  val arr5\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph5mcw5ze.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmph5mcw5ze.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph5mcw5ze.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr1 = arr.toList\n\
    \        val arr2 = arr1.reverse\n        val arr3 = arr2.reverse\n        val\
    \ arr4 = arr3.reverse\n        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n\
    \        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val\
    \ arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n\
    \        val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n      \
    \  val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16\
    \ = arr15.reverse\n        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n\
    \        val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n      \
    \  val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23\
    \ = arr22.reverse\n        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n\
    \        val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n      \
    \  val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30\
    \ = arr29.reverse\n        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n\
    \        val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n      \
    \  val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37\
    \ = arr36.reverse\n        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n\
    \        val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n      \
    \  val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44\
    \ = arr43.reverse\n        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n\
    \        val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n      \
    \  val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51\
    \ = arr50.reverse\n        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n\
    \        val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n      \
    \  val arr5\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvoj3cpdn.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvoj3cpdn.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvoj3cpdn.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798009
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr1 = arr.tail\n        val arr2 = arr1.tail\n\
    \        val arr3 = arr2.tail\n        val arr4 = arr3.tail\n        val arr5\
    \ = arr4.tail\n        val arr6 = arr5.tail\n        val arr7 = arr6.tail\n  \
    \      val arr8 = arr7.tail\n        val arr9 = arr8.tail\n        val arr10 =\
    \ arr9.tail\n        val arr11 = arr10.tail\n        val arr12 = arr11.tail\n\
    \        val arr13 = arr12.tail\n        val arr14 = arr13.tail\n        val arr15\
    \ = arr14.tail\n        val arr16 = arr15.tail\n        val arr17 = arr16.tail\n\
    \        val arr18 = arr17.tail\n        val arr19 = arr18.tail\n        val arr20\
    \ = arr19.tail\n        val arr21 = arr20.tail\n        val arr22 = arr21.tail\n\
    \        val arr23 = arr22.tail\n        val arr24 = arr23.tail\n        val arr25\
    \ = arr24.tail\n        val arr26 = arr25.tail\n        val arr27 = arr26.tail\n\
    \        val arr28 = arr27.tail\n        val arr29 = arr28.tail\n        val arr30\
    \ = arr29.tail\n        val arr31 = arr30.tail\n        val arr32 = arr31.tail\n\
    \        val arr33 = arr32.tail\n        val arr34 = arr33.tail\n        val arr35\
    \ = arr34.tail\n        val arr36 = arr35.tail\n        val arr37 = arr36.tail\n\
    \        val arr38 = arr37.tail\n        val arr39 = arr38.tail\n        val arr40\
    \ = arr39.tail\n        val arr41 = arr40.tail\n        val arr42 = arr41.tail\n\
    \        val arr43 = arr42.tail\n        val arr44 = arr43.tail\n        val arr45\
    \ = arr44.tail\n        val arr46 = arr45.tail\n        val arr47 = arr46.tail\n\
    \        val arr48 = arr47.tail\n        val arr49 = arr48.tail\n        val arr50\
    \ = arr49.tail\n        val arr51 = arr50.tail\n        val arr52 = arr51.tail\n\
    \        val arr53 = arr52.tail\n        val arr54 = arr53.tail\n        val arr55\
    \ = arr54.tail\n        val arr56 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqewu6btc.scala:83:19 ---------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m        \e[33mval\e[0m \e[36marr56\e[0m = \n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqewu6btc.scala:84:5 ---------------------\e[0m\e[0m\n\e[31m84\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798037
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        else {\n            val newArr = arr.tail\n            val newArrLength\
    \ = newArr.length\n            val newArrHead = newArr.head\n            val newArrTail\
    \ = newArr.tail\n            val newArrTailLength = newArrTail.length\n      \
    \      val newArrHeadLength = newArrHead.length\n            val newArrTailLength\
    \ = newArrTailLength\n            val newArrHeadHead = newArrHead.head\n     \
    \       val newArrTailHead = newArrTailHead\n            val newArrTailTail =\
    \ newArrTail.tail\n            val newArrTailTailLength = newArrTailTail.length\n\
    \            val newArrHeadTailLength = newArrHeadTail.length\n            val\
    \ newArrTailHeadLength = newArrTailHeadLength\n            val newArrTailTailHead\
    \ = newArrTailTailHead\n            val newArrTailTailTail = newArrTailTailTail\n\
    \            val newArrTailTailTailLength = newArrTailTailTail.length\n      \
    \      val newArrHeadTailTailLength = newArrHeadTailTail.length\n            val\
    \ newArrTailHeadTailLength = newArrTailHeadTailLength\n            val newArrTailTailHeadTail\
    \ = newArrTailTailHeadTail\n            val newArrTailTailTailHeadTail = newArrTailTailTailHeadTail\n\
    \            val newArrTailTailTailTailHeadTail = newArrTailTailTailTailHeadTail\n\
    \            val newArrTailTailTailTailTailHeadTail = newArrTailTailTailTailTailHeadTail\n\
    \            val newArrTailTailTailTailTailTailHeadTail = newArrTailTailTailTailTailHeadTail\n\
    \            val newArrTailTailTailTailTailTailHeadTail = newArrTailTailTailTailTailTailHeadTail\n\
    \            val newArrTailTailTailTailTailTailHeadTail = newArrTailTailTailTailTailTailHeadTail\n\
    \            val newArrTailTailTailTailTailTailHeadTail = newArrTailTailTailTailTailTailTailHeadTail\n\
    \            val newArrTailTailTailTailTailTailTailHeadTail = newArrTailTailTailTailTailTailTailHeadTail\n\
    \            val newArrTailTailTailTailTailTailTailHeadTail = newArrTailTailTailTailTailTailTailHeadTail\n\
    \            val newArrTailTailTailTailTailTailTailHeadTail = newArrTailTailTailTailTailTailTailHeadTail\n\
    \            val newArrTailTailTailTailTailTailTailTailHeadTail = newArrTailTailTailTailTailTailTailTailHeadTail\n\
    \            val newArrTailTailTailTailTailTailTailTailHeadTail = newArrTailTailTailTailTailTail\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7udoapjt.scala:69:0 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7udoapjt.scala:34:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e\
    [0m \e[36mnewArrTailLength\e[0m = newArrTailLength\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnewArrTailLength\
    \ is already defined as \e[33mvalue\e[0m \e[35mnewArrTailLength\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp7udoapjt.scala:51:16 ---------------------------\e[0m\e[0m\n\e[31m51\
    \ |\e[0m            \e[33mval\e[0m \e[36mnewArrTailTailTailTailTailTailHeadTail\e\
    [0m = newArrTailTailTailTailTailTailHeadTail\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewArrTailTailTailTailTailTailHeadTail is already defined\
    \ as \e[33mvalue\e[0m \e[35mnewArrTailTailTailTailTailTailHeadTail\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp7udoapjt.scala:52:16 ---------------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m            \e[33mval\e[0m \e[36mnewArrTailTailTailTailTailTailHeadTail\e\
    [0m = newArrTailTailTailTailTailTailHeadTail\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewArrTailTailTailTailTailTailHeadTail is already defined\
    \ as \e[33mvalue\e[0m \e[35mnewArrTailTailTailTailTailTailHeadTail\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp7udoapjt.scala:53:16 ---------------------------\e[0m\e[0m\n\e[31m53\
    \ |\e[0m            \e[33mval\e[0m \e[36mnewArrTailTailTailTailTailTailHeadTail\e\
    [0m = newArrTailTailTail"
  stdout: ''
  timestamp: 1659798038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val r = new Array[Long](n + 1)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n        while(i\
    \ < n) {\n            while(j < n) {\n                if(arr(i) < arr(j)) {\n\
    \                    temp = r(k)\n                    r(k) = arr(j)\n        \
    \            arr(j) = temp\n                    j++\n                } else {\n\
    \                    temp = r(k)\n                    r(k) = arr(j)\n        \
    \            arr(j) = temp\n                    j++\n                }\n     \
    \           k++\n            }\n            i = i + 1\n            j = 0\n   \
    \         k = 0\n        }\n        if(arr.length == 1) {\n            return\
    \ true\n        }\n        while(j < n) {\n            temp = r(k)\n         \
    \   r(k) = arr(j)\n            arr(j) = temp\n            j++\n            k++\n\
    \        }\n        while(i < n) {\n            temp = r(k)\n            r(k)\
    \ = arr(j)\n            arr(j) = temp\n            j++\n            k++\n    \
    \    }\n        while(j < n) {\n            temp = r(k)\n            r(k) = arr(j)\n\
    \            arr(j) = temp\n            j++\n            k++\n        }\n    \
    \    while(i < n) {\n            temp = r(k)\n            r(k) = arr(j)\n    \
    \        arr(j) = temp\n            j++\n            k++\n        }\n        while(j\
    \ < n) {\n            temp = r(k)\n            r(k) = arr(j)\n            arr(j)\
    \ = temp\n            j++\n            k++\n        }\n        while(i < n) {\n\
    \            temp = r(k)\n            r(k) = arr(j)\n            arr(j) = temp\n\
    \            j++\n            k++\n        }\n        while(j < n) {\n       \
    \     temp = r(k)\n            r(k) = arr(j)\n            arr(j) = temp\n    \
    \        j++\n            k++\n        }\n        while(i < n) {\n           \
    \ temp = r(k)\n            r(k) = arr(j)\n            arr(j) = temp\n        \
    \    j++\n            k++\n        }\n        while(j < n) {\n            temp\
    \ = r(k)\n            r(k) = arr(j)\n            arr(j) = temp\n            j++\n\
    \            k++\n        }\n        while(i < n) {\n            temp = r(k)\n\
    \            r(k) = arr(j)\n            arr(j) = temp\n            j++\n     \
    \       k++\n        }\n        while(j < n) {\n            temp = r(k)\n    \
    \        r(k) = arr(j)\n            arr(j) = temp\n            j++\n         \
    \   k++\n        }\n        while(i < n) {\n            temp = r(k)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpcgtatszu.scala:39:23 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpcgtatszu.scala:44:23 ---------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpcgtatszu.scala:46:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m                k++\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E018] Syntax Error: /tmp/tmpcgtatszu.scala:60:15 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m            k++\n\e[31m\e[31m   |\e[0m              \
    \ ^\e[0m\n\e[31m   |\e[0m               expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpcgtatszu.scala:67:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m67 |\e[0m            k++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpcgtatszu.scala:74:15 ---------------------------\e[0m\e[0m\n\e[31m74\
    \ |\e[0m            k++\n\e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m  \
    \ |\e[0m               expression expected but \e[31m'}'\e[0m found\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E018] Syntax Error"
  stdout: ''
  timestamp: 1659798045
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val mid = n / 2\n     \
    \       val left = arr.take(mid)\n            val right = arr.drop(mid)\n    \
    \        val leftSorted = left.sorted\n            val rightSorted = right.sorted\n\
    \            if (leftSorted.last < rightSorted.head) moveOneBall(leftSorted)\n\
    \            else moveOneBall(rightSorted)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: last of empty list\n\tat scala.collection.immutable.Nil$.last(List.scala:665)\n\
    \tat scala.collection.immutable.Nil$.last(List.scala:661)\n\tat Problem$.moveOneBall(tmpcari1c5l.scala:34)\n\
    \tat Problem$.main(tmpcari1c5l.scala:39)\n\tat Problem.main(tmpcari1c5l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798043
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val r = new Array[Long](n)\n        val x =\
    \ new Array[Long](n)\n        val y = new Array[Long](n)\n        val z = new\
    \ Array[Long](n)\n        val w = new Array[Long](n)\n        val v = new Array[Long](n)\n\
    \        val u = new Array[Long](n)\n        val t = new Array[Long](n)\n    \
    \    val s = new Array[Long](n)\n        val r = new Array[Long](n)\n        val\
    \ x = new Array[Long](n)\n        val y = new Array[Long](n)\n        val z =\
    \ new Array[Long](n)\n        val w = new Array[Long](n)\n        val v = new\
    \ Array[Long](n)\n        val u = new Array[Long](n)\n        val t = new Array[Long](n)\n\
    \        val s = new Array[Long](n)\n        val r = new Array[Long](n)\n    \
    \    val x = new Array[Long](n)\n        val y = new Array[Long](n)\n        val\
    \ z = new Array[Long](n)\n        val w = new Array[Long](n)\n        val v =\
    \ new Array[Long](n)\n        val u = new Array[Long](n)\n        val t = new\
    \ Array[Long](n)\n        val s = new Array[Long](n)\n        val r = new Array[Long](n)\n\
    \        val x = new Array[Long](n)\n        val y = new Array[Long](n)\n    \
    \    val z = new Array[Long](n)\n        val w = new Array[Long](n)\n        val\
    \ v = new Array[Long](n)\n        val u = new Array[Long](n)\n        val t =\
    \ new Array[Long](n)\n        val s = new Array[Long](n)\n        val r = new\
    \ Array[Long](n)\n        val x = new Array[Long](n)\n        val y = new Array[Long](n)\n\
    \        val z = new Array[Long](n)\n        val w = new Array[Long](n)\n    \
    \    val v = new Array[Long](n)\n        val u = new Array[Long](n)\n        val\
    \ t = new Array[Long](n)\n        val s = new Array[Long](n)\n        val r =\
    \ new Array[Long](n)\n        val x = new Array[Long](n)\n        val y = new\
    \ Array[Long](n)\n        val z = new Array[Long](n)\n        val w = new Array[Long](n)\n\
    \        val v = new Array\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp44wb_lh5.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp44wb_lh5.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mx\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mx is already defined as \e[33mvalue\e[0m \e[35mx\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp44wb_lh5.scala:39:12 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36my\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0my is already defined as \e[33mvalue\e[0m \e[35my\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp44wb_lh5.scala:40:12 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m        \e[33mval\e[0m \e[36mz\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mz is already defined as \e[33mvalue\e[0m \e[35mz\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp44wb_lh5.scala:41:12 ---------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m        \e[33mval\e[0m \e[36mw\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mw is already defined as \e[33mvalue\e[0m \e[35mw\e[0m\n\e[31m \
    \  |\e[0m\n\e["
  stdout: ''
  timestamp: 1659798041
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.last\n        val l = arr.head\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val m = arr.last\n        val l = arr.last\n        val r = arr.last\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpy0b3qmld.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy0b3qmld.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy0b3qmld.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy0b3qmld.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy0b3qmld.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy0b3qmld.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659798041
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val left = new mutable.ListBuffer[Long]()\n        val right = new mutable.ListBuffer[Long]()\n\
    \        val temp = new mutable.ListBuffer[Long]()\n        val temp2 = new mutable.ListBuffer[Long]()\n\
    \        val temp3 = new mutable.ListBuffer[Long]()\n        val temp4 = new mutable.ListBuffer[Long]()\n\
    \        val temp5 = new mutable.ListBuffer[Long]()\n        val temp6 = new mutable.ListBuffer[Long]()\n\
    \        val temp7 = new mutable.ListBuffer[Long]()\n        val temp8 = new mutable.ListBuffer[Long]()\n\
    \        val temp9 = new mutable.ListBuffer[Long]()\n        val temp10 = new\
    \ mutable.ListBuffer[Long]()\n        val temp11 = new mutable.ListBuffer[Long]()\n\
    \        val temp12 = new mutable.ListBuffer[Long]()\n        val temp13 = new\
    \ mutable.ListBuffer[Long]()\n        val temp14 = new mutable.ListBuffer[Long]()\n\
    \        val temp15 = new mutable.ListBuffer[Long]()\n        val temp16 = new\
    \ mutable.ListBuffer[Long]()\n        val temp17 = new mutable.ListBuffer[Long]()\n\
    \        val temp18 = new mutable.ListBuffer[Long]()\n        val temp19 = new\
    \ mutable.ListBuffer[Long]()\n        val temp20 = new mutable.ListBuffer[Long]()\n\
    \        val temp21 = new mutable.ListBuffer[Long]()\n        val temp22 = new\
    \ mutable.ListBuffer[Long]()\n        val temp23 = new mutable.ListBuffer[Long]()\n\
    \        val temp24 = new mutable.ListBuffer[Long]()\n        val temp25 = new\
    \ mutable.ListBuffer[Long]()\n        val temp26 = new mutable.ListBuffer[Long]()\n\
    \        val temp27 = new mutable.ListBuffer[Long]()\n        val temp28 = new\
    \ mutable.ListBuffer[Long]()\n        val temp29 = new mutable.ListBuffer[Long]()\n\
    \        val temp30 = new mutable.ListBuffer[Long]()\n        val temp31 = new\
    \ mutable.ListBuffer[Long]()\n        val temp32 = new mutable.ListBuffer[Long]()\n\
    \        val temp33 = new mutable.ListBuffer[Long]\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprd4kq0ui.scala:28:25 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprd4kq0ui.scala:29:23\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mleft\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmprd4kq0ui.scala:30:24 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mright\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmprd4kq0ui.scala:31:23 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mtemp\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprd4kq0ui.scala:32:24\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e\
    [36mtemp2\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmprd4kq0ui.scala:33:24 "
  stdout: ''
  timestamp: 1659798043
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val m = arr.last\n        val arr1 = arr.dropRight(1)\n\
    \        val arr2 = arr.dropRight(2)\n        val arr3 = arr.dropRight(3)\n  \
    \      val arr4 = arr.dropRight(4)\n        val arr5 = arr.dropRight(5)\n    \
    \    val arr6 = arr.dropRight(6)\n        val arr7 = arr.dropRight(7)\n      \
    \  val arr8 = arr.dropRight(8)\n        val arr9 = arr.dropRight(9)\n        val\
    \ arr10 = arr.dropRight(10)\n        val arr11 = arr.dropRight(11)\n        val\
    \ arr12 = arr.dropRight(12)\n        val arr13 = arr.dropRight(13)\n        val\
    \ arr14 = arr.dropRight(14)\n        val arr15 = arr.dropRight(15)\n        val\
    \ arr16 = arr.dropRight(16)\n        val arr17 = arr.dropRight(17)\n        val\
    \ arr18 = arr.dropRight(18)\n        val arr19 = arr.dropRight(19)\n        val\
    \ arr20 = arr.dropRight(20)\n        val arr21 = arr.dropRight(21)\n        val\
    \ arr22 = arr.dropRight(22)\n        val arr23 = arr.dropRight(23)\n        val\
    \ arr24 = arr.dropRight(24)\n        val arr25 = arr.dropRight(25)\n        val\
    \ arr26 = arr.dropRight(26)\n        val arr27 = arr.dropRight(27)\n        val\
    \ arr28 = arr.dropRight(28)\n        val arr29 = arr.dropRight(29)\n        val\
    \ arr30 = arr.dropRight(30)\n        val arr31 = arr.dropRight(31)\n        val\
    \ arr32 = arr.dropRight(32)\n        val arr33 = arr.dropRight(33)\n        val\
    \ arr34 = arr.dropRight(34)\n        val arr35 = arr.dropRight(35)\n        val\
    \ arr36 = arr.dropRight(36)\n        val arr37 = arr.dropRight(37)\n        val\
    \ arr38 = arr.dropRight(38)\n        val arr39 = arr.dropRight(39)\n        val\
    \ arr40 = arr.dropRight(40)\n        val arr41 = arr.dropRight(41)\n        val\
    \ arr42 = arr.dropRight(42)\n        val arr43 = arr.dropRight(43)\n        val\
    \ arr44 = arr.dropRight(44)\n        val arr45 = arr.dropRight(45)\n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdkvx46v5.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpdkvx46v5.scala:75:5 ---------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798043
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val r = arr.last\n        val s = arr.init\n\
    \        val t = arr.tail\n        val u = arr.init\n        val v = arr.tail\n\
    \        val w = arr.init\n        val x = arr.tail\n        val y = arr.init\n\
    \        val z = arr.tail\n        val a = arr.init\n        val b = arr.tail\n\
    \        val c = arr.init\n        val d = arr.tail\n        val e = arr.init\n\
    \        val f = arr.tail\n        val g = arr.init\n        val h = arr.tail\n\
    \        val i = arr.init\n        val j = arr.tail\n        val k = arr.init\n\
    \        val l = arr.tail\n        val m = arr.init\n        val n = arr.tail\n\
    \        val o = arr.init\n        val p = arr.tail\n        val q = arr.init\n\
    \        val r = arr.tail\n        val s = arr.init\n        val t = arr.tail\n\
    \        val u = arr.init\n        val v = arr.tail\n        val w = arr.init\n\
    \        val x = arr.tail\n        val y = arr.init\n        val z = arr.tail\n\
    \        val a = arr.init\n        val b = arr.tail\n        val c = arr.init\n\
    \        val d = arr.tail\n        val e = arr.init\n        val f = arr.tail\n\
    \        val g = arr.init\n        val h = arr.tail\n        val i = arr.init\n\
    \        val j = arr.tail\n        val k = arr.init\n        val l = arr.tail\n\
    \        val m = arr.init\n        val n = arr.tail\n        val o = arr.init\n\
    \        val p = arr.tail\n        val q = arr.init\n        val r = arr.tail\n\
    \        val s = arr.init\n        val t = arr.tail\n        val u = arr.init\n\
    \        val v = arr.tail\n        val w = arr.init\n        val x = arr.tail\n\
    \        val y = arr.init\n        val z = arr.tail\n        val a = arr.init\n\
    \        val b = arr.tail\n        val c = arr.init\n        val d = arr.tail\n\
    \        val e = arr.init\n        val f = arr.tail\n        val g = arr.init\n\
    \        val h = arr.tail\n        val i = arr.init\n        val j = arr.tail\n\
    \        val k = arr.init\n        val l = arr.tail\n        val m = arr.init\n\
    \        val n = arr.tail\n        val o = arr.init\n        val p = arr.tail\n\
    \        val q = arr.init\n        val r = arr.tail\n        val s = arr.init\n\
    \        val t = arr.tail\n        val u = arr.init\n        val v = arr.tail\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpqili2xi_.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqili2xi_.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqili2xi_.scala:50:12 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqili2xi_.scala:54:12 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqili2xi_.scala:55:12 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqili2xi_.scala:56:12 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m        \e[33mval\e[0m \e[36mt\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659798043
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val r = new Array[Long](n + 1)\n        val\
    \ l = new Array[Long](n + 1)\n        val d = new Array[Long](n + 1)\n       \
    \ val h = new Array[Long](n + 1)\n        val v = new Array[Long](n + 1)\n   \
    \     val w = new Array[Long](n + 1)\n        val x = new Array[Long](n + 1)\n\
    \        val y = new Array[Long](n + 1)\n        val z = new Array[Long](n + 1)\n\
    \        val a = new Array[Long](n + 1)\n        val b = new Array[Long](n + 1)\n\
    \        val c = new Array[Long](n + 1)\n        val d = new Array[Long](n + 1)\n\
    \        val e = new Array[Long](n + 1)\n        val f = new Array[Long](n + 1)\n\
    \        val g = new Array[Long](n + 1)\n        val h = new Array[Long](n + 1)\n\
    \        val i = new Array[Long](n + 1)\n        val j = new Array[Long](n + 1)\n\
    \        val k = new Array[Long](n + 1)\n        val l = new Array[Long](n + 1)\n\
    \        val m = new Array[Long](n + 1)\n        val n = new Array[Long](n + 1)\n\
    \        val o = new Array[Long](n + 1)\n        val p = new Array[Long](n + 1)\n\
    \        val q = new Array[Long](n + 1)\n        val r = new Array[Long](n + 1)\n\
    \        val s = new Array[Long](n + 1)\n        val t = new Array[Long](n + 1)\n\
    \        val u = new Array[Long](n + 1)\n        val v = new Array[Long](n + 1)\n\
    \        val w = new Array[Long](n + 1)\n        val x = new Array[Long](n + 1)\n\
    \        val y = new Array[Long](n + 1)\n        val z = new Array[Long](n + 1)\n\
    \        val a = new Array[Long](n + 1)\n        val b = new Array[Long](n + 1)\n\
    \        val c = new Array[Long](n + 1)\n        val d = new Array[Long](n + 1)\n\
    \        val e = new Array[Long](n + 1)\n        val f = new Array[Long](n + 1)\n\
    \        val g = new Array[Long](n + 1)\n        val h = new Array[Long](n + 1)\n\
    \        val i = new Array[Long](n + 1)\n        val j = new Array[Long](n + 1)\n\
    \        val k = new Array[\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp376i8vo.scala:74:4 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpp376i8vo.scala:40:12 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m        \e[33mval\e[0m \e[36md\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0md is already defined as \e[33mvalue\e[0m \e[35md\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpp376i8vo.scala:44:12 ---------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m        \e[33mval\e[0m \e[36mh\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mh is already defined as \e[33mvalue\e[0m \e[35mh\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpp376i8vo.scala:48:12 ---------------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpp376i8vo.scala:49:12 ---------------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpp376i8vo.scala:50"
  stdout: ''
  timestamp: 1659798043
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val first = arr.head\n\
    \            val last = arr.last\n            val mid = arr.size / 2\n       \
    \     val left = arr.take(mid)\n            val right = arr.drop(mid)\n      \
    \      val leftSorted = left.sortWith(_ < _)\n            val rightSorted = right.sortWith(_\
    \ < _)\n            val leftSortedRight = leftSorted.reverse\n            val\
    \ rightSortedRight = rightSorted.reverse\n            val leftSortedRightRight\
    \ = leftSortedRight.reverse\n            val rightSortedRightRight = rightSortedRight.reverse\n\
    \            val leftSortedRightLeftRight = leftSortedRight.reverse.sortWith(_\
    \ < _)\n            val rightSortedRightLeftRight = rightSortedRight.reverse.sortWith(_\
    \ < _)\n            val leftSortedRightLeftLeft = leftSortedRight.reverse.sortWith(_\
    \ < _)\n            val rightSortedRightLeftLeft = rightSortedRight.reverse.sortWith(_\
    \ < _)\n            val leftSortedRightLeftRightLeft = leftSortedRight.reverse.sortWith(_\
    \ < _)\n            val rightSortedRightLeftRightLeft = rightSortedRight.reverse.sortWith(_\
    \ < _)\n            val leftSortedRightLeftRightRightRight = leftSortedRight.reverse.sortWith(_\
    \ < _)\n            val rightSortedRightLeftRightRightRight = rightSortedRight.reverse.sortWith(_\
    \ < _)\n            val leftSortedRightLeftRightRightLeft = leftSortedRight.reverse.sortWith(_\
    \ < _)\n            val rightSortedRightLeftRightRightLeft = rightSortedRight.reverse.sortWith(_\
    \ < _)\n            val leftSortedRightLeftRightRightRightLeft = leftSortedRight.reverse.sortWith(_\
    \ < _)\n            val rightSortedRightLeftRightRightRightLeft = rightSortedRight.reverse.sortWith(_\
    \ < _)\n            val leftSortedRightLeftRightRightRightRight = leftSortedRight.reverse.sortWith(_\
    \ < _)\n            val rightSortedRightLeftRightRightRightRight = rightSortedRight.reverse.sortWith(_\
    \ < _)\n            val leftSortedRightLeftRightRightRightRightLeft = leftSortedRight.reverse.sortWith(_\
    \ < _)\n            val rightSortedRightLeftRightRightRightRightLeft = rightSortedRight.reverse.sortWith(_\
    \ < _)\n            val leftSortedRightLeftRightRightRightRightRight = leftSortedRight.reverse.sortWith(_\
    \ < _)\n            val rightSortedRightLeftRightRightRightRightRight = rightSortedRight.reverse.sortWith(_\
    \ < _)\n            \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp75cbfjoc.scala:69:0 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp75cbfjoc.scala:68:1\
    \ ---------------------\e[0m\e[0m\n\e[31m68 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmp75cbfjoc.scala:60:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m60 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1659798044
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val max = (arr.max)(_)\n        val min = (arr.min)(_)\n        val maxIndex\
    \ = (arr.indexOfMax)(_)\n        val minIndex = (arr.indexOfMin)(_)\n        val\
    \ maxIndex2 = maxIndex + 1\n        val minIndex2 = minIndex - 1\n        val\
    \ maxIndex3 = maxIndex - 2\n        val minIndex3 = minIndex - 2\n        val\
    \ maxIndex4 = maxIndex - 3\n        val minIndex4 = minIndex - 3\n        val\
    \ maxIndex5 = maxIndex - 4\n        val minIndex5 = minIndex - 4\n        val\
    \ maxIndex6 = maxIndex - 5\n        val minIndex6 = minIndex - 5\n        val\
    \ maxIndex7 = maxIndex - 6\n        val minIndex7 = minIndex - 6\n        val\
    \ maxIndex8 = maxIndex - 7\n        val minIndex8 = minIndex - 7\n        val\
    \ maxIndex9 = maxIndex - 8\n        val minIndex9 = minIndex - 8\n        val\
    \ maxIndex10 = maxIndex - 9\n        val minIndex10 = minIndex - 9\n        val\
    \ maxIndex11 = maxIndex - 10\n        val minIndex11 = minIndex - 10\n       \
    \ val maxIndex12 = maxIndex - 11\n        val minIndex12 = minIndex - 11\n   \
    \     val maxIndex13 = maxIndex - 12\n        val minIndex13 = minIndex - 12\n\
    \        val maxIndex14 = maxIndex - 13\n        val minIndex14 = minIndex - 13\n\
    \        val maxIndex15 = maxIndex - 14\n        val minIndex15 = minIndex - 14\n\
    \        val maxIndex16 = maxIndex - 15\n        val minIndex16 = minIndex - 15\n\
    \        val maxIndex17 = maxIndex - 16\n        val minIndex17 = minIndex - 16\n\
    \        val maxIndex18 = maxIndex - 17\n        val minIndex18 = minIndex - 17\n\
    \        val maxIndex19 = maxIndex - 18\n        val minIndex19 = minIndex - 18\n\
    \        val maxIndex20 = maxIndex - 19\n        val minIndex20 = minIndex - 19\n\
    \        val maxIndex21 = maxIndex - 20\n        val minIndex21 = minIndex - 20\n\
    \        val maxIndex22 = maxIndex - 21\n        val minIndex22 = minIndex - 21\n\
    \        val maxIndex23 = maxIndex - 22\n        val minIndex23 = minIndex - 22\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpc31gu7w8.scala:75:11 ---------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E081] Type Error: /tmp/tmpc31gu7w8.scala:29:40 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = (arr.indexOfMax)(_)\n\
    \e[31m\e[31m   |\e[0m                                        ^\e[0m\n\e[31m  \
    \ |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could\
    \ not infer the type of the parameter _$3 of expanded function:\n\e[31m   |\e\
    [0m   _$3 => (arr.indexOfMax)(_$3).\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc31gu7w8.scala:29:28\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxIndex\e[0m = (arr.indexOfMax)(_)\n\e[31m\e[31m   |\e[0m               \
    \         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue indexOfMax is not a member\
    \ of List[Long] - did you mean arr.indexOf?\n\e[31m\e[31m-- [E081] Type Error:\
    \ /tmp/tmpc31gu7w8.scala:30:40 -----------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mminIndex\e[0m = (arr.indexOfMin)(_)\n\e[31m\e\
    [31m   |\e[0m                                        ^\e[0m\n\e[31m   |\e[0m \
    \  Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$4 of expanded function:\n\e[31m   |\e[0m   _$4 =>\
    \ (arr.indexOfMin)(_$4).\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc31gu7w8.scala:30:28\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mminIndex\e[0m = (arr.indexOfMin)(_)\n\e[31m\e[31m   |\e[0m               \
    \         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue indexOfMin is not a member\
    \ of List[Long] - did you mean arr.indexOf?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpc31gu7w8.scala:76:5 ---------------------\e[0m\e[0m\n\e[31m76\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation"
  stdout: ''
  timestamp: 1659798045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val d = arr.last\n        val r = arr.dropRight(1)\n\
    \        val s = arr.dropRight(2)\n        val t = arr.dropRight(3)\n        val\
    \ u = arr.dropRight(4)\n        val v = arr.dropRight(5)\n        val w = arr.dropRight(6)\n\
    \        val x = arr.dropRight(7)\n        val y = arr.dropRight(8)\n        val\
    \ z = arr.dropRight(9)\n        val a = arr.dropRight(10)\n        val b = arr.dropRight(11)\n\
    \        val c = arr.dropRight(12)\n        val d = arr.dropRight(13)\n      \
    \  val e = arr.dropRight(14)\n        val f = arr.dropRight(15)\n        val g\
    \ = arr.dropRight(16)\n        val h = arr.dropRight(17)\n        val i = arr.dropRight(18)\n\
    \        val j = arr.dropRight(19)\n        val k = arr.dropRight(20)\n      \
    \  val l = arr.dropRight(21)\n        val m = arr.dropRight(22)\n        val n\
    \ = arr.dropRight(23)\n        val o = arr.dropRight(24)\n        val p = arr.dropRight(25)\n\
    \        val q = arr.dropRight(26)\n        val r = arr.dropRight(27)\n      \
    \  val s = arr.dropRight(28)\n        val t = arr.dropRight(29)\n        val u\
    \ = arr.dropRight(30)\n        val v = arr.dropRight(31)\n        val w = arr.dropRight(32)\n\
    \        val x = arr.dropRight(33)\n        val y = arr.dropRight(34)\n      \
    \  val z = arr.dropRight(35)\n        val a = arr.dropRight(36)\n        val b\
    \ = arr.dropRight(37)\n        val c = arr.dropRight(38)\n        val d = arr.dropRight(39)\n\
    \        val e = arr.dropRight(40)\n        val f = arr.dropRight(41)\n      \
    \  val g = arr.dropRight(42)\n        val h = arr.dropRight(43)\n        val i\
    \ = arr.dropRight(44)\n        val j = arr.dropRight(45)\n        val k = arr.dropRight(46)\n\
    \        val l = arr.dropRight(47)\n        val m = arr.dropRight(48)\n      \
    \  val n = arr.dropRight(49)\n        val o = arr.dropRight(50)\n        val p\
    \ = arr.dropRight(51)\n        val q = arr.dropRight(52)\n        val r = arr.dropRight(53)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdvt0zeho.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = arr.dropRight(\e\
    [31m13\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0md is already defined as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdvt0zeho.scala:50:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = arr.dropRight(\e[31m22\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpdvt0zeho.scala:51:12 ---------------------------\e[0m\e[0m\n\e[31m51\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.dropRight(\e[31m23\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is\
    \ already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdvt0zeho.scala:55:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m55 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = arr.dropRight(\e[31m27\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpdvt0zeho.scala:56:12 ---------------------------\e[0m\e[0m\n\e[31m56\
    \ |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = arr.dropRight(\e[31m28\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is\
    \ already defined as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definition"
  stdout: ''
  timestamp: 1659798044
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val m = arr.head\n    \
    \        val l = arr.tail\n            val l1 = l.tail\n            val l2 = l1.tail\n\
    \            val l3 = l2.tail\n            val l4 = l3.tail\n            val l5\
    \ = l4.tail\n            val l6 = l5.tail\n            val l7 = l6.tail\n    \
    \        val l8 = l7.tail\n            val l9 = l8.tail\n            val l10 =\
    \ l9.tail\n            val l11 = l10.tail\n            val l12 = l11.tail\n  \
    \          val l13 = l12.tail\n            val l14 = l13.tail\n            val\
    \ l15 = l14.tail\n            val l16 = l15.tail\n            val l17 = l16.tail\n\
    \            val l18 = l17.tail\n            val l19 = l18.tail\n            val\
    \ l20 = l19.tail\n            val l21 = l20.tail\n            val l22 = l21.tail\n\
    \            val l23 = l22.tail\n            val l24 = l23.tail\n            val\
    \ l25 = l24.tail\n            val l26 = l25.tail\n            val l27 = l26.tail\n\
    \            val l28 = l27.tail\n            val l29 = l28.tail\n            val\
    \ l30 = l29.tail\n            val l31 = l30.tail\n            val l32 = l31.tail\n\
    \            val l33 = l32.tail\n            val l34 = l33.tail\n            val\
    \ l35 = l34.tail\n            val l36 = l35.tail\n            val l37 = l36.tail\n\
    \            val l38 = l37.tail\n            val l39 = l38.tail\n            val\
    \ l40 = l39.tail\n            val l41 = l40.tail\n            val l42 = l41.tail\n\
    \            val l43 = l42.tail\n            val l44 = l43.tail\n            val\
    \ l45 = l44.tail\n            val l46 = l45.tail\n            val l47 = l46.tail\n\
    \            val l48 = l47.tail\n            val l49 = l48.tail\n            val\
    \ l50 = l49.tail\n            val l51 = l50.tail\n            val l52 = l51.tail\n\
    \            val l53 = l52.tail\n            val l54 = l53.tail\n            val\
    \ l\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphr5nrdm4.scala:86:4 ----------------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphr5nrdm4.scala:96:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m96 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmphr5nrdm4.scala:95:1 ---------------------\e[0m\e[0m\n\
    \e[31m95 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmphr5nrdm4.scala:87:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m87 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1659798046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val l = arr.head\n        val r = arr.last\n\
    \        val m = arr.length\n        val arr = arr.toList\n        val l = arr.head\n\
    \        val r = arr.last\n        val m = arr.length\n        val arr = arr.toList\n\
    \        val l = arr.head\n        val r = arr.last\n        val m = arr.length\n\
    \        val arr = arr.toList\n        val l = arr.head\n        val r = arr.last\n\
    \        val m = arr.length\n        val arr = arr.toList\n        val l = arr.head\n\
    \        val r = arr.last\n        val m = arr.length\n        val arr = arr.toList\n\
    \        val l = arr.head\n        val r = arr.last\n        val m = arr.length\n\
    \        val arr = arr.toList\n        val l = arr.head\n        val r = arr.last\n\
    \        val m = arr.length\n        val arr = arr.toList\n        val l = arr.head\n\
    \        val r = arr.last\n        val m = arr.length\n        val arr = arr.toList\n\
    \        val l = arr.head\n        val r = arr.last\n        val m = arr.length\n\
    \        val arr = arr.toList\n        val l = arr.head\n        val r = arr.last\n\
    \        val m = arr.length\n        val arr = arr.toList\n        val l = arr.head\n\
    \        val r = arr.last\n        val m = arr.length\n        val arr = arr.toList\n\
    \        val l = arr.head\n        val r = arr.last\n        val m = arr.length\n\
    \        val arr = arr.toList\n        val l = arr.head\n        val r = arr.last\n\
    \        val m = arr.length\n        val arr = arr.toList\n        val l = arr.head\n\
    \        val r = arr.last\n        val m = arr.length\n        val arr = arr.toList\n\
    \        val l = arr.head\n        val r = arr.last\n        val m = arr.length\n\
    \        val arr = arr.toList\n        val l = arr.head\n        val r = arr.last\n\
    \        val m = arr.length\n        val arr = arr.toList\n        val l = arr.head\n\
    \        val r = arr.last\n        val m = arr.length\n        val arr = arr.toList\n\
    \        val l = arr.head\n        val r = arr.last\n        val m = arr.length\n\
    \        val arr = arr.toList\n        val l = arr.head\n        val r = arr.last\n\
    \        val m = arr.length\n        val arr = arr.toList\n        val l = arr.head\n\
    \        val r = arr.last\n        val m = arr.length\n        val arr = arr.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo13agsux.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo13agsux.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo13agsux.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo13agsux.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already\
    \ defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo13agsux.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo13agsux.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m3"
  stdout: ''
  timestamp: 1659798045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val result = new Array[Boolean](n + 1)\n  \
    \      result(0) = true\n        result(1) = false\n        for(i <- 2 to n) {\n\
    \            val temp = arr(i)\n            for(j <- 1 to i) {\n             \
    \   arr(j) = arr(j - 1)\n            }\n            arr(i) = temp\n          \
    \  val temp = result(i)\n            result(i) = result(i-1) || moveOneBall(arr)\n\
    \            arr(i) = temp\n        }\n        result(n)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw5ecu8x8.scala:37:16 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e[0m \e[36mtemp\e[0m = result(i)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mtemp\
    \ is already defined as \e[33mvalue\e[0m \e[35mtemp\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw5ecu8x8.scala:34:16\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                arr(j) =\
    \ arr(j - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m\
    \   |\e[0m  value update is not a member of List[Long] - did you mean arr.updated?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw5ecu8x8.scala:36:12 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            arr(i) = temp\n\e[31m\e[31m   |\e[0m    \
    \        ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw5ecu8x8.scala:39:12\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m            arr(i) = temp\n\
    \e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n4 errors found\n"
  stdout: ''
  timestamp: 1659798045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val m = arr.head\n    \
    \        val l = arr.tail\n            val r = l.tail\n            val r1 = r.tail\n\
    \            val r2 = r1.tail\n            val r3 = r2.tail\n            val r4\
    \ = r3.tail\n            val r5 = r4.tail\n            val r6 = r5.tail\n    \
    \        val r7 = r6.tail\n            val r8 = r7.tail\n            val r9 =\
    \ r8.tail\n            val r10 = r9.tail\n            val r11 = r10.tail\n   \
    \         val r12 = r11.tail\n            val r13 = r12.tail\n            val\
    \ r14 = r13.tail\n            val r15 = r14.tail\n            val r16 = r15.tail\n\
    \            val r17 = r16.tail\n            val r18 = r17.tail\n            val\
    \ r19 = r18.tail\n            val r20 = r19.tail\n            val r21 = r20.tail\n\
    \            val r22 = r21.tail\n            val r23 = r22.tail\n            val\
    \ r24 = r23.tail\n            val r25 = r24.tail\n            val r26 = r25.tail\n\
    \            val r27 = r26.tail\n            val r28 = r27.tail\n            val\
    \ r29 = r28.tail\n            val r30 = r29.tail\n            val r31 = r30.tail\n\
    \            val r32 = r31.tail\n            val r33 = r32.tail\n            val\
    \ r34 = r33.tail\n            val r35 = r34.tail\n            val r36 = r35.tail\n\
    \            val r37 = r36.tail\n            val r38 = r37.tail\n            val\
    \ r39 = r38.tail\n            val r40 = r39.tail\n            val r41 = r40.tail\n\
    \            val r42 = r41.tail\n            val r43 = r42.tail\n            val\
    \ r44 = r43.tail\n            val r45 = r44.tail\n            val r46 = r45.tail\n\
    \            val r47 = r46.tail\n            val r48 = r47.tail\n            val\
    \ r49 = r48.tail\n            val r50 = r49.tail\n            val r51 = r50.tail\n\
    \            val r52 = r51.tail\n            val r53 = r52.tail\n            val\
    \ r54 = r53.tail\n            val r55 = r54.tail\n            val r56 = r55.tail\n\
    \            val r57 = r56.tail\n            val r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqm0q3bpb.scala:90:4 ----------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqm0q3bpb.scala:100:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m100 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpqm0q3bpb.scala:99:1 ---------------------\e[0m\e\
    [0m\n\e[31m99 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:  \
    \  Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpqm0q3bpb.scala:91:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m91 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val r = arr.last\n        val s = arr.init\n\
    \        val t = arr.tail\n        val u = arr.init\n        val v = arr.tail\n\
    \        val w = arr.init\n        val x = arr.tail\n        val y = arr.init\n\
    \        val z = arr.tail\n        val a = arr.init\n        val b = arr.tail\n\
    \        val c = arr.init\n        val d = arr.tail\n        val e = arr.init\n\
    \        val f = arr.tail\n        val g = arr.init\n        val h = arr.tail\n\
    \        val i = arr.init\n        val j = arr.tail\n        val k = arr.init\n\
    \        val l = arr.tail\n        val m = arr.init\n        val n = arr.tail\n\
    \        val o = arr.init\n        val p = arr.tail\n        val q = arr.init\n\
    \        val r = arr.tail\n        val s = arr.init\n        val t = arr.tail\n\
    \        val u = arr.init\n        val v = arr.tail\n        val w = arr.init\n\
    \        val x = arr.tail\n        val y = arr.init\n        val z = arr.tail\n\
    \        val a = arr.init\n        val b = arr.tail\n        val c = arr.init\n\
    \        val d = arr.tail\n        val e = arr.init\n        val f = arr.tail\n\
    \        val g = arr.init\n        val h = arr.tail\n        val i = arr.init\n\
    \        val j = arr.tail\n        val k = arr.init\n        val l = arr.tail\n\
    \        val m = arr.init\n        val n = arr.tail\n        val o = arr.init\n\
    \        val p = arr.tail\n        val q = arr.init\n        val r = arr.tail\n\
    \        val s = arr.init\n        val t = arr.tail\n        val u = arr.init\n\
    \        val v = arr.tail\n        val w = arr.init\n        val x = arr.tail\n\
    \        val y = arr.init\n        val z = arr.tail\n        val a = arr.init\n\
    \        val b = arr.tail\n        val c = arr.init\n        val d = arr.tail\n\
    \        val e = arr.init\n        val f = arr.tail\n        val g = arr.init\n\
    \        val h = arr.tail\n        val i = arr.init\n        val j = arr.tail\n\
    \        val k = arr.init\n        val l = arr.tail\n        val m = arr.init\n\
    \        val n = arr.tail\n        val o = arr.init\n        val p = arr.tail\n\
    \        val q = arr.init\n        val r = arr.tail\n        val s = arr.init\n\
    \        val t = arr.tail\n        val u = arr.init\n        val v = arr.tail\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpurh_q719.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpurh_q719.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpurh_q719.scala:50:12 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpurh_q719.scala:54:12 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpurh_q719.scala:55:12 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpurh_q719.scala:56:12 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m        \e[33mval\e[0m \e[36mt\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659798045
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val len = arr.length\n\
    \        if(len == 0) return true\n        val first = arr(0)\n        val last\
    \ = arr(len-1)\n        val mid = len/2\n        val leftArr = (arr.drop(mid).toList\
    \ ++ arr.take(mid).toList).sortBy(-_)\n        val rightArr = (arr.drop(mid).toList\
    \ ++ arr.take(mid).toList).sortBy(-_)\n        val leftSorted = leftArr.take(mid).reverse\n\
    \        val rightSorted = rightArr.take(mid).reverse\n        if(leftSorted.last\
    \ == last) moveOneBall(leftSorted)\n        else if(rightSorted.last == last)\
    \ moveOneBall(rightSorted)\n        else false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5rzn8k3n.scala:40)\n\tat Problem.main(tmp5rzn8k3n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798047
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val l = arr.head\n    \
    \        val r = arr.last\n            val m = arr.indexOf(l) + 1\n          \
    \  val n = arr.indexOf(r)\n            val k = arr.indexOf(l) + n\n          \
    \  val m = arr.indexOf(r) + n\n            val l = arr.take(m)\n            val\
    \ r = arr.drop(k)\n            val m = arr.indexOf(l) + 1\n            val n =\
    \ arr.indexOf(r)\n            val k = arr.indexOf(l) + n\n            val m =\
    \ arr.indexOf(r) + n\n            val l = arr.take(m)\n            val r = arr.drop(k)\n\
    \            val m = arr.indexOf(l) + 1\n            val n = arr.indexOf(r)\n\
    \            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(r) +\
    \ n\n            val l = arr.take(m)\n            val r = arr.drop(k)\n      \
    \      val m = arr.indexOf(l) + 1\n            val n = arr.indexOf(r)\n      \
    \      val k = arr.indexOf(l) + n\n            val m = arr.indexOf(r) + n\n  \
    \          val l = arr.take(m)\n            val r = arr.drop(k)\n            val\
    \ m = arr.indexOf(l) + 1\n            val n = arr.indexOf(r)\n            val\
    \ k = arr.indexOf(l) + n\n            val m = arr.indexOf(r) + n\n           \
    \ val l = arr.take(m)\n            val r = arr.drop(k)\n            val m = arr.indexOf(l)\
    \ + 1\n            val n = arr.indexOf(r)\n            val k = arr.indexOf(l)\
    \ + n\n            val m = arr.indexOf(r) + n\n            val l = arr.take(m)\n\
    \            val r = arr.drop(k)\n            val m = arr.indexOf(l) + 1\n   \
    \         val n = arr.indexOf(r)\n            val k = arr.indexOf(l) + n\n   \
    \         val m = arr.indexOf(r) + n\n            val l = arr.take(m)\n      \
    \      val r = arr.drop(k)\n            val m = arr.indexOf(l) + 1\n         \
    \   val n = arr.indexOf(r)\n            val k = arr.indexOf(l) + n\n         \
    \   val m = arr.indexOf(r) + n\n            val l = arr.take(m)\n            val\
    \ r = arr.drop(k)\n            val m = arr.indexOf(l) + 1\n            val n =\
    \ arr.indexOf(r)\n            val k = arr.indexOf(l) + n\n            val m =\
    \ arr.indexOf(r) + n\n            val l = arr.take(m)\n            val r = arr.drop(k)\n\
    \            val m = arr.indexOf(l) + 1\n            val n = arr.indexOf(r)\n\
    \            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(r) +\
    \ n\n            val l = arr.take(m)\n            val r = arr.drop\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiyhrebm3.scala:101:0 ---------------------------\e\
    [0m\e[0m\n\e[31m101 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiyhrebm3.scala:34:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e\
    [0m \e[36mm\e[0m = arr.indexOf(r) + n\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpiyhrebm3.scala:35:16 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m            \e[33mval\e[0m \e[36ml\e[0m = arr.take(m)\n\e[31m\e[31m  \
    \ |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiyhrebm3.scala:36:16 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = arr.drop(k)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is\
    \ already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiyhrebm3.scala:37:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e\
    [0m \e[36mm\e[0m = arr.indexOf(l) + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined as\
    \ \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpiyhrebm3.scala:38:16 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e[0m \e[36mn\e[0m = arr.indexOf(r)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn\
    \ is al"
  stdout: ''
  timestamp: 1659798047
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val max = (n - 1).toLong\n        val min = 0l\n        val maxIndex\
    \ = 0\n        val minIndex = 0\n        var i = 0\n        var j = 0\n      \
    \  var k = 0\n        var temp = 0\n        var temp2 = 0\n        var temp3 =\
    \ 0\n        var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n   \
    \     var temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n        var\
    \ temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n        var temp13\
    \ = 0\n        var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n\
    \        var temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n    \
    \    var temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n        var\
    \ temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n        var temp26\
    \ = 0\n        var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n\
    \        var temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n    \
    \    var temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n        var\
    \ temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n        var temp39\
    \ = 0\n        var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n\
    \        var temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n    \
    \    var temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n        var\
    \ temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n        var temp52\
    \ = 0\n        var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n\
    \        var temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n    \
    \    var temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n        var\
    \ temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n        var temp65\
    \ = 0\n        var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n\
    \        var temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n    \
    \    var temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n        var\
    \ temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n        var temp78\
    \ = 0\n        var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n\
    \        var temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n    \
    \    var temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n        var\
    \ temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n        var temp91\
    \ = 0\n        var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3010t27o.scala:128:5\
    \ --------------------\e[0m\e[0m\n\e[31m128 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        else if(arr.head == arr.last) moveOneBall(arr.tail)\n        else\
    \ {\n            val newArr = arr.tail.tail\n            val newArr2 = newArr.tail\n\
    \            val newArr3 = newArr2.tail\n            val newArr4 = newArr3.tail\n\
    \            val newArr5 = newArr4.tail\n            val newArr6 = newArr5.tail\n\
    \            val newArr7 = newArr6.tail\n            val newArr8 = newArr7.tail\n\
    \            val newArr9 = newArr8.tail\n            val newArr10 = newArr9.tail\n\
    \            val newArr11 = newArr10.tail\n            val newArr12 = newArr11.tail\n\
    \            val newArr13 = newArr12.tail\n            val newArr14 = newArr13.tail\n\
    \            val newArr15 = newArr14.tail\n            val newArr16 = newArr15.tail\n\
    \            val newArr17 = newArr16.tail\n            val newArr18 = newArr17.tail\n\
    \            val newArr19 = newArr18.tail\n            val newArr20 = newArr19.tail\n\
    \            val newArr21 = newArr20.tail\n            val newArr22 = newArr21.tail\n\
    \            val newArr23 = newArr22.tail\n            val newArr24 = newArr23.tail\n\
    \            val newArr25 = newArr24.tail\n            val newArr26 = newArr25.tail\n\
    \            val newArr27 = newArr26.tail\n            val newArr28 = newArr27.tail\n\
    \            val newArr29 = newArr28.tail\n            val newArr30 = newArr29.tail\n\
    \            val newArr31 = newArr30.tail\n            val newArr32 = newArr31.tail\n\
    \            val newArr33 = newArr32.tail\n            val newArr34 = newArr33.tail\n\
    \            val newArr35 = newArr34.tail\n            val newArr36 = newArr35.tail\n\
    \            val newArr37 = newArr36.tail\n            val newArr38 = newArr37.tail\n\
    \            val newArr39 = newArr38.tail\n            val newArr40 = newArr39.tail\n\
    \            val newArr41 = newArr40.tail\n            val newArr42 = newArr41.tail\n\
    \            val newArr43 = newArr42.tail\n            val newArr44 = newArr43.tail\n\
    \            val newArr45 = newArr44.tail\n            val newArr46 = newArr45.tail\n\
    \            val newArr47 = newArr46.tail\n            val newArr48 = new\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu0xbt_ua.scala:77:4 ----------------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpu0xbt_ua.scala:87:0 ----------------------------\e[0m\e[0m\n\e[31m87\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu0xbt_ua.scala:86:1 ---------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpu0xbt_ua.scala:78:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m78 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659798048
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val l = arr.last\n        val r = arr.init\n\
    \        val d = arr.last\n        val s = arr.init\n        val r = arr.last\n\
    \        val l = arr.init\n        val r = arr.last\n        val l = arr.init\n\
    \        val r = arr.last\n        val l = arr.init\n        val r = arr.last\n\
    \        val l = arr.init\n        val r = arr.last\n        val l = arr.init\n\
    \        val r = arr.last\n        val l = arr.init\n        val r = arr.last\n\
    \        val l = arr.init\n        val r = arr.last\n        val l = arr.init\n\
    \        val r = arr.last\n        val l = arr.init\n        val r = arr.last\n\
    \        val l = arr.init\n        val r = arr.last\n        val l = arr.init\n\
    \        val r = arr.last\n        val l = arr.init\n        val r = arr.last\n\
    \        val l = arr.init\n        val r = arr.last\n        val l = arr.init\n\
    \        val r = arr.last\n        val l = arr.init\n        val r = arr.last\n\
    \        val l = arr.init\n        val r = arr.last\n        val l = arr.init\n\
    \        val r = arr.last\n        val l = arr.init\n        val r = arr.last\n\
    \        val l = arr.init\n        val r = arr.last\n        val l = arr.init\n\
    \        val r = arr.last\n        val l = arr.init\n        val r = arr.last\n\
    \        val l = arr.init\n        val r = arr.last\n        val l = arr.init\n\
    \        val r = arr.last\n        val l = arr.init\n        val r = arr.last\n\
    \        val l = arr.init\n        val r = arr.last\n        val l = arr.init\n\
    \        val r = arr.last\n        val l = arr.init\n        val r = arr.last\n\
    \        val l = arr.init\n        val r = arr.last\n        val l = arr.init\n\
    \        val r = arr.last\n        val l = arr.init\n        val r = arr.last\n\
    \        val l = arr.init\n        val r = arr.last\n        val l = arr.init\n\
    \        val r = arr.last\n        val l = arr.init\n        val r = arr.last\n\
    \        val l = arr.init\n        val r = arr.last\n        val l = arr.init\n\
    \        val r = arr.last\n        val l = arr.init\n        val r = arr.last\n\
    \        val l = arr.init\n        val r = arr.last\n        val l = arr.init\n\
    \        val r = arr.last\n        val l = arr.init\n        val r = arr.last\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpfwnmxqlu.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfwnmxqlu.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfwnmxqlu.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfwnmxqlu.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfwnmxqlu.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfwnmxqlu.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659798049
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr1\
    \ = arr.toArray\n        val arr2 = arr.toBuffer\n        val arr3 = arr.toSeq\n\
    \        val arr4 = arr.toSet\n        val arr5 = arr.toMap\n        val arr6\
    \ = arr.toIterator\n        val arr7 = arr.toStream\n        val arr8 = arr.toTraversable\n\
    \        val arr9 = arr.toIndexedSeq\n        val arr10 = arr.toIndexedSeq\n \
    \       val arr11 = arr.toArray\n        val arr12 = arr.toList\n        val arr13\
    \ = arr.toSeq\n        val arr14 = arr.toSet\n        val arr15 = arr.toMap\n\
    \        val arr16 = arr.toIterator\n        val arr17 = arr.toStream\n      \
    \  val arr18 = arr.toTraversable\n        val arr19 = arr.toIndexedSeq\n     \
    \   val arr20 = arr.toIndexedSeq\n        val arr21 = arr.toArray\n        val\
    \ arr22 = arr.toList\n        val arr23 = arr.toSeq\n        val arr24 = arr.toSet\n\
    \        val arr25 = arr.toMap\n        val arr26 = arr.toIterator\n        val\
    \ arr27 = arr.toStream\n        val arr28 = arr.toTraversable\n        val arr29\
    \ = arr.toIndexedSeq\n        val arr30 = arr.toIndexedSeq\n        val arr31\
    \ = arr.toArray\n        val arr32 = arr.toList\n        val arr33 = arr.toSeq\n\
    \        val arr34 = arr.toSet\n        val arr35 = arr.toMap\n        val arr36\
    \ = arr.toIterator\n        val arr37 = arr.toStream\n        val arr38 = arr.toTraversable\n\
    \        val arr39 = arr.toIndexedSeq\n        val arr40 = arr.toIndexedSeq\n\
    \        val arr41 = arr.toArray\n        val arr42 = arr.toList\n        val\
    \ arr43 = arr.toSeq\n        val arr44 = arr.toSet\n        val arr45 = arr.toMap\n\
    \        val arr46 = arr.toIterator\n        val arr47 = arr.toStream\n      \
    \  val arr48 = arr.toTraversable\n        val arr49 = arr.toIndexedSeq\n     \
    \   val arr50 = arr.toIndexedSeq\n        val arr51 = arr.toArray\n        val\
    \ arr52 = arr.toList\n        val arr53 = arr.toSeq\n        val arr54 = arr.toSet\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxff84zdn.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpxff84zdn.scala:83:5 ---------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798049
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val r = new Array[Long](n)\n        var i =\
    \ 0\n        var j = 0\n        var k = 0\n        var temp = 0\n        var flag\
    \ = true\n        while(i < n && j < n) {\n            if(i == j) \n         \
    \       flag = false\n            else if(arr(i) > arr(j)) {\n               \
    \ temp = arr(i)\n                arr(i) = arr(j)\n                arr(j) = temp\n\
    \                i = i + 1\n                j = j + 1\n            } else if(arr(i)\
    \ < arr(j)) {\n                temp = arr(j)\n                arr(j) = arr(i)\n\
    \                arr(i) = temp\n                i = i + 1\n                j =\
    \ j + 1\n            } else if(arr(i) == arr(j)) {\n                k = i + 1\n\
    \                while(k < n && arr(k) < arr(j)) {\n                    k = k\
    \ + 1\n                }\n                temp = arr(j)\n                arr(j)\
    \ = arr(k)\n                arr(k) = temp\n                i = i + 1\n       \
    \         j = j + 1\n                k = k + 1\n            }\n        }\n   \
    \     if(flag)\n            true\n        else\n            false\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0ielieq5.scala:38:26\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m                temp = arr(i)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                  Found:    Long\n\e[31m   |\e[0m                       Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0ielieq5.scala:39:16\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                arr(i) =\
    \ arr(j)\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp0ielieq5.scala:40:16 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                arr(j) = temp\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0ielieq5.scala:44:26\
    \ --------------------\e[0m\e[0m\n\e[31m44 |\e[0m                temp = arr(j)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                  Found:    Long\n\e[31m   |\e[0m                       Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0ielieq5.scala:45:16\
    \ ------------------------\e[0m\e[0m\n\e[31m45 |\e[0m                arr(j) =\
    \ arr(i)\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp0ielieq5.scala:46:16 ------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                arr(i) = temp\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0ielieq5.scala:54:26\
    \ --------------------\e[0m\e[0m\n\e[31m54 |\e[0m                temp = arr(j)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659798054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val s = arr.tail\n        val r = new Array[Long](n)\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n\
    \        var m1 = new Array[Long](n)\n        var m2 = new Array[Long](n)\n  \
    \      var m3 = new Array[Long](n)\n        var m4 = new Array[Long](n)\n    \
    \    var m5 = new Array[Long](n)\n        var m6 = new Array[Long](n)\n      \
    \  var m7 = new Array[Long](n)\n        var m8 = new Array[Long](n)\n        var\
    \ m9 = new Array[Long](n)\n        var m10 = new Array[Long](n)\n        var m11\
    \ = new Array[Long](n)\n        var m12 = new Array[Long](n)\n        var m13\
    \ = new Array[Long](n)\n        var m14 = new Array[Long](n)\n        var m15\
    \ = new Array[Long](n)\n        var m16 = new Array[Long](n)\n        var m17\
    \ = new Array[Long](n)\n        var m18 = new Array[Long](n)\n        var m19\
    \ = new Array[Long](n)\n        var m20 = new Array[Long](n)\n        var m21\
    \ = new Array[Long](n)\n        var m22 = new Array[Long](n)\n        var m23\
    \ = new Array[Long](n)\n        var m24 = new Array[Long](n)\n        var m25\
    \ = new Array[Long](n)\n        var m26 = new Array[Long](n)\n        var m27\
    \ = new Array[Long](n)\n        var m28 = new Array[Long](n)\n        var m29\
    \ = new Array[Long](n)\n        var m30 = new Array[Long](n)\n        var m31\
    \ = new Array[Long](n)\n        var m32 = new Array[Long](n)\n        var m33\
    \ = new Array[Long](n)\n        var m34 = new Array[Long](n)\n        var m35\
    \ = new Array[Long](n)\n        var m36 = new Array[Long](n)\n        var m37\
    \ = new Array[Long](n)\n        var m38 = new Array[Long](n)\n        var m39\
    \ = new Array[Long](n)\n        var m40 = new Array[Long](n)\n        var m41\
    \ = new Array[Long](n)\n        var m42 = new Array[Long](n)\n        var m43\
    \ = new Array[Long](n)\n        var m44 = new Array[Long](n)\n        var m45\
    \ = new Array[Long](n)\n        var m46 = new Array[Long](n)\n        var m47\
    \ = new Array\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpu20v2_31.scala:80:18 -----------------------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m        \e[33mvar\e[0m \e[36mm47\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmissing argument for parameter _length of \e[33mconstructor\e[0m\
    \ \e[35mArray\e[0m in \e[33mclass\e[0m \e[35mArray\e[0m: (_length: Int): Array[T]\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu20v2_31.scala:81:5 ---------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798052
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr1 = arr.toList\n\
    \        val arr2 = arr1.reverse\n        val arr3 = arr2.reverse\n        val\
    \ arr4 = arr3.reverse\n        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n\
    \        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val\
    \ arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n\
    \        val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n      \
    \  val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16\
    \ = arr15.reverse\n        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n\
    \        val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n      \
    \  val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23\
    \ = arr22.reverse\n        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n\
    \        val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n      \
    \  val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30\
    \ = arr29.reverse\n        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n\
    \        val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n      \
    \  val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37\
    \ = arr36.reverse\n        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n\
    \        val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n      \
    \  val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44\
    \ = arr43.reverse\n        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n\
    \        val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n      \
    \  val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51\
    \ = arr50.reverse\n        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n\
    \        val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n      \
    \  val arr5\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph5mcw5ze.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmph5mcw5ze.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph5mcw5ze.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val start\
    \ = 0\n        val end = len - 1\n        val mid = len / 2\n        val left\
    \ = arr.take(mid)\n        val right = arr.drop(mid)\n        val leftLen = left.length\n\
    \        val rightLen = right.length\n        val leftStart = 0\n        val leftEnd\
    \ = leftLen - 1\n        val rightStart = 0\n        val rightEnd = rightLen -\
    \ 1\n        val leftMid = leftLen / 2\n        val rightMid = rightLen / 2\n\
    \        val leftLeft = left.take(leftMid)\n        val leftRight = left.drop(leftMid)\n\
    \        val rightLeft = right.take(rightMid)\n        val rightRight = right.drop(rightMid)\n\
    \        val leftLeftLen = leftLeft.length\n        val leftRightLen = leftRight.length\n\
    \        val rightLeftLen = rightLeft.length\n        val rightRightLen = rightRight.length\n\
    \        val leftLeftStart = 0\n        val leftLeftEnd = leftLeftLen - 1\n  \
    \      val leftRightStart = 0\n        val leftRightEnd = leftRightLen - 1\n \
    \       val rightLeftStart = 0\n        val rightLeftEnd = rightLeftLen - 1\n\
    \        val rightRightStart = 0\n        val rightRightEnd = rightRightLen -\
    \ 1\n        val leftLeftMid = leftLeftLen / 2\n        val leftRightMid = leftRightLen\
    \ / 2\n        val rightLeftMid = rightLeftLen / 2\n        val rightRightMid\
    \ = rightRightLen / 2\n        val leftLeftLeft = leftLeft.take(leftLeftMid)\n\
    \        val leftLeftRight = leftLeft.drop(leftLeftMid)\n        val leftRightLeft\
    \ = leftRight.take(leftRightMid)\n        val leftRightRight = leftRight.drop(leftRightMid)\n\
    \        val rightLeftLeft = rightLeft.take(rightLeftMid)\n        val rightLeftRight\
    \ = rightLeft.drop(rightLeftMid)\n        val rightRightLeft = rightRight.take(rightRightMid)\n\
    \        val rightRightRight = rightRight.drop(rightRightMid)\n        val leftLeftLeftLen\
    \ = leftLeftLeft.length\n        val leftLeftRightLen = leftLeftRight.length\n\
    \        val leftRightLeftLen = leftRightLeft.length\n        val leftRightRightLen\
    \ = leftRightRight.length\n        val rightLeftLeftLen = rightLeftLeft.length\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa7alogz1.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpa7alogz1.scala:76:5 ---------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798053
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val max = (len - 1).toLong\n        val\
    \ min = 0l.toLong\n        val mid = (len / 2).toLong\n        val left = arr.take(mid)\n\
    \        val right = arr.drop(mid)\n        val leftLen = left.length\n      \
    \  val rightLen = right.length\n        val leftMax = left.max\n        val rightMax\
    \ = right.max\n        val leftMin = left.min\n        val rightMin = right.min\n\
    \        val leftMid = (leftLen / 2).toLong\n        val rightMid = (rightLen\
    \ / 2).toLong\n        val leftMaxIndex = left.indexOf(leftMax)\n        val rightMaxIndex\
    \ = right.indexOf(rightMax)\n        val leftMinIndex = left.indexOf(leftMin)\n\
    \        val rightMinIndex = right.indexOf(rightMin)\n        val leftMidIndex\
    \ = left.indexOf(leftMid)\n        val rightMidIndex = right.indexOf(rightMid)\n\
    \        val leftMaxIndex = left.indexOf(leftMax)\n        val rightMaxIndex =\
    \ right.indexOf(rightMax)\n        val leftMinIndex = left.indexOf(leftMin)\n\
    \        val rightMinIndex = right.indexOf(rightMin)\n        val leftMidIndex\
    \ = left.indexOf(leftMid)\n        val rightMidIndex = right.indexOf(rightMid)\n\
    \        val leftMaxIndex = left.indexOf(leftMax)\n        val rightMaxIndex =\
    \ right.indexOf(rightMax)\n        val leftMinIndex = left.indexOf(leftMin)\n\
    \        val rightMinIndex = right.indexOf(rightMin)\n        val leftMidIndex\
    \ = left.indexOf(leftMid)\n        val rightMidIndex = right.indexOf(rightMid)\n\
    \        val leftMaxIndex = left.indexOf(leftMax)\n        val rightMaxIndex =\
    \ right.indexOf(rightMax)\n        val leftMinIndex = left.indexOf(leftMin)\n\
    \        val rightMinIndex = right.indexOf(rightMin)\n        val leftMidIndex\
    \ = left.indexOf(leftMid)\n        val rightMidIndex = right.indexOf(rightMid)\n\
    \        val leftMaxIndex = left.indexOf(leftMax)\n        val rightMaxIndex =\
    \ right.indexOf(rightMax)\n        val leftMinIndex = left.indexOf(leftMin)\n\
    \        val rightMinIndex = right.indexOf(rightMin)\n        val leftMidIndex\
    \ = left.indexOf(leftMid)\n        val rightMidIndex = right.indexOf(rightMid)\n\
    \        val leftMaxIndex = left.indexOf(leftMax)\n        val rightMaxIndex =\
    \ right.indexOf(rightMax)\n        val leftMinIndex = left.indexOf(leftMin)\n\
    \        val rightMinIndex = right.indexOf(rightMin)\n        val leftMidIndex\
    \ = left.indexOf(left\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpz1kmesdx.scala:76:4 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz1kmesdx.scala:47:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m\
    \ \e[36mleftMaxIndex\e[0m = left.indexOf(leftMax)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mleftMaxIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mleftMaxIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz1kmesdx.scala:48:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrightMaxIndex\e[0m = right.indexOf(rightMax)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrightMaxIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mrightMaxIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz1kmesdx.scala:49:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m\
    \ \e[36mleftMinIndex\e[0m = left.indexOf(leftMin)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mleftMinIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mleftMinIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz1kmesdx.scala:50:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrightMinIndex\e[0m = right.indexOf(rightMin)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrightMinIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mrightMinIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Er"
  stdout: ''
  timestamp: 1659798054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr1 = arr.toList\n\
    \        val arr2 = arr1.reverse\n        val arr3 = arr2.toList\n        val\
    \ arr4 = arr3.reverse\n        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n\
    \        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val\
    \ arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n\
    \        val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n      \
    \  val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16\
    \ = arr15.reverse\n        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n\
    \        val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n      \
    \  val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23\
    \ = arr22.reverse\n        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n\
    \        val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n      \
    \  val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30\
    \ = arr29.reverse\n        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n\
    \        val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n      \
    \  val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37\
    \ = arr36.reverse\n        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n\
    \        val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n      \
    \  val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44\
    \ = arr43.reverse\n        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n\
    \        val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n      \
    \  val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51\
    \ = arr50.reverse\n        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n\
    \        val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n      \
    \  val arr\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp46q1477e.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp46q1477e.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp46q1477e.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl4s99uyk.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl4s99uyk.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl4s99uyk.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl4s99uyk.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl4s99uyk.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl4s99uyk.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e"
  stdout: ''
  timestamp: 1659798055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val m = arr.head\n    \
    \        val r = arr.tail\n            val s = r.head\n            val t = r.tail\n\
    \            val u = t.head\n            val v = t.tail\n            val w = v.head\n\
    \            val x = v.tail\n            val y = x.head\n            val z = x.tail\n\
    \            val a = z.head\n            val b = z.tail\n            val c = b.head\n\
    \            val d = b.tail\n            val e = d.head\n            val f = d.tail\n\
    \            val g = f.head\n            val h = f.tail\n            val i = h.head\n\
    \            val j = h.tail\n            val k = j.head\n            val l = j.tail\n\
    \            val m = k.head\n            val n = k.tail\n            val o = l.head\n\
    \            val p = l.tail\n            val q = m.head\n            val r = m.tail\n\
    \            val s = r.head\n            val t = r.tail\n            val u = t.head\n\
    \            val v = t.tail\n            val w = v.head\n            val x = v.tail\n\
    \            val y = x.head\n            val z = x.tail\n            val a = z.head\n\
    \            val b = z.tail\n            val c = b.head\n            val d = b.tail\n\
    \            val e = d.head\n            val f = d.tail\n            val g = f.head\n\
    \            val h = f.tail\n            val i = h.head\n            val j = h.tail\n\
    \            val k = j.head\n            val l = j.tail\n            val m = k.head\n\
    \            val n = k.tail\n            val o = l.head\n            val p = l.tail\n\
    \            val q = m.head\n            val r = m.tail\n            val s = r.head\n\
    \            val t = r.tail\n            val u = t.head\n            val v = t.tail\n\
    \            val w = v.head\n            val x = v.tail\n            val y = x.head\n\
    \            val z = x.tail\n            val a = z.head\n            val b = z.tail\n\
    \            val c = b.head\n            val d = b.tail\n            val e = d.head\n\
    \            val f = d.tail\n            val g = f.head\n            val h = f.tail\n\
    \            val i = h.head\n            val j = h.tail\n            val k = j.head\n\
    \            val l = j.tail\n            val m = k.head\n            val n = k.tail\n\
    \            val o = l.head\n            val p = l.tail\n            val q = m.head\n\
    \            val r = m.tail\n            val s = r.head\n            val t = r.tail\n\
    \            val u = t.head\n            \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwf_5kgbx.scala:123:0 ---------------------------\e\
    [0m\e[0m\n\e[31m123 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwf_5kgbx.scala:51:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m51 |\e[0m            \e[33mval\e\
    [0m \e[36mm\e[0m = k.head\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpwf_5kgbx.scala:56:16 ---------------------------\e[0m\e[0m\n\e[31m56\
    \ |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = m.tail\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e\
    [0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpwf_5kgbx.scala:57:16 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m            \e[33mval\e[0m \e[36ms\e[0m = r.head\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already\
    \ defined as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwf_5kgbx.scala:58:16 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m            \e[33mval\e[0m \e[36mt\e[0m = r.tail\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mt is already\
    \ defined as \e[33mvalue\e[0m \e[35mt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwf_5kgbx.scala:59:16 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m            \e[33mval\e[0m \e[36mu\e[0m = t.head\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mu is already\
    \ defined as \e[33mvalue\e[0m \e[35mu\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded me"
  stdout: ''
  timestamp: 1659798056
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val r = new Array[Long](n)\n        val l =\
    \ new Array[Long](n)\n        val d = new Array[Long](n)\n        val h = new\
    \ Array[Long](n)\n        val v = new Array[Long](n)\n        val p = new Array[Long](n)\n\
    \        val q = new Array[Long](n)\n        val r = new Array[Long](n)\n    \
    \    val l = new Array[Long](n)\n        val d = new Array[Long](n)\n        val\
    \ h = new Array[Long](n)\n        val v = new Array[Long](n)\n        val p =\
    \ new Array[Long](n)\n        val q = new Array[Long](n)\n        val r = new\
    \ Array[Long](n)\n        val l = new Array[Long](n)\n        val d = new Array[Long](n)\n\
    \        val h = new Array[Long](n)\n        val v = new Array[Long](n)\n    \
    \    val p = new Array[Long](n)\n        val q = new Array[Long](n)\n        val\
    \ r = new Array[Long](n)\n        val l = new Array[Long](n)\n        val d =\
    \ new Array[Long](n)\n        val h = new Array[Long](n)\n        val v = new\
    \ Array[Long](n)\n        val p = new Array[Long](n)\n        val q = new Array[Long](n)\n\
    \        val r = new Array[Long](n)\n        val l = new Array[Long](n)\n    \
    \    val d = new Array[Long](n)\n        val h = new Array[Long](n)\n        val\
    \ v = new Array[Long](n)\n        val p = new Array[Long](n)\n        val q =\
    \ new Array[Long](n)\n        val r = new Array[Long](n)\n        val l = new\
    \ Array[Long](n)\n        val d = new Array[Long](n)\n        val h = new Array[Long](n)\n\
    \        val v = new Array[Long](n)\n        val p = new Array[Long](n)\n    \
    \    val q = new Array[Long](n)\n        val r = new Array[Long](n)\n        val\
    \ l = new Array[Long](n)\n        val d = new Array[Long](n)\n        val h =\
    \ new Array[Long](n)\n        val v = new Array[Long](n)\n        val p = new\
    \ Array[Long](n)\n        val q = new Array[Long](n)\n        val r = new Array[Long](n)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpki7h7i9e.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpki7h7i9e.scala:36:12 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpki7h7i9e.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36md\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0md is already defined as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpki7h7i9e.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mh\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mh is already defined as \e[33mvalue\e[0m \e[35mh\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpki7h7i9e.scala:39:12 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36mv\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mv is already defined as \e[33mvalue\e[0m \e[35mv\e[0m\n\e[31m \
    \  |\e[0m\n\e["
  stdout: ''
  timestamp: 1659798056
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr1\
    \ = arr.toArray\n        val arr2 = arr1.clone()\n        val arr3 = arr2.clone()\n\
    \        val arr4 = arr3.clone()\n        val arr5 = arr4.clone()\n        val\
    \ arr6 = arr5.clone()\n        val arr7 = arr6.clone()\n        val arr8 = arr7.clone()\n\
    \        val arr9 = arr8.clone()\n        val arr10 = arr9.clone()\n        val\
    \ arr11 = arr10.clone()\n        val arr12 = arr11.clone()\n        val arr13\
    \ = arr12.clone()\n        val arr14 = arr13.clone()\n        val arr15 = arr14.clone()\n\
    \        val arr16 = arr15.clone()\n        val arr17 = arr16.clone()\n      \
    \  val arr18 = arr17.clone()\n        val arr19 = arr18.clone()\n        val arr20\
    \ = arr19.clone()\n        val arr21 = arr20.clone()\n        val arr22 = arr21.clone()\n\
    \        val arr23 = arr22.clone()\n        val arr24 = arr23.clone()\n      \
    \  val arr25 = arr24.clone()\n        val arr26 = arr25.clone()\n        val arr27\
    \ = arr26.clone()\n        val arr28 = arr27.clone()\n        val arr29 = arr28.clone()\n\
    \        val arr30 = arr29.clone()\n        val arr31 = arr30.clone()\n      \
    \  val arr32 = arr31.clone()\n        val arr33 = arr32.clone()\n        val arr34\
    \ = arr33.clone()\n        val arr35 = arr34.clone()\n        val arr36 = arr35.clone()\n\
    \        val arr37 = arr36.clone()\n        val arr38 = arr37.clone()\n      \
    \  val arr39 = arr38.clone()\n        val arr40 = arr39.clone()\n        val arr41\
    \ = arr40.clone()\n        val arr42 = arr41.clone()\n        val arr43 = arr42.clone()\n\
    \        val arr44 = arr43.clone()\n        val arr45 = arr44.clone()\n      \
    \  val arr46 = arr45.clone()\n        val arr47 = arr46.clone()\n        val arr48\
    \ = arr47.clone()\n        val arr49 = arr48.clone()\n        val arr50 = arr49.clone()\n\
    \        val arr51 = arr50.clone()\n        val arr52 = arr51.clone()\n      \
    \  val arr53 = arr52.clone()\n        val arr54 = arr53.clone()\n        val arr55\
    \ = arr54\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppbk70c1c.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmppbk70c1c.scala:84:5 ---------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val newArr = new\
    \ Array[Long](n)\n        var i = 0\n        var j = 0\n        var k = 0\n  \
    \      var temp = 0\n        var flag = true\n        var temp1 = new Array[Long](n)\n\
    \        var temp2 = new Array[Long](n)\n        var temp3 = new Array[Long](n)\n\
    \        var temp4 = new Array[Long](n)\n        var temp5 = new Array[Long](n)\n\
    \        var temp6 = new Array[Long](n)\n        var temp7 = new Array[Long](n)\n\
    \        var temp8 = new Array[Long](n)\n        var temp9 = new Array[Long](n)\n\
    \        var temp10 = new Array[Long](n)\n        var temp11 = new Array[Long](n)\n\
    \        var temp12 = new Array[Long](n)\n        var temp13 = new Array[Long](n)\n\
    \        var temp14 = new Array[Long](n)\n        var temp15 = new Array[Long](n)\n\
    \        var temp16 = new Array[Long](n)\n        var temp17 = new Array[Long](n)\n\
    \        var temp18 = new Array[Long](n)\n        var temp19 = new Array[Long](n)\n\
    \        var temp20 = new Array[Long](n)\n        var temp21 = new Array[Long](n)\n\
    \        var temp22 = new Array[Long](n)\n        var temp23 = new Array[Long](n)\n\
    \        var temp24 = new Array[Long](n)\n        var temp25 = new Array[Long](n)\n\
    \        var temp26 = new Array[Long](n)\n        var temp27 = new Array[Long](n)\n\
    \        var temp28 = new Array[Long](n)\n        var temp29 = new Array[Long](n)\n\
    \        var temp30 = new Array[Long](n)\n        var temp31 = new Array[Long](n)\n\
    \        var temp32 = new Array[Long](n)\n        var temp33 = new Array[Long](n)\n\
    \        var temp34 = new Array[Long](n)\n        var temp35 = new Array[Long](n)\n\
    \        var temp36 = new Array[Long](n)\n        var temp37 = new Array[Long](n)\n\
    \        var temp38 = new Array[Long](n)\n        var temp39 = new Array[Long](n)\n\
    \        var temp40 = new Array[Long](n)\n        var temp41 = new Array[Long](n)\n\
    \        var temp42 = new Array[Long](n)\n        var temp43 = new Array[Long](n)\n\
    \        var temp44 = new Array[Long](n)\n        var temp45 = new Array[Long](n)\n\
    \        var temp46 = new Array[Long\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu4ewvybg.scala:81:4 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpu4ewvybg.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpu4ewvybg.scala:80:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m        \e[33mvar\e[0m \e[36mtemp46\e[0m = \e[33mnew\e\
    [0m \e[35mArray\e[0m[\e[35mLong\e[0m\n\e[31m\e[31m   |\e[0m                  \
    \   ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument for parameter _length\
    \ of \e[33mconstructor\e[0m \e[35mArray\e[0m in \e[33mclass\e[0m \e[35mArray\e\
    [0m: (_length: Int): Array[Long]\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu4ewvybg.scala:81:5\
    \ ---------------------\e[0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659798055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val len = arr.length\n\
    \        if (len == 0) true\n        else {\n            val mid = len/2\n   \
    \         val left = arr.take(mid)\n            val right = arr.drop(mid)\n  \
    \          val leftSorted = left.sortBy(x => x)\n            val rightSorted =\
    \ right.sortBy(x => x)\n            if (leftSorted.last < rightSorted.last) moveOneBall(leftSorted)\n\
    \            else moveOneBall(rightSorted)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: last of empty list\n\tat scala.collection.immutable.Nil$.last(List.scala:665)\n\
    \tat scala.collection.immutable.Nil$.last(List.scala:661)\n\tat Problem$.moveOneBall(tmp8j13dzhg.scala:34)\n\
    \tat Problem$.main(tmp8j13dzhg.scala:39)\n\tat Problem.main(tmp8j13dzhg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:34:12 ----------"
  stdout: ''
  timestamp: 1659797997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        if (n == 0) {\n            return true\n        }\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val left = 0\n        val\
    \ right = len - 2\n        val mid = len / 2\n        val leftRight = len - 1\n\
    \        val leftRightLeft = len - 2\n        val leftRightRight = len - 3\n \
    \       val leftRightLeftRight = len - 4\n        val leftRightLeftLeftRight =\
    \ len - 5\n        val leftRightLeftLeftLeftRight = len - 6\n        val leftRightLeftLeftLeftLeftRight\
    \ = len - 7\n        val leftRightLeftLeftLeftLeftLeftRight = len - 8\n      \
    \  val leftRightLeftLeftLeftLeftLeftRight = len - 9\n        val leftRightLeftLeftLeftLeftLeftRight\
    \ = len - 10\n        val leftRightLeftLeftLeftLeftLeftRight = len - 11\n    \
    \    val leftRightLeftLeftLeftLeftLeftRight = len - 12\n        val leftRightLeftLeftLeftLeftLeftRight\
    \ = len - 13\n        val leftRightLeftLeftLeftLeftLeftRight = len - 14\n    \
    \    val leftRightLeftLeftLeftLeftLeftRight = len - 15\n        val leftRightLeftLeftLeftLeftLeftRight\
    \ = len - 16\n        val leftRightLeftLeftLeftLeftLeftRight = len - 17\n    \
    \    val leftRightLeftLeftLeftLeftLeftRight = len - 18\n        val leftRightLeftLeftLeftLeftLeftRight\
    \ = len - 19\n        val leftRightLeftLeftLeftLeftLeftRight = len - 20\n    \
    \    val leftRightLeftLeftLeftLeftLeftRight = len - 21\n        val leftRightLeftLeftLeftLeftLeftRight\
    \ = len - 22\n        val leftRightLeftLeftLeftLeftLeftRight = len - 23\n    \
    \    val leftRightLeftLeftLeftLeftLeftRight = len - 24\n        val leftRightLeftLeftLeftLeftLeftRight\
    \ = len - 25\n        val leftRightLeftLeftLeftLeftLeftRight = len - 26\n    \
    \    val leftRightLeftLeftLeftLeftLeftRight = len - 27\n        val leftRightLeftLeftLeftLeftLeftRight\
    \ = len - 28\n        val leftRightLeftLeftLeftLeftLeftRight = len - 29\n    \
    \    val leftRightLeftLeftLeftLeftLeftRight = len - 30\n        val leftRightLeftLeftLeftLeftLeftRight\
    \ = len - 31\n        val leftRightLeftLeftLeftLeftLeftRight = len - 32\n    \
    \    val leftRightLeftLeftLeftLeftLeftRight = len - 33\n        val leftRightLeftLeftLeftLeftLeftRight\
    \ = len - 34\n        val leftRightLeftLeftLeftLeftLeftRight = len - 35\n    \
    \    val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpxmc4zvbw.scala:70:11 ---------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpxmc4zvbw.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mleftRightLeftLeftLeftLeftLeftRight\e\
    [0m = len - \e[31m9\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftRightLeftLeftLeftLeftLeftRight is already defined as \e\
    [33mvalue\e[0m \e[35mleftRightLeftLeftLeftLeftLeftRight\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxmc4zvbw.scala:44:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mleftRightLeftLeftLeftLeftLeftRight\e[0m = len - \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mleftRightLeftLeftLeftLeftLeftRight is already defined as \e[33mvalue\e\
    [0m \e[35mleftRightLeftLeftLeftLeftLeftRight\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxmc4zvbw.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36mleftRightLeftLeftLeftLeftLeftRight\e[0m = len - \e[31m11\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mleftRightLeftLeftLeftLeftLeftRight is already defined as \e[33mvalue\e\
    [0m \e[35mleftRightLeftLeftLeftLeftLeftRight\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxmc4zvbw.scala:46:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m\
    \ \e[36mleftRightLeftLeftLeftLeftLeftRight\e[0m = l"
  stdout: ''
  timestamp: 1659798056
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:34:12 ----------"
  stdout: ''
  timestamp: 1659797997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val r = new Array[Long](n)\n        var i =\
    \ 0\n        var j = 0\n        var k = 0\n        var temp = 0\n        while(i\
    \ < n) {\n            while(j < n) {\n                if(arr(i) < arr(j)) {\n\
    \                    temp = arr(i)\n                    arr(i) = arr(j)\n    \
    \                arr(j) = temp\n                    j++\n                }\n \
    \               else {\n                    j++\n                }\n         \
    \   }\n            k = i\n            while(k >= 0 && arr(k) < m) {\n        \
    \        arr(k) = arr(k - 1)\n                k--\n            }\n           \
    \ i = k + 1\n            j = 0\n        }\n        arr.toList.sortWith(_ < _)\n\
    \        arr.toList.forall(x => x == m)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp85fxx4is.scala:39:23 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp85fxx4is.scala:42:23 ---------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp85fxx4is.scala:48:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m48 |\e[0m                k--\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp85fxx4is.scala:36:30 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                    temp = arr(i)\n\e[31m\e[31m   |\e\
    [0m                           ^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \        Found:    Long\n\e[31m   |\e[0m                           Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp85fxx4is.scala:37:20\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m                    arr(i)\
    \ = arr(j)\n\e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m\
    \  value update is not a member of List[Long] - did you mean arr.updated?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp85fxx4is.scala:38:20 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                    arr(j) = temp\n\e[31m\e[31m   |\e\
    [0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp85fxx4is"
  stdout: ''
  timestamp: 1659798057
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr2 = arr.toList\n\
    \        val arr3 = arr2.reverse\n        val arr4 = arr3.toList\n        val\
    \ arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n        val arr7 = arr6.reverse\n\
    \        val arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n        val\
    \ arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n        val arr12 =\
    \ arr11.reverse\n        val arr13 = arr12.reverse\n        val arr14 = arr13.reverse\n\
    \        val arr15 = arr14.reverse\n        val arr16 = arr15.reverse\n      \
    \  val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n        val arr19\
    \ = arr18.reverse\n        val arr20 = arr19.reverse\n        val arr21 = arr20.reverse\n\
    \        val arr22 = arr21.reverse\n        val arr23 = arr22.reverse\n      \
    \  val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n        val arr26\
    \ = arr25.reverse\n        val arr27 = arr26.reverse\n        val arr28 = arr27.reverse\n\
    \        val arr29 = arr28.reverse\n        val arr30 = arr29.reverse\n      \
    \  val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n        val arr33\
    \ = arr32.reverse\n        val arr34 = arr33.reverse\n        val arr35 = arr34.reverse\n\
    \        val arr36 = arr35.reverse\n        val arr37 = arr36.reverse\n      \
    \  val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n        val arr40\
    \ = arr39.reverse\n        val arr41 = arr40.reverse\n        val arr42 = arr41.reverse\n\
    \        val arr43 = arr42.reverse\n        val arr44 = arr43.reverse\n      \
    \  val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n        val arr47\
    \ = arr46.reverse\n        val arr48 = arr47.reverse\n        val arr49 = arr48.reverse\n\
    \        val arr50 = arr49.reverse\n        val arr51 = arr50.reverse\n      \
    \  val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n        val arr54\
    \ = arr53.reverse\n        val arr55 = arr54.reverse\n        val arr56 = arr55.reverse\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp48gz978y.scala:84:11 ---------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp48gz978y.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp48gz978y.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798057
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr1 = arr.tail\n        val arr2 = arr1.tail\n\
    \        val arr3 = arr2.tail\n        val arr4 = arr3.tail\n        val arr5\
    \ = arr4.tail\n        val arr6 = arr5.tail\n        val arr7 = arr6.tail\n  \
    \      val arr8 = arr7.tail\n        val arr9 = arr8.tail\n        val arr10 =\
    \ arr9.tail\n        val arr11 = arr10.tail\n        val arr12 = arr11.tail\n\
    \        val arr13 = arr12.tail\n        val arr14 = arr13.tail\n        val arr15\
    \ = arr14.tail\n        val arr16 = arr15.tail\n        val arr17 = arr16.tail\n\
    \        val arr18 = arr17.tail\n        val arr19 = arr18.tail\n        val arr20\
    \ = arr19.tail\n        val arr21 = arr20.tail\n        val arr22 = arr21.tail\n\
    \        val arr23 = arr22.tail\n        val arr24 = arr23.tail\n        val arr25\
    \ = arr24.tail\n        val arr26 = arr25.tail\n        val arr27 = arr26.tail\n\
    \        val arr28 = arr27.tail\n        val arr29 = arr28.tail\n        val arr30\
    \ = arr29.tail\n        val arr31 = arr30.tail\n        val arr32 = arr31.tail\n\
    \        val arr33 = arr32.tail\n        val arr34 = arr33.tail\n        val arr35\
    \ = arr34.tail\n        val arr36 = arr35.tail\n        val arr37 = arr36.tail\n\
    \        val arr38 = arr37.tail\n        val arr39 = arr38.tail\n        val arr40\
    \ = arr39.tail\n        val arr41 = arr40.tail\n        val arr42 = arr41.tail\n\
    \        val arr43 = arr42.tail\n        val arr44 = arr43.tail\n        val arr45\
    \ = arr44.tail\n        val arr46 = arr45.tail\n        val arr47 = arr46.tail\n\
    \        val arr48 = arr47.tail\n        val arr49 = arr48.tail\n        val arr50\
    \ = arr49.tail\n        val arr51 = arr50.tail\n        val arr52 = arr51.tail\n\
    \        val arr53 = arr52.tail\n        val arr54 = arr53.tail\n        val arr55\
    \ = arr54.tail\n        val arr56 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqewu6btc.scala:83:19 ---------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m        \e[33mval\e[0m \e[36marr56\e[0m = \n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqewu6btc.scala:84:5 ---------------------\e[0m\e[0m\n\e[31m84\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798037
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val r = arr.last\n        val s = arr.init\n\
    \        val t = arr.tail\n        val u = arr.init\n        val v = arr.tail\n\
    \        val w = arr.init\n        val x = arr.tail\n        val y = arr.init\n\
    \        val z = arr.tail\n        val a = arr.init\n        val b = arr.tail\n\
    \        val c = arr.init\n        val d = arr.tail\n        val e = arr.init\n\
    \        val f = arr.tail\n        val g = arr.init\n        val h = arr.tail\n\
    \        val i = arr.init\n        val j = arr.tail\n        val k = arr.init\n\
    \        val l = arr.tail\n        val m = arr.init\n        val n = arr.tail\n\
    \        val o = arr.init\n        val p = arr.tail\n        val q = arr.init\n\
    \        val r = arr.tail\n        val s = arr.init\n        val t = arr.tail\n\
    \        val u = arr.init\n        val v = arr.tail\n        val w = arr.init\n\
    \        val x = arr.tail\n        val y = arr.init\n        val z = arr.tail\n\
    \        val a = arr.init\n        val b = arr.tail\n        val c = arr.init\n\
    \        val d = arr.tail\n        val e = arr.init\n        val f = arr.tail\n\
    \        val g = arr.init\n        val h = arr.tail\n        val i = arr.init\n\
    \        val j = arr.tail\n        val k = arr.init\n        val l = arr.tail\n\
    \        val m = arr.init\n        val n = arr.tail\n        val o = arr.init\n\
    \        val p = arr.tail\n        val q = arr.init\n        val r = arr.tail\n\
    \        val s = arr.init\n        val t = arr.tail\n        val u = arr.init\n\
    \        val v = arr.tail\n        val w = arr.init\n        val x = arr.tail\n\
    \        val y = arr.init\n        val z = arr.tail\n        val a = arr.init\n\
    \        val b = arr.tail\n        val c = arr.init\n        val d = arr.tail\n\
    \        val e = arr.init\n        val f = arr.tail\n        val g = arr.init\n\
    \        val h = arr.tail\n        val i = arr.init\n        val j = arr.tail\n\
    \        val k = arr.init\n        val l = arr.tail\n        val m = arr.init\n\
    \        val n = arr.tail\n        val o = arr.init\n        val p = arr.tail\n\
    \        val q = arr.init\n        val r = arr.tail\n        val s = arr.init\n\
    \        val t = arr.tail\n        val u = arr.init\n        val v = arr.tail\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpqili2xi_.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqili2xi_.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqili2xi_.scala:50:12 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqili2xi_.scala:54:12 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqili2xi_.scala:55:12 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqili2xi_.scala:56:12 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m        \e[33mval\e[0m \e[36mt\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659798043
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr1 = arr.toList\n\
    \        val arr2 = arr1.reverse\n        val arr3 = arr2.reverse\n        val\
    \ arr4 = arr3.reverse\n        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n\
    \        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val\
    \ arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n\
    \        val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n      \
    \  val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16\
    \ = arr15.reverse\n        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n\
    \        val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n      \
    \  val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23\
    \ = arr22.reverse\n        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n\
    \        val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n      \
    \  val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30\
    \ = arr29.reverse\n        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n\
    \        val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n      \
    \  val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37\
    \ = arr36.reverse\n        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n\
    \        val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n      \
    \  val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44\
    \ = arr43.reverse\n        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n\
    \        val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n      \
    \  val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51\
    \ = arr50.reverse\n        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n\
    \        val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n      \
    \  val arr5\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph5mcw5ze.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmph5mcw5ze.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph5mcw5ze.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val max = (len - 1).toLong\n        val\
    \ min = 0l\n        val max1 = (len - 1).toLong\n        val max2 = (len - 2).toLong\n\
    \        val max3 = (len - 3).toLong\n        val max4 = (len - 4).toLong\n  \
    \      val max5 = (len - 5).toLong\n        val max6 = (len - 6).toLong\n    \
    \    val max7 = (len - 7).toLong\n        val max8 = (len - 8).toLong\n      \
    \  val max9 = (len - 9).toLong\n        val max10 = (len - 10).toLong\n      \
    \  val max11 = (len - 11).toLong\n        val max12 = (len - 12).toLong\n    \
    \    val max13 = (len - 13).toLong\n        val max14 = (len - 14).toLong\n  \
    \      val max15 = (len - 15).toLong\n        val max16 = (len - 16).toLong\n\
    \        val max17 = (len - 17).toLong\n        val max18 = (len - 18).toLong\n\
    \        val max19 = (len - 19).toLong\n        val max20 = (len - 20).toLong\n\
    \        val max21 = (len - 21).toLong\n        val max22 = (len - 22).toLong\n\
    \        val max23 = (len - 23).toLong\n        val max24 = (len - 24).toLong\n\
    \        val max25 = (len - 25).toLong\n        val max26 = (len - 26).toLong\n\
    \        val max27 = (len - 27).toLong\n        val max28 = (len - 28).toLong\n\
    \        val max29 = (len - 29).toLong\n        val max30 = (len - 30).toLong\n\
    \        val max31 = (len - 31).toLong\n        val max32 = (len - 32).toLong\n\
    \        val max33 = (len - 33).toLong\n        val max34 = (len - 34).toLong\n\
    \        val max35 = (len - 35).toLong\n        val max36 = (len - 36).toLong\n\
    \        val max37 = (len - 37).toLong\n        val max38 = (len - 38).toLong\n\
    \        val max39 = (len - 39).toLong\n        val max40 = (len - 40).toLong\n\
    \        val max41 = (len - 41).toLong\n        val max42 = (len - 42).toLong\n\
    \        val max43 = (len - 43).toLong\n        val max44 = (len - 44).toLong\n\
    \        val max45 = (len - 45).toLong\n        val max46 = (len - 46).toLong\n\
    \        val max47 = (len - 47).toLong\n        val max48 = (len - 48).toLong\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpsmgulr3r.scala:78:11 ---------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsmgulr3r.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpsmgulr3r.scala:79:5 ---------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798056
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38v4qy1t.scala:34:12 ----------"
  stdout: ''
  timestamp: 1659797997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        if (n == 0) true\n        else {\n            val first = arr(0)\n  \
    \          val last = arr(n)\n            val mid = first + last\n           \
    \ val left = arr.filter(_ != mid)\n            val right = arr.filter(_ != mid).reverse\n\
    \            val leftSorted = moveOneBall(left)\n            val rightSorted =\
    \ moveOneBall(right)\n            if (leftSorted && rightSorted) true\n      \
    \      else moveOneBall(leftSorted) || moveOneBall(rightSorted)\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_qdyp38b.scala:37:29\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m moveOneBall(leftSorted)\
    \ || moveOneBall(rightSorted)\n\e[31m\e[31m   |\e[0m                         \
    \    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             Found:    (leftSorted\
    \ : Boolean)\n\e[31m   |\e[0m                             Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_qdyp38b.scala:37:56\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m moveOneBall(leftSorted)\
    \ || moveOneBall(rightSorted)\n\e[31m\e[31m   |\e[0m                         \
    \                               ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                           Found:    (rightSorted : Boolean)\n\e[31m   |\e[0m\
    \                                       Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val result = new Array[Long](n)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n        while(i\
    \ < n) {\n            while(j < n) {\n                temp = 0\n             \
    \   while(k <= j) {\n                    temp = temp + arr(k)\n              \
    \      k = k + 1\n                }\n                if(temp < m) {\n        \
    \            result(i) = temp\n                    i = i + 1\n               \
    \     j = j + 1\n                }\n                else {\n                 \
    \   result(i) = m\n                    i = i + 1\n                }\n        \
    \    }\n        }\n        if(result.length == n) {\n            return true\n\
    \        }\n        else {\n            return false\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp71g0s0w3.scala:37:27\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m                    temp = temp\
    \ + arr(k)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Found:    Long\n\e[31m   |\e[0m    \
    \                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798057
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val newArr = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr2 = new mutable.ArrayBuffer[Long]()\n        val newArr3 =\
    \ new mutable.ArrayBuffer[Long]()\n        val newArr4 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr5 = new mutable.ArrayBuffer[Long]()\n        val newArr6 =\
    \ new mutable.ArrayBuffer[Long]()\n        val newArr7 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr8 = new mutable.ArrayBuffer[Long]()\n        val newArr9 =\
    \ new mutable.ArrayBuffer[Long]()\n        val newArr10 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr11 = new mutable.ArrayBuffer[Long]()\n        val newArr12\
    \ = new mutable.ArrayBuffer[Long]()\n        val newArr13 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr14 = new mutable.ArrayBuffer[Long]()\n        val newArr15\
    \ = new mutable.ArrayBuffer[Long]()\n        val newArr16 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr17 = new mutable.ArrayBuffer[Long]()\n        val newArr18\
    \ = new mutable.ArrayBuffer[Long]()\n        val newArr19 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr20 = new mutable.ArrayBuffer[Long]()\n        val newArr21\
    \ = new mutable.ArrayBuffer[Long]()\n        val newArr22 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr23 = new mutable.ArrayBuffer[Long]()\n        val newArr24\
    \ = new mutable.ArrayBuffer[Long]()\n        val newArr25 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr26 = new mutable.ArrayBuffer[Long]()\n        val newArr27\
    \ = new mutable.ArrayBuffer[Long]()\n        val newArr28 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr29 = new mutable.ArrayBuffer[Long]()\n        val newArr30\
    \ = new mutable.ArrayBuffer[Long]()\n        val newArr31 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr32 = new mutable.ArrayBuffer[Long]()\n        val newArr33\
    \ = new mutable.ArrayBuffer[Long]()\n        val newArr34 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr35 = new mutable.ArrayBuffer[Long]()\n        val newArr36\
    \ = new mut\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5lg8xi7n.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5lg8xi7n.scala:28:25 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mnewArr\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5lg8xi7n.scala:29:26\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mnewArr2\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp5lg8xi7n.scala:30:26 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mnewArr3\e[0m = \e[33mnew\e[0m\
    \ mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5lg8xi7n.scala:31:26\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mnewArr4\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp5lg8xi7n.scala:32:26 "
  stdout: ''
  timestamp: 1659798057
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi_gm8d0s.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi_gm8d0s.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi_gm8d0s.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi_gm8d0s.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi_gm8d0s.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi_gm8d0s.scala:33:12 ----------"
  stdout: ''
  timestamp: 1659798058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val max =\
    \ (len - 1).toLong\n        val min = max\n        val maxVal = arr(max)\n   \
    \     val minVal = arr(min)\n        val maxValIndex = arr.lastIndexOf(maxVal)\n\
    \        val minValIndex = arr.lastIndexOf(minVal)\n        val maxValIndex2 =\
    \ arr.lastIndexOf(maxVal, maxValIndex + 1)\n        val minValIndex2 = arr.lastIndexOf(minVal,\
    \ minValIndex + 1)\n        val maxValIndex3 = arr.lastIndexOf(maxVal, maxValIndex\
    \ + 2)\n        val minValIndex3 = arr.lastIndexOf(minVal, minValIndex + 2)\n\
    \        val maxValIndex4 = arr.lastIndexOf(maxVal, maxValIndex + 3)\n       \
    \ val minValIndex4 = arr.lastIndexOf(minVal, minValIndex + 3)\n        val maxValIndex5\
    \ = arr.lastIndexOf(maxVal, maxValIndex + 4)\n        val minValIndex5 = arr.lastIndexOf(minVal,\
    \ minValIndex + 4)\n        val maxValIndex6 = arr.lastIndexOf(maxVal, maxValIndex\
    \ + 5)\n        val minValIndex6 = arr.lastIndexOf(minVal, minValIndex + 5)\n\
    \        val maxValIndex7 = arr.lastIndexOf(maxVal, maxValIndex + 6)\n       \
    \ val minValIndex7 = arr.lastIndexOf(minVal, minValIndex + 6)\n        val maxValIndex8\
    \ = arr.lastIndexOf(maxVal, maxValIndex + 7)\n        val minValIndex8 = arr.lastIndexOf(minVal,\
    \ minValIndex + 7)\n        val maxValIndex9 = arr.lastIndexOf(maxVal, maxValIndex\
    \ + 8)\n        val minValIndex9 = arr.lastIndexOf(minVal, minValIndex + 8)\n\
    \        val maxValIndex10 = arr.lastIndexOf(maxVal, maxValIndex + 9)\n      \
    \  val minValIndex10 = arr.lastIndexOf(minVal, minValIndex + 9)\n        val maxValIndex11\
    \ = arr.lastIndexOf(maxVal, maxValIndex + 10)\n        val minValIndex11 = arr.lastIndexOf(minVal,\
    \ minValIndex + 10)\n        val maxValIndex12 = arr.lastIndexOf(maxVal, maxValIndex\
    \ + 11)\n        val minValIndex12 = arr.lastIndexOf(minVal, minValIndex + 11)\n\
    \        val maxValIndex13 = arr.lastIndexOf(maxVal, maxValIndex + 12)\n     \
    \   val minValIndex13 = arr.lastIndexOf(minVal, minValIndex + 12)\n        val\
    \ maxValIndex\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxb74bl78.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxb74bl78.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxb74bl78.scala:60:5\
    \ ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr1 = arr.tail\n        val arr2 = arr1.tail\n\
    \        val arr3 = arr2.tail\n        val arr4 = arr3.tail\n        val arr5\
    \ = arr4.tail\n        val arr6 = arr5.tail\n        val arr7 = arr6.tail\n  \
    \      val arr8 = arr7.tail\n        val arr9 = arr8.tail\n        val arr10 =\
    \ arr9.tail\n        val arr11 = arr10.tail\n        val arr12 = arr11.tail\n\
    \        val arr13 = arr12.tail\n        val arr14 = arr13.tail\n        val arr15\
    \ = arr14.tail\n        val arr16 = arr15.tail\n        val arr17 = arr16.tail\n\
    \        val arr18 = arr17.tail\n        val arr19 = arr18.tail\n        val arr20\
    \ = arr19.tail\n        val arr21 = arr20.tail\n        val arr22 = arr21.tail\n\
    \        val arr23 = arr22.tail\n        val arr24 = arr23.tail\n        val arr25\
    \ = arr24.tail\n        val arr26 = arr25.tail\n        val arr27 = arr26.tail\n\
    \        val arr28 = arr27.tail\n        val arr29 = arr28.tail\n        val arr30\
    \ = arr29.tail\n        val arr31 = arr30.tail\n        val arr32 = arr31.tail\n\
    \        val arr33 = arr32.tail\n        val arr34 = arr33.tail\n        val arr35\
    \ = arr34.tail\n        val arr36 = arr35.tail\n        val arr37 = arr36.tail\n\
    \        val arr38 = arr37.tail\n        val arr39 = arr38.tail\n        val arr40\
    \ = arr39.tail\n        val arr41 = arr40.tail\n        val arr42 = arr41.tail\n\
    \        val arr43 = arr42.tail\n        val arr44 = arr43.tail\n        val arr45\
    \ = arr44.tail\n        val arr46 = arr45.tail\n        val arr47 = arr46.tail\n\
    \        val arr48 = arr47.tail\n        val arr49 = arr48.tail\n        val arr50\
    \ = arr49.tail\n        val arr51 = arr50.tail\n        val arr52 = arr51.tail\n\
    \        val arr53 = arr52.tail\n        val arr54 = arr53.tail\n        val arr55\
    \ = arr54.tail\n        val arr56 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5tu5ontz.scala:83:19 ---------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m        \e[33mval\e[0m \e[36marr56\e[0m = \n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp5tu5ontz.scala:84:5 ---------------------\e[0m\e[0m\n\e[31m84\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798059
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        if (n == 0) true\n        else {\n            val arr = arr.sortBy(x\
    \ => x)\n            val first = arr(0)\n            val last = arr(n)\n     \
    \       val mid = first + last\n            val diff = last - mid\n          \
    \  val newArr = arr.filterNot(x => x == mid)\n            if (diff == 0) moveOneBall(newArr)\n\
    \            else moveOneBall(newArr.filterNot(x => x == mid))\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpiqlufd45.scala:29:22 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m  \
    \ |\e[0m                      Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798057
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val leftMost = arr.head\n\
    \            val rightMost = arr.last\n            val leftMostIndex = arr.indexOf(0)\n\
    \            val rightMostIndex = arr.lastIndexOf(n)\n            val leftMostIndex\
    \ = arr.indexOf(0)\n            val rightMostIndex = arr.lastIndexOf(n)\n    \
    \        val leftMostIndex2 = arr.indexOf(0)\n            val rightMostIndex2\
    \ = arr.lastIndexOf(n)\n            val leftMostIndex3 = arr.indexOf(0)\n    \
    \        val rightMostIndex3 = arr.lastIndexOf(n)\n            val leftMostIndex4\
    \ = arr.indexOf(0)\n            val rightMostIndex4 = arr.lastIndexOf(n)\n   \
    \         val leftMostIndex5 = arr.indexOf(0)\n            val rightMostIndex5\
    \ = arr.lastIndexOf(n)\n            val leftMostIndex6 = arr.indexOf(0)\n    \
    \        val rightMostIndex6 = arr.lastIndexOf(n)\n            val leftMostIndex7\
    \ = arr.indexOf(0)\n            val rightMostIndex7 = arr.lastIndexOf(n)\n   \
    \         val leftMostIndex8 = arr.indexOf(0)\n            val rightMostIndex8\
    \ = arr.lastIndexOf(n)\n            val leftMostIndex9 = arr.indexOf(0)\n    \
    \        val rightMostIndex9 = arr.lastIndexOf(n)\n            val leftMostIndex10\
    \ = arr.indexOf(0)\n            val rightMostIndex10 = arr.lastIndexOf(n)\n  \
    \          val leftMostIndex11 = arr.indexOf(0)\n            val rightMostIndex11\
    \ = arr.lastIndexOf(n)\n            val leftMostIndex12 = arr.indexOf(0)\n   \
    \         val rightMostIndex12 = arr.lastIndexOf(n)\n            val leftMostIndex13\
    \ = arr.indexOf(0)\n            val rightMostIndex13 = arr.lastIndexOf(n)\n  \
    \          val leftMostIndex14 = arr.indexOf(0)\n            val rightMostIndex14\
    \ = arr.lastIndexOf(n)\n            val leftMostIndex15 = arr.indexOf(0)\n   \
    \         val rightMostIndex15 = arr.lastIndexOf(n)\n            val leftMostIndex16\
    \ = arr.indexOf(0)\n            val rightMostIndex16 = arr.lastIndexOf(n)\n  \
    \          val leftMostIndex17 = arr.indexOf(0)\n            val rightMostIndex17\
    \ = arr.lastIndexOf(n)\n            val leftMostIndex18 = arr.indexOf(0)\n   \
    \         val rightMostIndex18 = arr.lastIndexOf(n)\n            val leftMostIndex19\
    \ = arr.indexOf(0)\n            val rightMostIndex19 = arr.lastIndexOf(n)\n  \
    \          val leftMostIndex20 = arr.indexOf(0)\n            \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj_yvkji6.scala:83:0 ----------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj_yvkji6.scala:33:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m \e[36mleftMostIndex\e[0m = arr.indexOf(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mleftMostIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mleftMostIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj_yvkji6.scala:34:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e\
    [0m \e[36mrightMostIndex\e[0m = arr.lastIndexOf(n)\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrightMostIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mrightMostIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj_yvkji6.scala:82:1\
    \ ---------------------\e[0m\e[0m\n\e[31m82 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpj_yvkji6.scala:74:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m74 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659798062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val max = arr.max\n        val min = arr.min\n\
    \        val maxIndex = arr.lastIndex\n        val minIndex = arr.lastIndex\n\
    \        val maxIndex2 = arr.lastIndex\n        val minIndex2 = arr.lastIndex\n\
    \        val maxIndex3 = arr.lastIndex\n        val minIndex3 = arr.lastIndex\n\
    \        val maxIndex4 = arr.lastIndex\n        val minIndex4 = arr.lastIndex\n\
    \        val maxIndex5 = arr.lastIndex\n        val minIndex5 = arr.lastIndex\n\
    \        val maxIndex6 = arr.lastIndex\n        val minIndex6 = arr.lastIndex\n\
    \        val maxIndex7 = arr.lastIndex\n        val minIndex7 = arr.lastIndex\n\
    \        val maxIndex8 = arr.lastIndex\n        val minIndex8 = arr.lastIndex\n\
    \        val maxIndex9 = arr.lastIndex\n        val minIndex9 = arr.lastIndex\n\
    \        val maxIndex10 = arr.lastIndex\n        val minIndex10 = arr.lastIndex\n\
    \        val maxIndex11 = arr.lastIndex\n        val minIndex11 = arr.lastIndex\n\
    \        val maxIndex12 = arr.lastIndex\n        val minIndex12 = arr.lastIndex\n\
    \        val maxIndex13 = arr.lastIndex\n        val minIndex13 = arr.lastIndex\n\
    \        val maxIndex14 = arr.lastIndex\n        val minIndex14 = arr.lastIndex\n\
    \        val maxIndex15 = arr.lastIndex\n        val minIndex15 = arr.lastIndex\n\
    \        val maxIndex16 = arr.lastIndex\n        val minIndex16 = arr.lastIndex\n\
    \        val maxIndex17 = arr.lastIndex\n        val minIndex17 = arr.lastIndex\n\
    \        val maxIndex18 = arr.lastIndex\n        val minIndex18 = arr.lastIndex\n\
    \        val maxIndex19 = arr.lastIndex\n        val minIndex19 = arr.lastIndex\n\
    \        val maxIndex20 = arr.lastIndex\n        val minIndex20 = arr.lastIndex\n\
    \        val maxIndex21 = arr.lastIndex\n        val minIndex21 = arr.lastIndex\n\
    \        val maxIndex22 = arr.lastIndex\n        val minIndex22 = arr.lastIndex\n\
    \        val maxIndex23 = arr.lastIndex\n        val minIndex23 = arr.lastIndex\n\
    \        val maxIndex24 = arr.lastIndex\n        val minIndex24 = arr.lastIndex\n\
    \        val maxIndex25 = arr.lastIndex\n        val minIndex25 = arr.lastIndex\n\
    \        val maxIndex26 = arr.lastIndex\n        val minIndex26 = arr.lastIndex\n\
    \        val maxIndex27 = arr.lastIndex\n        val minIndex27 = arr.lastIndex\n\
    \        val maxIndex28 = arr.lastIndex\n        val minIndex28 = arr.lastIndex\n\
    \        val maxIndex29 = arr.lastIndex\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphysrqdjc.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmphysrqdjc.scala:88:5 ---------------------\e\
    [0m\e[0m\n\e[31m88 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797996
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val m = arr.head\n        val r = arr.last\n\
    \        val s = arr.init\n        val t = arr.tail\n        val m = arr.head\n\
    \        val r = arr.last\n        val s = arr.init\n        val t = arr.tail\n\
    \        val m = arr.head\n        val r = arr.last\n        val s = arr.init\n\
    \        val t = arr.tail\n        val m = arr.head\n        val r = arr.last\n\
    \        val s = arr.init\n        val t = arr.tail\n        val m = arr.head\n\
    \        val r = arr.last\n        val s = arr.init\n        val t = arr.tail\n\
    \        val m = arr.head\n        val r = arr.last\n        val s = arr.init\n\
    \        val t = arr.tail\n        val m = arr.head\n        val r = arr.last\n\
    \        val s = arr.init\n        val t = arr.tail\n        val m = arr.head\n\
    \        val r = arr.last\n        val s = arr.init\n        val t = arr.tail\n\
    \        val m = arr.head\n        val r = arr.last\n        val s = arr.init\n\
    \        val t = arr.tail\n        val m = arr.head\n        val r = arr.last\n\
    \        val s = arr.init\n        val t = arr.tail\n        val m = arr.head\n\
    \        val r = arr.last\n        val s = arr.init\n        val t = arr.tail\n\
    \        val m = arr.head\n        val r = arr.last\n        val s = arr.init\n\
    \        val t = arr.tail\n        val m = arr.head\n        val r = arr.last\n\
    \        val s = arr.init\n        val t = arr.tail\n        val m = arr.head\n\
    \        val r = arr.last\n        val s = arr.init\n        val t = arr.tail\n\
    \        val m = arr.head\n        val r = arr.last\n        val s = arr.init\n\
    \        val t = arr.tail\n        val m = arr.head\n        val r = arr.last\n\
    \        val s = arr.init\n        val t = arr.tail\n        val m = arr.head\n\
    \        val r = arr.last\n        val s = arr.init\n        val t = arr.tail\n\
    \        val m = arr.head\n        val r = arr.last\n        val s = arr.init\n\
    \        val t = arr.tail\n        val m = arr.head\n        val r = arr.last\n\
    \        val s = arr.init\n        val t = arr.tail\n        val m = arr.head\n\
    \        val r = arr.last\n        val s = arr.init\n        val t = arr.tail\n\
    \        val m = arr.head\n        val r = arr.last\n        val s = arr.init\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt18i90re.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt18i90re.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt18i90re.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt18i90re.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mt\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mt is already defined\
    \ as \e[33mvalue\e[0m \e[35mt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt18i90re.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt18i90re.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m "
  stdout: ''
  timestamp: 1659798062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val r = arr.tail\n        val m = m.toLong\n\
    \        val r = r.toLong\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        val arr = new mutable.ListBuffer[Long]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp23tn2ddu.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = m.toLong\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp23tn2ddu.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r.toLong\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp23tn2ddu.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp23tn2ddu.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp23tn2ddu.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that over"
  stdout: ''
  timestamp: 1659798064
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        else {\n            val n = arr.size\n            val m = arr.head\n\
    \            val r = arr.tail\n            val l = (r.reverse).head\n        \
    \    val r1 = r.reverse\n            val r2 = r1.tail\n            val r3 = r2.reverse\n\
    \            val r4 = r3.tail\n            val r5 = r4.reverse\n            val\
    \ r6 = r5.tail\n            val r7 = r6.reverse\n            val r8 = r7.reverse\n\
    \            val r9 = r8.reverse\n            val r10 = r9.reverse\n         \
    \   val r11 = r10.reverse\n            val r12 = r11.reverse\n            val\
    \ r13 = r12.reverse\n            val r14 = r13.reverse\n            val r15 =\
    \ r14.reverse\n            val r16 = r15.reverse\n            val r17 = r16.reverse\n\
    \            val r18 = r17.reverse\n            val r19 = r18.reverse\n      \
    \      val r20 = r19.reverse\n            val r21 = r20.reverse\n            val\
    \ r22 = r21.reverse\n            val r23 = r22.reverse\n            val r24 =\
    \ r23.reverse\n            val r25 = r24.reverse\n            val r26 = r25.reverse\n\
    \            val r27 = r26.reverse\n            val r28 = r27.reverse\n      \
    \      val r29 = r28.reverse\n            val r30 = r29.reverse\n            val\
    \ r31 = r30.reverse\n            val r32 = r31.reverse\n            val r33 =\
    \ r32.reverse\n            val r34 = r33.reverse\n            val r35 = r34.reverse\n\
    \            val r36 = r35.reverse\n            val r37 = r36.reverse\n      \
    \      val r38 = r37.reverse\n            val r39 = r38.reverse\n            val\
    \ r40 = r39.reverse\n            val r41 = r40.reverse\n            val r42 =\
    \ r41.reverse\n            val r43 = r42.reverse\n            val r44 = r43.reverse\n\
    \            val r45 = r44.reverse\n            val r46 = r45.reverse\n      \
    \      val r47 = r46.reverse\n            val r48 = r47.reverse\n            val\
    \ r49 = r48.reverse\n            val r50 = r49.reverse\n            val r51 =\
    \ r50.reverse\n            val r52 = r51.reverse\n            val r53 = r52.reverse\n\
    \            val r54 = r53.reverse\n            val r55 = r54.reverse\n      \
    \      val r56 = r55.reverse\n            val r57 = r56.reverse\n            val\
    \ r58 = r57.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoy11ki80.scala:100:0 ---------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoy11ki80.scala:99:1\
    \ ---------------------\e[0m\e[0m\n\e[31m99 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpoy11ki80.scala:91:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m91 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1659798066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val r = new Array[Long](n)\n        val rr\
    \ = new Array[Long](n)\n        val rrr = new Array[Long](n)\n        val rrrr\
    \ = new Array[Long](n)\n        val rrrrr = new Array[Long](n)\n        val rrrrrr\
    \ = new Array[Long](n)\n        val rrrrrrr = new Array[Long](n)\n        val\
    \ rrrrrrrr = new Array[Long](n)\n        val rrrrrrrr = new Array[Long](n)\n \
    \       val rrrrrrrrr = new Array[Long](n)\n        val rrrrrrrrrr = new Array[Long](n)\n\
    \        val rrrrrrrrrr = new Array[Long](n)\n        val rrrrrrrrrr = new Array[Long](n)\n\
    \        val rrrrrrrrrrr = new Array[Long](n)\n        val rrrrrrrrrrr = new Array[Long](n)\n\
    \        val rrrrrrrrrrr = new Array[Long](n)\n        val rrrrrrrrrrrr = new\
    \ Array[Long](n)\n        val rrrrrrrrrrrr = new Array[Long](n)\n        val rrrrrrrrrrrrr\
    \ = new Array[Long](n)\n        val rrrrrrrrrrrrrr = new Array[Long](n)\n    \
    \    val rrrrrrrrrrrrrr = new Array[Long](n)\n        val rrrrrrrrrrrrrrr = new\
    \ Array[Long](n)\n        val rrrrrrrrrrrrrrrr = new Array[Long](n)\n        val\
    \ rrrrrrrrrrrrrrr = new Array[Long](n)\n        val rrrrrrrrrrrrrrrr = new Array[Long](n)\n\
    \        val rrrrrrrrrrrrrrrr = new Array[Long](n)\n        val rrrrrrrrrrrrrrrrr\
    \ = new Array[Long](n)\n        val rrrrrrrrrrrrrrrrrr = new Array[Long](n)\n\
    \        val rrrrrrrrrrrrrrrrrr = new Array[Long](n)\n        val rrrrrrrrrrrrrrrrrrr\
    \ = new Array[Long](n)\n        val rrrrrrrrrrrrrrrrrrrr = new Array[Long](n)\n\
    \        val rrrrrrrrrrrrrrrrrrrr = new Array[Long](n)\n        val rrrrrrrr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp94nmpt3c.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp94nmpt3c.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrrrrrrrr\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mrrrrrrrr is already defined as \e[33mvalue\e[0m \e[35mrrrrrrrr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp94nmpt3c.scala:39:12 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36mrrrrrrrrrr\e[0m = \e[33mnew\e[0m \e[35mArray\e\
    [0m[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrrrrrrrrrr is already defined as \e[33mvalue\e[0m \e[35mrrrrrrrrrr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp94nmpt3c.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mrrrrrrrrrr\e[0m = \e[33mnew\e[0m \e\
    [35mArray\e[0m[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrrrrrrrrrr is already defined as \e[33mvalue\e[0m \e[35mrrrrrrrrrr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp94nmpt3c.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36mrrrrrrrrrrr\e[0m = \e[33mnew\e[0m \e\
    [35mArray\e[0m[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrrrrrrrrrrr is already defined as \e[33mvalue\e[0m \e[35mrrrrrrrrrrr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitio"
  stdout: ''
  timestamp: 1659798066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val newArr = new mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while (i < len) {\n            val j = i\n       \
    \     while (j < len) {\n                if (arr(j) > arr(j + 1)) {\n        \
    \            newArr ++= arr(j + 1)\n                    arr(j + 1) = arr(j)\n\
    \                    arr(j) = 0\n                }\n                j += 1\n \
    \           }\n            i += 1\n        }\n        if (newArr.isEmpty) {\n\
    \            return true\n        }\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpe9s_78sn.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpe9s_78sn.scala:28:25 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mnewArr\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe9s_78sn.scala:38:18\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                j += \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m         \
    \       value += is not a member of Int - did you mean j.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659798066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val m = arr.size\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpy_mpc2jm.scala:99:17 ---------------------------\e\
    [0m\e[0m\n\e[31m99 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = \n\e[31m\e[31m\
    \   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpy_mpc2jm.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpy_mpc2jm.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy_mpc2jm.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy_mpc2jm.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy_mpc2jm.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m     "
  stdout: ''
  timestamp: 1659798066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        else {\n            val n = arr.length\n            val arr =\
    \ arr.toList\n            val len = arr.length\n            val arr = arr.toList\n\
    \            val len = arr.length\n            val arr = arr.toList\n        \
    \    val len = arr.length\n            val arr = arr.toList\n            val len\
    \ = arr.length\n            val arr = arr.toList\n            val len = arr.length\n\
    \            val arr = arr.toList\n            val len = arr.length\n        \
    \    val arr = arr.toList\n            val len = arr.length\n            val arr\
    \ = arr.toList\n            val len = arr.length\n            val arr = arr.toList\n\
    \            val len = arr.length\n            val arr = arr.toList\n        \
    \    val len = arr.length\n            val arr = arr.toList\n            val len\
    \ = arr.length\n            val arr = arr.toList\n            val len = arr.length\n\
    \            val arr = arr.toList\n            val len = arr.length\n        \
    \    val arr = arr.toList\n            val len = arr.length\n            val arr\
    \ = arr.toList\n            val len = arr.length\n            val arr = arr.toList\n\
    \            val len = arr.length\n            val arr = arr.toList\n        \
    \    val len = arr.length\n            val arr = arr.toList\n            val len\
    \ = arr.length\n            val arr = arr.toList\n            val len = arr.length\n\
    \            val arr = arr.toList\n            val len = arr.length\n        \
    \    val arr = arr.toList\n            val len = arr.length\n            val arr\
    \ = arr.toList\n            val len = arr.length\n            val arr = arr.toList\n\
    \            val len = arr.length\n            val arr = arr.toList\n        \
    \    val len = arr.length\n            val arr = arr.toList\n            val len\
    \ = arr.length\n            val arr = arr.toList\n            val len = arr.length\n\
    \            val arr = arr.toList\n            val len = arr.length\n        \
    \    val arr = arr.toList\n            val len = arr.length\n            val arr\
    \ = arr.toList\n            val len = arr.length\n            val arr = arr.toList\n\
    \            val len = arr.length\n            val arr = arr.toList\n        \
    \    val len = arr.length\n            val arr = arr.toList\n            val len\
    \ = arr.length\n            val arr = arr.toList\n            val len = arr.length\n\
    \            val arr = arr.toList\n            val len = arr.length\n        \
    \    val arr = arr.toList\n            val len = arr.length\n            val arr\
    \ = arr.toList\n            val len = arr.length\n            val arr = arr.toList\n\
    \            val len = arr.length\n            val arr = arr.toList\n        \
    \    val len = arr.length\n            val arr = arr.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5irym9pw.scala:106:4 ---------------------------\e\
    [0m\e[0m\n\e[31m106 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp5irym9pw.scala:116:0 ---------------------------\e[0m\e[0m\n\e[31m116\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5irym9pw.scala:31:16 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5irym9pw.scala:32:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp5irym9pw.scala:33:16 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m            \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5irym9pw.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen\
    \ is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5irym9pw."
  stdout: ''
  timestamp: 1659798068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr = arr.toList\n\
    \        val arr2 = arr.toSeq\n        val arr3 = arr.toArray\n        val arr4\
    \ = arr.toBuffer\n        val arr5 = arr.toList\n        val arr6 = arr.toSeq\n\
    \        val arr7 = arr.toArray\n        val arr8 = arr.toBuffer\n        val\
    \ arr9 = arr.toList\n        val arr10 = arr.toSeq\n        val arr11 = arr.toArray\n\
    \        val arr12 = arr.toBuffer\n        val arr13 = arr.toList\n        val\
    \ arr14 = arr.toSeq\n        val arr15 = arr.toArray\n        val arr16 = arr.toBuffer\n\
    \        val arr17 = arr.toList\n        val arr18 = arr.toSeq\n        val arr19\
    \ = arr.toArray\n        val arr20 = arr.toBuffer\n        val arr21 = arr.toList\n\
    \        val arr22 = arr.toSeq\n        val arr23 = arr.toArray\n        val arr24\
    \ = arr.toBuffer\n        val arr25 = arr.toList\n        val arr26 = arr.toSeq\n\
    \        val arr27 = arr.toArray\n        val arr28 = arr.toBuffer\n        val\
    \ arr29 = arr.toList\n        val arr30 = arr.toSeq\n        val arr31 = arr.toArray\n\
    \        val arr32 = arr.toBuffer\n        val arr33 = arr.toList\n        val\
    \ arr34 = arr.toSeq\n        val arr35 = arr.toArray\n        val arr36 = arr.toBuffer\n\
    \        val arr37 = arr.toList\n        val arr38 = arr.toSeq\n        val arr39\
    \ = arr.toArray\n        val arr40 = arr.toBuffer\n        val arr41 = arr.toList\n\
    \        val arr42 = arr.toSeq\n        val arr43 = arr.toArray\n        val arr44\
    \ = arr.toBuffer\n        val arr45 = arr.toList\n        val arr46 = arr.toSeq\n\
    \        val arr47 = arr.toArray\n        val arr48 = arr.toBuffer\n        val\
    \ arr49 = arr.toList\n        val arr50 = arr.toSeq\n        val arr51 = arr.toArray\n\
    \        val arr52 = arr.toBuffer\n        val arr53 = arr.toList\n        val\
    \ arr54 = arr.toSeq\n        val arr55 = arr.toArray\n        val arr56 = arr.toBuffer\n\
    \        val arr\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkpavquh3.scala:86:4 ----------------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkpavquh3.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpkpavquh3.scala:28:18 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m\
    \                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpkpavquh3.scala:86:5 ---------------------\e[0m\e[0m\n\e[31m86\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659798067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr2 = arr.toList\n\
    \        val arr3 = arr2.reverse\n        val arr4 = arr3.toList\n        val\
    \ arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n        val arr7 = arr6.reverse\n\
    \        val arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n        val\
    \ arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n        val arr12 =\
    \ arr11.reverse\n        val arr13 = arr12.reverse\n        val arr14 = arr13.reverse\n\
    \        val arr15 = arr14.reverse\n        val arr16 = arr15.reverse\n      \
    \  val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n        val arr19\
    \ = arr18.reverse\n        val arr20 = arr19.reverse\n        val arr21 = arr20.reverse\n\
    \        val arr22 = arr21.reverse\n        val arr23 = arr22.reverse\n      \
    \  val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n        val arr26\
    \ = arr25.reverse\n        val arr27 = arr26.reverse\n        val arr28 = arr27.reverse\n\
    \        val arr29 = arr28.reverse\n        val arr30 = arr29.reverse\n      \
    \  val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n        val arr33\
    \ = arr32.reverse\n        val arr34 = arr33.reverse\n        val arr35 = arr34.reverse\n\
    \        val arr36 = arr35.reverse\n        val arr37 = arr36.reverse\n      \
    \  val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n        val arr40\
    \ = arr39.reverse\n        val arr41 = arr40.reverse\n        val arr42 = arr41.reverse\n\
    \        val arr43 = arr42.reverse\n        val arr44 = arr43.reverse\n      \
    \  val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n        val arr47\
    \ = arr46.reverse\n        val arr48 = arr47.reverse\n        val arr49 = arr48.reverse\n\
    \        val arr50 = arr49.reverse\n        val arr51 = arr50.reverse\n      \
    \  val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n        val arr54\
    \ = arr53.reverse\n        val arr55 = arr54.reverse\n        val arr56 = arr55.reverse\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpfdv8e_56.scala:84:11 ---------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfdv8e_56.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpfdv8e_56.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659797996
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr1 = arr.toList\n\
    \        val arr2 = arr1.reverse\n        val arr3 = arr2.toList\n        val\
    \ arr4 = arr3.reverse\n        val arr5 = arr4.toList\n        val arr6 = arr5.toList\n\
    \        val arr7 = arr6.reverse\n        val arr8 = arr7.toList\n        val\
    \ arr9 = arr8.reverse\n        val arr10 = arr9.toList\n        val arr11 = arr10.reverse\n\
    \        val arr12 = arr11.toList\n        val arr13 = arr12.reverse\n       \
    \ val arr14 = arr13.toList\n        val arr15 = arr14.reverse\n        val arr16\
    \ = arr15.toList\n        val arr17 = arr16.reverse\n        val arr18 = arr17.toList\n\
    \        val arr19 = arr18.reverse\n        val arr20 = arr19.toList\n       \
    \ val arr21 = arr20.reverse\n        val arr22 = arr21.toList\n        val arr23\
    \ = arr22.reverse\n        val arr24 = arr23.toList\n        val arr25 = arr24.reverse\n\
    \        val arr26 = arr25.toList\n        val arr27 = arr26.reverse\n       \
    \ val arr28 = arr27.toList\n        val arr29 = arr28.reverse\n        val arr30\
    \ = arr29.toList\n        val arr31 = arr30.reverse\n        val arr32 = arr31.toList\n\
    \        val arr33 = arr32.reverse\n        val arr34 = arr33.toList\n       \
    \ val arr35 = arr34.reverse\n        val arr36 = arr35.toList\n        val arr37\
    \ = arr36.reverse\n        val arr38 = arr37.toList\n        val arr39 = arr38.reverse\n\
    \        val arr40 = arr39.toList\n        val arr41 = arr40.reverse\n       \
    \ val arr42 = arr41.toList\n        val arr43 = arr42.reverse\n        val arr44\
    \ = arr43.toList\n        val arr45 = arr44.reverse\n        val arr46 = arr45.toList\n\
    \        val arr47 = arr46.reverse\n        val arr48 = arr47.toList\n       \
    \ val arr49 = arr48.reverse\n        val arr50 = arr49.toList\n        val arr51\
    \ = arr50.reverse\n        val arr52 = arr51.toList\n        val arr53 = arr5\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4925gpvk.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp4925gpvk.scala:82:5 ---------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr1 = arr.tail\n        val arr2 = arr1.tail\n\
    \        val arr3 = arr2.tail\n        val arr4 = arr3.tail\n        val arr5\
    \ = arr4.tail\n        val arr6 = arr5.tail\n        val arr7 = arr6.tail\n  \
    \      val arr8 = arr7.tail\n        val arr9 = arr8.tail\n        val arr10 =\
    \ arr9.tail\n        val arr11 = arr10.tail\n        val arr12 = arr11.tail\n\
    \        val arr13 = arr12.tail\n        val arr14 = arr13.tail\n        val arr15\
    \ = arr14.tail\n        val arr16 = arr15.tail\n        val arr17 = arr16.tail\n\
    \        val arr18 = arr17.tail\n        val arr19 = arr18.tail\n        val arr20\
    \ = arr19.tail\n        val arr21 = arr20.tail\n        val arr22 = arr21.tail\n\
    \        val arr23 = arr22.tail\n        val arr24 = arr23.tail\n        val arr25\
    \ = arr24.tail\n        val arr26 = arr25.tail\n        val arr27 = arr26.tail\n\
    \        val arr28 = arr27.tail\n        val arr29 = arr28.tail\n        val arr30\
    \ = arr29.tail\n        val arr31 = arr30.tail\n        val arr32 = arr31.tail\n\
    \        val arr33 = arr32.tail\n        val arr34 = arr33.tail\n        val arr35\
    \ = arr34.tail\n        val arr36 = arr35.tail\n        val arr37 = arr36.tail\n\
    \        val arr38 = arr37.tail\n        val arr39 = arr38.tail\n        val arr40\
    \ = arr39.tail\n        val arr41 = arr40.tail\n        val arr42 = arr41.tail\n\
    \        val arr43 = arr42.tail\n        val arr44 = arr43.tail\n        val arr45\
    \ = arr44.tail\n        val arr46 = arr45.tail\n        val arr47 = arr46.tail\n\
    \        val arr48 = arr47.tail\n        val arr49 = arr48.tail\n        val arr50\
    \ = arr49.tail\n        val arr51 = arr50.tail\n        val arr52 = arr51.tail\n\
    \        val arr53 = arr52.tail\n        val arr54 = arr53.tail\n        val arr55\
    \ = arr54.tail\n        val arr56 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqewu6btc.scala:83:19 ---------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m        \e[33mval\e[0m \e[36marr56\e[0m = \n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqewu6btc.scala:84:5 ---------------------\e[0m\e[0m\n\e[31m84\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798037
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val r = new Array[Long](n)\n        var i =\
    \ 0\n        var j = 0\n        var k = 0\n        var temp = 0\n        var flag\
    \ = true\n        while(i < n && j < n) {\n            if(i == j) \n         \
    \       r(i) = arr(i)\n            else {\n                temp = arr(i)\n   \
    \             arr(i) = arr(j)\n                arr(j) = temp\n               \
    \ i += 1\n                j += 1\n            }\n        }\n        while(i <\
    \ n) {\n            temp = arr(i)\n            arr(i) = arr(n - 1)\n         \
    \   arr(n - 1) = temp\n            i -= 1\n        }\n        while(j < n) {\n\
    \            temp = arr(j)\n            arr(j) = arr(0)\n            arr(0) =\
    \ temp\n            j -= 1\n        }\n        for(i = k; i < n; i++) {\n    \
    \        if(r(i) < m) \n                flag = false\n        }\n        if(flag)\n\
    \            return true\n        else\n            return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6omc18o3.scala:57:14 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mfor\e[0m(i = k; i < n; i++) {\n\e[31m\e\
    [31m   |\e[0m              ^\e[0m\n\e[31m   |\e[0m              ')' expected,\
    \ but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6omc18o3.scala:57:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m57 |\e[0m        \e[33mfor\e[0m(i\
    \ = k; i < n; i++) {\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e\
    [31m   |\e[0m                        '<-' expected, but ';' found\n\e[31m\e[31m--\
    \ [E032] Syntax Error: /tmp/tmp6omc18o3.scala:57:29 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mfor\e[0m(i = k; i < n; i++) {\n\e[31m\e\
    [31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m            \
    \                 pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp6omc18o3.scala:38:26 --------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m                temp = arr(i)\n\e[31m\e[31m   |\e[0m                 \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m                       Found:    Long\n\e[31m\
    \   |\e[0m                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp6omc18o3.scala:39:16 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                arr(i) = arr(j)\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6omc18o3.scala:40:16\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                arr(j) =\
    \ temp\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp6omc18o3.scala:46:22 --------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m            temp = arr(i)\n\e[31m\e[31m   |\e[0m    \
    \               ^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:    Long\n\
    \e[31m   |\e[0m        "
  stdout: ''
  timestamp: 1659798070
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val d = arr.last\n        val r = arr.init\n\
    \        val s = arr.tail\n        val x = arr.init\n        val y = arr.tail\n\
    \        val z = arr.init\n        val w = arr.tail\n        val a = arr.init\n\
    \        val b = arr.tail\n        val c = arr.init\n        val d = arr.tail\n\
    \        val e = arr.init\n        val f = arr.tail\n        val g = arr.init\n\
    \        val h = arr.tail\n        val i = arr.init\n        val j = arr.tail\n\
    \        val k = arr.init\n        val l = arr.tail\n        val m = arr.init\n\
    \        val n = arr.tail\n        val o = arr.init\n        val p = arr.tail\n\
    \        val q = arr.init\n        val r = arr.tail\n        val s = arr.init\n\
    \        val t = arr.tail\n        val u = arr.init\n        val v = arr.tail\n\
    \        val w = arr.init\n        val x = arr.tail\n        val y = arr.init\n\
    \        val z = arr.tail\n        val a = arr.init\n        val b = arr.tail\n\
    \        val c = arr.init\n        val d = arr.tail\n        val e = arr.init\n\
    \        val f = arr.tail\n        val g = arr.init\n        val h = arr.tail\n\
    \        val i = arr.init\n        val j = arr.tail\n        val k = arr.init\n\
    \        val l = arr.tail\n        val m = arr.init\n        val n = arr.tail\n\
    \        val o = arr.init\n        val p = arr.tail\n        val q = arr.init\n\
    \        val r = arr.tail\n        val s = arr.init\n        val t = arr.tail\n\
    \        val u = arr.init\n        val v = arr.tail\n        val w = arr.init\n\
    \        val x = arr.tail\n        val y = arr.init\n        val z = arr.tail\n\
    \        val a = arr.init\n        val b = arr.tail\n        val c = arr.init\n\
    \        val d = arr.tail\n        val e = arr.init\n        val f = arr.tail\n\
    \        val g = arr.init\n        val h = arr.tail\n        val i = arr.init\n\
    \        val j = arr.tail\n        val k = arr.init\n        val l = arr.tail\n\
    \        val m = arr.init\n        val n = arr.tail\n        val o = arr.init\n\
    \        val p = arr.tail\n        val q = arr.init\n        val r = arr.tail\n\
    \        val s = arr.init\n        val t = arr.tail\n        val u = arr.init\n\
    \        val v = arr.tail\n        val w = arr.init\n        val x = arr.tail\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmph79z4y2g.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmph79z4y2g.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined\
    \ as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmph79z4y2g.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmph79z4y2g.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmph79z4y2g.scala:52:12 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmph79z4y2g.scala:53:12 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659798069
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.last\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.sortWith(_ < _)\n        val arr = arr.takeRight(n)\n        val arr =\
    \ arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n    \
    \    val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n    \
    \    val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n    \
    \    val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n    \
    \    val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n    \
    \    val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n    \
    \    val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n    \
    \    \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp16pmuc7h.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp16pmuc7h.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.takeRight(n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp16pmuc7h.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.takeRight(n)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp16pmuc7h.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.takeRight(n)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp16pmuc7h.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.takeRight(n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e["
  stdout: ''
  timestamp: 1659798068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr2 = arr.toList\n\
    \        val arr3 = arr2.reverse\n        val arr4 = arr3.toList\n        val\
    \ arr5 = arr4.reverse\n        val arr6 = arr5.toList\n        val arr7 = arr6.reverse\n\
    \        val arr8 = arr7.toList\n        val arr9 = arr8.reverse\n        val\
    \ arr10 = arr9.toList\n        val arr11 = arr10.reverse\n        val arr12 =\
    \ arr11.toList\n        val arr13 = arr12.reverse\n        val arr14 = arr13.toList\n\
    \        val arr15 = arr14.reverse\n        val arr16 = arr15.toList\n       \
    \ val arr17 = arr16.reverse\n        val arr18 = arr17.toList\n        val arr19\
    \ = arr18.reverse\n        val arr20 = arr19.toList\n        val arr21 = arr20.reverse\n\
    \        val arr22 = arr21.toList\n        val arr23 = arr22.reverse\n       \
    \ val arr24 = arr23.toList\n        val arr25 = arr24.reverse\n        val arr26\
    \ = arr25.toList\n        val arr27 = arr26.reverse\n        val arr28 = arr27.toList\n\
    \        val arr29 = arr28.reverse\n        val arr30 = arr29.toList\n       \
    \ val arr31 = arr30.reverse\n        val arr32 = arr31.toList\n        val arr33\
    \ = arr32.reverse\n        val arr34 = arr33.toList\n        val arr35 = arr34.reverse\n\
    \        val arr36 = arr35.toList\n        val arr37 = arr36.reverse\n       \
    \ val arr38 = arr37.toList\n        val arr39 = arr38.reverse\n        val arr40\
    \ = arr39.toList\n        val arr41 = arr40.reverse\n        val arr42 = arr41.toList\n\
    \        val arr43 = arr42.reverse\n        val arr44 = arr43.toList\n       \
    \ val arr45 = arr44.reverse\n        val arr46 = arr45.toList\n        val arr47\
    \ = arr46.reverse\n        val arr48 = arr47.toList\n        val arr49 = arr48.reverse\n\
    \        val arr50 = arr49.toList\n        val arr51 = arr50.reverse\n       \
    \ val arr52 = arr51.toList\n        val arr53 = arr52.reverse\n        val arr54\
    \ = arr\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpp_b5uq9l.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpp_b5uq9l.scala:82:5 ---------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val len = arr.length\n\
    \        if (len == 0) true\n        else {\n            val first = arr(0)\n\
    \            val last = arr(len - 1) \n            val mid = first + last\n  \
    \          val mid1 = mid - 1\n            val mid2 = mid + 1\n            val\
    \ mid3 = mid + 2\n            val mid4 = mid + 3\n            val mid5 = mid +\
    \ 4\n            val mid6 = mid + 5\n            val mid7 = mid + 6\n        \
    \    val mid8 = mid + 7\n            val mid9 = mid + 8\n            val mid10\
    \ = mid + 9\n            val mid11 = mid + 10\n            val mid12 = mid + 11\n\
    \            val mid13 = mid + 12\n            val mid14 = mid + 13\n        \
    \    val mid15 = mid + 14\n            val mid16 = mid + 15\n            val mid17\
    \ = mid + 16\n            val mid18 = mid + 17\n            val mid19 = mid +\
    \ 18\n            val mid20 = mid + 19\n            val mid21 = mid + 20\n   \
    \         val mid22 = mid + 21\n            val mid23 = mid + 22\n           \
    \ val mid24 = mid + 23\n            val mid25 = mid + 24\n            val mid26\
    \ = mid + 25\n            val mid27 = mid + 26\n            val mid28 = mid +\
    \ 27\n            val mid29 = mid + 28\n            val mid30 = mid + 29\n   \
    \         val mid31 = mid + 30\n            val mid32 = mid + 31\n           \
    \ val mid33 = mid + 32\n            val mid34 = mid + 33\n            val mid35\
    \ = mid + 34\n            val mid36 = mid + 35\n            val mid37 = mid +\
    \ 36\n            val mid38 = mid + 37\n            val mid39 = mid + 38\n   \
    \         val mid40 = mid + 39\n            val mid41 = mid + 40\n           \
    \ val mid42 = mid + 41\n            val mid43 = mid + 42\n            val mid44\
    \ = mid + 43\n            val mid45 = mid + 44\n            val mid46 = mid +\
    \ 45\n            val mid47 = mid + 46\n            val mid48 = mid + 47\n   \
    \         val mid49 = mid + 48\n            val mid50 = mid + 49\n           \
    \ val mid51 = mid + 50\n            val mid52 = mid + 51\n            val mid53\
    \ = mid + 52\n            val mid54 = mid + 53\n            val mid55 = mid +\
    \ 54\n            val mid56 = mid + 55\n            val mid57 = mid + 56\n   \
    \         val mid58 = mid + 57\n            val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpv1mkeq4h.scala:90:15 ---------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv1mkeq4h.scala:101:0 ---------------------------\e\
    [0m\e[0m\n\e[31m101 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv1mkeq4h.scala:100:1\
    \ --------------------\e[0m\e[0m\n\e[31m100 |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e\
    [0m\n\e[31m    |\e[0m Found:    Unit\n\e[31m    |\e[0m Required: Boolean\n\e[31m\
    \    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpv1mkeq4h.scala:92:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m92 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659798070
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val l = arr.head\n    \
    \        val r = arr.last\n            val m = arr.length\n            val r1\
    \ = arr.drop(1).head\n            val r2 = arr.drop(1).last\n            val r3\
    \ = arr.drop(2).last\n            val r4 = arr.drop(3).last\n            val r5\
    \ = arr.drop(4).last\n            val r6 = arr.drop(5).last\n            val r7\
    \ = arr.drop(6).last\n            val r8 = arr.drop(7).last\n            val r9\
    \ = arr.drop(8).last\n            val r10 = arr.drop(9).last\n            val\
    \ r11 = arr.drop(10).last\n            val r12 = arr.drop(11).last\n         \
    \   val r13 = arr.drop(12).last\n            val r14 = arr.drop(13).last\n   \
    \         val r15 = arr.drop(14).last\n            val r16 = arr.drop(15).last\n\
    \            val r17 = arr.drop(16).last\n            val r18 = arr.drop(17).last\n\
    \            val r19 = arr.drop(18).last\n            val r20 = arr.drop(19).last\n\
    \            val r21 = arr.drop(20).last\n            val r22 = arr.drop(21).last\n\
    \            val r23 = arr.drop(22).last\n            val r24 = arr.drop(23).last\n\
    \            val r25 = arr.drop(24).last\n            val r26 = arr.drop(25).last\n\
    \            val r27 = arr.drop(26).last\n            val r28 = arr.drop(27).last\n\
    \            val r29 = arr.drop(28).last\n            val r30 = arr.drop(29).last\n\
    \            val r31 = arr.drop(30).last\n            val r32 = arr.drop(31).last\n\
    \            val r33 = arr.drop(32).last\n            val r34 = arr.drop(33).last\n\
    \            val r35 = arr.drop(34).last\n            val r36 = arr.drop(35).last\n\
    \            val r37 = arr.drop(36).last\n            val r38 = arr.drop(37).last\n\
    \            val r39 = arr.drop(38).last\n            val r40 = arr.drop(39).last\n\
    \            val r41 = arr.drop(40).last\n            val r42 = arr.drop(4\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8qf4r7ps.scala:74:4 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8qf4r7ps.scala:84:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m84 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp8qf4r7ps.scala:83:1 ---------------------\e[0m\e[0m\n\
    \e[31m83 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp8qf4r7ps.scala:75:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m75 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1659798069
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1enxt_uh.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp1enxt_uh.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1enxt_uh.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp1enxt_uh.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1enxt_uh.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the sam"
  stdout: ''
  timestamp: 1659798030
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val r = arr.last\n        val s = arr.init\n\
    \        val t = arr.tail\n        val x = arr.init\n        val y = arr.tail\n\
    \        val z = arr.init\n        val w = arr.tail\n        val a = arr.init\n\
    \        val b = arr.tail\n        val c = arr.init\n        val d = arr.tail\n\
    \        val e = arr.init\n        val f = arr.tail\n        val g = arr.init\n\
    \        val h = arr.tail\n        val i = arr.init\n        val j = arr.tail\n\
    \        val k = arr.init\n        val l = arr.tail\n        val m = arr.init\n\
    \        val n = arr.tail\n        val o = arr.init\n        val p = arr.tail\n\
    \        val q = arr.init\n        val r = arr.tail\n        val s = arr.init\n\
    \        val t = arr.tail\n        val u = arr.init\n        val v = arr.tail\n\
    \        val w = arr.init\n        val x = arr.tail\n        val y = arr.init\n\
    \        val z = arr.tail\n        val a = arr.init\n        val b = arr.tail\n\
    \        val c = arr.init\n        val d = arr.tail\n        val e = arr.init\n\
    \        val f = arr.tail\n        val g = arr.init\n        val h = arr.tail\n\
    \        val i = arr.init\n        val j = arr.tail\n        val k = arr.init\n\
    \        val l = arr.tail\n        val m = arr.init\n        val n = arr.tail\n\
    \        val o = arr.init\n        val p = arr.tail\n        val q = arr.init\n\
    \        val r = arr.tail\n        val s = arr.init\n        val t = arr.tail\n\
    \        val u = arr.init\n        val v = arr.tail\n        val w = arr.init\n\
    \        val x = arr.tail\n        val y = arr.init\n        val z = arr.tail\n\
    \        val a = arr.init\n        val b = arr.tail\n        val c = arr.init\n\
    \        val d = arr.tail\n        val e = arr.init\n        val f = arr.tail\n\
    \        val g = arr.init\n        val h = arr.tail\n        val i = arr.init\n\
    \        val j = arr.tail\n        val k = arr.init\n        val l = arr.tail\n\
    \        val m = arr.init\n        val n = arr.tail\n        val o = arr.init\n\
    \        val p = arr.tail\n        val q = arr.init\n        val r = arr.tail\n\
    \        val s = arr.init\n        val t = arr.tail\n        val u = arr.init\n\
    \        val v = arr.tail\n        val w = arr.init\n        val x = arr.tail\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp3dokorao.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3dokorao.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3dokorao.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3dokorao.scala:52:12 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3dokorao.scala:53:12 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3dokorao.scala:54:12 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e[36mt\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659798069
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr2 = arr.toList\n\
    \        val arr3 = arr2.reverse\n        val arr4 = arr3.toList\n        val\
    \ arr5 = arr4.reverse\n        val arr6 = arr5.toList\n        val arr7 = arr6.reverse\n\
    \        val arr8 = arr7.toList\n        val arr9 = arr8.reverse\n        val\
    \ arr10 = arr9.toList\n        val arr11 = arr10.reverse\n        val arr12 =\
    \ arr11.toList\n        val arr13 = arr12.reverse\n        val arr14 = arr13.toList\n\
    \        val arr15 = arr14.reverse\n        val arr16 = arr15.toList\n       \
    \ val arr17 = arr16.reverse\n        val arr18 = arr17.toList\n        val arr19\
    \ = arr18.reverse\n        val arr20 = arr19.toList\n        val arr21 = arr20.reverse\n\
    \        val arr22 = arr21.toList\n        val arr23 = arr22.reverse\n       \
    \ val arr24 = arr23.toList\n        val arr25 = arr24.reverse\n        val arr26\
    \ = arr25.toList\n        val arr27 = arr26.reverse\n        val arr28 = arr27.toList\n\
    \        val arr29 = arr28.reverse\n        val arr30 = arr29.toList\n       \
    \ val arr31 = arr30.reverse\n        val arr32 = arr31.toList\n        val arr33\
    \ = arr32.reverse\n        val arr34 = arr33.toList\n        val arr35 = arr34.reverse\n\
    \        val arr36 = arr35.toList\n        val arr37 = arr36.reverse\n       \
    \ val arr38 = arr37.toList\n        val arr39 = arr38.reverse\n        val arr40\
    \ = arr39.toList\n        val arr41 = arr40.reverse\n        val arr42 = arr41.toList\n\
    \        val arr43 = arr42.reverse\n        val arr44 = arr43.toList\n       \
    \ val arr45 = arr44.reverse\n        val arr46 = arr45.toList\n        val arr47\
    \ = arr46.reverse\n        val arr48 = arr47.toList\n        val arr49 = arr48.reverse\n\
    \        val arr50 = arr49.toList\n        val arr51 = arr50.reverse\n       \
    \ val arr52 = arr51.toList\n        val arr53 = arr52.reverse\n        val arr54\
    \ = arr\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpp_b5uq9l.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpp_b5uq9l.scala:82:5 ---------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val arr2 = arr.toArray\n        val arr3\
    \ = arr2.toList\n        val arr4 = arr3.toArray\n        val arr5 = arr4.toList\n\
    \        val arr6 = arr5.toArray\n        val arr7 = arr6.toList\n        val\
    \ arr8 = arr7.toArray\n        val arr9 = arr8.toList\n        val arr10 = arr9.toArray\n\
    \        val arr11 = arr10.toList\n        val arr12 = arr11.toArray\n       \
    \ val arr13 = arr12.toList\n        val arr14 = arr13.toArray\n        val arr15\
    \ = arr14.toList\n        val arr16 = arr15.toArray\n        val arr17 = arr16.toList\n\
    \        val arr18 = arr17.toArray\n        val arr19 = arr18.toList\n       \
    \ val arr20 = arr19.toArray\n        val arr21 = arr20.toList\n        val arr22\
    \ = arr21.toArray\n        val arr23 = arr22.toList\n        val arr24 = arr23.toArray\n\
    \        val arr25 = arr24.toList\n        val arr26 = arr25.toArray\n       \
    \ val arr27 = arr26.toList\n        val arr28 = arr27.toArray\n        val arr29\
    \ = arr28.toList\n        val arr30 = arr29.toArray\n        val arr31 = arr30.toList\n\
    \        val arr32 = arr31.toArray\n        val arr33 = arr32.toList\n       \
    \ val arr34 = arr33.toArray\n        val arr35 = arr34.toList\n        val arr36\
    \ = arr35.toArray\n        val arr37 = arr36.toList\n        val arr38 = arr37.toArray\n\
    \        val arr39 = arr38.toList\n        val arr40 = arr39.toArray\n       \
    \ val arr41 = arr40.toList\n        val arr42 = arr41.toArray\n        val arr43\
    \ = arr42.toList\n        val arr44 = arr43.toArray\n        val arr45 = arr44.toList\n\
    \        val arr46 = arr45.toArray\n        val arr47 = arr46.toList\n       \
    \ val arr48 = arr47.toArray\n        val arr49 = arr48.toList\n        val arr50\
    \ = arr49.toArray\n        val arr51 = arr50.toList\n        val arr52 = arr5\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp77uintpd.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp77uintpd.scala:79:5 ---------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798069
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) {\n            return true\n        }\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val start = arr(len - 2)\n\
    \        val end = arr(len - 1)\n        val mid = arr(len / 2)\n        val left\
    \ = new Array[Long](len - 1)\n        val right = new Array[Long](len - 1)\n \
    \       val temp = new Array[Long](len - 1)\n        val leftCount = new Array[Long](len\
    \ - 1)\n        val rightCount = new Array[Long](len - 1)\n        val tempCount\
    \ = new Array[Long](len - 1)\n        val leftCount2 = new Array[Long](len - 1)\n\
    \        val rightCount2 = new Array[Long](len - 1)\n        val tempCount2 =\
    \ new Array[Long](len - 1)\n        val leftCount3 = new Array[Long](len - 1)\n\
    \        val rightCount3 = new Array[Long](len - 1)\n        val tempCount3 =\
    \ new Array[Long](len - 1)\n        val leftCount4 = new Array[Long](len - 1)\n\
    \        val rightCount4 = new Array[Long](len - 1)\n        val tempCount4 =\
    \ new Array[Long](len - 1)\n        val leftCount5 = new Array[Long](len - 1)\n\
    \        val rightCount5 = new Array[Long](len - 1)\n        val tempCount5 =\
    \ new Array[Long](len - 1)\n        val leftCount6 = new Array[Long](len - 1)\n\
    \        val rightCount6 = new Array[Long](len - 1)\n        val tempCount6 =\
    \ new Array[Long](len - 1)\n        val leftCount7 = new Array[Long](len - 1)\n\
    \        val rightCount7 = new Array[Long](len - 1)\n        val tempCount7 =\
    \ new Array[Long](len - 1)\n        val leftCount8 = new Array[Long](len - 1)\n\
    \        val rightCount8 = new Array[Long](len - 1)\n        val tempCount8 =\
    \ new Array[Long](len - 1)\n        val leftCount9 = new Array[Long](len - 1)\n\
    \        val rightCount9 = new Array[Long](len - 1)\n        val tempCount9 =\
    \ new Array[Long](len - 1)\n        val leftCount10 = new Array[Long](len - 1)\n\
    \        val rightCount10 = new Array[Long](len - 1)\n        val tempCount10\
    \ = new Array[Long](len - 1)\n        val leftCount11 = new Array[Long](len -\
    \ 1)\n        val rightCount11 = new Array[Long](len - 1)\n        val tempCount11\
    \ = new Array[Long](len - 1)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp99hw1t9o.scala:30:18 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp99hw1t9o.scala:71:5 ---------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798070
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        else {\n            val arr = arr.sortBy(x => x)\n           \
    \ val len = arr.length\n            val max = (len - 1).toLong\n            val\
    \ min = 0l.toLong\n            val result = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjb0l13a2.scala:43:0 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjb0l13a2.scala:28:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e\
    [0m \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m    \
    \                  ^\e[0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpjb0l13a2.scala:42:1 ---------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpjb0l13a2.scala:34:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m34 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1659798070
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val m = arr.head\n    \
    \        val r = arr.tail\n            val r1 = r.tail\n            val r2 = r1.tail\n\
    \            val r3 = r2.tail\n            val r4 = r3.tail\n            val r5\
    \ = r4.tail\n            val r6 = r5.tail\n            val r7 = r6.tail\n    \
    \        val r8 = r7.tail\n            val r9 = r8.tail\n            val r10 =\
    \ r9.tail\n            val r11 = r10.tail\n            val r12 = r11.tail\n  \
    \          val r13 = r12.tail\n            val r14 = r13.tail\n            val\
    \ r15 = r14.tail\n            val r16 = r15.tail\n            val r17 = r16.tail\n\
    \            val r18 = r17.tail\n            val r19 = r18.tail\n            val\
    \ r20 = r19.tail\n            val r21 = r20.tail\n            val r22 = r21.tail\n\
    \            val r23 = r22.tail\n            val r24 = r23.tail\n            val\
    \ r25 = r24.tail\n            val r26 = r25.tail\n            val r27 = r26.tail\n\
    \            val r28 = r27.tail\n            val r29 = r28.tail\n            val\
    \ r30 = r29.tail\n            val r31 = r30.tail\n            val r32 = r31.tail\n\
    \            val r33 = r32.tail\n            val r34 = r33.tail\n            val\
    \ r35 = r34.tail\n            val r36 = r35.tail\n            val r37 = r36.tail\n\
    \            val r38 = r37.tail\n            val r39 = r38.tail\n            val\
    \ r40 = r39.tail\n            val r41 = r40.tail\n            val r42 = r41.tail\n\
    \            val r43 = r42.tail\n            val r44 = r43.tail\n            val\
    \ r45 = r44.tail\n            val r46 = r45.tail\n            val r47 = r46.tail\n\
    \            val r48 = r47.tail\n            val r49 = r48.tail\n            val\
    \ r50 = r49.tail\n            val r51 = r50.tail\n            val r52 = r51.tail\n\
    \            val r53 = r52.tail\n            val r54 = r53.tail\n            val\
    \ r55 = r54.tail\n            val r56 = r55.tail\n            val r57 = r56.tail\n\
    \            val r58 = r57.tail\n            val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpzft40z8m.scala:89:15 ---------------------------\e\
    [0m\e[0m\n\e[31m89 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzft40z8m.scala:100:0 ---------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzft40z8m.scala:99:1\
    \ ---------------------\e[0m\e[0m\n\e[31m99 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpzft40z8m.scala:91:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m91 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659798071
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val temp = new mutable.ListBuffer[Long]()\n        val temp2 = new mutable.ListBuffer[Long]()\n\
    \        val temp3 = new mutable.ListBuffer[Long]()\n        val temp4 = new mutable.ListBuffer[Long]()\n\
    \        val temp5 = new mutable.ListBuffer[Long]()\n        val temp6 = new mutable.ListBuffer[Long]()\n\
    \        val temp7 = new mutable.ListBuffer[Long]()\n        val temp8 = new mutable.ListBuffer[Long]()\n\
    \        val temp9 = new mutable.ListBuffer[Long]()\n        val temp10 = new\
    \ mutable.ListBuffer[Long]()\n        val temp11 = new mutable.ListBuffer[Long]()\n\
    \        val temp12 = new mutable.ListBuffer[Long]()\n        val temp13 = new\
    \ mutable.ListBuffer[Long]()\n        val temp14 = new mutable.ListBuffer[Long]()\n\
    \        val temp15 = new mutable.ListBuffer[Long]()\n        val temp16 = new\
    \ mutable.ListBuffer[Long]()\n        val temp17 = new mutable.ListBuffer[Long]()\n\
    \        val temp18 = new mutable.ListBuffer[Long]()\n        val temp19 = new\
    \ mutable.ListBuffer[Long]()\n        val temp20 = new mutable.ListBuffer[Long]()\n\
    \        val temp21 = new mutable.ListBuffer[Long]()\n        val temp22 = new\
    \ mutable.ListBuffer[Long]()\n        val temp23 = new mutable.ListBuffer[Long]()\n\
    \        val temp24 = new mutable.ListBuffer[Long]()\n        val temp25 = new\
    \ mutable.ListBuffer[Long]()\n        val temp26 = new mutable.ListBuffer[Long]()\n\
    \        val temp27 = new mutable.ListBuffer[Long]()\n        val temp28 = new\
    \ mutable.ListBuffer[Long]()\n        val temp29 = new mutable.ListBuffer[Long]()\n\
    \        val temp30 = new mutable.ListBuffer[Long]()\n        val temp31 = new\
    \ mutable.ListBuffer[Long]()\n        val temp32 = new mutable.ListBuffer[Long]()\n\
    \        val temp33 = new mutable.ListBuffer[Long]()\n        val temp34 = new\
    \ mutable.ListBuffer[Long]()\n        val temp35 = new mutable.ListBuffer[\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo75vb_z0.scala:64:4 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpo75vb_z0.scala:28:25 ------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpo75vb_z0.scala:29:23 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mtemp\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo75vb_z0.scala:30:24\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mtemp2\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpo75vb_z0.scala:31:24 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m        \e[33mval\e[0m \e[36mtemp3\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpo75vb_z0.scala:32:24 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mtemp4\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \           ^^^^^^^\e[0m\n\e[31m "
  stdout: ''
  timestamp: 1659798070
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val r = new Array[Long](n)\n        val d =\
    \ new Array[Long](n)\n        val x = new Array[Long](n)\n        val y = new\
    \ Array[Long](n)\n        val z = new Array[Long](n)\n        val w = new Array[Long](n)\n\
    \        val v = new Array[Long](n)\n        val t = new Array[Long](n)\n    \
    \    val u = new Array[Long](n)\n        val v1 = new Array[Long](n)\n       \
    \ val v2 = new Array[Long](n)\n        val v3 = new Array[Long](n)\n        val\
    \ v4 = new Array[Long](n)\n        val v5 = new Array[Long](n)\n        val v6\
    \ = new Array[Long](n)\n        val v7 = new Array[Long](n)\n        val v8 =\
    \ new Array[Long](n)\n        val v9 = new Array[Long](n)\n        val v10 = new\
    \ Array[Long](n)\n        val v11 = new Array[Long](n)\n        val v12 = new\
    \ Array[Long](n)\n        val v13 = new Array[Long](n)\n        val v14 = new\
    \ Array[Long](n)\n        val v15 = new Array[Long](n)\n        val v16 = new\
    \ Array[Long](n)\n        val v17 = new Array[Long](n)\n        val v18 = new\
    \ Array[Long](n)\n        val v19 = new Array[Long](n)\n        val v20 = new\
    \ Array[Long](n)\n        val v21 = new Array[Long](n)\n        val v22 = new\
    \ Array[Long](n)\n        val v23 = new Array[Long](n)\n        val v24 = new\
    \ Array[Long](n)\n        val v25 = new Array[Long](n)\n        val v26 = new\
    \ Array[Long](n)\n        val v27 = new Array[Long](n)\n        val v28 = new\
    \ Array[Long](n)\n        val v29 = new Array[Long](n)\n        val v30 = new\
    \ Array[Long](n)\n        val v31 = new Array[Long](n)\n        val v32 = new\
    \ Array[Long](n)\n        val v33 = new Array[Long](n)\n        val v34 = new\
    \ Array[Long](n)\n        val v35 = new Array[Long](n)\n        val v36 = new\
    \ Array[Long](n)\n        val v37 = new Array[Long](n)\n        val v38 = new\
    \ Array[\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj3hwx71z.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpj3hwx71z.scala:74:18\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m74 |\e[0m       \
    \ \e[33mval\e[0m \e[36mv38\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\n\e[31m\e[31m\
    \   |\e[0m                  ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument for\
    \ parameter _length of \e[33mconstructor\e[0m \e[35mArray\e[0m in \e[33mclass\e\
    [0m \e[35mArray\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj3hwx71z.scala:75:5\
    \ ---------------------\e[0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798071
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val l = arr.last\n        val r = arr.head\n\
    \        val m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n    \
    \    val m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n        val\
    \ m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n        val m =\
    \ arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n        val m = arr.indexOf(l)\
    \ + 1\n        val n = arr.indexOf(r) + 1\n        val m = arr.indexOf(l) + 1\n\
    \        val n = arr.indexOf(r) + 1\n        val m = arr.indexOf(l) + 1\n    \
    \    val n = arr.indexOf(r) + 1\n        val m = arr.indexOf(l) + 1\n        val\
    \ n = arr.indexOf(r) + 1\n        val m = arr.indexOf(l) + 1\n        val n =\
    \ arr.indexOf(r) + 1\n        val m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r)\
    \ + 1\n        val m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n\
    \        val m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n    \
    \    val m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n        val\
    \ m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n        val m =\
    \ arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n        val m = arr.indexOf(l)\
    \ + 1\n        val n = arr.indexOf(r) + 1\n        val m = arr.indexOf(l) + 1\n\
    \        val n = arr.indexOf(r) + 1\n        val m = arr.indexOf(l) + 1\n    \
    \    val n = arr.indexOf(r) + 1\n        val m = arr.indexOf(l) + 1\n        val\
    \ n = arr.indexOf(r) + 1\n        val m = arr.indexOf(l) + 1\n        val n =\
    \ arr.indexOf(r) + 1\n        val m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r)\
    \ + 1\n        val m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n\
    \        val m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n    \
    \    val m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n        val\
    \ m = arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n        val m =\
    \ arr.indexOf(l) + 1\n        val n = arr.indexOf(r) + 1\n        val m = arr.indexOf(l)\
    \ + 1\n        val n = arr.indexOf(r) + 1\n        val m = arr.indexOf(l) + 1\n\
    \        val n = arr.indexOf(r) + 1\n        val m = arr.indexOf(l) + 1\n    \
    \    val n = arr.indexOf(r) + 1\n        val m = arr.indexOf(l) + 1\n        val\
    \ n = arr.indexOf(r) + 1\n        val m = arr.indexOf(l) + 1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3lk0xyab.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.indexOf(r)\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp3lk0xyab.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.indexOf(l) + \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is\
    \ already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3lk0xyab.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mn\e[0m = arr.indexOf(r) + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp3lk0xyab.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.indexOf(l) + \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is\
    \ already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3lk0xyab.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mn\e[0m = arr.indexOf(r) + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel "
  stdout: ''
  timestamp: 1659798074
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val r = new Array[Long](n)\n        var i =\
    \ 0\n        var j = 0\n        var k = 0\n        var temp = 0\n        while(i\
    \ < n) {\n            while(j < n) {\n                if(arr(i) > arr(j)) {\n\
    \                    temp = arr(i)\n                    arr(i) = arr(j)\n    \
    \                arr(j) = temp\n                }\n                j += 1\n  \
    \          }\n            i += 1\n        }\n        while(j < n) {\n        \
    \    while(k < (n - 1)) {\n                if(arr(k) > arr(k + 1)) {\n       \
    \             temp = arr(k)\n                    arr(k) = arr(k + 1)\n       \
    \             arr(k + 1) = temp\n                }\n                k += 1\n \
    \           }\n            j += 1\n        }\n        for(i = 0 ; i < n ; i++)\
    \ {\n            r(i) = arr(i)\n        }\n        for(i = 0 ; i < n ; i++) {\n\
    \            if(r(i) > m) {\n                m = r(i)\n            }\n       \
    \ }\n        return m == 0\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvn56g6ik.scala:55:14 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m        \e[33mfor\e[0m(i = \e[31m0\e[0m ; i < n ; i++)\
    \ {\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e[0m              ')'\
    \ expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvn56g6ik.scala:55:26\
    \ ---------------------------\e[0m\e[0m\n\e[31m55 |\e[0m        \e[33mfor\e[0m(i\
    \ = \e[31m0\e[0m ; i < n ; i++) {\n\e[31m\e[31m   |\e[0m                     \
    \     ^\e[0m\n\e[31m   |\e[0m                          '<-' expected, but ';'\
    \ found\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpvn56g6ik.scala:55:31 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m        \e[33mfor\e[0m(i = \e[31m0\e[0m ; i < n ; i++)\
    \ {\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e\
    [0m                               pattern expected\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmpvn56g6ik.scala:58:14 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mfor\e[0m(i = \e[31m0\e[0m ; i < n ; i++)\
    \ {\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e[0m              ')'\
    \ expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvn56g6ik.scala:58:26\
    \ ---------------------------\e[0m\e[0m\n\e[31m58 |\e[0m        \e[33mfor\e[0m(i\
    \ = \e[31m0\e[0m ; i < n ; i++) {\n\e[31m\e[31m   |\e[0m                     \
    \     ^\e[0m\n\e[31m   |\e[0m                          '<-' expected, but ';'\
    \ found\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpvn56g6ik.scala:58:31 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mfor\e[0m(i = \e[31m0\e[0m ; i < n ; i++)\
    \ {\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e\
    [0m                               pattern expected\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpvn56g6ik.scala:36:30 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                    temp = arr(i)\n\e[31m\e[31m   |\e\
    [0m                           ^^^^^^\e[0m\n\e[31m   |\e[0m             "
  stdout: ''
  timestamp: 1659798077
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val max =\
    \ (len - 1) * arr.last\n        val min = (len - 1) * arr.head\n        val maxIndex\
    \ = arr.lastIndex\n        val minIndex = arr.head\n        val maxVal = arr.max\n\
    \        val minVal = arr.min\n        val maxIndexVal = arr.maxIndex\n      \
    \  val minIndexVal = arr.minIndex\n        val maxValVal = arr.maxValue\n    \
    \    val minValVal = arr.minValue\n        val maxIndexValVal = arr.maxIndexValue\n\
    \        val minIndexValVal = arr.minIndexValue\n        val maxValValVal = arr.maxValueValue\n\
    \        val minValValVal = arr.minValueValue\n        val maxIndexValValVal =\
    \ arr.maxIndexValueValue\n        val minIndexValValVal = arr.minIndexValueValue\n\
    \        val maxValValVal = arr.maxValueValueValue\n        val minValValVal =\
    \ arr.minValueValueValue\n        val maxIndexValValVal = arr.maxIndexValueValueValue\n\
    \        val minIndexValValVal = arr.minIndexValueValueValue\n        val maxValValVal\
    \ = arr.maxValueValueValueValue\n        val minValValVal = arr.minValueValueValueValue\n\
    \        val maxIndexValValVal = arr.maxIndexValueValueValueValue\n        val\
    \ minIndexValValVal = arr.minIndexValueValueValueValue\n        val maxValValVal\
    \ = arr.maxValueValueValueValueValue\n        val minValValVal = arr.minValueValueValueValueValue\n\
    \        val maxIndexValValVal = arr.maxIndexValueValueValueValue\n        val\
    \ minIndexValValVal = arr.minIndexValueValueValueValue\n        val maxValValVal\
    \ = arr.maxValueValueValueValueValue\n        val minValValVal = arr.minValueValueValueValueValue\n\
    \        val maxIndexValValVal = arr.maxIndexValueValueValueValue\n        val\
    \ minIndexValValVal = arr.minIndexValueValueValueValue\n        val maxValValVal\
    \ = arr.maxValueValueValueValueValueValue\n        val minValValVal = arr.minValueValueValueValueValueValue\n\
    \        val maxIndexValValVal = arr.maxIndexValueValueValueValueValue\n     \
    \   val minIndexValValVal = arr.minIndexValueValueValueValueValue\n        val\
    \ maxValValVal = arr.maxValueValueValueValueValueValue\n        val minValValVal\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpjqwbsfqe.scala:66:26 ---------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m        \e[33mval\e[0m \e[36mminValValVal\e[0m = \n\e\
    [31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m         \
    \                 expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpjqwbsfqe.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mmaxValValVal\e[0m = arr.maxValueValueValue\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmaxValValVal is already defined as \e[33mvalue\e[0m \e[35mmaxValValVal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjqwbsfqe.scala:46:12 ---------------------------\e[0m\e[0m\n\e\
    [31m46 |\e[0m        \e[33mval\e[0m \e[36mminValValVal\e[0m = arr.minValueValueValue\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mminValValVal is already defined as \e[33mvalue\e[0m \e[35mminValValVal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjqwbsfqe.scala:47:12 ---------------------------\e[0m\e[0m\n\e\
    [31m47 |\e[0m        \e[33mval\e[0m \e[36mmaxIndexValValVal\e[0m = arr.maxIndexValueValueValue\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxIndexValValVal is already defined as \e[33mvalue\e[0m \e\
    [35mmaxIndexValValVal\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpjqwbsfqe.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mminIndexValValVal\e[0m =\
    \ arr.minIndexValueValueValue\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[3"
  stdout: ''
  timestamp: 1659798075
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.sortBy(x \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2i3vgqx2.scala:79:4 ----------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2i3vgqx2.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp2i3vgqx2.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2i3vgqx2.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2i3vgqx2.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp2i3vgqx2.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\
    \e[31m\e[31m   |\e[0m        "
  stdout: ''
  timestamp: 1659798077
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val max = (arr.max).toLong\n        val min = (arr.min).toLong\n    \
    \    val maxIndex = (arr.lastIndexOfMax).toLong\n        val minIndex = (arr.lastIndexOfMin).toLong\n\
    \        val maxIndex2 = (arr.lastIndexOfMax2).toLong\n        val minIndex2 =\
    \ (arr.lastIndexOfMin2).toLong\n        val maxIndex3 = (arr.lastIndexOfMax3).toLong\n\
    \        val minIndex3 = (arr.lastIndexOfMin3).toLong\n        val maxIndex4 =\
    \ (arr.lastIndexOfMax4).toLong\n        val minIndex4 = (arr.lastIndexOfMin4).toLong\n\
    \        val maxIndex5 = (arr.lastIndexOfMax5).toLong\n        val minIndex5 =\
    \ (arr.lastIndexOfMin5).toLong\n        val maxIndex6 = (arr.lastIndexOfMax6).toLong\n\
    \        val minIndex6 = (arr.lastIndexOfMin6).toLong\n        val maxIndex7 =\
    \ (arr.lastIndexOfMax7).toLong\n        val minIndex7 = (arr.lastIndexOfMin7).toLong\n\
    \        val maxIndex8 = (arr.lastIndexOfMax8).toLong\n        val minIndex8 =\
    \ (arr.lastIndexOfMin8).toLong\n        val maxIndex9 = (arr.lastIndexOfMax9).toLong\n\
    \        val minIndex9 = (arr.lastIndexOfMin9).toLong\n        val maxIndex10\
    \ = (arr.lastIndexOfMax10).toLong\n        val minIndex10 = (arr.lastIndexOfMin10).toLong\n\
    \        val maxIndex11 = (arr.lastIndexOfMax11).toLong\n        val minIndex11\
    \ = (arr.lastIndexOfMin11).toLong\n        val maxIndex12 = (arr.lastIndexOfMax12).toLong\n\
    \        val minIndex12 = (arr.lastIndexOfMin12).toLong\n        val maxIndex13\
    \ = (arr.lastIndexOfMax13).toLong\n        val minIndex13 = (arr.lastIndexOfMin13).toLong\n\
    \        val maxIndex14 = (arr.lastIndexOfMax14).toLong\n        val minIndex14\
    \ = (arr.lastIndexOfMin14).toLong\n        val maxIndex15 = (arr.lastIndexOfMax15).toLong\n\
    \        val minIndex15 = (arr.lastIndexOfMin15).toLong\n        val maxIndex16\
    \ = (arr.lastIndexOfMax16).toLong\n        val minIndex16 = (arr.lastIndexOfMin16).toLong\n\
    \        val maxIndex17 = (arr.lastIndexOfMax17).toLong\n        val minIndex17\
    \ = (arr.lastIndexOfMin17).toLong\n        val maxIndex18 = (arr.lastIndexOfMax18).toLong\n\
    \        val minIndex\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmps0dqcld_.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps0dqcld_.scala:29:28\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxIndex\e[0m = (arr.lastIndexOfMax).toLong\n\e[31m\e[31m   |\e[0m       \
    \                 ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue lastIndexOfMax\
    \ is not a member of List[Long] - did you mean arr.lastIndexOf?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmps0dqcld_.scala:30:28 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mminIndex\e[0m = (arr.lastIndexOfMin).toLong\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue lastIndexOfMin is not a member of List[Long] - did you mean arr.lastIndexOf?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps0dqcld_.scala:31:29 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex2\e[0m = (arr.lastIndexOfMax2).toLong\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     value lastIndexOfMax2 is not a member of List[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps0dqcld_.scala:32:29 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mminIndex2\e[0m = (arr.lastIndexOfMin2).toLong\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     value lastIndexOfMin2 is not a member of List[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps0dqcld_.scala:33:29 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex3\e[0m = (arr.lastIndexOfMax3).toLong\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     value lastIndexOfMax3 is not a member of List[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps0dqcld_.scala:34:29 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mminIndex3\e[0m = (arr.lastIn"
  stdout: ''
  timestamp: 1659798080
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val newArr\
    \ = new Array[Long](len)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var temp = 0\n        var temp2 = 0\n        var temp3 = 0\n  \
    \      var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n        var\
    \ temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n        var temp10\
    \ = 0\n        var temp11 = 0\n        var temp12 = 0\n        var temp13 = 0\n\
    \        var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n    \
    \    var temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n        var\
    \ temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n        var temp23\
    \ = 0\n        var temp24 = 0\n        var temp25 = 0\n        var temp26 = 0\n\
    \        var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n    \
    \    var temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n        var\
    \ temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n        var temp36\
    \ = 0\n        var temp37 = 0\n        var temp38 = 0\n        var temp39 = 0\n\
    \        var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n    \
    \    var temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n        var\
    \ temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n        var temp49\
    \ = 0\n        var temp50 = 0\n        var temp51 = 0\n        var temp52 = 0\n\
    \        var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n    \
    \    var temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n        var\
    \ temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n        var temp62\
    \ = 0\n        var temp63 = 0\n        var temp64 = 0\n        var temp65 = 0\n\
    \        var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n    \
    \    var temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n        var\
    \ temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n        var temp75\
    \ = 0\n        var temp76 = 0\n        var temp77 = 0\n        var temp78 = 0\n\
    \        var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n    \
    \    var temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n        var\
    \ temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n        var temp88\
    \ = 0\n        var temp89 = 0\n        var temp90 = 0\n        var temp91 = 0\n\
    \        var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n    \
    \    var \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp81hpud45.scala:127:11 --------------------------\e\
    [0m\e[0m\n\e[31m127 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp81hpud45.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp81hpud45.scala:128:5 --------------------\e\
    [0m\e[0m\n\e[31m128 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Boolean\n\e[31m  \
    \  |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798076
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val mid = n / 2\n     \
    \       val left = arr.take(mid)\n            val right = arr.drop(mid)\n    \
    \        val leftSorted = left.sortWith(_ < _)\n            val rightSorted =\
    \ right.sortWith(_ < _)\n            if (leftSorted.length == rightSorted.length\
    \ && leftSorted == rightSorted) true\n            else moveOneBall(leftSorted)\
    \ && moveOneBall(rightSorted)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659798082
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr2 = arr.toList\n\
    \        val arr3 = arr2.reverse\n        val arr4 = arr3.toList\n        val\
    \ arr5 = arr4.toList\n        val arr6 = arr5.toList\n        val arr7 = arr6.reverse\n\
    \        val arr8 = arr7.toList\n        val arr9 = arr8.toList\n        val arr10\
    \ = arr9.reverse\n        val arr11 = arr10.toList\n        val arr12 = arr11.toList\n\
    \        val arr13 = arr12.reverse\n        val arr14 = arr13.toList\n       \
    \ val arr15 = arr14.toList\n        val arr16 = arr15.reverse\n        val arr17\
    \ = arr16.toList\n        val arr18 = arr17.toList\n        val arr19 = arr18.reverse\n\
    \        val arr20 = arr19.toList\n        val arr21 = arr20.toList\n        val\
    \ arr22 = arr21.reverse\n        val arr23 = arr22.toList\n        val arr24 =\
    \ arr23.toList\n        val arr25 = arr24.reverse\n        val arr26 = arr25.toList\n\
    \        val arr27 = arr26.reverse\n        val arr28 = arr27.toList\n       \
    \ val arr29 = arr28.reverse\n        val arr30 = arr29.toList\n        val arr31\
    \ = arr30.reverse\n        val arr32 = arr31.toList\n        val arr33 = arr32.reverse\n\
    \        val arr34 = arr33.toList\n        val arr35 = arr34.reverse\n       \
    \ val arr36 = arr35.toList\n        val arr37 = arr36.reverse\n        val arr38\
    \ = arr37.toList\n        val arr39 = arr38.reverse\n        val arr40 = arr39.toList\n\
    \        val arr41 = arr40.reverse\n        val arr42 = arr41.toList\n       \
    \ val arr43 = arr42.reverse\n        val arr44 = arr43.toList\n        val arr45\
    \ = arr44.reverse\n        val arr46 = arr45.toList\n        val arr47 = arr46.reverse\n\
    \        val arr48 = arr47.toList\n        val arr49 = arr48.reverse\n       \
    \ val arr50 = arr49.toList\n        val arr51 = arr50.reverse\n        val arr52\
    \ = arr51.toList\n        val arr53 = arr52.reverse\n        val \n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpiypucy94.scala:81:11 ---------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpiypucy94.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpiypucy94.scala:82:5 ---------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798077
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        if (n == 0) true\n        else {\n            val m = arr.head\n    \
    \        val r = arr.tail\n            val l = new Array[Long](n + 1)\n      \
    \      for (i <- 0 until n) l(i) = arr(i)\n            l(n) = m\n            val\
    \ k = n - 1\n            val p = r\n            val q = r.head\n            val\
    \ r = r.tail\n            val s = r.head\n            val t = r.tail\n       \
    \     val u = r.head\n            val v = r.tail\n            val w = r.head\n\
    \            val x = r.tail\n            val y = r.head\n            val z = r.tail\n\
    \            val a = r.head\n            val b = r.tail\n            val c = r.head\n\
    \            val d = r.tail\n            val e = r.head\n            val f = r.tail\n\
    \            val g = r.head\n            val h = r.tail\n            val i = r.head\n\
    \            val j = r.tail\n            val k = r.head\n            val l = r.tail\n\
    \            val m = r.head\n            val n = r.tail\n            val o = r.head\n\
    \            val p = r.tail\n            val q = r.head\n            val r = r.tail\n\
    \            val s = r.head\n            val t = r.tail\n            val u = r.head\n\
    \            val v = r.tail\n            val w = r.head\n            val x = r.tail\n\
    \            val y = r.head\n            val z = r.tail\n            val a = r.head\n\
    \            val b = r.tail\n            val c = r.head\n            val d = r.tail\n\
    \            val e = r.head\n            val f = r.tail\n            val g = r.head\n\
    \            val h = r.tail\n            val i = r.head\n            val j = r.tail\n\
    \            val k = r.head\n            val l = r.tail\n            val m = r.head\n\
    \            val n = r.tail\n            val o = r.head\n            val p = r.tail\n\
    \            val q = r.head\n            val r = r.tail\n            val s = r.head\n\
    \            val t = r.tail\n            val u = r.head\n            val v = r.tail\n\
    \            val w = r.head\n            val x = r.tail\n            val y = r.head\n\
    \            val z = r.tail\n            val a = r.head\n            val b = r.tail\n\
    \            val c = r.head\n            val d = r.tail\n            val e = r.head\n\
    \            val f = r.tail\n            val g = r.head\n            val h = r.tail\n\
    \            val i = r.head\n            val j = r.tail\n            val k = r.head\n\
    \            val l = r.tail\n            val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp0e0vxi01.scala:110:15 --------------------------\e\
    [0m\e[0m\n\e[31m110 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m\
    \               ^\e[0m\n\e[31m    |\e[0m               pattern expected\n\e[31m\
    \    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0e0vxi01.scala:121:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m121 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161]\
    \ Naming Error: /tmp/tmp0e0vxi01.scala:37:16 ---------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r.tail\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0e0vxi01.scala:56:16 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m            \e[33mval\e[0m \e[36mk\e[0m = r.head\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mk is already\
    \ defined as \e[33mvalue\e[0m \e[35mk\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0e0vxi01.scala:57:16 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m            \e[33mval\e[0m \e[36ml\e[0m = r.tail\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already\
    \ defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0e0vxi01.scala:58:16 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = r.head\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already\
    \ defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31"
  stdout: ''
  timestamp: 1659798080
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val first = arr.head\n\
    \            val last = arr.last\n            val mid = first + last/2\n     \
    \       val left = arr.drop(1).dropRight(1)\n            val right = arr.dropRight(1)\n\
    \            val leftSorted = left.sortBy(_.toLong)\n            val rightSorted\
    \ = right.sortBy(_.toLong)\n            val leftSorted2 = leftSorted.reverse\n\
    \            val rightSorted2 = rightSorted.reverse\n            val leftSorted3\
    \ = leftSorted2.reverse\n            val rightSorted3 = rightSorted2.reverse\n\
    \            val leftSorted4 = leftSorted3.reverse\n            val rightSorted4\
    \ = rightSorted3.reverse\n            val leftSorted5 = leftSorted4.reverse\n\
    \            val rightSorted5 = rightSorted4.reverse\n            val leftSorted6\
    \ = leftSorted5.reverse\n            val rightSorted6 = rightSorted5.reverse\n\
    \            val leftSorted7 = leftSorted6.reverse\n            val rightSorted7\
    \ = rightSorted6.reverse\n            val leftSorted8 = leftSorted7.reverse\n\
    \            val rightSorted8 = rightSorted7.reverse\n            val leftSorted9\
    \ = leftSorted8.reverse\n            val rightSorted9 = rightSorted8.reverse\n\
    \            val leftSorted10 = leftSorted9.reverse\n            val rightSorted10\
    \ = rightSorted9.reverse\n            val leftSorted11 = leftSorted10.reverse\n\
    \            val rightSorted11 = rightSorted10.reverse\n            val leftSorted12\
    \ = leftSorted11.reverse\n            val rightSorted12 = rightSorted11.reverse\n\
    \            val leftSorted13 = leftSorted12.reverse\n            val rightSorted13\
    \ = rightSorted12.reverse\n            val leftSorted14 = leftSorted13.reverse\n\
    \            val rightSorted14 = rightSorted13.reverse\n            val leftSorted15\
    \ = leftSorted14.reverse\n            val rightSorted15 = rightSorted14.reverse\n\
    \            val leftSorted16 = leftSorted15.reverse\n            val rightSorted16\
    \ = rightSorted15.reverse\n            val leftSorted17 = leftSorted16.reverse\n\
    \            val rightSorted17 = rightSorted16.reverse\n            val leftSorted18\
    \ = leftSorted17.reverse\n            val rightSorted18 = rightSorted17.reverse\n\
    \            val leftSorted19 = leftSorted18.reverse\n            val rightSorted19\
    \ = rightSorted18.reverse\n            val leftSorted20 = leftSorted19.reverse\n\
    \            val rightSorted20 = rightSorted19.reverse\n            val leftSorted21\
    \ = leftSorted20.reverse\n            val rightSorted21 = rightSorted20.reverse\n\
    \            val leftSorted22 = leftSorted21.reverse\n            val rightSorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuvovsbi4.scala:78:4 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuvovsbi4.scala:88:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m88 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpuvovsbi4.scala:87:1 ---------------------\e[0m\e[0m\n\
    \e[31m87 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpuvovsbi4.scala:79:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m79 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1659798078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val s = arr.last\n        val d = arr.last\n\
    \        val r = arr.last\n        val t = arr.last\n        val u = arr.last\n\
    \        val v = arr.last\n        val w = arr.last\n        val x = arr.last\n\
    \        val y = arr.last\n        val z = arr.last\n        val a = arr.last\n\
    \        val b = arr.last\n        val c = arr.last\n        val d = arr.last\n\
    \        val e = arr.last\n        val f = arr.last\n        val g = arr.last\n\
    \        val h = arr.last\n        val i = arr.last\n        val j = arr.last\n\
    \        val k = arr.last\n        val l = arr.last\n        val m = arr.last\n\
    \        val n = arr.last\n        val o = arr.last\n        val p = arr.last\n\
    \        val q = arr.last\n        val r = arr.last\n        val s = arr.last\n\
    \        val t = arr.last\n        val u = arr.last\n        val v = arr.last\n\
    \        val w = arr.last\n        val x = arr.last\n        val y = arr.last\n\
    \        val z = arr.last\n        val a = arr.last\n        val b = arr.last\n\
    \        val c = arr.last\n        val d = arr.last\n        val e = arr.last\n\
    \        val f = arr.last\n        val g = arr.last\n        val h = arr.last\n\
    \        val i = arr.last\n        val j = arr.last\n        val k = arr.last\n\
    \        val l = arr.last\n        val m = arr.last\n        val n = arr.last\n\
    \        val o = arr.last\n        val p = arr.last\n        val q = arr.last\n\
    \        val r = arr.last\n        val s = arr.last\n        val t = arr.last\n\
    \        val u = arr.last\n        val v = arr.last\n        val w = arr.last\n\
    \        val x = arr.last\n        val y = arr.last\n        val z = arr.last\n\
    \        val a = arr.last\n        val b = arr.last\n        val c = arr.last\n\
    \        val d = arr.last\n        val e = arr.last\n        val f = arr.last\n\
    \        val g = arr.last\n        val h = arr.last\n        val i = arr.last\n\
    \        val j = arr.last\n        val k = arr.last\n        val l = arr.last\n\
    \        val m = arr.last\n        val n = arr.last\n        val o = arr.last\n\
    \        val p = arr.last\n        val q = arr.last\n        val r = arr.last\n\
    \        val s = arr.last\n        val t = arr.last\n        val u = arr.last\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpj20cerp6.scala:111:11 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj20cerp6.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined\
    \ as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj20cerp6.scala:50:12 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj20cerp6.scala:51:12 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj20cerp6.scala:55:12 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj20cerp6.scala:56:12 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659798078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(-_)\n        val arr = arr.drop(arr.length-1)\n    \
    \    val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortBy(-_)\n        val arr = arr.drop(arr.length-1)\n        val\
    \ arr = arr.take(arr.length-1)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_)\n        val arr = arr.drop(arr.length-1)\n        val arr\
    \ = arr.take(arr.length-1)\n        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n\
    \        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr\
    \ = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n       \
    \ val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(-_)\n        val arr = arr.drop(arr.length-1)\n    \
    \    val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortBy(-_)\n        val arr = arr.drop(arr.length-1)\n        val\
    \ arr = arr.take(arr.length-1)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_)\n        val arr = arr.drop(arr.length-1)\n        val arr\
    \ = arr.take(arr.length-1)\n        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n\
    \        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr\
    \ = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n       \
    \ val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5mi2nqvs.scala:82:29 ---------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5mi2nqvs.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5mi2nqvs.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5mi2nqvs.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.drop(arr.length-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined\
    \ as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5mi2nqvs.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.take(arr.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[3"
  stdout: ''
  timestamp: 1659798079
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnogrev2w.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnogrev2w.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnogrev2w.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnogrev2w.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnogrev2w.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnogrev2w.scala:33:12 ---------------------------\e\
    [0m\e[0"
  stdout: ''
  timestamp: 1659798007
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val r = arr.last\n        val s = arr.init\n\
    \        val t = arr.tail\n        val a = arr.toArray\n        val b = a.clone\n\
    \        val c = b.clone\n        val d = c.clone\n        val e = d.clone\n \
    \       val f = e.clone\n        val g = f.clone\n        val h = g.clone\n  \
    \      val i = h.clone\n        val j = i.clone\n        val k = j.clone\n   \
    \     val l = k.clone\n        val m = l.clone\n        val n = m.clone\n    \
    \    val o = n.clone\n        val p = o.clone\n        val q = p.clone\n     \
    \   val r = q.clone\n        val s = r.clone\n        val t = s.clone\n      \
    \  val u = t.clone\n        val v = u.clone\n        val w = v.clone\n       \
    \ val x = w.clone\n        val y = x.clone\n        val z = y.clone\n        val\
    \ a = z.clone\n        val b = a.clone\n        val c = b.clone\n        val d\
    \ = c.clone\n        val e = d.clone\n        val f = e.clone\n        val g =\
    \ f.clone\n        val h = g.clone\n        val i = h.clone\n        val j = i.clone\n\
    \        val k = j.clone\n        val l = k.clone\n        val m = l.clone\n \
    \       val n = m.clone\n        val o = n.clone\n        val p = o.clone\n  \
    \      val q = p.clone\n        val r = q.clone\n        val s = r.clone\n   \
    \     val t = s.clone\n        val u = t.clone\n        val v = u.clone\n    \
    \    val w = v.clone\n        val x = w.clone\n        val y = x.clone\n     \
    \   val z = y.clone\n        val a = z.clone\n        val b = a.clone\n      \
    \  val c = b.clone\n        val d = c.clone\n        val e = d.clone\n       \
    \ val f = e.clone\n        val g = f.clone\n        val h = g.clone\n        val\
    \ i = h.clone\n        val j = i.clone\n        val k = j.clone\n        val l\
    \ = k.clone\n        val m = l.clone\n        val n = m.clone\n        val o =\
    \ n.clone\n        val p = o.clone\n        val q = p.clone\n        val r = q.clone\n\
    \        val s = r.clone\n        val t = s.clone\n        val u = t.clone\n \
    \       val v = u.clone\n        val w = v.clone\n        val x = w.clone\n  \
    \      val y = x.clone\n        val z = y.clone\n        val a = z.clone\n   \
    \     val b = a.clone\n        \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp71do3ajr.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = l.clone\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp71do3ajr.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = m.clone\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp71do3ajr.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = q.clone\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp71do3ajr.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = r.clone\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp71do3ajr.scala:50:12 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mt\e[0m = s.clone\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mt is already defined\
    \ as \e[33mvalue\e[0m \e[35mt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp71do3ajr.scala:57:12 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \e[36ma\e[0m"
  stdout: ''
  timestamp: 1659798079
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val maxIndex = arr.maxIndex\n\
    \            val maxValue = arr.max\n            val minIndex = arr.minIndex\n\
    \            val minValue = arr.min\n            val mid = maxIndex + minIndex\
    \ / 2\n            val midValue = arr(mid)\n            val leftIndex = mid -\
    \ 1\n            val leftValue = arr(leftIndex)\n            val rightIndex =\
    \ mid + 1\n            val rightValue = arr(rightIndex)\n            val leftShiftCount\
    \ = arr.length - 1\n            val rightShiftCount = arr.length - 1\n       \
    \     val leftShiftCount = arr.length - 1\n            val rightShiftCount = arr.length\
    \ - 1\n            val leftShiftCount = arr.length - 1\n            val rightShiftCount\
    \ = arr.length - 1\n            val leftShiftCount = arr.length - 1\n        \
    \    val rightShiftCount = arr.length - 1\n            val leftShiftCount = arr.length\
    \ - 1\n            val rightShiftCount = arr.length - 1\n            val leftShiftCount\
    \ = arr.length - 1\n            val rightShiftCount = arr.length - 1\n       \
    \     val leftShiftCount = arr.length - 1\n            val rightShiftCount = arr.length\
    \ - 1\n            val leftShiftCount = arr.length - 1\n            val rightShiftCount\
    \ = arr.length - 1\n            val leftShiftCount = arr.length - 1\n        \
    \    val rightShiftCount = arr.length - 1\n            val leftShiftCount = arr.length\
    \ - 1\n            val rightShiftCount = arr.length - 1\n            val leftShiftCount\
    \ = arr.length - 1\n            val rightShiftCount = arr.length - 1\n       \
    \     val leftShiftCount = arr.length - 1\n            val rightShiftCount = arr.length\
    \ - 1\n            val leftShiftCount = arr.length - 1\n            val rightShiftCount\
    \ = arr.length - 1\n            val leftShiftCount = arr.length - 1\n        \
    \    val rightShiftCount = arr.length - 1\n            val leftShiftCount = arr.length\
    \ - 1\n            val rightShiftCount = arr.length - 1\n            val leftShiftCount\
    \ = arr.length - 1\n            val rightShiftCount = arr.length - 1\n       \
    \     val leftShiftCount = arr.length - 1\n            val rightShiftCount = arr.length\
    \ - 1\n            val leftShiftCount = arr.length - 1\n            val rightShiftCount\
    \ = arr.length - 1\n            val leftShiftCount = arr.length - 1\n        \
    \    val rightShiftCount = arr.length - 1\n            val leftShiftCount = arr.length\
    \ - 1\n            val rightShiftCount = arr.length - 1\n            val leftShiftCount\
    \ = arr.length - 1\n            val rightShiftCount = arr.length - 1\n       \
    \     val leftShiftCount = arr.length - 1\n            val rightShiftCount = arr.length\
    \ - 1\n            val leftShiftCount = arr.length - 1\n            val rightShiftCount\
    \ = arr.length - 1\n\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsgx4q89z.scala:96:0 ----------------------------\e\
    [0m\e[0m\n\e[31m96 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsgx4q89z.scala:41:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e\
    [0m \e[36mleftShiftCount\e[0m = arr.length - \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mleftShiftCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mleftShiftCount\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsgx4q89z.scala:42:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e\
    [0m \e[36mrightShiftCount\e[0m = arr.length - \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrightShiftCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mrightShiftCount\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsgx4q89z.scala:43:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m            \e[33mval\e\
    [0m \e[36mleftShiftCount\e[0m = arr.length - \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mleftShiftCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mleftShiftCount\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsgx4q89z.scala:44:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m            \e[33mval\e\
    [0m \e[36mrightShiftCount\e[0m = arr.length - \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrightShiftCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mrightShiftCount\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e"
  stdout: ''
  timestamp: 1659798080
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val max = (arr.max)(_ - _)\n        val min = (arr.min)(_ - _)\n    \
    \    val mid = max / 2\n        val left = arr.take(mid)\n        val right =\
    \ arr.drop(mid)\n        val leftSorted = left.sortBy(_ - _)\n        val rightSorted\
    \ = right.sortBy(_ - _)\n        val leftSortedLength = leftSorted.length\n  \
    \      val rightSortedLength = rightSorted.length\n        val leftSortedLength\
    \ = leftSortedLength - rightSortedLength\n        val leftSortedLength = leftSortedLength\
    \ * 2\n        val rightSortedLength = rightSortedLength * 2\n        val leftSortedLength\
    \ = leftSortedLength + rightSortedLength\n        val leftSortedLength = leftSortedLength\
    \ * 2\n        val rightSortedLength = rightSortedLength * 2\n        val leftSortedLength\
    \ = leftSortedLength + rightSortedLength\n        val leftSortedLength = leftSortedLength\
    \ * 2\n        val rightSortedLength = rightSortedLength * 2\n        val leftSortedLength\
    \ = leftSortedLength + rightSortedLength\n        val leftSortedLength = leftSortedLength\
    \ * 2\n        val rightSortedLength = rightSortedLength * 2\n        val leftSortedLength\
    \ = leftSortedLength + rightSortedLength\n        val leftSortedLength = leftSortedLength\
    \ * 2\n        val rightSortedLength = rightSortedLength * 2\n        val leftSortedLength\
    \ = leftSortedLength + rightSortedLength\n        val leftSortedLength = leftSortedLength\
    \ * 2\n        val rightSortedLength = rightSortedLength * 2\n        val leftSortedLength\
    \ = leftSortedLength + rightSortedLength\n        val leftSortedLength = leftSortedLength\
    \ * 2\n        val rightSortedLength = rightSortedLength * 2\n        val leftSortedLength\
    \ = leftSortedLength + rightSortedLength\n        val leftSortedLength = leftSortedLength\
    \ * 2\n        val rightSortedLength = rightSortedLength * 2\n        val leftSortedLength\
    \ = leftSortedLength + rightSortedLength\n        val leftSortedLength = leftSortedLength\
    \ * 2\n        val rightSortedLength = rightSortedLength * 2\n        val leftSortedLength\
    \ = leftSortedLength + rightSortedLength\n        val leftSortedLength = leftSortedLength\
    \ * 2\n        val rightSortedLength = rightSortedLength * 2\n        val leftSortedLength\
    \ = leftSortedLength + rightSortedLength\n        val leftSortedLength = leftSortedLength\
    \ * 2\n        val rightSortedLength = rightSortedLength * 2\n        val leftSortedLength\
    \ = leftSortedLength + rightSortedLength\n        val leftSortedLength = leftSortedLength\
    \ * 2\n        \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3e2oeimp.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mleftSortedLength\e[0m =\
    \ leftSortedLength - rightSortedLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftSortedLength is already defined as \e[33mvalue\e[0m \e\
    [35mleftSortedLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3e2oeimp.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mleftSortedLength\e[0m =\
    \ leftSortedLength * \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftSortedLength is already defined as \e[33mvalue\e[0m \e\
    [35mleftSortedLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3e2oeimp.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mrightSortedLength\e[0m =\
    \ rightSortedLength * \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightSortedLength is already defined as \e[33mvalue\e[0m \e\
    [35mrightSortedLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3e2oeimp.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mleftSortedLength\e[0m =\
    \ leftSortedLength + rightSortedLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftSortedLength is already defined as \e[33mvalue\e[0m \e\
    [35mleftSortedLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3e2oeimp.scala:40:12 ---------------------------\e\
    ["
  stdout: ''
  timestamp: 1659798080
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        if (n == 0) true\n        else {\n            val m = arr.head\n    \
    \        val r = arr.tail\n            val l = r.head\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            val r = r.tail\n            val r = r.tail\n\
    \            val r = r.tail\n            \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph4wn_9ot.scala:123:0 ---------------------------\e\
    [0m\e[0m\n\e[31m123 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph4wn_9ot.scala:32:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mr\e[0m = r.tail\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmph4wn_9ot.scala:33:16 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r.tail\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e\
    [0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmph4wn_9ot.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r.tail\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmph4wn_9ot.scala:35:16 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r.tail\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmph4wn_9ot.scala:36:16 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r.tail\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded me"
  stdout: ''
  timestamp: 1659798080
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val result = new Array[Long](n)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n        var\
    \ temp1 = 0\n        var temp2 = 0\n        var temp3 = 0\n        var temp4 =\
    \ 0\n        var temp5 = 0\n        var temp6 = 0\n        var temp7 = 0\n   \
    \     var temp8 = 0\n        var temp9 = 0\n        var temp10 = 0\n        var\
    \ temp11 = 0\n        var temp12 = 0\n        var temp13 = 0\n        var temp14\
    \ = 0\n        var temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n\
    \        var temp18 = 0\n        var temp19 = 0\n        var temp20 = 0\n    \
    \    var temp21 = 0\n        var temp22 = 0\n        var temp23 = 0\n        var\
    \ temp24 = 0\n        var temp25 = 0\n        var temp26 = 0\n        var temp27\
    \ = 0\n        var temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n\
    \        var temp31 = 0\n        var temp32 = 0\n        var temp33 = 0\n    \
    \    var temp34 = 0\n        var temp35 = 0\n        var temp36 = 0\n        var\
    \ temp37 = 0\n        var temp38 = 0\n        var temp39 = 0\n        var temp40\
    \ = 0\n        var temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n\
    \        var temp44 = 0\n        var temp45 = 0\n        var temp46 = 0\n    \
    \    var temp47 = 0\n        var temp48 = 0\n        var temp49 = 0\n        var\
    \ temp50 = 0\n        var temp51 = 0\n        var temp52 = 0\n        var temp53\
    \ = 0\n        var temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n\
    \        var temp57 = 0\n        var temp58 = 0\n        var temp59 = 0\n    \
    \    var temp60 = 0\n        var temp61 = 0\n        var temp62 = 0\n        var\
    \ temp63 = 0\n        var temp64 = 0\n        var temp65 = 0\n        var temp66\
    \ = 0\n        var temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n\
    \        var temp70 = 0\n        var temp71 = 0\n        var temp72 = 0\n    \
    \    var temp73 = 0\n        var temp74 = 0\n        var temp75 = 0\n        var\
    \ temp76 = 0\n        var temp77 = 0\n        var temp78 = 0\n        var temp79\
    \ = 0\n        var temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n\
    \        var temp83 = 0\n        var temp84 = 0\n        var temp85 = 0\n    \
    \    var temp86 = 0\n        var temp87 = 0\n        var temp88 = 0\n        var\
    \ temp89 = 0\n        var temp90 = 0\n        var temp91 = 0\n        var temp92\
    \ = 0\n        var temp93 = 0\n        var temp94 = 0\n        var temp95 = 0\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprmm_tbe0.scala:129:5\
    \ --------------------\e[0m\e[0m\n\e[31m129 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798079
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val m = arr.last\n        val arr = arr.toList\n        val arr1 = arr.dropRight(1)\n\
    \        val arr2 = arr.takeRight(1)\n        val arr3 = arr2.reverse\n      \
    \  val arr4 = arr3.reverse\n        val arr5 = arr4.reverse\n        val arr6\
    \ = arr5.reverse\n        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n\
    \        val arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val\
    \ arr11 = arr10.reverse\n        val arr12 = arr11.reverse\n        val arr13\
    \ = arr12.reverse\n        val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n\
    \        val arr16 = arr15.reverse\n        val arr17 = arr16.reverse\n      \
    \  val arr18 = arr17.reverse\n        val arr19 = arr18.reverse\n        val arr20\
    \ = arr19.reverse\n        val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n\
    \        val arr23 = arr22.reverse\n        val arr24 = arr23.reverse\n      \
    \  val arr25 = arr24.reverse\n        val arr26 = arr25.reverse\n        val arr27\
    \ = arr26.reverse\n        val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n\
    \        val arr30 = arr29.reverse\n        val arr31 = arr30.reverse\n      \
    \  val arr32 = arr31.reverse\n        val arr33 = arr32.reverse\n        val arr34\
    \ = arr33.reverse\n        val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n\
    \        val arr37 = arr36.reverse\n        val arr38 = arr37.reverse\n      \
    \  val arr39 = arr38.reverse\n        val arr40 = arr39.reverse\n        val arr41\
    \ = arr40.reverse\n        val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n\
    \        val arr44 = arr43.reverse\n        val arr45 = arr44.reverse\n      \
    \  val arr46 = arr45.reverse\n        val arr47 = arr46.reverse\n        val arr48\
    \ = arr47.reverse\n        val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n\
    \        val arr51 = arr50.reverse\n        val arr52 = arr51.reverse\n      \
    \  val arr53 = arr52.reverse\n        val arr54 = arr53.reverse\n        val arr55\
    \ = arr54.reverse\n        \n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkaapfm3e.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpkaapfm3e.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798079
