name: HumanEval_128_prod_signs
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list arr of integers and you need to return\n    // sum\
  \ of magnitudes of integers multiplied by product of all signs\n    // of each number\
  \ in the list, represented by 1, -1 or 0.\n    // Note: return None for empty arr.\n\
  \    // Example:\n    // >>> prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
  \ -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong, 1l.toLong)))\n\
  \    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n    def prodSigns(arr\
  \ : List[Long]) : Option[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
  \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
  \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n   \
  \ assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
  \    }\n\n}\n"
completions: ["        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val magnitudes = arr.map(x => math.abs(x))\n        val product\
    \ = signs.map(x => x * magnitudes.sum).sum\n        val productSign = signs.map(x\
    \ => x * product).sum\n        val productMagnitude = magnitudes.map(x => x *\
    \ product).sum\n        if (productMagnitude == 0) None else Some(productSign)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * x).sum\n        val magnitudes = signs.map(x\
    \ => math.abs(x))\n        magnitudes.zip(product).map(x => x._1 * x._2).sum",
  "        val product = arr.foldLeft(1L) { (product, elem) => product * elem}\n \
    \       val signs = arr.map(elem => if (elem < 0) -1 else if (elem > 0) 1 else\
    \ 0)\n        signs.foldLeft(product) { (product, sign) => product * sign}", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.map(x\
    \ => x * magnitudes.sum).sum\n        Some(product)", "        val product = arr.foldLeft(1L)\
    \ {\n            (product, elem) => product * elem\n        }\n        val signs\
    \ = arr.map(elem => if (elem < 0L) -1L else 1L)\n        val magnitudes = signs.map(elem\
    \ => math.abs(elem))\n        magnitudes.zip(product).map(elem => elem._1 * elem._2)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * x).sum\n        signs.map(x => product * x).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * x).sum\n        val magnitudes = signs.map(x\
    \ => math.abs(x))\n        magnitudes.zip(product).map(x => (x._1 * x._2))", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.reduceLeft(_ * _)\n        val magnitude = arr.map(x\
    \ => math.abs(x)).sum\n        val result = magnitude.map(x => x * product).getOrElse(None)\n\
    \        result", "        val signs = arr.map(x => if (x < 0) -1 else if (x >\
    \ 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n        val\
    \ product = signs.reduce(_ * _)\n        magnitudes.map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitudes = signs.map(x => x * product)\n      \
    \  magnitudes.sum", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n       \
    \ val product = signs.map(x => x * magnitudes.getOrElse(0l))\n        val sum\
    \ = product.sum\n        if (sum > 0L) Some(sum) else None", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.getOrElse(0))\n        val sum = product.sum\n    \
    \    val magnitude = product.map(x => math.abs(x)).sum\n        Some(sum * magnitude)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val result = magnitudes.map(x => x * product).sum\n\
    \        if (result > 0) Some(result) else None", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitudes = signs.map(x => x * product)\n      \
    \  magnitudes.sum", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = arr.map(x => x * x).sum\n        signs.map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val product = signs.reduce(_ * _)\n        magnitudes.map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.product\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.sum\n        val result = magnitudes.map(x => x\
    \ * product).sum / sum\n        Some(result)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(math.pow(_,\
    \ product))", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduceLeft(_ + _)\n\
    \        Some(product * sum)", "        val product = arr.map(x => x * x).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else 1).sum\n        Some(signs\
    \ * product)", "        val product = arr.map(x => x * x).sum\n        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitude\
    \ = signs.map(x => x * product).sum\n        magnitude", "        val signs =\
    \ arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product =\
    \ arr.map(x => x * x).sum\n        val magnitudes = arr.map(x => math.abs(x)).sum\n\
    \        val result = signs.map(x => x * product).sum * magnitudes\n        if\
    \ (result > 0) Some(result) else None", "        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val product = signs.reduce(_ * _)\n        Some(signs.map(x => x * product).sum\
    \ / m)", "        val product = arr.foldLeft(1L) { (product, elem) =>\n      \
    \      product * elem\n        }\n        val signs = arr.map(elem => if (elem\
    \ < 0) -1 else if (elem > 0) 1 else 0)\n        val magnitudes = signs.map(elem\
    \ => math.abs(elem))\n        magnitudes.zip(product).map(elem => elem._1 * elem._2)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        magnitudes.zip(signs).map(x => x._1 * x._2).sum", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduce((x,\
    \ y) => x * y)\n        if (magnitudes.sum == product) Some(product) else None",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduce(_ * _)\n        val magnitudes = arr.map(x =>\
    \ math.abs(x))\n        val sum = magnitudes.reduce(_ + _)\n        Some(sum *\
    \ product)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1\
    \ else 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        magnitudes.zip(product).map(x => x._1 *\
    \ x._2)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val product = signs.foldLeft(1L) { (x, y) => x * y }\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.foldLeft(0L)\
    \ { (x, y) => x + y }\n        Some(sum * product)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        signs.map(x => x * product).sum", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.product\n        val magnitudes = arr.map(x => math.abs(x))\n      \
    \  val sum = magnitudes.sum\n        Some(sum * product)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.reduceLeft(_ + _)\n        Some(sum * product)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val productMagnitudes = product.zip(magnitudes)\n        productMagnitudes.foldLeft(0l){\
    \ (sum, tuple) =>\n            val productSign = tuple._1 * tuple._2\n       \
    \     sum + productSign\n        }", "        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n     \
    \   val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n \
    \       val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(product).map(x\
    \ => x._1 * x._2).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        val productSign\
    \ = signs.reduce(_ * _)\n        val magnitudeSign = magnitudes.map(x => math.abs(x))\n\
    \        val magnitudeSignSum = magnitudeSign.sum\n        val magnitudeSignProduct\
    \ = magnitudeSign.map(x => math.abs(x)).reduce(_ * _)\n        val magnitudeSignProductSum\
    \ = magnitudeSignProduct.sum\n        val magnitudeSignProductProduct = magnitudeSignProduct.map(x\
    \ => math.abs(x)).reduce(_ * _)\n        val magnitudeSignProductProductSum =\
    \ magnitudeSignProductProduct.sum\n        val magnitudeSignProductProductProduct\
    \ = magnitudeSignProductProduct.map(x => math.abs(x)).reduce(_ * _)\n        val\
    \ magnitudeSignProductProductProductSum = magnitudeSignProductProductProduct.sum\n\
    \        val magnitudeSignProductProductProductProduct = magnitudeSignProductProductProduct.map(x\
    \ => math.abs(x)).reduce(_ * _)\n        val magnitudeSignProductProductProductProductSum\
    \ = magnitudeSignProductProductProductProduct.sum\n        val magnitudeSignProductProductProductProductProduct\
    \ = magnitudeSignProductProductProductProduct.map(x => math.abs(x)).reduce(_ *\
    \ _)\n        val magnitudeSignProductProductProductProductSum = magnitudeSignProductProductProductProductProduct.sum\n\
    \        val magnitudeSignProductProductProductProductProduct = magnitudeSignProductProductProductProductProduct.map(x\
    \ => math.abs(x)).reduce(_ * _)\n        val magnitudeSignProductProductProductProductProductSum\
    \ = magnitudeSignProductProductProductProductProduct.sum\n        val magnitudeSignProductProductProductProductProductProduct\
    \ = magnitudeSignProductProductProductProductProductProduct.map(x => math.abs(x)).reduce(_\
    \ * _)\n        val magnitudeSignProductProductProductProductProductSum = magnitudeSignProductProductProductProductProductProduct.sum\n\
    \        val magnitudeSignProductProductProductProductProductProduct = magnitudeSignProductProductProductProductProductProduct.map(x\
    \ => math.abs(x)).reduce(_ * _)\n        val magnitudeSignProductProductProductProductProductSum\
    \ = magnitudeSignProductProductProductProductProductProduct.sum\n        val magnitudeSignProductProductProductProductProductProduct\
    \ = magnitudeSignProductProductProductProductProductProduct.map(x => math.abs(x)).reduce(_\
    \ * _)\n        val magnitudeSignProductProductProductProductProductSum = magnitudeSignProductProductProductProductProductProductProduct.sum\n\
    \        val magnitudeSignProductProductProductProductProductProduct", "     \
    \   val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n       \
    \ val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduce(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitudes = arr.map(x => math.abs(x))\n  \
    \      val sum = magnitudes.foldLeft(1L) { (x, y) => x * y }\n        Some(sum\
    \ * product)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val productMagnitudes = product.zip(magnitudes)\n\
    \        productMagnitudes.map(x => x._1 * x._2).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val sum = magnitudes.sum\n        if (sum == 0) None else Some(sum * product.sum)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * x).sum\n        val magnitude = arr.map(x\
    \ => x * x).map(x => math.abs(x)).sum\n        val result = signs.map(x => x *\
    \ product).map(x => x * magnitude)\n        if (result.isEmpty) None else Some(result.sum)",
  "        val m = arr.map(_.abs).sum\n        val s = arr.map(x => if (x == 0) 0\
    \ else math.signum(x))\n        Some(arr.map(x => x * m * s(x)).sum)", "     \
    \   val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n       \
    \ val product = signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        val sum = magnitudes.sum\n        Some(sum * product)", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduce(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.reduce(_ + _)\n        Some(product * sum)", " \
    \       val m = arr.map(_.abs).sum\n        val signs = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n  \
    \      Some(product * m)", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n      \
    \  val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(product).filter(_._1\
    \ == _._2).map(_._2).sum", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        val result = magnitudes.zip(product).map(x\
    \ => x._1 * x._2)\n        if (result.isEmpty) None else Some(result.sum)", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).getOrElse(None)", "        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ *\
    \ _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum", "        val product = arr.foldLeft(1L) { (product, elem)\
    \ => product * elem}\n        val signs = arr.map(elem => if (elem < 0L) -1L else\
    \ 0L)\n        val magnitudes = signs.map(elem => math.abs(elem))\n        val\
    \ sum = magnitudes.sum\n        val productOfSigns = signs.foldLeft(1L) { (product,\
    \ elem) => product * elem}\n        val productOfMagnitudes = magnitudes.foldLeft(1L)\
    \ { (product, elem) => product * elem}\n        val productOfSums = magnitudes.foldLeft(1L)\
    \ { (product, elem) => product * elem}\n        val productOfProducts = productOfSigns\
    \ * productOfMagnitudes * productOfSums * productOfProducts\n        val productOfProductsAbs\
    \ = productOfProducts.abs\n        val productOfProductsAbsSum = productOfProductsAbs.sum\n\
    \        val productOfProductsAbsProduct = productOfProductsAbs.product\n    \
    \    val productOfProductsAbsProductSum = productOfProductsAbsProduct.sum\n  \
    \      val productOfProductsAbsProductProduct = productOfProductsAbsProduct.product\n\
    \        val productOfProductsAbsProductProductSum = productOfProductsAbsProductProduct.sum\n\
    \        val productOfProductsAbsProductProductProduct = productOfProductsAbsProductProduct.product\n\
    \        val productOfProductsAbsProductProductProductSum = productOfProductsAbsProductProductProduct.sum\n\
    \        val productOfProductsAbsProductProductProductProduct = productOfProductsAbsProductProductProduct.product\n\
    \        val productOfProductsAbsProductProductProductProductSum = productOfProductsAbsProductProductProductProduct.sum\n\
    \        val productOfProductsAbsProductProductProductProductProduct = productOfProductsAbsProductProductProductProduct.product\n\
    \        val productOfProductsAbsProductProductProductProductProductSum = productOfProductsAbsProductProductProductProductProduct.sum\n\
    \        val productOfProductsAbsProductProductProductProductProductProduct =\
    \ productOfProductsAbsProductProductProductProductProduct.product\n        val\
    \ productOfProductsAbsProductProductProductProductProductProductSum = productOfProductsAbsProductProductProductProductProductProduct.sum\n\
    \        val productOfProductsAbsProductProductProductProductProductProductProduct\
    \ = productOfProductsAbsProductProductProductProductProduct", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        magnitudes.zip(signs).map(x => x._1 * x._2).sum", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.reduceLeft(_ + _)\n        Some(sum * product)",
  "        val product = arr.foldLeft(1L) { (product, num) => product * num }\n  \
    \      val signs = arr.map(num => if (num > 0) 1 else -1)\n        signs.foldLeft(product)\
    \ { (product, sign) => product * sign }", "        val signs = arr.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x =>\
    \ math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.getOrElse(0))\n        val sum = product.sum\n\
    \        val mag = product.map(x => math.abs(x)).sum\n        val mag2 = mag *\
    \ mag\n        if (mag2 > sum) Some(mag) else None", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val result\
    \ = magnitudes.zip(product).map(x => x._1 * x._2)\n        if (result.isEmpty)\
    \ None else Some(result.sum)", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n     \
    \   val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduce(_\
    \ + _)\n        Some(product * sum)", "        val signs = arr.map(x => if (x\
    \ < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n\
    \        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        if (sum > 0) Some(magnitudes.sum * product.sum) else None", "       \
    \ val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduce(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitude = signs.map(x => x * product).sum\n   \
    \     magnitude.map(x => x.toLong)", "        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ *\
    \ _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * x).sum\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.zip(signs).map(x => x._1 * x._2).sum\n\
    \        if (sum == 0) None else Some(sum)", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(product).filter(_._1\
    \ == _._2).map(_._2).sum", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = arr.map(x => x * x).sum\n      \
    \  val magnitudes = signs.map(x => x * product).sum\n        magnitudes.toOption",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduce((x, y) => x * y)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val result = magnitudes.map(x => x * product).sum\n\
    \        if (result > 0) Some(result) else None", "        val product = arr.foldLeft(1L)(_\
    \ * _)\n        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        signs.foldLeft(product)(_ * _)", "        val product = arr.foldLeft(1L)\
    \ { (product, elem) =>\n            product * elem\n        }\n        val signs\
    \ = arr.map(elem => if (elem < 0) -1 else if (elem > 0) 1 else 0)\n        signs.foldLeft(product)\
    \ { (product, sign) =>\n            product * sign\n        }", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val product = signs.reduce(_ * _)\n   \
    \     magnitudes.map(x => x * product).sum", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)", "        val signs =\
    \ arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product =\
    \ signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.reduceLeft(_ + _)\n        Some(product * sum)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_\
    \ * _)\n        magnitudes.map(x => x * product).getOrElse(None)", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n\
    \        val result = magnitude.map(x => product * x)\n        Some(result.sum)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.sum)\n        val magnitudes = product.map(math.abs)\n\
    \        val sum = magnitudes.sum\n        if (sum > 0) Some(sum) else None",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.sum)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.sum\n        if (sum == 0) None\
    \ else Some(sum * product.sum)", "        val product = arr.foldLeft(1L){\n  \
    \          (product, elem) => product * elem\n        }\n        val signs = arr.map(elem\
    \ => if (elem < 0L) -1L else 1L)\n        val magnitudes = signs.map(elem => math.abs(elem))\n\
    \        val sum = magnitudes.foldLeft(product){\n            (sum, elem) => sum\
    \ + elem\n        }\n        Some(sum)", "        val signs = arr.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x =>\
    \ math.abs(x))\n        val product = signs.reduce((x, y) => x * y)\n        magnitudes.map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x * product).getOrElse(None)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduce(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)", "        val product\
    \ = arr.map(x => x * x).sum\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0).sum\n        Some(signs * product)", "        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(_.signum).sum\n        Some(signs * m * arr.product)",
  "        val m = arr.map(_.abs).sum\n        val s = arr.map(_.signum).sum\n   \
    \     Some(m * s)", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n       \
    \ val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * x).sum\n        val magnitudes = signs.map(x\
    \ => math.abs(x))\n        val productMagnitudes = magnitudes.map(x => x * product)\n\
    \        magnitudes.zip(productMagnitudes).filter(_._2 > 0).map(_._1)", "    \
    \    val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n      \
    \  val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes\
    \ = magnitudes.map(x => x * product)\n        productMagnitudes.sum", "      \
    \  val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val\
    \ product = arr.map(x => x * signs.sum)\n        product.sum", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.foldLeft(0L)(_ + _)\n        Some(sum * product)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(_.signum).sum\n        Some(signs * m * arr.product)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val productMagnitudes = magnitudes.map(x => x * product)\n\
    \        val productMagnitudesSum = productMagnitudes.sum\n        val productMagnitudesSumAbs\
    \ = math.abs(productMagnitudesSum)\n        if (productMagnitudesSumAbs == 0)\
    \ None else Some(productMagnitudesSumAbs)", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).getOrElse(None)", "        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x\
    \ * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = signs.product\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        Some(sum\
    \ * product)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = signs.reduce(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val productMagnitudes = magnitudes.map(x\
    \ => x * product)\n        productMagnitudes.sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitudes = arr.map(x => math.abs(x)).sum\n    \
    \    magnitudes * product * signs", "        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n\
    \        val magnitudes = product.map(x => math.abs(x))\n        magnitudes.sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val product =\
    \ arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        signs.foldLeft(product)(_ * _)", "        val\
    \ product = arr.foldLeft(1l)(_ * _)\n        val signs = arr.map(x => if (x <\
    \ 0) -1 else 1)\n        signs.foldLeft(product)(_ * _)", "        val signs =\
    \ arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product =\
    \ arr.map(x => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.zip(product).map(x => x._1 * x._2).sum\n       \
    \ if (sum > 0) Some(sum) else None", "        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x\
    \ * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n       \
    \ val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x * product).getOrElse(None)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        magnitudes.map(x => x * product).sum", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n\
    \        Some(magnitude * product)", "        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ *\
    \ _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduceLeft(_\
    \ + _)\n        Some(product * sum)", "        val product = arr.foldLeft(1L)\
    \ {\n            case (acc, x) => acc * x\n        }\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        signs.foldLeft(product)\
    \ {\n            case (acc, x) => acc * x\n        }", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x)).sum\n        mag match {\n            case 0 =>\
    \ None\n            case x if x == 0 => Some(sum)\n            case x => Some(sum\
    \ - mag)\n        }", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val product = signs.map(x => x * magnitudes.getOrElse(0l)).sum\n        val\
    \ result = if (product == 0l) None else Some(product)\n        result", "    \
    \    val product = arr.foldLeft(1L) { (product, elem) => product * elem}\n   \
    \     val signs = arr.map(elem => if (elem < 0L) -1L else 0L)\n        val magnitudes\
    \ = arr.map(elem => if (elem < 0L) elem else elem * product)\n        magnitudes.sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.product\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val productMagnitudes = magnitudes.map(x => x * product)\n        productMagnitudes.sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduce(_ * _)\n        val magnitudes = arr.map(x =>\
    \ math.abs(x))\n        magnitudes.map(x => x * product).sum", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.reduceLeft(_ + _)\n        Some(sum * product)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude\
    \ * product)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        val result\
    \ = if (sum == 0) None else Some(sum * product.sum)\n        result", "      \
    \  val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val\
    \ product = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.foldLeft(0L) { (x, y) => x + y\
    \ }\n        Some(sum * product)", "        val signs = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n\
    \        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        if (sum == 0) None else Some(sum * product.sum)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * x).sum\n        signs.map(x => x * product).sum", "     \
    \   val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n       \
    \ val product = arr.map(x => x * signs.sum)\n        val magnitudes = product.map(x\
    \ => math.abs(x))\n        magnitudes.sum", "        val product = arr.map(x =>\
    \ x * x).sum\n        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1\
    \ else 0)\n        signs.map(x => product * x).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n       \
    \ val magnitudes = arr.map(x => math.abs(x)).filter(x => x != 0)\n        magnitudes.map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes = magnitudes.map(x\
    \ => x * product)\n        val productMagnitudesSum = productMagnitudes.sum\n\
    \        val productMagnitudesSumAbs = math.abs(productMagnitudesSum)\n      \
    \  val productMagnitudesSumAbsMinusOne = productMagnitudesSumAbs - 1\n       \
    \ val productMagnitudesSumAbsMinusOneAbs = math.abs(productMagnitudesSumAbsMinusOne)\n\
    \        val productMagnitudesSumAbsMinusOneAbsMinusOne = productMagnitudesSumAbsMinusOneAbs\
    \ - 1\n        val productMagnitudesSumAbsMinusOneAbsMinusOneAbs = math.abs(productMagnitudesSumAbsMinusOneAbsMinusOne)\n\
    \        val productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOne = productMagnitudesSumAbsMinusOneAbsMinusOneAbs\
    \ - 1\n        val productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne\
    \ = math.abs(productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOne)\n        val\
    \ productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne\
    \ = productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne\
    \ - 1\n        val productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne\
    \ = math.abs(productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne)\n\
    \        val productMagnitudesSumAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOneAbsMinusOne",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * x).sum\n        signs.map(x => product * x).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduceLeft(_ * _)\n        val magnitude = arr.map(x\
    \ => math.abs(x)).sum\n        val result = if (magnitude == 0) None else Some(magnitude\
    \ * product)\n        result", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n \
    \       val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(product).filter(_._1\
    \ == _._2).map(_._1).sum", "        val m = arr.map(_.abs).sum\n        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduce(_ * _)\n        Some(signs.map(x => x * product).sum / m)", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = arr.map(x => x * signs.sum)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.sum\n        if (sum == 0) None\
    \ else Some(sum * product.sum)", "        val signs = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n\
    \        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduceLeft(_\
    \ + _)\n        Some(sum * product)", "        val signs = arr.map(x => if (x\
    \ < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val product = signs.reduce(_ * _)\n        magnitudes.map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.product\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.sum\n        val productSigns = signs.map(x => x\
    \ * product)\n        val productSignsSum = productSigns.sum\n        if (sum\
    \ == productSignsSum) Some(sum) else None", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x =>\
    \ x * x).sum\n        signs.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce((x,\
    \ y) => x * y)\n        val magnitudes = arr.map(x => math.abs(x))\n        val\
    \ productMagnitudes = magnitudes.reduce((x, y) => x * y)\n        if (productMagnitudes\
    \ == 0) None else Some(product * productMagnitudes)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val productMagnitudes = product.zip(magnitudes)\n        productMagnitudes.foldLeft(0l)\
    \ { (sum, tuple) => sum + tuple._1 * tuple._2 }", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = arr.map(x => x * x).sum\n        val\
    \ magnitude = arr.map(x => x * x).map(x => math.abs(x)).sum\n        val result\
    \ = signs.zip(magnitude).map(x => x._1 * x._2)\n        Some(result.sum)", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.reduce(_ * _)\n        val magnitudes = arr.map(x =>\
    \ math.abs(x))\n        magnitudes.zip(product).map(x => (x._1 * x._2)).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * x).sum\n        val magnitudes = signs.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.map(x => x * product).sum\n  \
    \      if (sum > 0) Some(sum) else None", "        val signs = arr.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce((x,\
    \ y) => x * y)\n        val magnitudes = arr.map(x => math.abs(x))\n        val\
    \ sum = magnitudes.reduce((x, y) => x + y)\n        val result = if (sum == product)\
    \ Some(product) else None\n        result", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        val result = Some(sum * product)\n        result", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val productMagnitudes = magnitudes.map(x => x * product)\n        productMagnitudes.sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.product\n        val result = magnitudes.map(x\
    \ => x * product).sum\n        if (result > 0) Some(result) else None", "    \
    \    val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n      \
    \  val product = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.foldLeft(0L) { (x,\
    \ y) => x + y }\n        Some(sum * product)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val product = signs.map(x => x * magnitudes.getOrElse(0l))\n        magnitudes.zip(product).map(x\
    \ => x._1 * x._2).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduceLeft(_\
    \ + _)\n        Some(sum * product)", "        val signs = arr.map(x => if (x\
    \ < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n\
    \        product.sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x => x._1 * x._2).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_\
    \ * _)\n        magnitudes.map(x => x * product).getOrElse(None)", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduce((x, y) => x * y)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val productMagnitudes = magnitudes.map(x => x * product)\n        val\
    \ sum = productMagnitudes.reduce((x, y) => x + y)\n        Some(sum)", "     \
    \   val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n       \
    \ val product = arr.map(x => x * signs.sum)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.sum\n        if (sum > 0) Some(magnitudes.sum\
    \ * product.sum) else None", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.getOrElse(0))\n\
    \        val sum = product.sum\n        val mag = product.map(x => math.abs(x)).sum\n\
    \        Some(mag)", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n       \
    \ val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduce(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduceLeft(_\
    \ + _)\n        val result = if (product == 0) None else Some(sum / product)\n\
    \        result", "        val signs = arr.map(x => if (x < 0) -1 else if (x >\
    \ 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n        val\
    \ product = signs.product\n        val productMagnitudes = magnitudes.map(x =>\
    \ x * product)\n        val productMagnitudesSum = productMagnitudes.sum\n   \
    \     val productMagnitudesSumAbs = productMagnitudesSum.abs\n        val productMagnitudesSumAbsProduct\
    \ = productMagnitudesSumAbs.product\n        val productMagnitudesSumAbsProductProduct\
    \ = productMagnitudesSumAbsProduct.product\n        val productMagnitudesSumAbsProductProductProduct\
    \ = productMagnitudesSumAbsProductProduct.product\n        val productMagnitudesSumAbsProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProduct.product\n        val productMagnitudesSumAbsProductProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProductProduct.product\n        val productMagnitudesSumAbsProductProductProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProductProductProduct.product\n     \
    \   val productMagnitudesSumAbsProductProductProductProductProductProduct = productMagnitudesSumAbsProductProductProductProductProductProduct.product\n\
    \        val productMagnitudesSumAbsProductProductProductProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProductProductProductProductProduct.product\n\
    \        val productMagnitudesSumAbsProductProductProductProductProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProductProductProductProductProductProduct.product\n\
    \        val productMagnitudesSumAbsProductProductProductProductProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProductProductProductProductProductProduct.product\n\
    \        val productMagnitudesSumAbsProductProductProductProductProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProductProductProductProductProductProductProduct.product\n\
    \        val productMagnitudesSumAbsProductProductProductProductProductProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProductProductProductProductProductProductProduct.product\n\
    \        val productMagnitudesSumAbsProductProductProductProductProductProductProductProductProduct\
    \ = productMagnitudesSumAbsProductProductProductProductProductProductProductProductProduct.product\n\
    \        val product", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n     \
    \   val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        val result = magnitudes.zip(product).map(x => x._1 * x._2).sum\n    \
    \    if (sum == 0) None else Some(result)", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x =>\
    \ x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n       \
    \ val productMagnitudes = product.zip(magnitudes)\n        val productMagnitudesSum\
    \ = productMagnitudes.map(x => x._1 * x._2)\n        val productMagnitudesSumSum\
    \ = productMagnitudesSum.sum\n        val productMagnitudesSumSumAbs = math.abs(productMagnitudesSumSum)\n\
    \        val productMagnitudesSumSumAbsAbs = math.abs(productMagnitudesSumSumAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbs = math.abs(productMagnitudesSumSumAbsAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbsAbs = math.abs(productMagnitudesSumSumAbsAbsAbsAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbsAbsAbs = math.abs(productMagnitudesSumSumAbsAbsAbsAbsAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbsAbsAbsAbs = math.abs(productMagnitudesSumSumAbsAbsAbsAbsAbsAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbs = math.abs(productMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbs = math.abs(productMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbsAbs = math.abs(productMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbsAbsAbs = math.abs(productMagnitudesSumSumAbsAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val productMagnitudesSumSumAbsAbsAbsAbsAbsAb", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitude = signs.map(x => x * product).sum\n   \
    \     Some(magnitude)", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n     \
    \   val magnitude = product.map(x => math.abs(x))\n        val sum = magnitude.sum\n\
    \        if (sum > 0) Some(sum) else None"]
stop_tokens:
- "\n    }\n"
